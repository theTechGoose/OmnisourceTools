#!/usr/bin/env deno run --no-check -A
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
import { createRequire } from "node:module";
var __require = createRequire(import.meta.url);

var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require2() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// ../../../../../node_modules/.deno/collection-utils@1.0.1/node_modules/collection-utils/dist/index.js
var require_dist = __commonJS({
  "../../../../../node_modules/.deno/collection-utils@1.0.1/node_modules/collection-utils/dist/index.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : new P(function(resolve2) {
            resolve2(result.value);
          }).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.hashCodeInit = 17;
    function hashString(str) {
      let hash = 0;
      for (let i2 = 0; i2 < str.length; i2++) {
        const chr = str.charCodeAt(i2);
        hash = (hash << 5) - hash + chr;
        hash = hash & hash;
      }
      return hash;
    }
    exports.hashString = hashString;
    function addHashCode(acc, h) {
      return acc * 31 + (h | 0) | 0;
    }
    exports.addHashCode = addHashCode;
    function withDefault(x, theDefault) {
      if (x !== void 0) {
        return x;
      }
      return theDefault;
    }
    exports.withDefault = withDefault;
    function definedMap(x, f) {
      if (x === void 0) return void 0;
      return f(x);
    }
    exports.definedMap = definedMap;
    function definedMapWithDefault(x, theDefault, f) {
      return withDefault(definedMap(x, f), theDefault);
    }
    exports.definedMapWithDefault = definedMapWithDefault;
    function hasOwnProperty(obj2, name) {
      if (obj2 === void 0 || obj2 === null) return false;
      return Object.prototype.hasOwnProperty.call(obj2, name);
    }
    exports.hasOwnProperty = hasOwnProperty;
    function iterableFind(it, p) {
      for (const v of it) {
        if (p(v)) {
          return v;
        }
      }
      return void 0;
    }
    exports.iterableFind = iterableFind;
    function iterableEvery(it, p) {
      for (const v of it) {
        if (!p(v)) {
          return false;
        }
      }
      return true;
    }
    exports.iterableEvery = iterableEvery;
    function iterableSome(it, p) {
      for (const v of it) {
        if (p(v)) {
          return true;
        }
      }
      return false;
    }
    exports.iterableSome = iterableSome;
    function iterableFirst(it) {
      for (const v of it) {
        return v;
      }
      return void 0;
    }
    exports.iterableFirst = iterableFirst;
    function iterableMax(it) {
      let max = void 0;
      for (const v of it) {
        if (max === void 0 || v > max) {
          max = v;
        }
      }
      return max;
    }
    exports.iterableMax = iterableMax;
    function iterableMinBy(it, key) {
      let min = void 0;
      let minValue = void 0;
      for (const v of it) {
        const k = key(v);
        if (min === void 0 || k < min) {
          min = k;
          minValue = v;
        }
      }
      return minValue;
    }
    exports.iterableMinBy = iterableMinBy;
    function iterableReduce(it, unit, reducer) {
      let result = unit;
      for (const v of it) {
        result = reducer(result, v);
      }
      return result;
    }
    exports.iterableReduce = iterableReduce;
    function* iterableEnumerate(it) {
      let i2 = 0;
      for (const v of it) {
        yield [
          i2,
          v
        ];
        i2 += 1;
      }
    }
    exports.iterableEnumerate = iterableEnumerate;
    function* iterableSkip(it, n) {
      let i2 = 0;
      for (const v of it) {
        if (i2 >= n) {
          yield v;
        } else {
          i2 += 1;
        }
      }
    }
    exports.iterableSkip = iterableSkip;
    function arrayGetFromEnd(arr, i2) {
      const l = arr.length;
      if (i2 > l) return void 0;
      return arr[l - i2];
    }
    exports.arrayGetFromEnd = arrayGetFromEnd;
    function arrayLast(arr) {
      return arrayGetFromEnd(arr, 1);
    }
    exports.arrayLast = arrayLast;
    function arrayPop(arr) {
      const l = arr.length;
      if (l === 0) {
        throw new Error("Cannot pop empty array");
      }
      return arr.slice(0, l - 1);
    }
    exports.arrayPop = arrayPop;
    function arrayIntercalate(separator, items) {
      const acc = [];
      for (const x of items) {
        if (acc.length > 0) acc.push(separator);
        acc.push(x);
      }
      return acc;
    }
    exports.arrayIntercalate = arrayIntercalate;
    function arrayMapSync(set, f) {
      return __awaiter(this, void 0, void 0, function* () {
        const result = [];
        let i2 = 0;
        for (const v of set) {
          result.push(yield f(v, i2));
          i2 += 1;
        }
        return result;
      });
    }
    exports.arrayMapSync = arrayMapSync;
    function compareKeys(sa, sb) {
      if (sa < sb) return -1;
      if (sa > sb) return 1;
      return 0;
    }
    function arraySortByInto(arr, sortKey) {
      return arr.sort((a, b) => compareKeys(sortKey(a), sortKey(b)));
    }
    exports.arraySortByInto = arraySortByInto;
    function toReadonlyArray(it) {
      if (Array.isArray(it)) return it;
      return Array.from(it);
    }
    exports.toReadonlyArray = toReadonlyArray;
    function mapMap(m, f) {
      const result = /* @__PURE__ */ new Map();
      for (const [k, v] of m) {
        result.set(k, f(v, k));
      }
      return result;
    }
    exports.mapMap = mapMap;
    function mapFirst(m) {
      for (const v of m.values()) {
        return v;
      }
      return void 0;
    }
    exports.mapFirst = mapFirst;
    function mapContains(m, valueToFind) {
      for (const v of m.values()) {
        if (v === valueToFind) {
          return true;
        }
      }
      return false;
    }
    exports.mapContains = mapContains;
    function mapSome(m, p) {
      for (const [k, v] of m) {
        if (p(v, k)) {
          return true;
        }
      }
      return false;
    }
    exports.mapSome = mapSome;
    function mapMergeInto(dest, src) {
      for (const [k, v] of src) {
        dest.set(k, v);
      }
      return dest;
    }
    exports.mapMergeInto = mapMergeInto;
    function mapMerge(ma, mb) {
      const result = new Map(ma);
      mapMergeInto(result, mb);
      return result;
    }
    exports.mapMerge = mapMerge;
    function mapMergeWithInto(ma, merger, mb) {
      for (const [k, vb] of mb) {
        const va = ma.get(k);
        const v = va === void 0 ? vb : merger(va, vb, k);
        ma.set(k, v);
      }
      return ma;
    }
    exports.mapMergeWithInto = mapMergeWithInto;
    function mapMergeWith(ma, merger, mb) {
      const result = new Map(ma);
      mapMergeWithInto(result, merger, mb);
      return result;
    }
    exports.mapMergeWith = mapMergeWith;
    function mapFilter(m, p) {
      const result = /* @__PURE__ */ new Map();
      for (const [k, v] of m) {
        if (p(v, k)) {
          result.set(k, v);
        }
      }
      return result;
    }
    exports.mapFilter = mapFilter;
    function mapFilterMap(m, f) {
      const result = /* @__PURE__ */ new Map();
      for (const [k, v] of m) {
        const w = f(v, k);
        if (w !== void 0) {
          result.set(k, w);
        }
      }
      return result;
    }
    exports.mapFilterMap = mapFilterMap;
    function mapSortToArray(m, sortKey) {
      return arraySortByInto(Array.from(m), ([k, v]) => sortKey(v, k));
    }
    exports.mapSortToArray = mapSortToArray;
    function mapSortBy(m, sortKey) {
      return new Map(mapSortToArray(m, sortKey));
    }
    exports.mapSortBy = mapSortBy;
    function mapSortByKey(m) {
      return mapSortBy(m, (_, k) => k);
    }
    exports.mapSortByKey = mapSortByKey;
    function mapMapEntries(m, f) {
      const result = /* @__PURE__ */ new Map();
      for (const [k, v] of m) {
        const [l, w] = f(v, k);
        result.set(l, w);
      }
      return result;
    }
    exports.mapMapEntries = mapMapEntries;
    function mapUpdateInto(m, k, updater) {
      m.set(k, updater(m.get(k)));
      return m;
    }
    exports.mapUpdateInto = mapUpdateInto;
    function mapFromObject(obj2) {
      const result = /* @__PURE__ */ new Map();
      for (const k of Object.getOwnPropertyNames(obj2)) {
        result.set(k, obj2[k]);
      }
      return result;
    }
    exports.mapFromObject = mapFromObject;
    function mapToObject(m) {
      const result = {};
      for (const [k, v] of m) {
        result[k] = v;
      }
      return result;
    }
    exports.mapToObject = mapToObject;
    function mapFromIterable(it, valueForKey) {
      const result = /* @__PURE__ */ new Map();
      for (const k of it) {
        result.set(k, valueForKey(k));
      }
      return result;
    }
    exports.mapFromIterable = mapFromIterable;
    function mapFind(it, p) {
      for (const [k, v] of it) {
        if (p(v, k)) {
          return v;
        }
      }
      return void 0;
    }
    exports.mapFind = mapFind;
    function mapTranspose(maps) {
      const result = /* @__PURE__ */ new Map();
      for (const m of maps) {
        for (const [k, v] of m) {
          let arr = result.get(k);
          if (arr === void 0) {
            arr = [];
            result.set(k, arr);
          }
          arr.push(v);
        }
      }
      return result;
    }
    exports.mapTranspose = mapTranspose;
    function mapMapSync(m, f) {
      return __awaiter(this, void 0, void 0, function* () {
        const result = /* @__PURE__ */ new Map();
        for (const [k, v] of m) {
          result.set(k, yield f(v, k));
        }
        return result;
      });
    }
    exports.mapMapSync = mapMapSync;
    function setIsSuperset(set, subset) {
      for (const elem of subset) {
        if (!set.has(elem)) return false;
      }
      return true;
    }
    exports.setIsSuperset = setIsSuperset;
    function setUnionManyInto(dest, srcs) {
      for (const src of srcs) {
        for (const v of src) {
          dest.add(v);
        }
      }
      return dest;
    }
    exports.setUnionManyInto = setUnionManyInto;
    function setUnionInto(dest, ...srcs) {
      return setUnionManyInto(dest, srcs);
    }
    exports.setUnionInto = setUnionInto;
    function setIntersect(s1, s2) {
      const result = /* @__PURE__ */ new Set();
      for (const v of s1) {
        if (s2.has(v)) {
          result.add(v);
        }
      }
      return result;
    }
    exports.setIntersect = setIntersect;
    function setSubtract(src, diff) {
      const result = new Set(src);
      for (const v of diff) {
        result.delete(v);
      }
      return result;
    }
    exports.setSubtract = setSubtract;
    function setUnion(...sets) {
      const result = /* @__PURE__ */ new Set();
      setUnionInto(result, ...sets);
      return result;
    }
    exports.setUnion = setUnion;
    function setMap(set, f) {
      const result = /* @__PURE__ */ new Set();
      for (const v of set) {
        result.add(f(v));
      }
      return result;
    }
    exports.setMap = setMap;
    function setFilter(set, p) {
      const result = /* @__PURE__ */ new Set();
      for (const v of set) {
        if (p(v)) {
          result.add(v);
        }
      }
      return result;
    }
    exports.setFilter = setFilter;
    function setFilterMap(set, f) {
      const result = /* @__PURE__ */ new Set();
      for (const v of set) {
        const u = f(v);
        if (u !== void 0) {
          result.add(u);
        }
      }
      return result;
    }
    exports.setFilterMap = setFilterMap;
    function setSortBy(it, sortKey) {
      return new Set(arraySortByInto(Array.from(it), sortKey));
    }
    exports.setSortBy = setSortBy;
    function setGroupBy(it, grouper) {
      const result = /* @__PURE__ */ new Map();
      for (const v of it) {
        const g = grouper(v);
        let group = result.get(g);
        if (group === void 0) {
          group = /* @__PURE__ */ new Set();
          result.set(g, group);
        }
        group.add(v);
      }
      return result;
    }
    exports.setGroupBy = setGroupBy;
    function toReadonlySet(it) {
      if (it instanceof Set) return it;
      return new Set(it);
    }
    exports.toReadonlySet = toReadonlySet;
    var EqualityMap = class {
      constructor() {
        this._map = /* @__PURE__ */ new Map();
      }
      set(k, v) {
        let h = hashCodeOf(k) | 0;
        for (; ; ) {
          const kvp = this._map.get(h);
          if (kvp === void 0) {
            this._map.set(h, [
              k,
              v
            ]);
            return;
          }
          if (areEqual(k, kvp[0])) {
            kvp[1] = v;
            return;
          }
          h = h + 1 | 0;
        }
      }
      get(k) {
        let h = hashCodeOf(k) | 0;
        for (; ; ) {
          const kvp = this._map.get(h);
          if (kvp === void 0) {
            return void 0;
          }
          if (areEqual(k, kvp[0])) {
            return kvp[1];
          }
          h = h + 1 | 0;
        }
      }
      has(k) {
        return this.get(k) !== void 0;
      }
      *values() {
        for (const [, [, v]] of this._map) {
          yield v;
        }
      }
    };
    exports.EqualityMap = EqualityMap;
    function areEqual(a, b) {
      if (a === b) {
        return true;
      }
      if (a === void 0 || b === void 0 || a === null || b === null) {
        return false;
      }
      if (typeof a.equals === "function" && typeof b.equals === "function") {
        return a.equals(b);
      }
      if (a instanceof Set && b instanceof Set) {
        if (a.size !== b.size) return false;
        for (const x of a) {
          if (!b.has(x)) return false;
        }
        return true;
      }
      if (a instanceof Map && b instanceof Map) {
        if (a.size !== b.size) return false;
        for (const [k, v] of a) {
          const w = b.get(k);
          if (!areEqual(v, w)) return false;
        }
        return true;
      }
      if (Array.isArray(a) && Array.isArray(b)) {
        const n = a.length;
        if (n !== b.length) return false;
        for (let i2 = 0; i2 < n; i2++) {
          if (!areEqual(a[i2], b[i2])) return false;
        }
        return true;
      }
      return false;
    }
    exports.areEqual = areEqual;
    function hashCodeOf(x) {
      if (typeof x === "number") return x | 0;
      if (typeof x === "string") return hashString(x);
      let h = exports.hashCodeInit;
      if (x === void 0) return h;
      if (x === true) return h + 1 | 0;
      if (x === false) return h + 2 | 0;
      if (x === null) return h + 3 | 0;
      if (typeof x.hashCode === "function") {
        return x.hashCode();
      }
      if (x instanceof Set) {
        for (const y of x) {
          h += hashCodeOf(y);
        }
        return h;
      }
      if (x instanceof Map) {
        let g = exports.hashCodeInit;
        for (const [k, v] of x) {
          g += hashCodeOf(k);
          h += hashCodeOf(v);
        }
        return addHashCode(g, h);
      }
      if (Array.isArray(x)) {
        for (const y of x) {
          h = addHashCode(h, hashCodeOf(y));
        }
        return h;
      }
      throw new Error(`Cannot hash ${x}`);
    }
    exports.hashCodeOf = hashCodeOf;
  }
});

// ../../../../../node_modules/.deno/pluralize@8.0.0/node_modules/pluralize/pluralize.js
var require_pluralize = __commonJS({
  "../../../../../node_modules/.deno/pluralize@8.0.0/node_modules/pluralize/pluralize.js"(exports, module) {
    (function(root, pluralize) {
      if (typeof __require === "function" && typeof exports === "object" && typeof module === "object") {
        module.exports = pluralize();
      } else if (typeof define === "function" && define.amd) {
        define(function() {
          return pluralize();
        });
      } else {
        root.pluralize = pluralize();
      }
    })(exports, function() {
      var pluralRules = [];
      var singularRules = [];
      var uncountables = {};
      var irregularPlurals = {};
      var irregularSingles = {};
      function sanitizeRule(rule) {
        if (typeof rule === "string") {
          return new RegExp("^" + rule + "$", "i");
        }
        return rule;
      }
      function restoreCase(word, token) {
        if (word === token) return token;
        if (word === word.toLowerCase()) return token.toLowerCase();
        if (word === word.toUpperCase()) return token.toUpperCase();
        if (word[0] === word[0].toUpperCase()) {
          return token.charAt(0).toUpperCase() + token.substr(1).toLowerCase();
        }
        return token.toLowerCase();
      }
      function interpolate(str, args) {
        return str.replace(/\$(\d{1,2})/g, function(match2, index) {
          return args[index] || "";
        });
      }
      function replace(word, rule) {
        return word.replace(rule[0], function(match2, index) {
          var result = interpolate(rule[1], arguments);
          if (match2 === "") {
            return restoreCase(word[index - 1], result);
          }
          return restoreCase(match2, result);
        });
      }
      function sanitizeWord(token, word, rules) {
        if (!token.length || uncountables.hasOwnProperty(token)) {
          return word;
        }
        var len = rules.length;
        while (len--) {
          var rule = rules[len];
          if (rule[0].test(word)) return replace(word, rule);
        }
        return word;
      }
      function replaceWord(replaceMap, keepMap, rules) {
        return function(word) {
          var token = word.toLowerCase();
          if (keepMap.hasOwnProperty(token)) {
            return restoreCase(word, token);
          }
          if (replaceMap.hasOwnProperty(token)) {
            return restoreCase(word, replaceMap[token]);
          }
          return sanitizeWord(token, word, rules);
        };
      }
      function checkWord(replaceMap, keepMap, rules, bool) {
        return function(word) {
          var token = word.toLowerCase();
          if (keepMap.hasOwnProperty(token)) return true;
          if (replaceMap.hasOwnProperty(token)) return false;
          return sanitizeWord(token, token, rules) === token;
        };
      }
      function pluralize(word, count, inclusive) {
        var pluralized = count === 1 ? pluralize.singular(word) : pluralize.plural(word);
        return (inclusive ? count + " " : "") + pluralized;
      }
      pluralize.plural = replaceWord(irregularSingles, irregularPlurals, pluralRules);
      pluralize.isPlural = checkWord(irregularSingles, irregularPlurals, pluralRules);
      pluralize.singular = replaceWord(irregularPlurals, irregularSingles, singularRules);
      pluralize.isSingular = checkWord(irregularPlurals, irregularSingles, singularRules);
      pluralize.addPluralRule = function(rule, replacement) {
        pluralRules.push([
          sanitizeRule(rule),
          replacement
        ]);
      };
      pluralize.addSingularRule = function(rule, replacement) {
        singularRules.push([
          sanitizeRule(rule),
          replacement
        ]);
      };
      pluralize.addUncountableRule = function(word) {
        if (typeof word === "string") {
          uncountables[word.toLowerCase()] = true;
          return;
        }
        pluralize.addPluralRule(word, "$0");
        pluralize.addSingularRule(word, "$0");
      };
      pluralize.addIrregularRule = function(single, plural) {
        plural = plural.toLowerCase();
        single = single.toLowerCase();
        irregularSingles[single] = plural;
        irregularPlurals[plural] = single;
      };
      [
        // Pronouns.
        [
          "I",
          "we"
        ],
        [
          "me",
          "us"
        ],
        [
          "he",
          "they"
        ],
        [
          "she",
          "they"
        ],
        [
          "them",
          "them"
        ],
        [
          "myself",
          "ourselves"
        ],
        [
          "yourself",
          "yourselves"
        ],
        [
          "itself",
          "themselves"
        ],
        [
          "herself",
          "themselves"
        ],
        [
          "himself",
          "themselves"
        ],
        [
          "themself",
          "themselves"
        ],
        [
          "is",
          "are"
        ],
        [
          "was",
          "were"
        ],
        [
          "has",
          "have"
        ],
        [
          "this",
          "these"
        ],
        [
          "that",
          "those"
        ],
        // Words ending in with a consonant and `o`.
        [
          "echo",
          "echoes"
        ],
        [
          "dingo",
          "dingoes"
        ],
        [
          "volcano",
          "volcanoes"
        ],
        [
          "tornado",
          "tornadoes"
        ],
        [
          "torpedo",
          "torpedoes"
        ],
        // Ends with `us`.
        [
          "genus",
          "genera"
        ],
        [
          "viscus",
          "viscera"
        ],
        // Ends with `ma`.
        [
          "stigma",
          "stigmata"
        ],
        [
          "stoma",
          "stomata"
        ],
        [
          "dogma",
          "dogmata"
        ],
        [
          "lemma",
          "lemmata"
        ],
        [
          "schema",
          "schemata"
        ],
        [
          "anathema",
          "anathemata"
        ],
        // Other irregular rules.
        [
          "ox",
          "oxen"
        ],
        [
          "axe",
          "axes"
        ],
        [
          "die",
          "dice"
        ],
        [
          "yes",
          "yeses"
        ],
        [
          "foot",
          "feet"
        ],
        [
          "eave",
          "eaves"
        ],
        [
          "goose",
          "geese"
        ],
        [
          "tooth",
          "teeth"
        ],
        [
          "quiz",
          "quizzes"
        ],
        [
          "human",
          "humans"
        ],
        [
          "proof",
          "proofs"
        ],
        [
          "carve",
          "carves"
        ],
        [
          "valve",
          "valves"
        ],
        [
          "looey",
          "looies"
        ],
        [
          "thief",
          "thieves"
        ],
        [
          "groove",
          "grooves"
        ],
        [
          "pickaxe",
          "pickaxes"
        ],
        [
          "passerby",
          "passersby"
        ]
      ].forEach(function(rule) {
        return pluralize.addIrregularRule(rule[0], rule[1]);
      });
      [
        [
          /s?$/i,
          "s"
        ],
        [
          /[^\u0000-\u007F]$/i,
          "$0"
        ],
        [
          /([^aeiou]ese)$/i,
          "$1"
        ],
        [
          /(ax|test)is$/i,
          "$1es"
        ],
        [
          /(alias|[^aou]us|t[lm]as|gas|ris)$/i,
          "$1es"
        ],
        [
          /(e[mn]u)s?$/i,
          "$1s"
        ],
        [
          /([^l]ias|[aeiou]las|[ejzr]as|[iu]am)$/i,
          "$1"
        ],
        [
          /(alumn|syllab|vir|radi|nucle|fung|cact|stimul|termin|bacill|foc|uter|loc|strat)(?:us|i)$/i,
          "$1i"
        ],
        [
          /(alumn|alg|vertebr)(?:a|ae)$/i,
          "$1ae"
        ],
        [
          /(seraph|cherub)(?:im)?$/i,
          "$1im"
        ],
        [
          /(her|at|gr)o$/i,
          "$1oes"
        ],
        [
          /(agend|addend|millenni|dat|extrem|bacteri|desiderat|strat|candelabr|errat|ov|symposi|curricul|automat|quor)(?:a|um)$/i,
          "$1a"
        ],
        [
          /(apheli|hyperbat|periheli|asyndet|noumen|phenomen|criteri|organ|prolegomen|hedr|automat)(?:a|on)$/i,
          "$1a"
        ],
        [
          /sis$/i,
          "ses"
        ],
        [
          /(?:(kni|wi|li)fe|(ar|l|ea|eo|oa|hoo)f)$/i,
          "$1$2ves"
        ],
        [
          /([^aeiouy]|qu)y$/i,
          "$1ies"
        ],
        [
          /([^ch][ieo][ln])ey$/i,
          "$1ies"
        ],
        [
          /(x|ch|ss|sh|zz)$/i,
          "$1es"
        ],
        [
          /(matr|cod|mur|sil|vert|ind|append)(?:ix|ex)$/i,
          "$1ices"
        ],
        [
          /\b((?:tit)?m|l)(?:ice|ouse)$/i,
          "$1ice"
        ],
        [
          /(pe)(?:rson|ople)$/i,
          "$1ople"
        ],
        [
          /(child)(?:ren)?$/i,
          "$1ren"
        ],
        [
          /eaux$/i,
          "$0"
        ],
        [
          /m[ae]n$/i,
          "men"
        ],
        [
          "thou",
          "you"
        ]
      ].forEach(function(rule) {
        return pluralize.addPluralRule(rule[0], rule[1]);
      });
      [
        [
          /s$/i,
          ""
        ],
        [
          /(ss)$/i,
          "$1"
        ],
        [
          /(wi|kni|(?:after|half|high|low|mid|non|night|[^\w]|^)li)ves$/i,
          "$1fe"
        ],
        [
          /(ar|(?:wo|[ae])l|[eo][ao])ves$/i,
          "$1f"
        ],
        [
          /ies$/i,
          "y"
        ],
        [
          /\b([pl]|zomb|(?:neck|cross)?t|coll|faer|food|gen|goon|group|lass|talk|goal|cut)ies$/i,
          "$1ie"
        ],
        [
          /\b(mon|smil)ies$/i,
          "$1ey"
        ],
        [
          /\b((?:tit)?m|l)ice$/i,
          "$1ouse"
        ],
        [
          /(seraph|cherub)im$/i,
          "$1"
        ],
        [
          /(x|ch|ss|sh|zz|tto|go|cho|alias|[^aou]us|t[lm]as|gas|(?:her|at|gr)o|[aeiou]ris)(?:es)?$/i,
          "$1"
        ],
        [
          /(analy|diagno|parenthe|progno|synop|the|empha|cri|ne)(?:sis|ses)$/i,
          "$1sis"
        ],
        [
          /(movie|twelve|abuse|e[mn]u)s$/i,
          "$1"
        ],
        [
          /(test)(?:is|es)$/i,
          "$1is"
        ],
        [
          /(alumn|syllab|vir|radi|nucle|fung|cact|stimul|termin|bacill|foc|uter|loc|strat)(?:us|i)$/i,
          "$1us"
        ],
        [
          /(agend|addend|millenni|dat|extrem|bacteri|desiderat|strat|candelabr|errat|ov|symposi|curricul|quor)a$/i,
          "$1um"
        ],
        [
          /(apheli|hyperbat|periheli|asyndet|noumen|phenomen|criteri|organ|prolegomen|hedr|automat)a$/i,
          "$1on"
        ],
        [
          /(alumn|alg|vertebr)ae$/i,
          "$1a"
        ],
        [
          /(cod|mur|sil|vert|ind)ices$/i,
          "$1ex"
        ],
        [
          /(matr|append)ices$/i,
          "$1ix"
        ],
        [
          /(pe)(rson|ople)$/i,
          "$1rson"
        ],
        [
          /(child)ren$/i,
          "$1"
        ],
        [
          /(eau)x?$/i,
          "$1"
        ],
        [
          /men$/i,
          "man"
        ]
      ].forEach(function(rule) {
        return pluralize.addSingularRule(rule[0], rule[1]);
      });
      [
        // Singular words with no plurals.
        "adulthood",
        "advice",
        "agenda",
        "aid",
        "aircraft",
        "alcohol",
        "ammo",
        "analytics",
        "anime",
        "athletics",
        "audio",
        "bison",
        "blood",
        "bream",
        "buffalo",
        "butter",
        "carp",
        "cash",
        "chassis",
        "chess",
        "clothing",
        "cod",
        "commerce",
        "cooperation",
        "corps",
        "debris",
        "diabetes",
        "digestion",
        "elk",
        "energy",
        "equipment",
        "excretion",
        "expertise",
        "firmware",
        "flounder",
        "fun",
        "gallows",
        "garbage",
        "graffiti",
        "hardware",
        "headquarters",
        "health",
        "herpes",
        "highjinks",
        "homework",
        "housework",
        "information",
        "jeans",
        "justice",
        "kudos",
        "labour",
        "literature",
        "machinery",
        "mackerel",
        "mail",
        "media",
        "mews",
        "moose",
        "music",
        "mud",
        "manga",
        "news",
        "only",
        "personnel",
        "pike",
        "plankton",
        "pliers",
        "police",
        "pollution",
        "premises",
        "rain",
        "research",
        "rice",
        "salmon",
        "scissors",
        "series",
        "sewage",
        "shambles",
        "shrimp",
        "software",
        "species",
        "staff",
        "swine",
        "tennis",
        "traffic",
        "transportation",
        "trout",
        "tuna",
        "wealth",
        "welfare",
        "whiting",
        "wildebeest",
        "wildlife",
        "you",
        /pok[eÃ©]mon$/i,
        // Regexes.
        /[^aeiou]ese$/i,
        /deer$/i,
        /fish$/i,
        /measles$/i,
        /o[iu]s$/i,
        /pox$/i,
        /sheep$/i
      ].forEach(pluralize.addUncountableRule);
      return pluralize;
    });
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/support/Chance.js
var require_Chance = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/support/Chance.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Chance = void 0;
    var MersenneTwister = class {
      constructor(seed) {
        if (seed === void 0) {
          seed = Math.floor(Math.random() * Math.pow(10, 13));
        }
        this.N = 624;
        this.M = 397;
        this.MATRIX_A = 2567483615;
        this.UPPER_MASK = 2147483648;
        this.LOWER_MASK = 2147483647;
        this.mt = new Array(this.N);
        this.mti = this.N + 1;
        this.init_genrand(seed);
      }
      /* initializes mt[N] with a seed */
      init_genrand(s) {
        this.mt[0] = s >>> 0;
        for (this.mti = 1; this.mti < this.N; this.mti++) {
          s = this.mt[this.mti - 1] ^ this.mt[this.mti - 1] >>> 30;
          this.mt[this.mti] = (((s & 4294901760) >>> 16) * 1812433253 << 16) + (s & 65535) * 1812433253 + this.mti;
          this.mt[this.mti] >>>= 0;
        }
      }
      /* generates a random number on [0,0xffffffff]-interval */
      genrand_int32() {
        let y;
        const mag01 = [
          0,
          this.MATRIX_A
        ];
        if (this.mti >= this.N) {
          let kk;
          if (this.mti === this.N + 1) {
            this.init_genrand(5489);
          }
          for (kk = 0; kk < this.N - this.M; kk++) {
            y = this.mt[kk] & this.UPPER_MASK | this.mt[kk + 1] & this.LOWER_MASK;
            this.mt[kk] = this.mt[kk + this.M] ^ y >>> 1 ^ mag01[y & 1];
          }
          for (; kk < this.N - 1; kk++) {
            y = this.mt[kk] & this.UPPER_MASK | this.mt[kk + 1] & this.LOWER_MASK;
            this.mt[kk] = this.mt[kk + (this.M - this.N)] ^ y >>> 1 ^ mag01[y & 1];
          }
          y = this.mt[this.N - 1] & this.UPPER_MASK | this.mt[0] & this.LOWER_MASK;
          this.mt[this.N - 1] = this.mt[this.M - 1] ^ y >>> 1 ^ mag01[y & 1];
          this.mti = 0;
        }
        y = this.mt[this.mti++];
        y ^= y >>> 11;
        y ^= y << 7 & 2636928640;
        y ^= y << 15 & 4022730752;
        y ^= y >>> 18;
        return y >>> 0;
      }
      /* generates a random number on [0,1)-real-interval */
      random() {
        return this.genrand_int32() * (1 / 4294967296);
      }
    };
    var Chance = class {
      constructor(seed) {
        this.seed = seed;
        this.mt = new MersenneTwister(this.seed);
      }
      random() {
        return this.mt.random();
      }
      /**
         *  Return a random integer
         *
         *  NOTE the max and min are INCLUDED in the range. So:
         *  chance.integer({min: 1, max: 3});
         *  would return either 1, 2, or 3.
         *
         *  @param {Object} [options={}] can specify a min and/or max
         *  @returns {Number} a single random integer number
         *  @throws {RangeError} min cannot be greater than max
         */
      integer(options) {
        return Math.floor(this.random() * (options.max - options.min + 1) + options.min);
      }
      /**
         *  Return a random natural
         *
         *  NOTE the max and min are INCLUDED in the range. So:
         *  chance.natural({min: 1, max: 3});
         *  would return either 1, 2, or 3.
         *
         *  @param {Object} [options={}] can specify a min and/or maxm or a numerals count.
         *  @returns {Number} a single random integer number
         *  @throws {RangeError} min cannot be greater than max
         */
      natural(options) {
        return this.integer({
          min: 0,
          max: options.max
        });
      }
      pick(arr) {
        if (arr.length === 0) {
          throw new RangeError("Chance: Cannot pick() from an empty array");
        }
        return arr[this.natural({
          max: arr.length - 1
        })];
      }
      animal() {
        const animalTypeArray = [
          "desert",
          "forest",
          "ocean",
          "zoo",
          "farm",
          "pet",
          "grassland"
        ];
        return this.pick(animals[this.pick(animalTypeArray)]);
      }
      city() {
        return this.pick(cities);
      }
    };
    exports.Chance = Chance;
    var animals = {
      // list of ocean animals comes from https://owlcation.com/stem/list-of-ocean-animals
      ocean: [
        "Acantharea",
        "Anemone",
        "Angelfish King",
        "Ahi Tuna",
        "Albacore",
        "American Oyster",
        "Anchovy",
        "Armored Snail",
        "Arctic Char",
        "Atlantic Bluefin Tuna",
        "Atlantic Cod",
        "Atlantic Goliath Grouper",
        "Atlantic Trumpetfish",
        "Atlantic Wolffish",
        "Baleen Whale",
        "Banded Butterflyfish",
        "Banded Coral Shrimp",
        "Banded Sea Krait",
        "Barnacle",
        "Barndoor Skate",
        "Barracuda",
        "Basking Shark",
        "Bass",
        "Beluga Whale",
        "Bluebanded Goby",
        "Bluehead Wrasse",
        "Bluefish",
        "Bluestreak Cleaner-Wrasse",
        "Blue Marlin",
        "Blue Shark",
        "Blue Spiny Lobster",
        "Blue Tang",
        "Blue Whale",
        "Broadclub Cuttlefish",
        "Bull Shark",
        "Chambered Nautilus",
        "Chilean Basket Star",
        "Chilean Jack Mackerel",
        "Chinook Salmon",
        "Christmas Tree Worm",
        "Clam",
        "Clown Anemonefish",
        "Clown Triggerfish",
        "Cod",
        "Coelacanth",
        "Cockscomb Cup Coral",
        "Common Fangtooth",
        "Conch",
        "Cookiecutter Shark",
        "Copepod",
        "Coral",
        "Corydoras",
        "Cownose Ray",
        "Crab",
        "Crown-of-Thorns Starfish",
        "Cushion Star",
        "Cuttlefish",
        "California Sea Otters",
        "Dolphin",
        "Dolphinfish",
        "Dory",
        "Devil Fish",
        "Dugong",
        "Dumbo Octopus",
        "Dungeness Crab",
        "Eccentric Sand Dollar",
        "Edible Sea Cucumber",
        "Eel",
        "Elephant Seal",
        "Elkhorn Coral",
        "Emperor Shrimp",
        "Estuarine Crocodile",
        "Fathead Sculpin",
        "Fiddler Crab",
        "Fin Whale",
        "Flameback",
        "Flamingo Tongue Snail",
        "Flashlight Fish",
        "Flatback Turtle",
        "Flatfish",
        "Flying Fish",
        "Flounder",
        "Fluke",
        "French Angelfish",
        "Frilled Shark",
        "Fugu (also called Pufferfish)",
        "Gar",
        "Geoduck",
        "Giant Barrel Sponge",
        "Giant Caribbean Sea Anemone",
        "Giant Clam",
        "Giant Isopod",
        "Giant Kingfish",
        "Giant Oarfish",
        "Giant Pacific Octopus",
        "Giant Pyrosome",
        "Giant Sea Star",
        "Giant Squid",
        "Glowing Sucker Octopus",
        "Giant Tube Worm",
        "Goblin Shark",
        "Goosefish",
        "Great White Shark",
        "Greenland Shark",
        "Grey Atlantic Seal",
        "Grouper",
        "Grunion",
        "Guineafowl Puffer",
        "Haddock",
        "Hake",
        "Halibut",
        "Hammerhead Shark",
        "Hapuka",
        "Harbor Porpoise",
        "Harbor Seal",
        "Hatchetfish",
        "Hawaiian Monk Seal",
        "Hawksbill Turtle",
        "Hector's Dolphin",
        "Hermit Crab",
        "Herring",
        "Hoki",
        "Horn Shark",
        "Horseshoe Crab",
        "Humpback Anglerfish",
        "Humpback Whale",
        "Icefish",
        "Imperator Angelfish",
        "Irukandji Jellyfish",
        "Isopod",
        "Ivory Bush Coral",
        "Japanese Spider Crab",
        "Jellyfish",
        "John Dory",
        "Juan Fernandez Fur Seal",
        "Killer Whale",
        "Kiwa Hirsuta",
        "Krill",
        "Lagoon Triggerfish",
        "Lamprey",
        "Leafy Seadragon",
        "Leopard Seal",
        "Limpet",
        "Ling",
        "Lionfish",
        "Lions Mane Jellyfish",
        "Lobe Coral",
        "Lobster",
        "Loggerhead Turtle",
        "Longnose Sawshark",
        "Longsnout Seahorse",
        "Lophelia Coral",
        "Marrus Orthocanna",
        "Manatee",
        "Manta Ray",
        "Marlin",
        "Megamouth Shark",
        "Mexican Lookdown",
        "Mimic Octopus",
        "Moon Jelly",
        "Mollusk",
        "Monkfish",
        "Moray Eel",
        "Mullet",
        "Mussel",
        "Megaladon",
        "Napoleon Wrasse",
        "Nassau Grouper",
        "Narwhal",
        "Nautilus",
        "Needlefish",
        "Northern Seahorse",
        "North Atlantic Right Whale",
        "Northern Red Snapper",
        "Norway Lobster",
        "Nudibranch",
        "Nurse Shark",
        "Oarfish",
        "Ocean Sunfish",
        "Oceanic Whitetip Shark",
        "Octopus",
        "Olive Sea Snake",
        "Orange Roughy",
        "Ostracod",
        "Otter",
        "Oyster",
        "Pacific Angelshark",
        "Pacific Blackdragon",
        "Pacific Halibut",
        "Pacific Sardine",
        "Pacific Sea Nettle Jellyfish",
        "Pacific White Sided Dolphin",
        "Pantropical Spotted Dolphin",
        "Patagonian Toothfish",
        "Peacock Mantis Shrimp",
        "Pelagic Thresher Shark",
        "Penguin",
        "Peruvian Anchoveta",
        "Pilchard",
        "Pink Salmon",
        "Pinniped",
        "Plankton",
        "Porpoise",
        "Polar Bear",
        "Portuguese Man o' War",
        "Pycnogonid Sea Spider",
        "Quahog",
        "Queen Angelfish",
        "Queen Conch",
        "Queen Parrotfish",
        "Queensland Grouper",
        "Ragfish",
        "Ratfish",
        "Rattail Fish",
        "Ray",
        "Red Drum",
        "Red King Crab",
        "Ringed Seal",
        "Risso's Dolphin",
        "Ross Seals",
        "Sablefish",
        "Salmon",
        "Sand Dollar",
        "Sandbar Shark",
        "Sawfish",
        "Sarcastic Fringehead",
        "Scalloped Hammerhead Shark",
        "Seahorse",
        "Sea Cucumber",
        "Sea Lion",
        "Sea Urchin",
        "Seal",
        "Shark",
        "Shortfin Mako Shark",
        "Shovelnose Guitarfish",
        "Shrimp",
        "Silverside Fish",
        "Skipjack Tuna",
        "Slender Snipe Eel",
        "Smalltooth Sawfish",
        "Smelts",
        "Sockeye Salmon",
        "Southern Stingray",
        "Sponge",
        "Spotted Porcupinefish",
        "Spotted Dolphin",
        "Spotted Eagle Ray",
        "Spotted Moray",
        "Squid",
        "Squidworm",
        "Starfish",
        "Stickleback",
        "Stonefish",
        "Stoplight Loosejaw",
        "Sturgeon",
        "Swordfish",
        "Tan Bristlemouth",
        "Tasseled Wobbegong",
        "Terrible Claw Lobster",
        "Threespot Damselfish",
        "Tiger Prawn",
        "Tiger Shark",
        "Tilefish",
        "Toadfish",
        "Tropical Two-Wing Flyfish",
        "Tuna",
        "Umbrella Squid",
        "Velvet Crab",
        "Venus Flytrap Sea Anemone",
        "Vigtorniella Worm",
        "Viperfish",
        "Vampire Squid",
        "Vaquita",
        "Wahoo",
        "Walrus",
        "West Indian Manatee",
        "Whale",
        "Whale Shark",
        "Whiptail Gulper",
        "White-Beaked Dolphin",
        "White-Ring Garden Eel",
        "White Shrimp",
        "Wobbegong",
        "Wrasse",
        "Wreckfish",
        "Xiphosura",
        "Yellowtail Damselfish",
        "Yelloweye Rockfish",
        "Yellow Cup Black Coral",
        "Yellow Tube Sponge",
        "Yellowfin Tuna",
        "Zebrashark",
        "Zooplankton"
      ],
      // list of desert, grassland, and forest animals comes from http://www.skyenimals.com/
      desert: [
        "Aardwolf",
        "Addax",
        "African Wild Ass",
        "Ant",
        "Antelope",
        "Armadillo",
        "Baboon",
        "Badger",
        "Bat",
        "Bearded Dragon",
        "Beetle",
        "Bird",
        "Black-footed Cat",
        "Boa",
        "Brown Bear",
        "Bustard",
        "Butterfly",
        "Camel",
        "Caracal",
        "Caracara",
        "Caterpillar",
        "Centipede",
        "Cheetah",
        "Chipmunk",
        "Chuckwalla",
        "Climbing Mouse",
        "Coati",
        "Cobra",
        "Cotton Rat",
        "Cougar",
        "Courser",
        "Crane Fly",
        "Crow",
        "Dassie Rat",
        "Dove",
        "Dunnart",
        "Eagle",
        "Echidna",
        "Elephant",
        "Emu",
        "Falcon",
        "Fly",
        "Fox",
        "Frogmouth",
        "Gecko",
        "Geoffroy's Cat",
        "Gerbil",
        "Grasshopper",
        "Guanaco",
        "Gundi",
        "Hamster",
        "Hawk",
        "Hedgehog",
        "Hyena",
        "Hyrax",
        "Jackal",
        "Kangaroo",
        "Kangaroo Rat",
        "Kestrel",
        "Kowari",
        "Kultarr",
        "Leopard",
        "Lion",
        "Macaw",
        "Meerkat",
        "Mouse",
        "Oryx",
        "Ostrich",
        "Owl",
        "Pronghorn",
        "Python",
        "Rabbit",
        "Raccoon",
        "Rattlesnake",
        "Rhinoceros",
        "Sand Cat",
        "Spectacled Bear",
        "Spiny Mouse",
        "Starling",
        "Stick Bug",
        "Tarantula",
        "Tit",
        "Toad",
        "Tortoise",
        "Tyrant Flycatcher",
        "Viper",
        "Vulture",
        "Waxwing",
        "Xerus",
        "Zebra"
      ],
      grassland: [
        "Aardvark",
        "Aardwolf",
        "Accentor",
        "African Buffalo",
        "African Wild Dog",
        "Alpaca",
        "Anaconda",
        "Ant",
        "Anteater",
        "Antelope",
        "Armadillo",
        "Baboon",
        "Badger",
        "Bandicoot",
        "Barbet",
        "Bat",
        "Bee",
        "Bee-eater",
        "Beetle",
        "Bird",
        "Bison",
        "Black-footed Cat",
        "Black-footed Ferret",
        "Bluebird",
        "Boa",
        "Bowerbird",
        "Brown Bear",
        "Bush Dog",
        "Bushshrike",
        "Bustard",
        "Butterfly",
        "Buzzard",
        "Caracal",
        "Caracara",
        "Cardinal",
        "Caterpillar",
        "Cheetah",
        "Chipmunk",
        "Civet",
        "Climbing Mouse",
        "Clouded Leopard",
        "Coati",
        "Cobra",
        "Cockatoo",
        "Cockroach",
        "Common Genet",
        "Cotton Rat",
        "Cougar",
        "Courser",
        "Coyote",
        "Crane",
        "Crane Fly",
        "Cricket",
        "Crow",
        "Culpeo",
        "Death Adder",
        "Deer",
        "Deer Mouse",
        "Dingo",
        "Dinosaur",
        "Dove",
        "Drongo",
        "Duck",
        "Duiker",
        "Dunnart",
        "Eagle",
        "Echidna",
        "Elephant",
        "Elk",
        "Emu",
        "Falcon",
        "Finch",
        "Flea",
        "Fly",
        "Flying Frog",
        "Fox",
        "Frog",
        "Frogmouth",
        "Garter Snake",
        "Gazelle",
        "Gecko",
        "Geoffroy's Cat",
        "Gerbil",
        "Giant Tortoise",
        "Giraffe",
        "Grasshopper",
        "Grison",
        "Groundhog",
        "Grouse",
        "Guanaco",
        "Guinea Pig",
        "Hamster",
        "Harrier",
        "Hartebeest",
        "Hawk",
        "Hedgehog",
        "Helmetshrike",
        "Hippopotamus",
        "Hornbill",
        "Hyena",
        "Hyrax",
        "Impala",
        "Jackal",
        "Jaguar",
        "Jaguarundi",
        "Kangaroo",
        "Kangaroo Rat",
        "Kestrel",
        "Kultarr",
        "Ladybug",
        "Leopard",
        "Lion",
        "Macaw",
        "Meerkat",
        "Mouse",
        "Newt",
        "Oryx",
        "Ostrich",
        "Owl",
        "Pangolin",
        "Pheasant",
        "Prairie Dog",
        "Pronghorn",
        "Przewalski's Horse",
        "Python",
        "Quoll",
        "Rabbit",
        "Raven",
        "Rhinoceros",
        "Shelduck",
        "Sloth Bear",
        "Spectacled Bear",
        "Squirrel",
        "Starling",
        "Stick Bug",
        "Tamandua",
        "Tasmanian Devil",
        "Thornbill",
        "Thrush",
        "Toad",
        "Tortoise"
      ],
      forest: [
        "Agouti",
        "Anaconda",
        "Anoa",
        "Ant",
        "Anteater",
        "Antelope",
        "Armadillo",
        "Asian Black Bear",
        "Aye-aye",
        "Babirusa",
        "Baboon",
        "Badger",
        "Bandicoot",
        "Banteng",
        "Barbet",
        "Basilisk",
        "Bat",
        "Bearded Dragon",
        "Bee",
        "Bee-eater",
        "Beetle",
        "Bettong",
        "Binturong",
        "Bird-of-paradise",
        "Bongo",
        "Bowerbird",
        "Bulbul",
        "Bush Dog",
        "Bushbaby",
        "Bushshrike",
        "Butterfly",
        "Buzzard",
        "Caecilian",
        "Cardinal",
        "Cassowary",
        "Caterpillar",
        "Centipede",
        "Chameleon",
        "Chimpanzee",
        "Cicada",
        "Civet",
        "Clouded Leopard",
        "Coati",
        "Cobra",
        "Cockatoo",
        "Cockroach",
        "Colugo",
        "Cotinga",
        "Cotton Rat",
        "Cougar",
        "Crane Fly",
        "Cricket",
        "Crocodile",
        "Crow",
        "Cuckoo",
        "Cuscus",
        "Death Adder",
        "Deer",
        "Dhole",
        "Dingo",
        "Dinosaur",
        "Drongo",
        "Duck",
        "Duiker",
        "Eagle",
        "Echidna",
        "Elephant",
        "Finch",
        "Flat-headed Cat",
        "Flea",
        "Flowerpecker",
        "Fly",
        "Flying Frog",
        "Fossa",
        "Frog",
        "Frogmouth",
        "Gaur",
        "Gecko",
        "Gorilla",
        "Grison",
        "Hawaiian Honeycreeper",
        "Hawk",
        "Hedgehog",
        "Helmetshrike",
        "Hornbill",
        "Hyrax",
        "Iguana",
        "Jackal",
        "Jaguar",
        "Jaguarundi",
        "Kestrel",
        "Ladybug",
        "Lemur",
        "Leopard",
        "Lion",
        "Macaw",
        "Mandrill",
        "Margay",
        "Monkey",
        "Mouse",
        "Mouse Deer",
        "Newt",
        "Okapi",
        "Old World Flycatcher",
        "Orangutan",
        "Owl",
        "Pangolin",
        "Peafowl",
        "Pheasant",
        "Possum",
        "Python",
        "Quokka",
        "Rabbit",
        "Raccoon",
        "Red Panda",
        "Red River Hog",
        "Rhinoceros",
        "Sloth Bear",
        "Spectacled Bear",
        "Squirrel",
        "Starling",
        "Stick Bug",
        "Sun Bear",
        "Tamandua",
        "Tamarin",
        "Tapir",
        "Tarantula",
        "Thrush",
        "Tiger",
        "Tit",
        "Toad",
        "Tortoise",
        "Toucan",
        "Trogon",
        "Trumpeter",
        "Turaco",
        "Turtle",
        "Tyrant Flycatcher",
        "Viper",
        "Vulture",
        "Wallaby",
        "Warbler",
        "Wasp",
        "Waxwing",
        "Weaver",
        "Weaver-finch",
        "Whistler",
        "White-eye",
        "Whydah",
        "Woodswallow",
        "Worm",
        "Wren",
        "Xenops",
        "Yellowjacket",
        "Accentor",
        "African Buffalo",
        "American Black Bear",
        "Anole",
        "Bird",
        "Bison",
        "Boa",
        "Brown Bear",
        "Chipmunk",
        "Common Genet",
        "Copperhead",
        "Coyote",
        "Deer Mouse",
        "Dormouse",
        "Elk",
        "Emu",
        "Fisher",
        "Fox",
        "Garter Snake",
        "Giant Panda",
        "Giant Tortoise",
        "Groundhog",
        "Grouse",
        "Guanaco",
        "Himalayan Tahr",
        "Kangaroo",
        "Koala",
        "Numbat",
        "Quoll",
        "Raccoon dog",
        "Tasmanian Devil",
        "Thornbill",
        "Turkey",
        "Vole",
        "Weasel",
        "Wildcat",
        "Wolf",
        "Wombat",
        "Woodchuck",
        "Woodpecker"
      ],
      // list of farm animals comes from https://www.buzzle.com/articles/farm-animals-list.html
      farm: [
        "Alpaca",
        "Buffalo",
        "Banteng",
        "Cow",
        "Cat",
        "Chicken",
        "Carp",
        "Camel",
        "Donkey",
        "Dog",
        "Duck",
        "Emu",
        "Goat",
        "Gayal",
        "Guinea",
        "Goose",
        "Horse",
        "Honey",
        "Llama",
        "Pig",
        "Pigeon",
        "Rhea",
        "Rabbit",
        "Sheep",
        "Silkworm",
        "Turkey",
        "Yak",
        "Zebu"
      ],
      // list of pet animals comes from https://www.dogbreedinfo.com/pets/pet.htm
      pet: [
        "Bearded Dragon",
        "Birds",
        "Burro",
        "Cats",
        "Chameleons",
        "Chickens",
        "Chinchillas",
        "Chinese Water Dragon",
        "Cows",
        "Dogs",
        "Donkey",
        "Ducks",
        "Ferrets",
        "Fish",
        "Geckos",
        "Geese",
        "Gerbils",
        "Goats",
        "Guinea Fowl",
        "Guinea Pigs",
        "Hamsters",
        "Hedgehogs",
        "Horses",
        "Iguanas",
        "Llamas",
        "Lizards",
        "Mice",
        "Mule",
        "Peafowl",
        "Pigs and Hogs",
        "Pigeons",
        "Ponies",
        "Pot Bellied Pig",
        "Rabbits",
        "Rats",
        "Sheep",
        "Skinks",
        "Snakes",
        "Stick Insects",
        "Sugar Gliders",
        "Tarantula",
        "Turkeys",
        "Turtles"
      ],
      // list of zoo animals comes from https://bronxzoo.com/animals
      zoo: [
        "Aardvark",
        "African Wild Dog",
        "Aldabra Tortoise",
        "American Alligator",
        "American Bison",
        "Amur Tiger",
        "Anaconda",
        "Andean Condor",
        "Asian Elephant",
        "Baby Doll Sheep",
        "Bald Eagle",
        "Barred Owl",
        "Blue Iguana",
        "Boer Goat",
        "California Sea Lion",
        "Caribbean Flamingo",
        "Chinchilla",
        "Collared Lemur",
        "Coquerel's Sifaka",
        "Cuban Amazon Parrot",
        "Ebony Langur",
        "Fennec Fox",
        "Fossa",
        "Gelada",
        "Giant Anteater",
        "Giraffe",
        "Gorilla",
        "Grizzly Bear",
        "Henkel's Leaf-tailed Gecko",
        "Indian Gharial",
        "Indian Rhinoceros",
        "King Cobra",
        "King Vulture",
        "Komodo Dragon",
        "Linne's Two-toed Sloth",
        "Lion",
        "Little Penguin",
        "Madagascar Tree Boa",
        "Magellanic Penguin",
        "Malayan Tapir",
        "Malayan Tiger",
        "Matschies Tree Kangaroo",
        "Mini Donkey",
        "Monarch Butterfly",
        "Nile crocodile",
        "North American Porcupine",
        "Nubian Ibex",
        "Okapi",
        "Poison Dart Frog",
        "Polar Bear",
        "Pygmy Marmoset",
        "Radiated Tortoise",
        "Red Panda",
        "Red Ruffed Lemur",
        "Ring-tailed Lemur",
        "Ring-tailed Mongoose",
        "Rock Hyrax",
        "Small Clawed Asian Otter",
        "Snow Leopard",
        "Snowy Owl",
        "Southern White-faced Owl",
        "Southern White Rhinocerous",
        "Squirrel Monkey",
        "Tufted Puffin",
        "White Cheeked Gibbon",
        "White-throated Bee Eater",
        "Zebra"
      ]
    };
    var cities = [
      "Alert",
      "Nord",
      "Eureka",
      "Ny-\xC5lesund",
      "Longyearbyen",
      "Qaanaaq",
      "Grise Fiord",
      "Dikson",
      "Upernavik",
      "Tiksi",
      "Belushya Guba",
      "Barrow",
      "Honningsv\xE5g",
      "Hammerfest",
      "Deadhorse",
      "Nuorgam",
      "Vads\xF8",
      "Alta",
      "Utsjoki",
      "Kirkenes",
      "Troms\xF8",
      "Tuktoyaktuk",
      "Norilsk",
      "Murmansk",
      "Harstad",
      "Narvik",
      "Inuvik",
      "Kiruna",
      "Verkhoyansk",
      "Bod\xF8",
      "G\xE4llivare",
      "Kemij\xE4rvi",
      "Rovaniemi",
      "\xCDsafj\xF6r\xF0ur",
      "Kuusamo",
      "Tornio",
      "Boden",
      "Haparanda",
      "Kemi",
      "Akureyri",
      "Lule\xE5",
      "Pudasj\xE4rvi",
      "Pite\xE5",
      "Oulu",
      "Fairbanks",
      "Skellefte\xE5",
      "Anadyr",
      "Arkhangelsk",
      "Nome",
      "Nuuk (Godth\xE5b)",
      "Reykjav\xEDk",
      "Ume\xE5",
      "Iqaluit",
      "Stj\xF8rdal",
      "Trondheim",
      "\xD6rnsk\xF6ldsvik",
      "\xD6stersund",
      "Vaasa",
      "Kuopio",
      "Yellowknife",
      "Sundsvall",
      "Jyv\xE4skyl\xE4",
      "Yakutsk",
      "T\xF3rshavn",
      "Petrozavodsk",
      "Tampere",
      "Anchorage",
      "Lillehammer",
      "Lahti",
      "Qaqortoq",
      "Whitehorse",
      "Turku",
      "Bergen",
      "Vantaa",
      "Lerwick",
      "Espoo",
      "Helsinki",
      "Oslo",
      "Saint Petersburg",
      "Uppsala",
      "Fritz Creek",
      "Magadan",
      "Tallinn",
      "Stockholm",
      "Sarpsborg",
      "\xD6rebro",
      "Vologda",
      "Norrk\xF6ping",
      "Link\xF6ping",
      "Tartu",
      "Juneau",
      "Arendal",
      "Kristiansand",
      "Perm",
      "Valga",
      "Gothenburg",
      "Visby",
      "Yaroslavl",
      "Inverness",
      "Aberdeen",
      "Sitka",
      "Riga",
      "Izhevsk",
      "Yekaterinburg",
      "Fort McMurray",
      "Dundee",
      "Nizhny Novgorod",
      "Stirling",
      "Bratsk",
      "Aarhus",
      "Krasnoyarsk",
      "Edinburgh",
      "Glasgow",
      "Kazan",
      "Moscow",
      "Copenhagen",
      "Malm\xF6",
      "Esbjerg",
      "Odense",
      "Grande Prairie",
      "Chelyabinsk",
      "Novosibirsk",
      "Derry",
      "Omsk",
      "Newcastle upon Tyne",
      "Sunderland",
      "Petropavl",
      "Flensburg",
      "Ufa",
      "Kaliningrad",
      "Vilnius",
      "Belfast",
      "Middlesbrough",
      "Gdynia",
      "Gda\u0144sk",
      "Kiel",
      "Douglas",
      "Rostock",
      "Lancaster",
      "York",
      "Prince George",
      "Minsk",
      "Bradford",
      "Leeds",
      "Hamburg",
      "Edmonton",
      "Tolyatti",
      "Manchester",
      "Liverpool",
      "Sheffield",
      "Dublin",
      "Groningen",
      "Samara",
      "Bremen",
      "Petropavlovsk-Kamchatsky",
      "Nottingham",
      "Derby",
      "Leicester",
      "Norwich",
      "Peterborough",
      "Berlin",
      "Birmingham",
      "Gomel",
      "Coventry",
      "Pozna\u0144",
      "Haarlem",
      "Amsterdam",
      "Hannover",
      "Irkutsk",
      "Warsaw",
      "Enschede",
      "Cambridge",
      "Leiden",
      "Saskatoon",
      "Utrecht",
      "The Hague",
      "M\xFCnster",
      "Rotterdam",
      "Cork",
      "Adak",
      "Gloucester",
      "Oxford",
      "Voronezh",
      "Swansea",
      "Saratov",
      "Dortmund",
      "London",
      "Cardiff",
      "Greenwich",
      "Bristol",
      "Bath",
      "Leipzig",
      "D\xFCsseldorf",
      "Antwerp",
      "Astana",
      "Winchester",
      "Calgary",
      "Ghent",
      "Dresden",
      "Erfurt",
      "Calais",
      "Cologne",
      "Southampton",
      "Maastricht",
      "Brussels",
      "Brighton and Hove",
      "Portsmouth",
      "Exeter",
      "Kamloops",
      "Lille",
      "Regina",
      "Kiev",
      "Charleroi",
      "Plymouth",
      "Frankfurt am Main",
      "Prague",
      "Krak\xF3w",
      "Kharkiv",
      "Winnipeg",
      "Kelowna",
      "Lviv",
      "Luxembourg",
      "Le Havre",
      "Nuremberg",
      "Rouen",
      "Vancouver",
      "Paris",
      "Stuttgart",
      "Bellingham",
      "Volgograd",
      "Strasbourg",
      "Dnipro",
      "Victoria",
      "Saguenay",
      "Brest",
      "Thunder Bay",
      "Linz",
      "Vienna",
      "Bratislava",
      "Munich",
      "Donetsk",
      "Ulaanbaatar",
      "Orl\xE9ans",
      "Salzburg",
      "Seattle",
      "St. John's",
      "Basel",
      "Budapest",
      "Qiqihar",
      "Z\xFCrich",
      "Innsbruck",
      "Rostov-on-Don",
      "Nantes",
      "Vaduz",
      "Atyrau",
      "Graz",
      "Chi\u015Fin\u0103u",
      "Bern",
      "Tiraspol",
      "Quebec City",
      "Bismarck",
      "Duluth",
      "Saint-Pierre",
      "Cluj-Napoca",
      "Moscow",
      "Helena",
      "Sault Ste. Marie",
      "Lausanne",
      "Sudbury",
      "Odessa",
      "North Bay",
      "Charlottetown",
      "Geneva",
      "Moncton",
      "Ljubljana",
      "Fredericton",
      "Zagreb",
      "Lyon",
      "Harbin",
      "New Glasgow",
      "Portland",
      "Montreal",
      "Milan",
      "Venice",
      "Ottawa",
      "Wakkanai",
      "Saint John",
      "Novi Sad",
      "Turin",
      "Krasnodar",
      "Minneapolis",
      "Simferopol",
      "Halifax",
      "Bordeaux",
      "Belgrade",
      "\u0160abac",
      "Drobeta Turnu Severin",
      "Bologna",
      "Bucharest",
      "Ravenna",
      "Genoa",
      "Pierre",
      "Craiova",
      "Augusta",
      "Montpelier",
      "Bath",
      "San Marino",
      "Changchun",
      "Sarajevo",
      "Yarmouth",
      "\xDCr\xFCmqi",
      "Florence",
      "Asahikawa",
      "Monaco",
      "Nice",
      "Toronto",
      "Boise",
      "Toulouse",
      "Sochi",
      "Cannes",
      "Gij\xF3n",
      "Sioux Falls",
      "Split",
      "Oviedo",
      "Nemuro",
      "San Sebasti\xE1n",
      "Marseille",
      "Almaty",
      "Bilbao",
      "Concord",
      "Rochester",
      "Vladivostok",
      "Sapporo",
      "Milwaukee",
      "Sukhumi",
      "Kushiro",
      "London",
      "Follonica",
      "Obihiro",
      "Buffalo",
      "Santiago de Compostela",
      "Bishkek",
      "Vitoria-Gasteiz",
      "Sofia",
      "Pristina",
      "Andorra la Vella",
      "Nukus",
      "Podgorica",
      "Boston",
      "Detroit",
      "Windsor",
      "Vigo",
      "Tskhinvali",
      "Avezzano",
      "Skopje",
      "Colchester",
      "Rome",
      "Vatican City",
      "Chicago",
      "Providence",
      "Shenyang",
      "Chongjin",
      "Hartford",
      "Hakodate",
      "Tbilisi",
      "Valladolid",
      "Zaragoza",
      "Des Moines",
      "Braga",
      "Cleveland",
      "Barcelona",
      "Tirana",
      "Tashkent",
      "Porto",
      "Cheyenne",
      "Bari",
      "Fort Wayne",
      "Istanbul",
      "Trabzon",
      "Namangan",
      "Naples",
      "Aomori",
      "Lincoln",
      "Eureka",
      "Salt Lake City",
      "Jersey City",
      "New York City",
      "Thessaloniki",
      "Lleida",
      "Pittsburgh",
      "Baku",
      "Madrid",
      "Trenton",
      "Bursa",
      "Yerevan",
      "Boulder",
      "Columbus",
      "Ankara",
      "Philadelphia",
      "Beijing",
      "Stepanakert",
      "Forked River",
      "Eskisehir",
      "Indianapolis",
      "Denver",
      "Akita",
      "Morioka",
      "Palma",
      "Reno",
      "Flores Island",
      "Valencia",
      "Baltimore",
      "Cagliari",
      "Dover",
      "Wonsan",
      "Tianjin",
      "Cincinnati",
      "Kansas City",
      "Pyongyang",
      "Ibiza",
      "Dalian",
      "Washington",
      "Lisbon",
      "St. Louis",
      "Horta",
      "Sacramento",
      "Dushanbe",
      "Angra do Hero\xEDsmo",
      "Halkida",
      "\u0130zmir",
      "Charleston",
      "Alicante",
      "Sendai",
      "Louisville",
      "Yamagata",
      "Messina",
      "Palermo",
      "Tabriz",
      "Shijiazhuang",
      "Trapani",
      "Athena",
      "Kaesong",
      "Ashgabat",
      "Niigata",
      "Taiyuan",
      "Konya",
      "Ponta Delgada",
      "Oakland",
      "San Francisco",
      "Fukushima",
      "Wichita",
      "Seoul",
      "San Jose",
      "Catania",
      "Incheon",
      "Sevilla",
      "Mugla",
      "Springfield",
      "Gaziantep",
      "Adana",
      "Virginia Beach",
      "Almer\xEDa",
      "Tunis",
      "Mersin",
      "Algiers",
      "M\xE1laga",
      "Toyama",
      "Jinan",
      "Nagano",
      "Xining",
      "Handan",
      "Kanazawa",
      "Utsunomiya",
      "Maebashi",
      "Mito",
      "Mosul",
      "Mashhad",
      "Arbil",
      "Las Vegas",
      "Nashville",
      "Gibraltar",
      "Tulsa",
      "Fukui",
      "Qingdao",
      "Lanzhou",
      "Knoxville",
      "Valletta",
      "Birkirkara",
      "Los Alamos",
      "Daegu",
      "Raleigh",
      "Tangier",
      "Tehran",
      "Tokyo",
      "Santa Fe",
      "K\u014Dfu",
      "Chiba",
      "Latakia",
      "Kawasaki",
      "Tottori",
      "Oklahoma City",
      "Matsue",
      "Kirkuk",
      "Yokohama",
      "Gifu",
      "Tiaret",
      "Heraklion",
      "Melilla",
      "Charlotte",
      "Nagoya",
      "Busan",
      "Nicosia",
      "Memphis",
      "Albuquerque",
      "\u014Ctsu",
      "Kyoto",
      "Shizuoka",
      "Zhengzhou",
      "Little Rock",
      "Sfax",
      "Tsu",
      "Osaka",
      "K\u014Dbe",
      "Nara",
      "Okayama",
      "Kabul",
      "Santa Barbara",
      "Hiroshima",
      "Takamatsu",
      "Xi'an",
      "Wakayama",
      "Wilmington",
      "Yamaguchi",
      "Arak",
      "Srinagar",
      "Tokushima",
      "Los Angeles",
      "Rabat",
      "Peshawar",
      "Columbia",
      "Riverside",
      "Beirut",
      "Matsuyama",
      "Atlanta",
      "Islamabad",
      "Birmingham",
      "Rawalpindi",
      "Fukuoka",
      "K\u014Dchi",
      "Casablanca",
      "Damascus",
      "Phoenix",
      "Lubbock",
      "Baghdad",
      "Saga",
      "\u014Cita",
      "Tripoli",
      "Charleston",
      "Dallas",
      "Nagasaki",
      "Kumamoto",
      "San Diego",
      "Mexicali",
      "Funchal",
      "El Centro",
      "Isfahan",
      "Karbala",
      "Tijuana",
      "Shreveport",
      "Jackson",
      "Hamilton",
      "Tucson",
      "Benghazi",
      "Tel Aviv",
      "Nanjing",
      "Najaf",
      "Amman",
      "Miyazaki",
      "Ramallah",
      "Ensenada",
      "El Paso",
      "Jerusalem",
      "Ciudad Ju\xE1rez",
      "Amritsar",
      "Marrakech",
      "Kandahar",
      "Kagoshima",
      "Lahore",
      "Gaza",
      "Faisalabad",
      "Port Said",
      "Alexandria",
      "Shanghai",
      "Shimla",
      "Ludhiana",
      "Chandigarh",
      "Mobile",
      "Chengdu",
      "Wuhan",
      "Basra",
      "Agadir",
      "Jacksonville",
      "Austin",
      "Hangzhou",
      "Multan",
      "Cairo",
      "New Orleans",
      "Suez",
      "Houston",
      "Lhasa",
      "Chongqing",
      "Eilat",
      "San Antonio",
      "Kuwait City",
      "Shigatse",
      "Hermosillo",
      "Chihuahua",
      "New Delhi",
      "Santa Cruz de Tenerife",
      "Orlando",
      "Las Palmas de Gran Canaria",
      "Tampa",
      "Corpus Christi",
      "Maspalomas",
      "Kathmandu",
      "Dibrugarh",
      "Thimphu",
      "Gangtok",
      "Agra",
      "El Aai\xFAn",
      "Sabha",
      "Jaipur",
      "Lucknow",
      "Siliguri",
      "Tezpur",
      "Kanpur",
      "Dammam",
      "Naha",
      "Manama",
      "Guwahati",
      "Brownsville",
      "Miami",
      "Luxor",
      "Monterrey",
      "Patna",
      "Shillong",
      "Torre\xF3n",
      "Kulpahar",
      "Doha",
      "Dubai",
      "Hyderabad",
      "Nassau",
      "Kunming",
      "Taipei",
      "Karachi",
      "Culiac\xE1n",
      "Riyadh",
      "Key West",
      "Medina",
      "Abu Dhabi",
      "Al Ain",
      "Taichung",
      "Durango",
      "Agartala",
      "Dhaka",
      "Muscat",
      "Havana",
      "Guangzhou",
      "Ahmedabad",
      "Dongguan",
      "Tainan",
      "Cabo San Lucas",
      "Nanning",
      "Kaohsiung",
      "Kolkata (Calcutta)",
      "Shenzhen",
      "Chittagong",
      "Hong Kong",
      "Tampico",
      "San Luis Potos\xED",
      "Aguascalientes",
      "Jeddah",
      "Cockburn Town",
      "Mecca",
      "Honolulu",
      "Chhattisgarh",
      "Canc\xFAn",
      "Surat",
      "Nagpur",
      "Le\xF3n",
      "Hanoi",
      "M\xE9rida",
      "Hai Phong",
      "Zapopan",
      "Puerto Vallarta",
      "Guadalajara",
      "Quer\xE9taro",
      "Haikou",
      "Santiago de Cuba",
      "Chiang Rai",
      "Naypyidaw",
      "Hilo",
      "George Town",
      "Veracruz",
      "Puebla",
      "Mumbai",
      "Chiang Mai",
      "Port-au-Prince",
      "Pune",
      "Santo Domingo",
      "San Juan",
      "Road Town",
      "Charlotte Amalie",
      "The Valley",
      "Nouakchott",
      "Kingston",
      "Vientiane",
      "Visakhapatnam",
      "Belize City",
      "Udon Thani",
      "Hyderabad",
      "Basseterre",
      "Belmopan",
      "St. John's",
      "Salalah",
      "Acapulco",
      "Yangon",
      "Timbuktu",
      "Hu\u1EBF",
      "Khon Kaen",
      "Da Nang",
      "Basse-Terre",
      "Omdurman",
      "Khartoum",
      "Sana'a",
      "Asmara",
      "Roseau",
      "Saipan",
      "Son My",
      "Nakhon Ratchasima",
      "Praia",
      "Tapachula",
      "Quetzaltenango",
      "Thi\xE8s",
      "Dakar",
      "Quezon City",
      "Guatemala City",
      "Fort-de-France",
      "Manila",
      "Makati",
      "Ayutthaya",
      "Tegucigalpa",
      "Castries",
      "Bangkok",
      "San Salvador",
      "Niamey",
      "Dededo",
      "Hag\xE5t\xF1a",
      "Banjul",
      "Serekunda",
      "Siem Reap",
      "Brikama",
      "Kingstown",
      "Bridgetown",
      "Chennai (Madras)",
      "Bangalore",
      "Pattaya",
      "Koulikoro",
      "Bamako",
      "Chinandega",
      "Oranjestad",
      "Ouagadougou",
      "Managua",
      "Willemstad",
      "N'Djamena",
      "St. George's",
      "Kano",
      "Bissau",
      "Port Blair",
      "Djibouti",
      "Phnom Penh",
      "Bobo-Dioulasso",
      "Barranquilla",
      "Ho Chi Minh City",
      "Iloilo City",
      "Port of Spain",
      "Maracaibo",
      "Liberia",
      "Caracas",
      "Chaguanas",
      "Cartagena",
      "San Fernando",
      "Cebu City",
      "Maracay",
      "Valencia",
      "Alajuela",
      "Lim\xF3n",
      "Jaffna",
      "Hargeisa",
      "Puntarenas",
      "Kochi",
      "San Jos\xE9",
      "Tagbilaran",
      "Conakry",
      "Tamale",
      "Surat Thani",
      "Abuja",
      "Addis Ababa",
      "Panama City",
      "M\xE9rida",
      "Moundou",
      "Trivandrum",
      "Freetown",
      "Ciudad Bol\xEDvar",
      "C\xFAcuta",
      "Phuket",
      "San Crist\xF3bal",
      "Nz\xE9r\xE9kor\xE9",
      "Batticaloa",
      "Melekeok",
      "Weno",
      "Ibadan",
      "Koror",
      "Kandy",
      "Majuro",
      "Davao City",
      "Hat Yai",
      "Colombo",
      "Palikir",
      "Sri Jayawardenapura-Kotte",
      "Zamboanga City",
      "Yamoussoukro",
      "Georgetown",
      "Kumasi",
      "Porto-Novo",
      "Lagos",
      "Enugu",
      "Cotonou",
      "Benin City",
      "Monrovia",
      "Medell\xEDn",
      "Lom\xE9",
      "Kota Bharu",
      "Alor Setar",
      "Kota Kinabalu",
      "Paramaribo",
      "Puerto Ayacucho",
      "Accra",
      "Banda Aceh",
      "George Town",
      "Abidjan",
      "Cayenne",
      "Sekondi-Takoradi",
      "Bandar Seri Begawan",
      "Juba",
      "Port Harcourt",
      "Ipoh",
      "Bogot\xE1",
      "Miri",
      "Bangui",
      "Mal\xE9",
      "Douala",
      "Yaound\xE9",
      "Malabo",
      "Medan",
      "Santiago de Cali",
      "Kuala Lumpur",
      "Boa Vista",
      "Malacca Town",
      "Mogadishu",
      "Kuching",
      "Johor Bahru",
      "South Tarawa",
      "Singapore",
      "Pekanbaru",
      "Libreville",
      "S\xE3o Tom\xE9",
      "Kampala",
      "Entebbe",
      "Mbandaka",
      "Macap\xE1",
      "Pontianak",
      "Quito",
      "Kismayo",
      "Yaren District",
      "Padang",
      "Balikpapan",
      "Nairobi",
      "Bel\xE9m",
      "Kigali",
      "Guayaquil",
      "Mwanza",
      "S\xE3o Lu\xEDs",
      "Jayapura",
      "Palembang",
      "Manaus",
      "Bujumbura",
      "Sobral",
      "Ambon",
      "Fortaleza",
      "Iquitos",
      "Fernando de Noronha",
      "Mombasa",
      "Brazzaville",
      "Kinshasa",
      "Victoria",
      "Teresina",
      "Makassar",
      "Imperatriz",
      "Natal",
      "Zanzibar City",
      "Dodoma",
      "Jakarta",
      "Bogor",
      "Dar es Salaam",
      "Bandung",
      "Semarang",
      "Jo\xE3o Pessoa",
      "Juazeiro do Norte",
      "Campina Grande",
      "Surabaya",
      "Yogyakarta",
      "Malang",
      "Recife",
      "Trujillo",
      "Caruaru",
      "Funafuti",
      "Dili",
      "Denpasar",
      "Porto Velho",
      "Luanda",
      "Garanhuns",
      "Nukulaelae",
      "Petrolina",
      "Honiara",
      "Port Moresby",
      "Macei\xF3",
      "Rio Branco",
      "Aracaju",
      "Palmas",
      "Lubumbashi",
      "Moroni",
      "Sinop",
      "Lima",
      "Darwin",
      "Huambo",
      "Mamoudzou",
      "Ndola",
      "Salvador",
      "Ayacucho",
      "Mata-Utu",
      "Cusco",
      "Apia",
      "Lilongwe",
      "Pago Pago",
      "Ilh\xE9us",
      "Lusaka",
      "Cuiab\xE1",
      "Blantyre",
      "Bras\xEDlia",
      "Jamestown",
      "Arequipa",
      "Labasa",
      "Rabi Island",
      "La Paz",
      "Goi\xE2nia",
      "Cairns",
      "Papeete",
      "Port Vila",
      "Santa Cruz de la Sierra",
      "Livingstone",
      "Harare",
      "Suva",
      "Arica",
      "Governador Valadares",
      "Uberl\xE2ndia",
      "Antananarivo",
      "Mutare",
      "Sucre",
      "Alofi",
      "Townsville",
      "Gweru",
      "Belo Horizonte",
      "Port Louis",
      "Bulawayo",
      "Iquique",
      "Port Hedland",
      "Vit\xF3ria",
      "Campo Grande",
      "S\xE3o Jos\xE9 do Rio Preto",
      "Saint-Denis",
      "Nuku\u02BBalofa",
      "Francistown",
      "Ribeir\xE3o Preto",
      "Avarua",
      "Juiz de Fora",
      "Po\xE7os de Caldas",
      "Araraquara",
      "Noum\xE9a",
      "Bauru",
      "Calama",
      "Windhoek",
      "Assis",
      "Campinas",
      "Rio de Janeiro",
      "S\xE3o Jos\xE9 dos Campos",
      "Rockhampton",
      "S\xE3o Paulo",
      "Antofagasta",
      "Polokwane",
      "Gaborone",
      "Salta",
      "Adamstown",
      "Asunci\xF3n",
      "Curitiba",
      "Nelspruit",
      "Ciudad del Este",
      "Pretoria",
      "Mafikeng",
      "Maputo",
      "Johannesburg",
      "Mbabane",
      "Lobamba",
      "Manzini",
      "San Miguel de Tucum\xE1n",
      "Hanga Roa",
      "Copiap\xF3",
      "Brisbane",
      "Corrientes",
      "Florian\xF3polis",
      "Gold Coast",
      "Kimberley",
      "Kingston",
      "Bloemfontein",
      "Maseru",
      "Pietermaritzburg",
      "Durban",
      "La Serena",
      "C\xF3rdoba",
      "Santa Fe",
      "Pelotas",
      "Perth",
      "San Juan",
      "Mandurah",
      "Bhisho",
      "Mendoza",
      "Newcastle",
      "Rosario",
      "Vi\xF1a del Mar",
      "Valpara\xEDso",
      "Santiago",
      "Chu\xED",
      "Sydney",
      "Cape Town",
      "Port Elizabeth",
      "Wollongong",
      "Buenos Aires",
      "Montevideo",
      "Adelaide",
      "Canberra",
      "Concepci\xF3n",
      "Auckland",
      "Edinburgh of the Seven Seas",
      "Hamilton",
      "Melbourne",
      "Mar del Plata",
      "Geelong",
      "Bah\xEDa Blanca",
      "Temuco",
      "Neuqu\xE9n",
      "Hastings",
      "Valdivia",
      "San Carlos de Bariloche",
      "Nelson",
      "Wellington",
      "Puerto Montt",
      "Launceston, Tasmania",
      "Hobart",
      "Trelew",
      "Christchurch",
      "Waitangi",
      "Puerto Ais\xE9n",
      "Coihaique",
      "Comodoro Rivadavia",
      "Dunedin",
      "Invercargill",
      "R\xEDo Gallegos",
      "Stanley",
      "Punta Arenas",
      "Grytviken",
      "Ushuaia",
      "Puerto Williams",
      "Puerto Toro",
      "Villa Las Estrellas",
      "Esperanza",
      "Rothera",
      "Concordia"
    ];
  }
});

// ../../../../../node_modules/.deno/base64-js@1.5.1/node_modules/base64-js/index.js
var require_base64_js = __commonJS({
  "../../../../../node_modules/.deno/base64-js@1.5.1/node_modules/base64-js/index.js"(exports) {
    "use strict";
    exports.byteLength = byteLength;
    exports.toByteArray = toByteArray;
    exports.fromByteArray = fromByteArray;
    var lookup = [];
    var revLookup = [];
    var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (i2 = 0, len = code.length; i2 < len; ++i2) {
      lookup[i2] = code[i2];
      revLookup[code.charCodeAt(i2)] = i2;
    }
    var i2;
    var len;
    revLookup["-".charCodeAt(0)] = 62;
    revLookup["_".charCodeAt(0)] = 63;
    function getLens(b64) {
      var len2 = b64.length;
      if (len2 % 4 > 0) {
        throw new Error("Invalid string. Length must be a multiple of 4");
      }
      var validLen = b64.indexOf("=");
      if (validLen === -1) validLen = len2;
      var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
      return [
        validLen,
        placeHoldersLen
      ];
    }
    function byteLength(b64) {
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function _byteLength(b64, validLen, placeHoldersLen) {
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function toByteArray(b64) {
      var tmp;
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
      var curByte = 0;
      var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
      var i3;
      for (i3 = 0; i3 < len2; i3 += 4) {
        tmp = revLookup[b64.charCodeAt(i3)] << 18 | revLookup[b64.charCodeAt(i3 + 1)] << 12 | revLookup[b64.charCodeAt(i3 + 2)] << 6 | revLookup[b64.charCodeAt(i3 + 3)];
        arr[curByte++] = tmp >> 16 & 255;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i3)] << 2 | revLookup[b64.charCodeAt(i3 + 1)] >> 4;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i3)] << 10 | revLookup[b64.charCodeAt(i3 + 1)] << 4 | revLookup[b64.charCodeAt(i3 + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      return arr;
    }
    function tripletToBase64(num) {
      return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
    }
    function encodeChunk(uint8, start, end) {
      var tmp;
      var output = [];
      for (var i3 = start; i3 < end; i3 += 3) {
        tmp = (uint8[i3] << 16 & 16711680) + (uint8[i3 + 1] << 8 & 65280) + (uint8[i3 + 2] & 255);
        output.push(tripletToBase64(tmp));
      }
      return output.join("");
    }
    function fromByteArray(uint8) {
      var tmp;
      var len2 = uint8.length;
      var extraBytes = len2 % 3;
      var parts = [];
      var maxChunkLength = 16383;
      for (var i3 = 0, len22 = len2 - extraBytes; i3 < len22; i3 += maxChunkLength) {
        parts.push(encodeChunk(uint8, i3, i3 + maxChunkLength > len22 ? len22 : i3 + maxChunkLength));
      }
      if (extraBytes === 1) {
        tmp = uint8[len2 - 1];
        parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "==");
      } else if (extraBytes === 2) {
        tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
        parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "=");
      }
      return parts.join("");
    }
  }
});

// ../../../../../node_modules/.deno/tiny-inflate@1.0.3/node_modules/tiny-inflate/index.js
var require_tiny_inflate = __commonJS({
  "../../../../../node_modules/.deno/tiny-inflate@1.0.3/node_modules/tiny-inflate/index.js"(exports, module) {
    var TINF_OK = 0;
    var TINF_DATA_ERROR = -3;
    function Tree() {
      this.table = new Uint16Array(16);
      this.trans = new Uint16Array(288);
    }
    function Data(source, dest) {
      this.source = source;
      this.sourceIndex = 0;
      this.tag = 0;
      this.bitcount = 0;
      this.dest = dest;
      this.destLen = 0;
      this.ltree = new Tree();
      this.dtree = new Tree();
    }
    var sltree = new Tree();
    var sdtree = new Tree();
    var length_bits = new Uint8Array(30);
    var length_base = new Uint16Array(30);
    var dist_bits = new Uint8Array(30);
    var dist_base = new Uint16Array(30);
    var clcidx = new Uint8Array([
      16,
      17,
      18,
      0,
      8,
      7,
      9,
      6,
      10,
      5,
      11,
      4,
      12,
      3,
      13,
      2,
      14,
      1,
      15
    ]);
    var code_tree = new Tree();
    var lengths = new Uint8Array(288 + 32);
    function tinf_build_bits_base(bits, base, delta, first) {
      var i2, sum;
      for (i2 = 0; i2 < delta; ++i2) bits[i2] = 0;
      for (i2 = 0; i2 < 30 - delta; ++i2) bits[i2 + delta] = i2 / delta | 0;
      for (sum = first, i2 = 0; i2 < 30; ++i2) {
        base[i2] = sum;
        sum += 1 << bits[i2];
      }
    }
    function tinf_build_fixed_trees(lt, dt) {
      var i2;
      for (i2 = 0; i2 < 7; ++i2) lt.table[i2] = 0;
      lt.table[7] = 24;
      lt.table[8] = 152;
      lt.table[9] = 112;
      for (i2 = 0; i2 < 24; ++i2) lt.trans[i2] = 256 + i2;
      for (i2 = 0; i2 < 144; ++i2) lt.trans[24 + i2] = i2;
      for (i2 = 0; i2 < 8; ++i2) lt.trans[24 + 144 + i2] = 280 + i2;
      for (i2 = 0; i2 < 112; ++i2) lt.trans[24 + 144 + 8 + i2] = 144 + i2;
      for (i2 = 0; i2 < 5; ++i2) dt.table[i2] = 0;
      dt.table[5] = 32;
      for (i2 = 0; i2 < 32; ++i2) dt.trans[i2] = i2;
    }
    var offs = new Uint16Array(16);
    function tinf_build_tree(t, lengths2, off, num) {
      var i2, sum;
      for (i2 = 0; i2 < 16; ++i2) t.table[i2] = 0;
      for (i2 = 0; i2 < num; ++i2) t.table[lengths2[off + i2]]++;
      t.table[0] = 0;
      for (sum = 0, i2 = 0; i2 < 16; ++i2) {
        offs[i2] = sum;
        sum += t.table[i2];
      }
      for (i2 = 0; i2 < num; ++i2) {
        if (lengths2[off + i2]) t.trans[offs[lengths2[off + i2]]++] = i2;
      }
    }
    function tinf_getbit(d) {
      if (!d.bitcount--) {
        d.tag = d.source[d.sourceIndex++];
        d.bitcount = 7;
      }
      var bit = d.tag & 1;
      d.tag >>>= 1;
      return bit;
    }
    function tinf_read_bits(d, num, base) {
      if (!num) return base;
      while (d.bitcount < 24) {
        d.tag |= d.source[d.sourceIndex++] << d.bitcount;
        d.bitcount += 8;
      }
      var val = d.tag & 65535 >>> 16 - num;
      d.tag >>>= num;
      d.bitcount -= num;
      return val + base;
    }
    function tinf_decode_symbol(d, t) {
      while (d.bitcount < 24) {
        d.tag |= d.source[d.sourceIndex++] << d.bitcount;
        d.bitcount += 8;
      }
      var sum = 0, cur = 0, len = 0;
      var tag = d.tag;
      do {
        cur = 2 * cur + (tag & 1);
        tag >>>= 1;
        ++len;
        sum += t.table[len];
        cur -= t.table[len];
      } while (cur >= 0);
      d.tag = tag;
      d.bitcount -= len;
      return t.trans[sum + cur];
    }
    function tinf_decode_trees(d, lt, dt) {
      var hlit, hdist, hclen;
      var i2, num, length;
      hlit = tinf_read_bits(d, 5, 257);
      hdist = tinf_read_bits(d, 5, 1);
      hclen = tinf_read_bits(d, 4, 4);
      for (i2 = 0; i2 < 19; ++i2) lengths[i2] = 0;
      for (i2 = 0; i2 < hclen; ++i2) {
        var clen = tinf_read_bits(d, 3, 0);
        lengths[clcidx[i2]] = clen;
      }
      tinf_build_tree(code_tree, lengths, 0, 19);
      for (num = 0; num < hlit + hdist; ) {
        var sym = tinf_decode_symbol(d, code_tree);
        switch (sym) {
          case 16:
            var prev = lengths[num - 1];
            for (length = tinf_read_bits(d, 2, 3); length; --length) {
              lengths[num++] = prev;
            }
            break;
          case 17:
            for (length = tinf_read_bits(d, 3, 3); length; --length) {
              lengths[num++] = 0;
            }
            break;
          case 18:
            for (length = tinf_read_bits(d, 7, 11); length; --length) {
              lengths[num++] = 0;
            }
            break;
          default:
            lengths[num++] = sym;
            break;
        }
      }
      tinf_build_tree(lt, lengths, 0, hlit);
      tinf_build_tree(dt, lengths, hlit, hdist);
    }
    function tinf_inflate_block_data(d, lt, dt) {
      while (1) {
        var sym = tinf_decode_symbol(d, lt);
        if (sym === 256) {
          return TINF_OK;
        }
        if (sym < 256) {
          d.dest[d.destLen++] = sym;
        } else {
          var length, dist, offs2;
          var i2;
          sym -= 257;
          length = tinf_read_bits(d, length_bits[sym], length_base[sym]);
          dist = tinf_decode_symbol(d, dt);
          offs2 = d.destLen - tinf_read_bits(d, dist_bits[dist], dist_base[dist]);
          for (i2 = offs2; i2 < offs2 + length; ++i2) {
            d.dest[d.destLen++] = d.dest[i2];
          }
        }
      }
    }
    function tinf_inflate_uncompressed_block(d) {
      var length, invlength;
      var i2;
      while (d.bitcount > 8) {
        d.sourceIndex--;
        d.bitcount -= 8;
      }
      length = d.source[d.sourceIndex + 1];
      length = 256 * length + d.source[d.sourceIndex];
      invlength = d.source[d.sourceIndex + 3];
      invlength = 256 * invlength + d.source[d.sourceIndex + 2];
      if (length !== (~invlength & 65535)) return TINF_DATA_ERROR;
      d.sourceIndex += 4;
      for (i2 = length; i2; --i2) d.dest[d.destLen++] = d.source[d.sourceIndex++];
      d.bitcount = 0;
      return TINF_OK;
    }
    function tinf_uncompress(source, dest) {
      var d = new Data(source, dest);
      var bfinal, btype, res;
      do {
        bfinal = tinf_getbit(d);
        btype = tinf_read_bits(d, 2, 0);
        switch (btype) {
          case 0:
            res = tinf_inflate_uncompressed_block(d);
            break;
          case 1:
            res = tinf_inflate_block_data(d, sltree, sdtree);
            break;
          case 2:
            tinf_decode_trees(d, d.ltree, d.dtree);
            res = tinf_inflate_block_data(d, d.ltree, d.dtree);
            break;
          default:
            res = TINF_DATA_ERROR;
        }
        if (res !== TINF_OK) throw new Error("Data error");
      } while (!bfinal);
      if (d.destLen < d.dest.length) {
        if (typeof d.dest.slice === "function") return d.dest.slice(0, d.destLen);
        else return d.dest.subarray(0, d.destLen);
      }
      return d.dest;
    }
    tinf_build_fixed_trees(sltree, sdtree);
    tinf_build_bits_base(length_bits, length_base, 4, 3);
    tinf_build_bits_base(dist_bits, dist_base, 2, 1);
    length_bits[28] = 0;
    length_base[28] = 258;
    module.exports = tinf_uncompress;
  }
});

// ../../../../../node_modules/.deno/unicode-trie@2.0.0/node_modules/unicode-trie/swap.js
var require_swap = __commonJS({
  "../../../../../node_modules/.deno/unicode-trie@2.0.0/node_modules/unicode-trie/swap.js"(exports, module) {
    var isBigEndian = new Uint8Array(new Uint32Array([
      305419896
    ]).buffer)[0] === 18;
    var swap = (b, n, m) => {
      let i2 = b[n];
      b[n] = b[m];
      b[m] = i2;
    };
    var swap32 = (array) => {
      const len = array.length;
      for (let i2 = 0; i2 < len; i2 += 4) {
        swap(array, i2, i2 + 3);
        swap(array, i2 + 1, i2 + 2);
      }
    };
    var swap32LE = (array) => {
      if (isBigEndian) {
        swap32(array);
      }
    };
    module.exports = {
      swap32LE
    };
  }
});

// ../../../../../node_modules/.deno/unicode-trie@2.0.0/node_modules/unicode-trie/index.js
var require_unicode_trie = __commonJS({
  "../../../../../node_modules/.deno/unicode-trie@2.0.0/node_modules/unicode-trie/index.js"(exports, module) {
    var inflate = require_tiny_inflate();
    var { swap32LE } = require_swap();
    var SHIFT_1 = 6 + 5;
    var SHIFT_2 = 5;
    var SHIFT_1_2 = SHIFT_1 - SHIFT_2;
    var OMITTED_BMP_INDEX_1_LENGTH = 65536 >> SHIFT_1;
    var INDEX_2_BLOCK_LENGTH = 1 << SHIFT_1_2;
    var INDEX_2_MASK = INDEX_2_BLOCK_LENGTH - 1;
    var INDEX_SHIFT = 2;
    var DATA_BLOCK_LENGTH = 1 << SHIFT_2;
    var DATA_MASK = DATA_BLOCK_LENGTH - 1;
    var LSCP_INDEX_2_OFFSET = 65536 >> SHIFT_2;
    var LSCP_INDEX_2_LENGTH = 1024 >> SHIFT_2;
    var INDEX_2_BMP_LENGTH = LSCP_INDEX_2_OFFSET + LSCP_INDEX_2_LENGTH;
    var UTF8_2B_INDEX_2_OFFSET = INDEX_2_BMP_LENGTH;
    var UTF8_2B_INDEX_2_LENGTH = 2048 >> 6;
    var INDEX_1_OFFSET = UTF8_2B_INDEX_2_OFFSET + UTF8_2B_INDEX_2_LENGTH;
    var DATA_GRANULARITY = 1 << INDEX_SHIFT;
    var UnicodeTrie = class {
      constructor(data) {
        const isBuffer = typeof data.readUInt32BE === "function" && typeof data.slice === "function";
        if (isBuffer || data instanceof Uint8Array) {
          let uncompressedLength;
          if (isBuffer) {
            this.highStart = data.readUInt32LE(0);
            this.errorValue = data.readUInt32LE(4);
            uncompressedLength = data.readUInt32LE(8);
            data = data.slice(12);
          } else {
            const view = new DataView(data.buffer);
            this.highStart = view.getUint32(0, true);
            this.errorValue = view.getUint32(4, true);
            uncompressedLength = view.getUint32(8, true);
            data = data.subarray(12);
          }
          data = inflate(data, new Uint8Array(uncompressedLength));
          data = inflate(data, new Uint8Array(uncompressedLength));
          swap32LE(data);
          this.data = new Uint32Array(data.buffer);
        } else {
          ({ data: this.data, highStart: this.highStart, errorValue: this.errorValue } = data);
        }
      }
      get(codePoint) {
        let index;
        if (codePoint < 0 || codePoint > 1114111) {
          return this.errorValue;
        }
        if (codePoint < 55296 || codePoint > 56319 && codePoint <= 65535) {
          index = (this.data[codePoint >> SHIFT_2] << INDEX_SHIFT) + (codePoint & DATA_MASK);
          return this.data[index];
        }
        if (codePoint <= 65535) {
          index = (this.data[LSCP_INDEX_2_OFFSET + (codePoint - 55296 >> SHIFT_2)] << INDEX_SHIFT) + (codePoint & DATA_MASK);
          return this.data[index];
        }
        if (codePoint < this.highStart) {
          index = this.data[INDEX_1_OFFSET - OMITTED_BMP_INDEX_1_LENGTH + (codePoint >> SHIFT_1)];
          index = this.data[index + (codePoint >> SHIFT_2 & INDEX_2_MASK)];
          index = (index << INDEX_SHIFT) + (codePoint & DATA_MASK);
          return this.data[index];
        }
        return this.data[this.data.length - DATA_GRANULARITY];
      }
    };
    module.exports = UnicodeTrie;
  }
});

// ../../../../../node_modules/.deno/unicode-properties@1.4.1/node_modules/unicode-properties/dist/main.cjs
var require_main = __commonJS({
  "../../../../../node_modules/.deno/unicode-properties@1.4.1/node_modules/unicode-properties/dist/main.cjs"(exports, module) {
    var $c5L0i$base64js = require_base64_js();
    var $c5L0i$unicodetrie = require_unicode_trie();
    function $parcel$interopDefault(a) {
      return a && a.__esModule ? a.default : a;
    }
    function $parcel$defineInteropFlag(a) {
      Object.defineProperty(a, "__esModule", {
        value: true,
        configurable: true
      });
    }
    function $parcel$export(e, n, v, s) {
      Object.defineProperty(e, n, {
        get: v,
        set: s,
        enumerable: true,
        configurable: true
      });
    }
    $parcel$defineInteropFlag(module.exports);
    $parcel$export(module.exports, "getCategory", () => $43d7963e56408b24$export$410364bbb673ddbc);
    $parcel$export(module.exports, "getCombiningClass", () => $43d7963e56408b24$export$c03b919c6651ed55);
    $parcel$export(module.exports, "getScript", () => $43d7963e56408b24$export$941569448d136665);
    $parcel$export(module.exports, "getEastAsianWidth", () => $43d7963e56408b24$export$92f6187db8ca6d26);
    $parcel$export(module.exports, "getNumericValue", () => $43d7963e56408b24$export$7d1258ebb7625a0d);
    $parcel$export(module.exports, "isAlphabetic", () => $43d7963e56408b24$export$52c8ea63abd07594);
    $parcel$export(module.exports, "isDigit", () => $43d7963e56408b24$export$727d9dbc4fbb948f);
    $parcel$export(module.exports, "isPunctuation", () => $43d7963e56408b24$export$a5b49f4dc6a07d2c);
    $parcel$export(module.exports, "isLowerCase", () => $43d7963e56408b24$export$7b6804e8df61fcf5);
    $parcel$export(module.exports, "isUpperCase", () => $43d7963e56408b24$export$aebd617640818cda);
    $parcel$export(module.exports, "isTitleCase", () => $43d7963e56408b24$export$de8b4ee23b2cf823);
    $parcel$export(module.exports, "isWhiteSpace", () => $43d7963e56408b24$export$3c52dd84024ae72c);
    $parcel$export(module.exports, "isBaseForm", () => $43d7963e56408b24$export$a11bdcffe109e74b);
    $parcel$export(module.exports, "isMark", () => $43d7963e56408b24$export$e33ad6871e762338);
    $parcel$export(module.exports, "default", () => $43d7963e56408b24$export$2e2bcd8739ae039);
    var $29668e65f2091c2c$exports = {};
    $29668e65f2091c2c$exports = JSON.parse('{"categories":["Cc","Zs","Po","Sc","Ps","Pe","Sm","Pd","Nd","Lu","Sk","Pc","Ll","So","Lo","Pi","Cf","No","Pf","Lt","Lm","Mn","Me","Mc","Nl","Zl","Zp","Cs","Co"],"combiningClasses":["Not_Reordered","Above","Above_Right","Below","Attached_Above_Right","Attached_Below","Overlay","Iota_Subscript","Double_Below","Double_Above","Below_Right","Above_Left","CCC10","CCC11","CCC12","CCC13","CCC14","CCC15","CCC16","CCC17","CCC18","CCC19","CCC20","CCC21","CCC22","CCC23","CCC24","CCC25","CCC30","CCC31","CCC32","CCC27","CCC28","CCC29","CCC33","CCC34","CCC35","CCC36","Nukta","Virama","CCC84","CCC91","CCC103","CCC107","CCC118","CCC122","CCC129","CCC130","CCC132","Attached_Above","Below_Left","Left","Kana_Voicing","CCC26","Right"],"scripts":["Common","Latin","Bopomofo","Inherited","Greek","Coptic","Cyrillic","Armenian","Hebrew","Arabic","Syriac","Thaana","Nko","Samaritan","Mandaic","Devanagari","Bengali","Gurmukhi","Gujarati","Oriya","Tamil","Telugu","Kannada","Malayalam","Sinhala","Thai","Lao","Tibetan","Myanmar","Georgian","Hangul","Ethiopic","Cherokee","Canadian_Aboriginal","Ogham","Runic","Tagalog","Hanunoo","Buhid","Tagbanwa","Khmer","Mongolian","Limbu","Tai_Le","New_Tai_Lue","Buginese","Tai_Tham","Balinese","Sundanese","Batak","Lepcha","Ol_Chiki","Braille","Glagolitic","Tifinagh","Han","Hiragana","Katakana","Yi","Lisu","Vai","Bamum","Syloti_Nagri","Phags_Pa","Saurashtra","Kayah_Li","Rejang","Javanese","Cham","Tai_Viet","Meetei_Mayek","null","Linear_B","Lycian","Carian","Old_Italic","Gothic","Old_Permic","Ugaritic","Old_Persian","Deseret","Shavian","Osmanya","Osage","Elbasan","Caucasian_Albanian","Linear_A","Cypriot","Imperial_Aramaic","Palmyrene","Nabataean","Hatran","Phoenician","Lydian","Meroitic_Hieroglyphs","Meroitic_Cursive","Kharoshthi","Old_South_Arabian","Old_North_Arabian","Manichaean","Avestan","Inscriptional_Parthian","Inscriptional_Pahlavi","Psalter_Pahlavi","Old_Turkic","Old_Hungarian","Hanifi_Rohingya","Old_Sogdian","Sogdian","Elymaic","Brahmi","Kaithi","Sora_Sompeng","Chakma","Mahajani","Sharada","Khojki","Multani","Khudawadi","Grantha","Newa","Tirhuta","Siddham","Modi","Takri","Ahom","Dogra","Warang_Citi","Nandinagari","Zanabazar_Square","Soyombo","Pau_Cin_Hau","Bhaiksuki","Marchen","Masaram_Gondi","Gunjala_Gondi","Makasar","Cuneiform","Egyptian_Hieroglyphs","Anatolian_Hieroglyphs","Mro","Bassa_Vah","Pahawh_Hmong","Medefaidrin","Miao","Tangut","Nushu","Duployan","SignWriting","Nyiakeng_Puachue_Hmong","Wancho","Mende_Kikakui","Adlam"],"eaw":["N","Na","A","W","H","F"]}');
    var $43d7963e56408b24$var$trie = new (0, $parcel$interopDefault($c5L0i$unicodetrie))((0, $parcel$interopDefault($c5L0i$base64js)).toByteArray("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"));
    var $43d7963e56408b24$var$log2 = Math.log2 || ((n) => Math.log(n) / Math.LN2);
    var $43d7963e56408b24$var$bits = (n) => $43d7963e56408b24$var$log2(n) + 1 | 0;
    var $43d7963e56408b24$var$CATEGORY_BITS = $43d7963e56408b24$var$bits((0, /* @__PURE__ */ $parcel$interopDefault($29668e65f2091c2c$exports)).categories.length - 1);
    var $43d7963e56408b24$var$COMBINING_BITS = $43d7963e56408b24$var$bits((0, /* @__PURE__ */ $parcel$interopDefault($29668e65f2091c2c$exports)).combiningClasses.length - 1);
    var $43d7963e56408b24$var$SCRIPT_BITS = $43d7963e56408b24$var$bits((0, /* @__PURE__ */ $parcel$interopDefault($29668e65f2091c2c$exports)).scripts.length - 1);
    var $43d7963e56408b24$var$EAW_BITS = $43d7963e56408b24$var$bits((0, /* @__PURE__ */ $parcel$interopDefault($29668e65f2091c2c$exports)).eaw.length - 1);
    var $43d7963e56408b24$var$NUMBER_BITS = 10;
    var $43d7963e56408b24$var$CATEGORY_SHIFT = $43d7963e56408b24$var$COMBINING_BITS + $43d7963e56408b24$var$SCRIPT_BITS + $43d7963e56408b24$var$EAW_BITS + $43d7963e56408b24$var$NUMBER_BITS;
    var $43d7963e56408b24$var$COMBINING_SHIFT = $43d7963e56408b24$var$SCRIPT_BITS + $43d7963e56408b24$var$EAW_BITS + $43d7963e56408b24$var$NUMBER_BITS;
    var $43d7963e56408b24$var$SCRIPT_SHIFT = $43d7963e56408b24$var$EAW_BITS + $43d7963e56408b24$var$NUMBER_BITS;
    var $43d7963e56408b24$var$EAW_SHIFT = $43d7963e56408b24$var$NUMBER_BITS;
    var $43d7963e56408b24$var$CATEGORY_MASK = (1 << $43d7963e56408b24$var$CATEGORY_BITS) - 1;
    var $43d7963e56408b24$var$COMBINING_MASK = (1 << $43d7963e56408b24$var$COMBINING_BITS) - 1;
    var $43d7963e56408b24$var$SCRIPT_MASK = (1 << $43d7963e56408b24$var$SCRIPT_BITS) - 1;
    var $43d7963e56408b24$var$EAW_MASK = (1 << $43d7963e56408b24$var$EAW_BITS) - 1;
    var $43d7963e56408b24$var$NUMBER_MASK = (1 << $43d7963e56408b24$var$NUMBER_BITS) - 1;
    function $43d7963e56408b24$export$410364bbb673ddbc(codePoint) {
      const val = $43d7963e56408b24$var$trie.get(codePoint);
      return (0, /* @__PURE__ */ $parcel$interopDefault($29668e65f2091c2c$exports)).categories[val >> $43d7963e56408b24$var$CATEGORY_SHIFT & $43d7963e56408b24$var$CATEGORY_MASK];
    }
    function $43d7963e56408b24$export$c03b919c6651ed55(codePoint) {
      const val = $43d7963e56408b24$var$trie.get(codePoint);
      return (0, /* @__PURE__ */ $parcel$interopDefault($29668e65f2091c2c$exports)).combiningClasses[val >> $43d7963e56408b24$var$COMBINING_SHIFT & $43d7963e56408b24$var$COMBINING_MASK];
    }
    function $43d7963e56408b24$export$941569448d136665(codePoint) {
      const val = $43d7963e56408b24$var$trie.get(codePoint);
      return (0, /* @__PURE__ */ $parcel$interopDefault($29668e65f2091c2c$exports)).scripts[val >> $43d7963e56408b24$var$SCRIPT_SHIFT & $43d7963e56408b24$var$SCRIPT_MASK];
    }
    function $43d7963e56408b24$export$92f6187db8ca6d26(codePoint) {
      const val = $43d7963e56408b24$var$trie.get(codePoint);
      return (0, /* @__PURE__ */ $parcel$interopDefault($29668e65f2091c2c$exports)).eaw[val >> $43d7963e56408b24$var$EAW_SHIFT & $43d7963e56408b24$var$EAW_MASK];
    }
    function $43d7963e56408b24$export$7d1258ebb7625a0d(codePoint) {
      let val = $43d7963e56408b24$var$trie.get(codePoint);
      let num = val & $43d7963e56408b24$var$NUMBER_MASK;
      if (num === 0) return null;
      else if (num <= 50) return num - 1;
      else if (num < 480) {
        const numerator = (num >> 4) - 12;
        const denominator = (num & 15) + 1;
        return numerator / denominator;
      } else if (num < 768) {
        val = (num >> 5) - 14;
        let exp = (num & 31) + 2;
        while (exp > 0) {
          val *= 10;
          exp--;
        }
        return val;
      } else {
        val = (num >> 2) - 191;
        let exp = (num & 3) + 1;
        while (exp > 0) {
          val *= 60;
          exp--;
        }
        return val;
      }
    }
    function $43d7963e56408b24$export$52c8ea63abd07594(codePoint) {
      const category = $43d7963e56408b24$export$410364bbb673ddbc(codePoint);
      return category === "Lu" || category === "Ll" || category === "Lt" || category === "Lm" || category === "Lo" || category === "Nl";
    }
    function $43d7963e56408b24$export$727d9dbc4fbb948f(codePoint) {
      return $43d7963e56408b24$export$410364bbb673ddbc(codePoint) === "Nd";
    }
    function $43d7963e56408b24$export$a5b49f4dc6a07d2c(codePoint) {
      const category = $43d7963e56408b24$export$410364bbb673ddbc(codePoint);
      return category === "Pc" || category === "Pd" || category === "Pe" || category === "Pf" || category === "Pi" || category === "Po" || category === "Ps";
    }
    function $43d7963e56408b24$export$7b6804e8df61fcf5(codePoint) {
      return $43d7963e56408b24$export$410364bbb673ddbc(codePoint) === "Ll";
    }
    function $43d7963e56408b24$export$aebd617640818cda(codePoint) {
      return $43d7963e56408b24$export$410364bbb673ddbc(codePoint) === "Lu";
    }
    function $43d7963e56408b24$export$de8b4ee23b2cf823(codePoint) {
      return $43d7963e56408b24$export$410364bbb673ddbc(codePoint) === "Lt";
    }
    function $43d7963e56408b24$export$3c52dd84024ae72c(codePoint) {
      const category = $43d7963e56408b24$export$410364bbb673ddbc(codePoint);
      return category === "Zs" || category === "Zl" || category === "Zp";
    }
    function $43d7963e56408b24$export$a11bdcffe109e74b(codePoint) {
      const category = $43d7963e56408b24$export$410364bbb673ddbc(codePoint);
      return category === "Nd" || category === "No" || category === "Nl" || category === "Lu" || category === "Ll" || category === "Lt" || category === "Lm" || category === "Lo" || category === "Me" || category === "Mc";
    }
    function $43d7963e56408b24$export$e33ad6871e762338(codePoint) {
      const category = $43d7963e56408b24$export$410364bbb673ddbc(codePoint);
      return category === "Mn" || category === "Me" || category === "Mc";
    }
    var $43d7963e56408b24$export$2e2bcd8739ae039 = {
      getCategory: $43d7963e56408b24$export$410364bbb673ddbc,
      getCombiningClass: $43d7963e56408b24$export$c03b919c6651ed55,
      getScript: $43d7963e56408b24$export$941569448d136665,
      getEastAsianWidth: $43d7963e56408b24$export$92f6187db8ca6d26,
      getNumericValue: $43d7963e56408b24$export$7d1258ebb7625a0d,
      isAlphabetic: $43d7963e56408b24$export$52c8ea63abd07594,
      isDigit: $43d7963e56408b24$export$727d9dbc4fbb948f,
      isPunctuation: $43d7963e56408b24$export$a5b49f4dc6a07d2c,
      isLowerCase: $43d7963e56408b24$export$7b6804e8df61fcf5,
      isUpperCase: $43d7963e56408b24$export$aebd617640818cda,
      isTitleCase: $43d7963e56408b24$export$de8b4ee23b2cf823,
      isWhiteSpace: $43d7963e56408b24$export$3c52dd84024ae72c,
      isBaseForm: $43d7963e56408b24$export$a11bdcffe109e74b,
      isMark: $43d7963e56408b24$export$e33ad6871e762338
    };
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/Messages.js
var require_Messages = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/Messages.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.QuickTypeError = void 0;
    exports.messageError = messageError;
    exports.messageAssert = messageAssert;
    var errorMessages = {
      InternalError: "Internal error: ${message}",
      // Misc
      MiscJSONParseError: "Syntax error in ${description} JSON ${address}: ${message}",
      MiscReadError: "Cannot read from file or URL ${fileOrURL}: ${message}",
      MiscUnicodeHighSurrogateWithoutLowSurrogate: "Malformed unicode: High surrogate not followed by low surrogate",
      MiscInvalidMinMaxConstraint: "Invalid min-max constraint: ${min}-${max}",
      // Inference
      InferenceJSONReferenceNotRooted: "JSON reference doesn't start with '#/': ${reference}",
      InferenceJSONReferenceToUnion: "JSON reference points to a union type: ${reference}",
      InferenceJSONReferenceWrongProperty: "JSON reference points to a non-existant property: ${reference}",
      InferenceJSONReferenceInvalidArrayIndex: "JSON reference uses invalid array index: ${reference}",
      // JSON Schema input
      SchemaArrayIsInvalidSchema: "An array is not a valid JSON Schema at ${ref}",
      SchemaNullIsInvalidSchema: "null is not a valid JSON Schema at ${ref}",
      SchemaRefMustBeString: "$ref must be a string, but is an ${actual} at ${ref}",
      SchemaAdditionalTypesForbidRequired: "Can't have non-specified required properties but forbidden additionalTypes at ${ref}",
      SchemaNoTypeSpecified: "JSON Schema must specify at least one type at ${ref}",
      SchemaInvalidType: "Invalid type ${type} in JSON Schema at ${ref}",
      SchemaFalseNotSupported: 'Schema "false" is not supported at ${ref}',
      SchemaInvalidJSONSchemaType: "Value of type ${type} is not valid JSON Schema at ${ref}",
      SchemaRequiredMustBeStringOrStringArray: "`required` must be string or array of strings, but is ${actual} at ${ref}",
      SchemaRequiredElementMustBeString: "`required` must contain only strings, but it has ${element}, at ${ref}",
      SchemaTypeMustBeStringOrStringArray: "`type` must be string or array of strings, but is ${actual}",
      SchemaTypeElementMustBeString: "`type` must contain only strings, but it has ${element}",
      SchemaArrayItemsMustBeStringOrArray: "Array items must be an array or an object, but is ${actual}",
      SchemaIDMustHaveAddress: "$id ${id} doesn't have an address at ${ref}",
      SchemaWrongAccessorEntryArrayLength: "Accessor entry array must have the same number of entries as the ${operation} at ${ref}",
      SchemaSetOperationCasesIsNotArray: "${operation} cases must be an array, but is ${cases}, at ${ref}",
      SchemaMoreThanOneUnionMemberName: "More than one name given for union member: ${names}",
      SchemaCannotGetTypesFromBoolean: "Schema value to get top-level types from must be an object, but is boolean, at ${ref}",
      SchemaCannotIndexArrayWithNonNumber: "Trying to index array in schema with key that is not a number, but is ${actual} at ${ref}",
      SchemaIndexNotInArray: "Index ${index} out of range of schema array at ${ref}",
      SchemaKeyNotInObject: "Key ${key} not in schema object at ${ref}",
      SchemaFetchError: "Could not fetch schema ${address}, referred to from ${base}",
      SchemaFetchErrorTopLevel: "Could not fetch top-level schema ${address}",
      SchemaFetchErrorAdditional: "Could not fetch additional schema ${address}",
      // GraphQL input
      GraphQLNoQueriesDefined: "GraphQL file doesn't have any queries defined.",
      // Driver
      DriverUnknownSourceLanguage: "Unknown source language ${lang}",
      DriverUnknownOutputLanguage: "Unknown output language ${lang}",
      DriverMoreThanOneInputGiven: "More than one input given for top-level ${topLevel}",
      DriverCannotInferNameForSchema: "Cannot infer name for schema ${uri}",
      DriverNoGraphQLQueryGiven: "Please specify at least one GraphQL query as input",
      DriverNoGraphQLSchemaInDir: "No GraphQL schema in ${dir}",
      DriverMoreThanOneGraphQLSchemaInDir: "More than one GraphQL schema in ${dir}",
      DriverSourceLangMustBeGraphQL: "If a GraphQL schema is specified, the source language must be GraphQL",
      DriverGraphQLSchemaNeeded: "Please specify a GraphQL schema with --graphql-schema or --graphql-introspect",
      DriverInputFileDoesNotExist: "Input file ${filename} does not exist",
      DriverCannotMixJSONWithOtherSamples: "Cannot mix JSON samples with JSON Schems, GraphQL, or TypeScript in input subdirectory ${dir}",
      DriverCannotMixNonJSONInputs: "Cannot mix JSON Schema, GraphQL, and TypeScript in an input subdirectory ${dir}",
      DriverUnknownDebugOption: "Unknown debug option ${option}",
      DriverNoLanguageOrExtension: "Please specify a language (--lang) or an output file extension",
      DriverCLIOptionParsingFailed: "Option parsing failed: ${message}",
      // IR
      IRNoForwardDeclarableTypeInCycle: "Cannot resolve cycle because it doesn't contain types that can be forward declared",
      IRTypeAttributesNotPropagated: "Type attributes for ${count} types were not carried over to the new graph: ${indexes}",
      IRNoEmptyUnions: "Trying to make an empty union - do you have an impossible type in your schema?",
      // Rendering
      RendererUnknownOptionValue: "Unknown value ${value} for option ${name}",
      // TypeScript input
      TypeScriptCompilerError: "TypeScript error: ${message}"
    };
    var QuickTypeError = class extends Error {
      constructor(errorMessage, messageName, userMessage, properties) {
        super(userMessage);
        this.errorMessage = errorMessage;
        this.messageName = messageName;
        this.userMessage = userMessage;
        this.properties = properties;
      }
    };
    exports.QuickTypeError = QuickTypeError;
    function messageError(kind, properties) {
      const message = errorMessages[kind];
      let userMessage = message;
      for (const [name, value] of Object.entries(properties)) {
        let valueString = "";
        if (typeof value === "object" && typeof (value === null || value === void 0 ? void 0 : value.toString) === "function") {
          valueString = value.toString();
        } else if (typeof (value === null || value === void 0 ? void 0 : value.message) === "string") {
          valueString = value.message;
        } else if (typeof value !== "string") {
          valueString = JSON.stringify(value);
        }
        userMessage = userMessage.replace("${" + name + "}", valueString);
      }
      throw new QuickTypeError(message, kind, userMessage, properties);
    }
    function messageAssert(assertion, kind, properties) {
      if (assertion) return;
      return messageError(kind, properties);
    }
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/support/Acronyms.const.js
var require_Acronyms_const = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/support/Acronyms.const.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.acronyms = void 0;
    exports.acronyms = [
      "aaa",
      "aabb",
      "aac",
      "aal",
      "aalc",
      "aarp",
      "abac",
      "abcl",
      "abi",
      "abm",
      "abr",
      "ac",
      "acd",
      "ack",
      "acl",
      "acm",
      "acme",
      "acp",
      "acpi",
      "acr",
      "adb",
      "adc",
      "adccp",
      "ado",
      "adsl",
      "adt",
      "ae",
      "aes",
      "af",
      "afp",
      "agp",
      "ai",
      "aix",
      "alac",
      "algol",
      "alsa",
      "alu",
      "amd",
      "amoled",
      "amqp",
      "amr",
      "ann",
      "ansi",
      "aop",
      "apci",
      "api",
      "apic",
      "apipa",
      "apl",
      "apr",
      "arin",
      "aros",
      "arp",
      "arpa",
      "arpanet",
      "ascii",
      "aset",
      "asg",
      "asic",
      "asimo",
      "aslr",
      "asm",
      "asmp",
      "asp",
      "asr",
      "assp",
      "ast",
      "ata",
      "atag",
      "atapi",
      "atm",
      "av",
      "avc",
      "avi",
      "awfl",
      "awk",
      "awt",
      "bal",
      "bam",
      "bbp",
      "bbs",
      "bcd",
      "bcnf",
      "beep",
      "ber",
      "bfd",
      "bfs",
      "bft",
      "bgp",
      "bi",
      "binac",
      "bios",
      "bjt",
      "bmp",
      "bnc",
      "boinc",
      "bom",
      "bootp",
      "bpdu",
      "bpel",
      "bpl",
      "bpm",
      "brm",
      "brms",
      "brr",
      "brs",
      "bsa",
      "bsb",
      "bsd",
      "bss",
      "bt",
      "bw",
      "byod",
      "ca",
      "cad",
      "cae",
      "cai",
      "caid",
      "captcha",
      "caq",
      "cd",
      "cde",
      "cdfs",
      "cdma",
      "cdn",
      "cdp",
      "cdsa",
      "cert",
      "ces",
      "cf",
      "cfd",
      "cfg",
      "cg",
      "cga",
      "cgi",
      "cgt",
      "chs",
      "cidr",
      "cifs",
      "cim",
      "cio",
      "cir",
      "cisc",
      "cjk",
      "cjkv",
      "cli",
      "clr",
      "cm",
      "cmdb",
      "cmmi",
      "cmo",
      "cmos",
      "cms",
      "cn",
      "cnc",
      "cng",
      "cnr",
      "cobol",
      "com",
      "corba",
      "cots",
      "cpa",
      "cpan",
      "cpri",
      "cps",
      "cpu",
      "cr",
      "cran",
      "crc",
      "crlf",
      "crm",
      "crs",
      "crt",
      "crud",
      "cs",
      "cse",
      "csi",
      "csm",
      "csp",
      "csrf",
      "css",
      "csv",
      "ct",
      "ctan",
      "ctcp",
      "ctfe",
      "cti",
      "ctl",
      "ctm",
      "cts",
      "ctss",
      "cua",
      "cvs",
      "dac",
      "dal",
      "dao",
      "dap",
      "darpa",
      "dat",
      "db",
      "dba",
      "dbcs",
      "dbms",
      "dcc",
      "dcca",
      "dccp",
      "dcl",
      "dcmi",
      "dcom",
      "dcs",
      "dd",
      "dde",
      "ddi",
      "ddl",
      "ddr",
      "dec",
      "des",
      "dfa",
      "dfd",
      "dfs",
      "dgd",
      "dhcp",
      "dhtml",
      "dif",
      "dimm",
      "din",
      "dip",
      "dism",
      "divx",
      "dkim",
      "dl",
      "dll",
      "dlna",
      "dlp",
      "dma",
      "dmca",
      "dmi",
      "dml",
      "dmr",
      "dmz",
      "dn",
      "dnd",
      "dns",
      "doa",
      "docsis",
      "dom",
      "dos",
      "dp",
      "dpc",
      "dpi",
      "dpmi",
      "dpms",
      "dr",
      "dram",
      "dri",
      "drm",
      "dsa",
      "dsdl",
      "dsdm",
      "dsl",
      "dslam",
      "dsn",
      "dsp",
      "dsssl",
      "dtd",
      "dte",
      "dtp",
      "dtr",
      "dvd",
      "dvi",
      "dvr",
      "dw",
      "eai",
      "eap",
      "eas",
      "ebcdic",
      "ebml",
      "ecc",
      "ecma",
      "ecn",
      "ecos",
      "ecrs",
      "eda",
      "edi",
      "edo",
      "edsac",
      "edvac",
      "eeprom",
      "eff",
      "efi",
      "efm",
      "efs",
      "ega",
      "egp",
      "eide",
      "eigrp",
      "eisa",
      "elf",
      "emacs",
      "ems",
      "eniac",
      "eod",
      "eof",
      "eol",
      "eom",
      "eos",
      "eprom",
      "erd",
      "erm",
      "erp",
      "esb",
      "escon",
      "esd",
      "esr",
      "etl",
      "etw",
      "euc",
      "eula",
      "ewmh",
      "ext",
      "fap",
      "faq",
      "fasm",
      "fbdimm",
      "fcb",
      "fcs",
      "fdc",
      "fdd",
      "fddi",
      "fdm",
      "fdma",
      "fds",
      "fec",
      "femb",
      "fet",
      "fhs",
      "ficon",
      "fifo",
      "fips",
      "fl",
      "flac",
      "flops",
      "fmc",
      "fmo",
      "foldoc",
      "fosdem",
      "fosi",
      "foss",
      "fp",
      "fpga",
      "fps",
      "fpu",
      "fqdn",
      "fru",
      "fs",
      "fsb",
      "fsf",
      "fsm",
      "ftp",
      "ftta",
      "fttc",
      "ftth",
      "fttp",
      "fud",
      "fvek",
      "fws",
      "fxp",
      "fyi",
      "gb",
      "gcc",
      "gcj",
      "gcr",
      "gdb",
      "gdi",
      "geran",
      "gfdl",
      "gif",
      "gigo",
      "gimps",
      "gis",
      "gml",
      "gnu",
      "goms",
      "gpasm",
      "gpfs",
      "gpg",
      "gpgpu",
      "gpib",
      "gpl",
      "gprs",
      "gpt",
      "gpu",
      "gsm",
      "gui",
      "guid",
      "gwt",
      "gyr",
      "hal",
      "hasp",
      "hba",
      "hci",
      "hcl",
      "hd",
      "hdd",
      "hdl",
      "hdmi",
      "hf",
      "hfs",
      "hhd",
      "hid",
      "hig",
      "hird",
      "hlasm",
      "hls",
      "hma",
      "hp",
      "hpc",
      "hpfs",
      "hsdpa",
      "hsm",
      "ht",
      "htc",
      "htm",
      "html",
      "http",
      "https",
      "htx",
      "hurd",
      "hvd",
      "iana",
      "ibm",
      "ic",
      "icann",
      "ich",
      "icmp",
      "icp",
      "ics",
      "ict",
      "id",
      "ide",
      "idf",
      "idl",
      "ids",
      "iec",
      "ieee",
      "ietf",
      "ifl",
      "igmp",
      "igrp",
      "ihv",
      "iiop",
      "iis",
      "ike",
      "il",
      "im",
      "imap",
      "ime",
      "infosec",
      "ip",
      "ipam",
      "ipc",
      "ipl",
      "ipmi",
      "ipo",
      "ipp",
      "ips",
      "iptv",
      "ipx",
      "ir",
      "irc",
      "iri",
      "irp",
      "irq",
      "isa",
      "isam",
      "isatap",
      "isc",
      "isdn",
      "iso",
      "isp",
      "ispf",
      "isr",
      "isv",
      "itil",
      "itl",
      "itu",
      "ivcr",
      "ivrs",
      "jaxb",
      "jaxp",
      "jbod",
      "jce",
      "jcl",
      "jcp",
      "jdbc",
      "jdk",
      "jds",
      "jee",
      "jes",
      "jfc",
      "jfet",
      "jfs",
      "jini",
      "jit",
      "jme",
      "jms",
      "jmx",
      "jndi",
      "jni",
      "jnz",
      "jpeg",
      "jre",
      "js",
      "jse",
      "json",
      "jsp",
      "jtag",
      "jvm",
      "kb",
      "kde",
      "km",
      "krl",
      "kvm",
      "lacp",
      "lan",
      "lb",
      "lba",
      "lcd",
      "lcos",
      "lcr",
      "ldap",
      "le",
      "led",
      "lf",
      "lfs",
      "lga",
      "lgpl",
      "lib",
      "lif",
      "lifo",
      "lilo",
      "lisp",
      "lkml",
      "lm",
      "loc",
      "lpc",
      "lpi",
      "lpt",
      "lru",
      "lsb",
      "lsi",
      "lte",
      "ltl",
      "ltr",
      "lun",
      "lv",
      "lvd",
      "lvm",
      "lzw",
      "mac",
      "manet",
      "mapi",
      "mb",
      "mbcs",
      "mbd",
      "mbr",
      "mca",
      "mcad",
      "mcas",
      "mcdba",
      "mcdst",
      "mcitp",
      "mcm",
      "mcp",
      "mcpc",
      "mcpd",
      "mcsa",
      "mcsd",
      "mcse",
      "mct",
      "mcts",
      "mda",
      "mdf",
      "mdi",
      "mf",
      "mfc",
      "mfm",
      "mgcp",
      "mib",
      "micr",
      "midi",
      "mimd",
      "mime",
      "mimo",
      "minix",
      "mips",
      "mis",
      "misd",
      "mit",
      "mmc",
      "mmds",
      "mmf",
      "mmi",
      "mmio",
      "mmorpg",
      "mmu",
      "mmx",
      "mng",
      "mom",
      "mos",
      "mosfet",
      "motd",
      "mous",
      "mov",
      "mpaa",
      "mpeg",
      "mpl",
      "mpls",
      "mpu",
      "ms",
      "msa",
      "msb",
      "msdn",
      "msi",
      "msn",
      "mt",
      "mta",
      "mtbf",
      "mtu",
      "mua",
      "mvc",
      "mvp",
      "mvs",
      "mwc",
      "mx",
      "mxf",
      "nack",
      "nak",
      "nas",
      "nasm",
      "ncp",
      "ncq",
      "ncsa",
      "ndis",
      "ndps",
      "nds",
      "nep",
      "nfa",
      "nfc",
      "nfs",
      "ngl",
      "ngscb",
      "ni",
      "nic",
      "nim",
      "nio",
      "nist",
      "nlp",
      "nls",
      "nmi",
      "nntp",
      "noc",
      "nop",
      "nos",
      "np",
      "npl",
      "nptl",
      "npu",
      "ns",
      "nsa",
      "nsi",
      "nspr",
      "nss",
      "nt",
      "ntfs",
      "ntlm",
      "ntp",
      "numa",
      "nurbs",
      "nvr",
      "nvram",
      "oat",
      "obsai",
      "odbc",
      "oem",
      "oes",
      "ofdm",
      "oftc",
      "oid",
      "olap",
      "ole",
      "oled",
      "olpc",
      "oltp",
      "omf",
      "omg",
      "omr",
      "oo",
      "ooe",
      "oom",
      "oop",
      "ootb",
      "opml",
      "orb",
      "orm",
      "os",
      "oscon",
      "osdn",
      "osi",
      "ospf",
      "oss",
      "ostg",
      "oui",
      "pap",
      "parc",
      "pata",
      "pbs",
      "pc",
      "pcb",
      "pci",
      "pcl",
      "pcm",
      "pcmcia",
      "pcre",
      "pd",
      "pda",
      "pdf",
      "pdh",
      "pdp",
      "pe",
      "perl",
      "pfa",
      "pg",
      "pga",
      "pgo",
      "pgp",
      "php",
      "pid",
      "pim",
      "pio",
      "pkcs",
      "pki",
      "plc",
      "pld",
      "plt",
      "pmm",
      "png",
      "pnrp",
      "poid",
      "pojo",
      "posix",
      "ppc",
      "ppi",
      "ppp",
      "pptp",
      "pr",
      "ps",
      "psa",
      "psm",
      "psu",
      "psvi",
      "pv",
      "pvg",
      "pvr",
      "pxe",
      "pxi",
      "qa",
      "qdr",
      "qfp",
      "qotd",
      "qsop",
      "qtam",
      "racf",
      "rad",
      "raid",
      "raii",
      "rait",
      "ram",
      "rarp",
      "ras",
      "rc",
      "rcs",
      "rd",
      "rdbms",
      "rdc",
      "rdf",
      "rdm",
      "rdos",
      "rdp",
      "rds",
      "refal",
      "rest",
      "rf",
      "rfc",
      "rfi",
      "rfid",
      "rgb",
      "rgba",
      "rhel",
      "rhl",
      "ria",
      "riaa",
      "rip",
      "rir",
      "risc",
      "rje",
      "rle",
      "rll",
      "rmi",
      "rms",
      "rom",
      "romb",
      "rpc",
      "rpg",
      "rpm",
      "rras",
      "rsa",
      "rsi",
      "rss",
      "rtai",
      "rtc",
      "rte",
      "rtems",
      "rtl",
      "rtos",
      "rtp",
      "rts",
      "rtsp",
      "rtti",
      "rwd",
      "san",
      "sas",
      "sata",
      "sax",
      "sbod",
      "sbu",
      "scada",
      "scid",
      "scm",
      "scp",
      "scpc",
      "scpi",
      "scsa",
      "scsi",
      "sctp",
      "sd",
      "sddl",
      "sdh",
      "sdi",
      "sdio",
      "sdk",
      "sdl",
      "sdn",
      "sdp",
      "sdr",
      "sdram",
      "sdsl",
      "se",
      "sec",
      "sei",
      "seo",
      "sftp",
      "sgi",
      "sgml",
      "sgr",
      "sha",
      "shdsl",
      "sigcat",
      "siggraph",
      "simd",
      "simm",
      "sip",
      "sisd",
      "siso",
      "sles",
      "sli",
      "slm",
      "sloc",
      "sma",
      "smb",
      "smbios",
      "sme",
      "smf",
      "smil",
      "smp",
      "smps",
      "sms",
      "smt",
      "smtp",
      "sna",
      "snmp",
      "sntp",
      "soa",
      "soe",
      "soho",
      "soi",
      "sopa",
      "sp",
      "spa",
      "sparc",
      "spf",
      "spi",
      "spm",
      "spmd",
      "sql",
      "sram",
      "ssa",
      "ssd",
      "ssdp",
      "sse",
      "ssh",
      "ssi",
      "ssid",
      "ssl",
      "ssp",
      "ssse",
      "sssp",
      "sstp",
      "sus",
      "suse",
      "svc",
      "svd",
      "svg",
      "svga",
      "swf",
      "swt",
      "tao",
      "tapi",
      "tasm",
      "tb",
      "tcp",
      "tcu",
      "tdma",
      "tft",
      "tftp",
      "ti",
      "tla",
      "tld",
      "tls",
      "tlv",
      "tnc",
      "tpf",
      "tpm",
      "troff",
      "tron",
      "trsdos",
      "tso",
      "tsp",
      "tsr",
      "tta",
      "ttf",
      "ttl",
      "tts",
      "tty",
      "tucows",
      "twain",
      "uaag",
      "uac",
      "uart",
      "uat",
      "ucs",
      "uddi",
      "udma",
      "udp",
      "uefi",
      "uhf",
      "ui",
      "ul",
      "ula",
      "uma",
      "umb",
      "uml",
      "umpc",
      "umts",
      "unc",
      "univac",
      "ups",
      "uri",
      "url",
      "usb",
      "usr",
      "utc",
      "utf",
      "utp",
      "utran",
      "uucp",
      "uuid",
      "uun",
      "uvc",
      "uwp",
      "ux",
      "vax",
      "vb",
      "vba",
      "vbs",
      "vcpi",
      "vdm",
      "vdsl",
      "vesa",
      "vfat",
      "vfs",
      "vg",
      "vga",
      "vhf",
      "vlan",
      "vlb",
      "vlf",
      "vliw",
      "vlsi",
      "vlsm",
      "vm",
      "vmm",
      "vnc",
      "vod",
      "vpn",
      "vpu",
      "vr",
      "vram",
      "vrml",
      "vsam",
      "vsat",
      "vt",
      "vtam",
      "vtl",
      "wafs",
      "wai",
      "wais",
      "wan",
      "wap",
      "wasm",
      "wbem",
      "wcag",
      "wcf",
      "wdm",
      "wep",
      "wfi",
      "wins",
      "wlan",
      "wma",
      "wmi",
      "wmv",
      "wns",
      "wol",
      "wor",
      "wora",
      "wpa",
      "wpad",
      "wpan",
      "wpf",
      "wsdl",
      "wsfl",
      "wusb",
      "wwan",
      "wwdc",
      "wwid",
      "wwn",
      "www",
      "wysiwyg",
      "wzc",
      "xag",
      "xaml",
      "xcbl",
      "xdm",
      "xdmcp",
      "xhtml",
      "xilp",
      "xml",
      "xmms",
      "xmpp",
      "xms",
      "xns",
      "xp",
      "xpcom",
      "xpi",
      "xpidl",
      "xps",
      "xsd",
      "xsl",
      "xslt",
      "xss",
      "xtf",
      "xul",
      "xvga",
      "yaaf",
      "yacc",
      "yaml",
      "zcav",
      "zcs",
      "zif",
      "zifs",
      "zisc",
      "zma",
      "zoi",
      "zope",
      "zpl"
    ];
  }
});

// ../../../../../node_modules/.deno/js-base64@3.7.8/node_modules/js-base64/base64.js
var require_base64 = __commonJS({
  "../../../../../node_modules/.deno/js-base64@3.7.8/node_modules/js-base64/base64.js"(exports, module) {
    (function(global2, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (
        // cf. https://github.com/dankogai/js-base64/issues/119
        function() {
          var _Base64 = global2.Base64;
          var gBase64 = factory();
          gBase64.noConflict = function() {
            global2.Base64 = _Base64;
            return gBase64;
          };
          if (global2.Meteor) {
            Base64 = gBase64;
          }
          global2.Base64 = gBase64;
        }()
      );
    })(typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : exports, function() {
      "use strict";
      var version = "3.7.8";
      var VERSION = version;
      var _hasBuffer = typeof Buffer === "function";
      var _TD = typeof TextDecoder === "function" ? new TextDecoder() : void 0;
      var _TE = typeof TextEncoder === "function" ? new TextEncoder() : void 0;
      var b64ch = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
      var b64chs = Array.prototype.slice.call(b64ch);
      var b64tab = function(a) {
        var tab = {};
        a.forEach(function(c, i2) {
          return tab[c] = i2;
        });
        return tab;
      }(b64chs);
      var b64re = /^(?:[A-Za-z\d+\/]{4})*?(?:[A-Za-z\d+\/]{2}(?:==)?|[A-Za-z\d+\/]{3}=?)?$/;
      var _fromCC = String.fromCharCode.bind(String);
      var _U8Afrom = typeof Uint8Array.from === "function" ? Uint8Array.from.bind(Uint8Array) : function(it) {
        return new Uint8Array(Array.prototype.slice.call(it, 0));
      };
      var _mkUriSafe = function(src) {
        return src.replace(/=/g, "").replace(/[+\/]/g, function(m0) {
          return m0 == "+" ? "-" : "_";
        });
      };
      var _tidyB64 = function(s) {
        return s.replace(/[^A-Za-z0-9\+\/]/g, "");
      };
      var btoaPolyfill = function(bin) {
        var u32, c0, c1, c2, asc = "";
        var pad = bin.length % 3;
        for (var i2 = 0; i2 < bin.length; ) {
          if ((c0 = bin.charCodeAt(i2++)) > 255 || (c1 = bin.charCodeAt(i2++)) > 255 || (c2 = bin.charCodeAt(i2++)) > 255) throw new TypeError("invalid character found");
          u32 = c0 << 16 | c1 << 8 | c2;
          asc += b64chs[u32 >> 18 & 63] + b64chs[u32 >> 12 & 63] + b64chs[u32 >> 6 & 63] + b64chs[u32 & 63];
        }
        return pad ? asc.slice(0, pad - 3) + "===".substring(pad) : asc;
      };
      var _btoa = typeof btoa === "function" ? function(bin) {
        return btoa(bin);
      } : _hasBuffer ? function(bin) {
        return Buffer.from(bin, "binary").toString("base64");
      } : btoaPolyfill;
      var _fromUint8Array = _hasBuffer ? function(u8a) {
        return Buffer.from(u8a).toString("base64");
      } : function(u8a) {
        var maxargs = 4096;
        var strs = [];
        for (var i2 = 0, l = u8a.length; i2 < l; i2 += maxargs) {
          strs.push(_fromCC.apply(null, u8a.subarray(i2, i2 + maxargs)));
        }
        return _btoa(strs.join(""));
      };
      var fromUint8Array = function(u8a, urlsafe) {
        if (urlsafe === void 0) {
          urlsafe = false;
        }
        return urlsafe ? _mkUriSafe(_fromUint8Array(u8a)) : _fromUint8Array(u8a);
      };
      var cb_utob = function(c) {
        if (c.length < 2) {
          var cc = c.charCodeAt(0);
          return cc < 128 ? c : cc < 2048 ? _fromCC(192 | cc >>> 6) + _fromCC(128 | cc & 63) : _fromCC(224 | cc >>> 12 & 15) + _fromCC(128 | cc >>> 6 & 63) + _fromCC(128 | cc & 63);
        } else {
          var cc = 65536 + (c.charCodeAt(0) - 55296) * 1024 + (c.charCodeAt(1) - 56320);
          return _fromCC(240 | cc >>> 18 & 7) + _fromCC(128 | cc >>> 12 & 63) + _fromCC(128 | cc >>> 6 & 63) + _fromCC(128 | cc & 63);
        }
      };
      var re_utob = /[\uD800-\uDBFF][\uDC00-\uDFFFF]|[^\x00-\x7F]/g;
      var utob = function(u) {
        return u.replace(re_utob, cb_utob);
      };
      var _encode = _hasBuffer ? function(s) {
        return Buffer.from(s, "utf8").toString("base64");
      } : _TE ? function(s) {
        return _fromUint8Array(_TE.encode(s));
      } : function(s) {
        return _btoa(utob(s));
      };
      var encode = function(src, urlsafe) {
        if (urlsafe === void 0) {
          urlsafe = false;
        }
        return urlsafe ? _mkUriSafe(_encode(src)) : _encode(src);
      };
      var encodeURI = function(src) {
        return encode(src, true);
      };
      var re_btou = /[\xC0-\xDF][\x80-\xBF]|[\xE0-\xEF][\x80-\xBF]{2}|[\xF0-\xF7][\x80-\xBF]{3}/g;
      var cb_btou = function(cccc) {
        switch (cccc.length) {
          case 4:
            var cp = (7 & cccc.charCodeAt(0)) << 18 | (63 & cccc.charCodeAt(1)) << 12 | (63 & cccc.charCodeAt(2)) << 6 | 63 & cccc.charCodeAt(3), offset = cp - 65536;
            return _fromCC((offset >>> 10) + 55296) + _fromCC((offset & 1023) + 56320);
          case 3:
            return _fromCC((15 & cccc.charCodeAt(0)) << 12 | (63 & cccc.charCodeAt(1)) << 6 | 63 & cccc.charCodeAt(2));
          default:
            return _fromCC((31 & cccc.charCodeAt(0)) << 6 | 63 & cccc.charCodeAt(1));
        }
      };
      var btou = function(b) {
        return b.replace(re_btou, cb_btou);
      };
      var atobPolyfill = function(asc) {
        asc = asc.replace(/\s+/g, "");
        if (!b64re.test(asc)) throw new TypeError("malformed base64.");
        asc += "==".slice(2 - (asc.length & 3));
        var u24, r1, r2;
        var binArray = [];
        for (var i2 = 0; i2 < asc.length; ) {
          u24 = b64tab[asc.charAt(i2++)] << 18 | b64tab[asc.charAt(i2++)] << 12 | (r1 = b64tab[asc.charAt(i2++)]) << 6 | (r2 = b64tab[asc.charAt(i2++)]);
          if (r1 === 64) {
            binArray.push(_fromCC(u24 >> 16 & 255));
          } else if (r2 === 64) {
            binArray.push(_fromCC(u24 >> 16 & 255, u24 >> 8 & 255));
          } else {
            binArray.push(_fromCC(u24 >> 16 & 255, u24 >> 8 & 255, u24 & 255));
          }
        }
        return binArray.join("");
      };
      var _atob = typeof atob === "function" ? function(asc) {
        return atob(_tidyB64(asc));
      } : _hasBuffer ? function(asc) {
        return Buffer.from(asc, "base64").toString("binary");
      } : atobPolyfill;
      var _toUint8Array = _hasBuffer ? function(a) {
        return _U8Afrom(Buffer.from(a, "base64"));
      } : function(a) {
        return _U8Afrom(_atob(a).split("").map(function(c) {
          return c.charCodeAt(0);
        }));
      };
      var toUint8Array = function(a) {
        return _toUint8Array(_unURI(a));
      };
      var _decode = _hasBuffer ? function(a) {
        return Buffer.from(a, "base64").toString("utf8");
      } : _TD ? function(a) {
        return _TD.decode(_toUint8Array(a));
      } : function(a) {
        return btou(_atob(a));
      };
      var _unURI = function(a) {
        return _tidyB64(a.replace(/[-_]/g, function(m0) {
          return m0 == "-" ? "+" : "/";
        }));
      };
      var decode = function(src) {
        return _decode(_unURI(src));
      };
      var isValid = function(src) {
        if (typeof src !== "string") return false;
        var s = src.replace(/\s+/g, "").replace(/={0,2}$/, "");
        return !/[^\s0-9a-zA-Z\+/]/.test(s) || !/[^\s0-9a-zA-Z\-_]/.test(s);
      };
      var _noEnum = function(v) {
        return {
          value: v,
          enumerable: false,
          writable: true,
          configurable: true
        };
      };
      var extendString = function() {
        var _add = function(name, body) {
          return Object.defineProperty(String.prototype, name, _noEnum(body));
        };
        _add("fromBase64", function() {
          return decode(this);
        });
        _add("toBase64", function(urlsafe) {
          return encode(this, urlsafe);
        });
        _add("toBase64URI", function() {
          return encode(this, true);
        });
        _add("toBase64URL", function() {
          return encode(this, true);
        });
        _add("toUint8Array", function() {
          return toUint8Array(this);
        });
      };
      var extendUint8Array = function() {
        var _add = function(name, body) {
          return Object.defineProperty(Uint8Array.prototype, name, _noEnum(body));
        };
        _add("toBase64", function(urlsafe) {
          return fromUint8Array(this, urlsafe);
        });
        _add("toBase64URI", function() {
          return fromUint8Array(this, true);
        });
        _add("toBase64URL", function() {
          return fromUint8Array(this, true);
        });
      };
      var extendBuiltins = function() {
        extendString();
        extendUint8Array();
      };
      var gBase64 = {
        version,
        VERSION,
        atob: _atob,
        atobPolyfill,
        btoa: _btoa,
        btoaPolyfill,
        fromBase64: decode,
        toBase64: encode,
        encode,
        encodeURI,
        encodeURL: encodeURI,
        utob,
        btou,
        decode,
        isValid,
        fromUint8Array,
        toUint8Array,
        extendString,
        extendUint8Array,
        extendBuiltins
      };
      gBase64.Base64 = {};
      Object.keys(gBase64).forEach(function(k) {
        return gBase64.Base64[k] = gBase64[k];
      });
      return gBase64;
    });
  }
});

// ../../../../../node_modules/.deno/pako@1.0.11/node_modules/pako/lib/utils/common.js
var require_common = __commonJS({
  "../../../../../node_modules/.deno/pako@1.0.11/node_modules/pako/lib/utils/common.js"(exports) {
    "use strict";
    var TYPED_OK = typeof Uint8Array !== "undefined" && typeof Uint16Array !== "undefined" && typeof Int32Array !== "undefined";
    function _has(obj2, key) {
      return Object.prototype.hasOwnProperty.call(obj2, key);
    }
    exports.assign = function(obj2) {
      var sources = Array.prototype.slice.call(arguments, 1);
      while (sources.length) {
        var source = sources.shift();
        if (!source) {
          continue;
        }
        if (typeof source !== "object") {
          throw new TypeError(source + "must be non-object");
        }
        for (var p in source) {
          if (_has(source, p)) {
            obj2[p] = source[p];
          }
        }
      }
      return obj2;
    };
    exports.shrinkBuf = function(buf, size) {
      if (buf.length === size) {
        return buf;
      }
      if (buf.subarray) {
        return buf.subarray(0, size);
      }
      buf.length = size;
      return buf;
    };
    var fnTyped = {
      arraySet: function(dest, src, src_offs, len, dest_offs) {
        if (src.subarray && dest.subarray) {
          dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
          return;
        }
        for (var i2 = 0; i2 < len; i2++) {
          dest[dest_offs + i2] = src[src_offs + i2];
        }
      },
      // Join array of chunks to single array.
      flattenChunks: function(chunks) {
        var i2, l, len, pos, chunk, result;
        len = 0;
        for (i2 = 0, l = chunks.length; i2 < l; i2++) {
          len += chunks[i2].length;
        }
        result = new Uint8Array(len);
        pos = 0;
        for (i2 = 0, l = chunks.length; i2 < l; i2++) {
          chunk = chunks[i2];
          result.set(chunk, pos);
          pos += chunk.length;
        }
        return result;
      }
    };
    var fnUntyped = {
      arraySet: function(dest, src, src_offs, len, dest_offs) {
        for (var i2 = 0; i2 < len; i2++) {
          dest[dest_offs + i2] = src[src_offs + i2];
        }
      },
      // Join array of chunks to single array.
      flattenChunks: function(chunks) {
        return [].concat.apply([], chunks);
      }
    };
    exports.setTyped = function(on) {
      if (on) {
        exports.Buf8 = Uint8Array;
        exports.Buf16 = Uint16Array;
        exports.Buf32 = Int32Array;
        exports.assign(exports, fnTyped);
      } else {
        exports.Buf8 = Array;
        exports.Buf16 = Array;
        exports.Buf32 = Array;
        exports.assign(exports, fnUntyped);
      }
    };
    exports.setTyped(TYPED_OK);
  }
});

// ../../../../../node_modules/.deno/pako@1.0.11/node_modules/pako/lib/zlib/trees.js
var require_trees = __commonJS({
  "../../../../../node_modules/.deno/pako@1.0.11/node_modules/pako/lib/zlib/trees.js"(exports) {
    "use strict";
    var utils = require_common();
    var Z_FIXED = 4;
    var Z_BINARY = 0;
    var Z_TEXT = 1;
    var Z_UNKNOWN = 2;
    function zero(buf) {
      var len = buf.length;
      while (--len >= 0) {
        buf[len] = 0;
      }
    }
    var STORED_BLOCK = 0;
    var STATIC_TREES = 1;
    var DYN_TREES = 2;
    var MIN_MATCH = 3;
    var MAX_MATCH = 258;
    var LENGTH_CODES = 29;
    var LITERALS = 256;
    var L_CODES = LITERALS + 1 + LENGTH_CODES;
    var D_CODES = 30;
    var BL_CODES = 19;
    var HEAP_SIZE = 2 * L_CODES + 1;
    var MAX_BITS = 15;
    var Buf_size = 16;
    var MAX_BL_BITS = 7;
    var END_BLOCK = 256;
    var REP_3_6 = 16;
    var REPZ_3_10 = 17;
    var REPZ_11_138 = 18;
    var extra_lbits = (
      /* extra bits for each length code */
      [
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        1,
        1,
        1,
        1,
        2,
        2,
        2,
        2,
        3,
        3,
        3,
        3,
        4,
        4,
        4,
        4,
        5,
        5,
        5,
        5,
        0
      ]
    );
    var extra_dbits = (
      /* extra bits for each distance code */
      [
        0,
        0,
        0,
        0,
        1,
        1,
        2,
        2,
        3,
        3,
        4,
        4,
        5,
        5,
        6,
        6,
        7,
        7,
        8,
        8,
        9,
        9,
        10,
        10,
        11,
        11,
        12,
        12,
        13,
        13
      ]
    );
    var extra_blbits = (
      /* extra bits for each bit length code */
      [
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        2,
        3,
        7
      ]
    );
    var bl_order = [
      16,
      17,
      18,
      0,
      8,
      7,
      9,
      6,
      10,
      5,
      11,
      4,
      12,
      3,
      13,
      2,
      14,
      1,
      15
    ];
    var DIST_CODE_LEN = 512;
    var static_ltree = new Array((L_CODES + 2) * 2);
    zero(static_ltree);
    var static_dtree = new Array(D_CODES * 2);
    zero(static_dtree);
    var _dist_code = new Array(DIST_CODE_LEN);
    zero(_dist_code);
    var _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);
    zero(_length_code);
    var base_length = new Array(LENGTH_CODES);
    zero(base_length);
    var base_dist = new Array(D_CODES);
    zero(base_dist);
    function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
      this.static_tree = static_tree;
      this.extra_bits = extra_bits;
      this.extra_base = extra_base;
      this.elems = elems;
      this.max_length = max_length;
      this.has_stree = static_tree && static_tree.length;
    }
    var static_l_desc;
    var static_d_desc;
    var static_bl_desc;
    function TreeDesc(dyn_tree, stat_desc) {
      this.dyn_tree = dyn_tree;
      this.max_code = 0;
      this.stat_desc = stat_desc;
    }
    function d_code(dist) {
      return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
    }
    function put_short(s, w) {
      s.pending_buf[s.pending++] = w & 255;
      s.pending_buf[s.pending++] = w >>> 8 & 255;
    }
    function send_bits(s, value, length) {
      if (s.bi_valid > Buf_size - length) {
        s.bi_buf |= value << s.bi_valid & 65535;
        put_short(s, s.bi_buf);
        s.bi_buf = value >> Buf_size - s.bi_valid;
        s.bi_valid += length - Buf_size;
      } else {
        s.bi_buf |= value << s.bi_valid & 65535;
        s.bi_valid += length;
      }
    }
    function send_code(s, c, tree) {
      send_bits(s, tree[c * 2], tree[c * 2 + 1]);
    }
    function bi_reverse(code, len) {
      var res = 0;
      do {
        res |= code & 1;
        code >>>= 1;
        res <<= 1;
      } while (--len > 0);
      return res >>> 1;
    }
    function bi_flush(s) {
      if (s.bi_valid === 16) {
        put_short(s, s.bi_buf);
        s.bi_buf = 0;
        s.bi_valid = 0;
      } else if (s.bi_valid >= 8) {
        s.pending_buf[s.pending++] = s.bi_buf & 255;
        s.bi_buf >>= 8;
        s.bi_valid -= 8;
      }
    }
    function gen_bitlen(s, desc) {
      var tree = desc.dyn_tree;
      var max_code = desc.max_code;
      var stree = desc.stat_desc.static_tree;
      var has_stree = desc.stat_desc.has_stree;
      var extra = desc.stat_desc.extra_bits;
      var base = desc.stat_desc.extra_base;
      var max_length = desc.stat_desc.max_length;
      var h;
      var n, m;
      var bits;
      var xbits;
      var f;
      var overflow = 0;
      for (bits = 0; bits <= MAX_BITS; bits++) {
        s.bl_count[bits] = 0;
      }
      tree[s.heap[s.heap_max] * 2 + 1] = 0;
      for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {
        n = s.heap[h];
        bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
        if (bits > max_length) {
          bits = max_length;
          overflow++;
        }
        tree[n * 2 + 1] = bits;
        if (n > max_code) {
          continue;
        }
        s.bl_count[bits]++;
        xbits = 0;
        if (n >= base) {
          xbits = extra[n - base];
        }
        f = tree[n * 2];
        s.opt_len += f * (bits + xbits);
        if (has_stree) {
          s.static_len += f * (stree[n * 2 + 1] + xbits);
        }
      }
      if (overflow === 0) {
        return;
      }
      do {
        bits = max_length - 1;
        while (s.bl_count[bits] === 0) {
          bits--;
        }
        s.bl_count[bits]--;
        s.bl_count[bits + 1] += 2;
        s.bl_count[max_length]--;
        overflow -= 2;
      } while (overflow > 0);
      for (bits = max_length; bits !== 0; bits--) {
        n = s.bl_count[bits];
        while (n !== 0) {
          m = s.heap[--h];
          if (m > max_code) {
            continue;
          }
          if (tree[m * 2 + 1] !== bits) {
            s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
            tree[m * 2 + 1] = bits;
          }
          n--;
        }
      }
    }
    function gen_codes(tree, max_code, bl_count) {
      var next_code = new Array(MAX_BITS + 1);
      var code = 0;
      var bits;
      var n;
      for (bits = 1; bits <= MAX_BITS; bits++) {
        next_code[bits] = code = code + bl_count[bits - 1] << 1;
      }
      for (n = 0; n <= max_code; n++) {
        var len = tree[n * 2 + 1];
        if (len === 0) {
          continue;
        }
        tree[n * 2] = bi_reverse(next_code[len]++, len);
      }
    }
    function tr_static_init() {
      var n;
      var bits;
      var length;
      var code;
      var dist;
      var bl_count = new Array(MAX_BITS + 1);
      length = 0;
      for (code = 0; code < LENGTH_CODES - 1; code++) {
        base_length[code] = length;
        for (n = 0; n < 1 << extra_lbits[code]; n++) {
          _length_code[length++] = code;
        }
      }
      _length_code[length - 1] = code;
      dist = 0;
      for (code = 0; code < 16; code++) {
        base_dist[code] = dist;
        for (n = 0; n < 1 << extra_dbits[code]; n++) {
          _dist_code[dist++] = code;
        }
      }
      dist >>= 7;
      for (; code < D_CODES; code++) {
        base_dist[code] = dist << 7;
        for (n = 0; n < 1 << extra_dbits[code] - 7; n++) {
          _dist_code[256 + dist++] = code;
        }
      }
      for (bits = 0; bits <= MAX_BITS; bits++) {
        bl_count[bits] = 0;
      }
      n = 0;
      while (n <= 143) {
        static_ltree[n * 2 + 1] = 8;
        n++;
        bl_count[8]++;
      }
      while (n <= 255) {
        static_ltree[n * 2 + 1] = 9;
        n++;
        bl_count[9]++;
      }
      while (n <= 279) {
        static_ltree[n * 2 + 1] = 7;
        n++;
        bl_count[7]++;
      }
      while (n <= 287) {
        static_ltree[n * 2 + 1] = 8;
        n++;
        bl_count[8]++;
      }
      gen_codes(static_ltree, L_CODES + 1, bl_count);
      for (n = 0; n < D_CODES; n++) {
        static_dtree[n * 2 + 1] = 5;
        static_dtree[n * 2] = bi_reverse(n, 5);
      }
      static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
      static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS);
      static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS);
    }
    function init_block(s) {
      var n;
      for (n = 0; n < L_CODES; n++) {
        s.dyn_ltree[n * 2] = 0;
      }
      for (n = 0; n < D_CODES; n++) {
        s.dyn_dtree[n * 2] = 0;
      }
      for (n = 0; n < BL_CODES; n++) {
        s.bl_tree[n * 2] = 0;
      }
      s.dyn_ltree[END_BLOCK * 2] = 1;
      s.opt_len = s.static_len = 0;
      s.last_lit = s.matches = 0;
    }
    function bi_windup(s) {
      if (s.bi_valid > 8) {
        put_short(s, s.bi_buf);
      } else if (s.bi_valid > 0) {
        s.pending_buf[s.pending++] = s.bi_buf;
      }
      s.bi_buf = 0;
      s.bi_valid = 0;
    }
    function copy_block(s, buf, len, header) {
      bi_windup(s);
      if (header) {
        put_short(s, len);
        put_short(s, ~len);
      }
      utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);
      s.pending += len;
    }
    function smaller(tree, n, m, depth) {
      var _n2 = n * 2;
      var _m2 = m * 2;
      return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m];
    }
    function pqdownheap(s, tree, k) {
      var v = s.heap[k];
      var j = k << 1;
      while (j <= s.heap_len) {
        if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
          j++;
        }
        if (smaller(tree, v, s.heap[j], s.depth)) {
          break;
        }
        s.heap[k] = s.heap[j];
        k = j;
        j <<= 1;
      }
      s.heap[k] = v;
    }
    function compress_block(s, ltree, dtree) {
      var dist;
      var lc;
      var lx = 0;
      var code;
      var extra;
      if (s.last_lit !== 0) {
        do {
          dist = s.pending_buf[s.d_buf + lx * 2] << 8 | s.pending_buf[s.d_buf + lx * 2 + 1];
          lc = s.pending_buf[s.l_buf + lx];
          lx++;
          if (dist === 0) {
            send_code(s, lc, ltree);
          } else {
            code = _length_code[lc];
            send_code(s, code + LITERALS + 1, ltree);
            extra = extra_lbits[code];
            if (extra !== 0) {
              lc -= base_length[code];
              send_bits(s, lc, extra);
            }
            dist--;
            code = d_code(dist);
            send_code(s, code, dtree);
            extra = extra_dbits[code];
            if (extra !== 0) {
              dist -= base_dist[code];
              send_bits(s, dist, extra);
            }
          }
        } while (lx < s.last_lit);
      }
      send_code(s, END_BLOCK, ltree);
    }
    function build_tree(s, desc) {
      var tree = desc.dyn_tree;
      var stree = desc.stat_desc.static_tree;
      var has_stree = desc.stat_desc.has_stree;
      var elems = desc.stat_desc.elems;
      var n, m;
      var max_code = -1;
      var node;
      s.heap_len = 0;
      s.heap_max = HEAP_SIZE;
      for (n = 0; n < elems; n++) {
        if (tree[n * 2] !== 0) {
          s.heap[++s.heap_len] = max_code = n;
          s.depth[n] = 0;
        } else {
          tree[n * 2 + 1] = 0;
        }
      }
      while (s.heap_len < 2) {
        node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
        tree[node * 2] = 1;
        s.depth[node] = 0;
        s.opt_len--;
        if (has_stree) {
          s.static_len -= stree[node * 2 + 1];
        }
      }
      desc.max_code = max_code;
      for (n = s.heap_len >> 1; n >= 1; n--) {
        pqdownheap(s, tree, n);
      }
      node = elems;
      do {
        n = s.heap[
          1
          /*SMALLEST*/
        ];
        s.heap[
          1
          /*SMALLEST*/
        ] = s.heap[s.heap_len--];
        pqdownheap(
          s,
          tree,
          1
          /*SMALLEST*/
        );
        m = s.heap[
          1
          /*SMALLEST*/
        ];
        s.heap[--s.heap_max] = n;
        s.heap[--s.heap_max] = m;
        tree[node * 2] = tree[n * 2] + tree[m * 2];
        s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
        tree[n * 2 + 1] = tree[m * 2 + 1] = node;
        s.heap[
          1
          /*SMALLEST*/
        ] = node++;
        pqdownheap(
          s,
          tree,
          1
          /*SMALLEST*/
        );
      } while (s.heap_len >= 2);
      s.heap[--s.heap_max] = s.heap[
        1
        /*SMALLEST*/
      ];
      gen_bitlen(s, desc);
      gen_codes(tree, max_code, s.bl_count);
    }
    function scan_tree(s, tree, max_code) {
      var n;
      var prevlen = -1;
      var curlen;
      var nextlen = tree[0 * 2 + 1];
      var count = 0;
      var max_count = 7;
      var min_count = 4;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      }
      tree[(max_code + 1) * 2 + 1] = 65535;
      for (n = 0; n <= max_code; n++) {
        curlen = nextlen;
        nextlen = tree[(n + 1) * 2 + 1];
        if (++count < max_count && curlen === nextlen) {
          continue;
        } else if (count < min_count) {
          s.bl_tree[curlen * 2] += count;
        } else if (curlen !== 0) {
          if (curlen !== prevlen) {
            s.bl_tree[curlen * 2]++;
          }
          s.bl_tree[REP_3_6 * 2]++;
        } else if (count <= 10) {
          s.bl_tree[REPZ_3_10 * 2]++;
        } else {
          s.bl_tree[REPZ_11_138 * 2]++;
        }
        count = 0;
        prevlen = curlen;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        } else if (curlen === nextlen) {
          max_count = 6;
          min_count = 3;
        } else {
          max_count = 7;
          min_count = 4;
        }
      }
    }
    function send_tree(s, tree, max_code) {
      var n;
      var prevlen = -1;
      var curlen;
      var nextlen = tree[0 * 2 + 1];
      var count = 0;
      var max_count = 7;
      var min_count = 4;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      }
      for (n = 0; n <= max_code; n++) {
        curlen = nextlen;
        nextlen = tree[(n + 1) * 2 + 1];
        if (++count < max_count && curlen === nextlen) {
          continue;
        } else if (count < min_count) {
          do {
            send_code(s, curlen, s.bl_tree);
          } while (--count !== 0);
        } else if (curlen !== 0) {
          if (curlen !== prevlen) {
            send_code(s, curlen, s.bl_tree);
            count--;
          }
          send_code(s, REP_3_6, s.bl_tree);
          send_bits(s, count - 3, 2);
        } else if (count <= 10) {
          send_code(s, REPZ_3_10, s.bl_tree);
          send_bits(s, count - 3, 3);
        } else {
          send_code(s, REPZ_11_138, s.bl_tree);
          send_bits(s, count - 11, 7);
        }
        count = 0;
        prevlen = curlen;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        } else if (curlen === nextlen) {
          max_count = 6;
          min_count = 3;
        } else {
          max_count = 7;
          min_count = 4;
        }
      }
    }
    function build_bl_tree(s) {
      var max_blindex;
      scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
      scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
      build_tree(s, s.bl_desc);
      for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
        if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
          break;
        }
      }
      s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
      return max_blindex;
    }
    function send_all_trees(s, lcodes, dcodes, blcodes) {
      var rank;
      send_bits(s, lcodes - 257, 5);
      send_bits(s, dcodes - 1, 5);
      send_bits(s, blcodes - 4, 4);
      for (rank = 0; rank < blcodes; rank++) {
        send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1], 3);
      }
      send_tree(s, s.dyn_ltree, lcodes - 1);
      send_tree(s, s.dyn_dtree, dcodes - 1);
    }
    function detect_data_type(s) {
      var black_mask = 4093624447;
      var n;
      for (n = 0; n <= 31; n++, black_mask >>>= 1) {
        if (black_mask & 1 && s.dyn_ltree[n * 2] !== 0) {
          return Z_BINARY;
        }
      }
      if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {
        return Z_TEXT;
      }
      for (n = 32; n < LITERALS; n++) {
        if (s.dyn_ltree[n * 2] !== 0) {
          return Z_TEXT;
        }
      }
      return Z_BINARY;
    }
    var static_init_done = false;
    function _tr_init(s) {
      if (!static_init_done) {
        tr_static_init();
        static_init_done = true;
      }
      s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
      s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
      s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
      s.bi_buf = 0;
      s.bi_valid = 0;
      init_block(s);
    }
    function _tr_stored_block(s, buf, stored_len, last) {
      send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);
      copy_block(s, buf, stored_len, true);
    }
    function _tr_align(s) {
      send_bits(s, STATIC_TREES << 1, 3);
      send_code(s, END_BLOCK, static_ltree);
      bi_flush(s);
    }
    function _tr_flush_block(s, buf, stored_len, last) {
      var opt_lenb, static_lenb;
      var max_blindex = 0;
      if (s.level > 0) {
        if (s.strm.data_type === Z_UNKNOWN) {
          s.strm.data_type = detect_data_type(s);
        }
        build_tree(s, s.l_desc);
        build_tree(s, s.d_desc);
        max_blindex = build_bl_tree(s);
        opt_lenb = s.opt_len + 3 + 7 >>> 3;
        static_lenb = s.static_len + 3 + 7 >>> 3;
        if (static_lenb <= opt_lenb) {
          opt_lenb = static_lenb;
        }
      } else {
        opt_lenb = static_lenb = stored_len + 5;
      }
      if (stored_len + 4 <= opt_lenb && buf !== -1) {
        _tr_stored_block(s, buf, stored_len, last);
      } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {
        send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
        compress_block(s, static_ltree, static_dtree);
      } else {
        send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
        send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
        compress_block(s, s.dyn_ltree, s.dyn_dtree);
      }
      init_block(s);
      if (last) {
        bi_windup(s);
      }
    }
    function _tr_tally(s, dist, lc) {
      s.pending_buf[s.d_buf + s.last_lit * 2] = dist >>> 8 & 255;
      s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 255;
      s.pending_buf[s.l_buf + s.last_lit] = lc & 255;
      s.last_lit++;
      if (dist === 0) {
        s.dyn_ltree[lc * 2]++;
      } else {
        s.matches++;
        dist--;
        s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]++;
        s.dyn_dtree[d_code(dist) * 2]++;
      }
      return s.last_lit === s.lit_bufsize - 1;
    }
    exports._tr_init = _tr_init;
    exports._tr_stored_block = _tr_stored_block;
    exports._tr_flush_block = _tr_flush_block;
    exports._tr_tally = _tr_tally;
    exports._tr_align = _tr_align;
  }
});

// ../../../../../node_modules/.deno/pako@1.0.11/node_modules/pako/lib/zlib/adler32.js
var require_adler32 = __commonJS({
  "../../../../../node_modules/.deno/pako@1.0.11/node_modules/pako/lib/zlib/adler32.js"(exports, module) {
    "use strict";
    function adler32(adler, buf, len, pos) {
      var s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n = 0;
      while (len !== 0) {
        n = len > 2e3 ? 2e3 : len;
        len -= n;
        do {
          s1 = s1 + buf[pos++] | 0;
          s2 = s2 + s1 | 0;
        } while (--n);
        s1 %= 65521;
        s2 %= 65521;
      }
      return s1 | s2 << 16 | 0;
    }
    module.exports = adler32;
  }
});

// ../../../../../node_modules/.deno/pako@1.0.11/node_modules/pako/lib/zlib/crc32.js
var require_crc32 = __commonJS({
  "../../../../../node_modules/.deno/pako@1.0.11/node_modules/pako/lib/zlib/crc32.js"(exports, module) {
    "use strict";
    function makeTable() {
      var c, table = [];
      for (var n = 0; n < 256; n++) {
        c = n;
        for (var k = 0; k < 8; k++) {
          c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
        }
        table[n] = c;
      }
      return table;
    }
    var crcTable = makeTable();
    function crc32(crc, buf, len, pos) {
      var t = crcTable, end = pos + len;
      crc ^= -1;
      for (var i2 = pos; i2 < end; i2++) {
        crc = crc >>> 8 ^ t[(crc ^ buf[i2]) & 255];
      }
      return crc ^ -1;
    }
    module.exports = crc32;
  }
});

// ../../../../../node_modules/.deno/pako@1.0.11/node_modules/pako/lib/zlib/messages.js
var require_messages = __commonJS({
  "../../../../../node_modules/.deno/pako@1.0.11/node_modules/pako/lib/zlib/messages.js"(exports, module) {
    "use strict";
    module.exports = {
      2: "need dictionary",
      /* Z_NEED_DICT       2  */
      1: "stream end",
      /* Z_STREAM_END      1  */
      0: "",
      /* Z_OK              0  */
      "-1": "file error",
      /* Z_ERRNO         (-1) */
      "-2": "stream error",
      /* Z_STREAM_ERROR  (-2) */
      "-3": "data error",
      /* Z_DATA_ERROR    (-3) */
      "-4": "insufficient memory",
      /* Z_MEM_ERROR     (-4) */
      "-5": "buffer error",
      /* Z_BUF_ERROR     (-5) */
      "-6": "incompatible version"
      /* Z_VERSION_ERROR (-6) */
    };
  }
});

// ../../../../../node_modules/.deno/pako@1.0.11/node_modules/pako/lib/zlib/deflate.js
var require_deflate = __commonJS({
  "../../../../../node_modules/.deno/pako@1.0.11/node_modules/pako/lib/zlib/deflate.js"(exports) {
    "use strict";
    var utils = require_common();
    var trees = require_trees();
    var adler32 = require_adler32();
    var crc32 = require_crc32();
    var msg = require_messages();
    var Z_NO_FLUSH = 0;
    var Z_PARTIAL_FLUSH = 1;
    var Z_FULL_FLUSH = 3;
    var Z_FINISH = 4;
    var Z_BLOCK = 5;
    var Z_OK = 0;
    var Z_STREAM_END = 1;
    var Z_STREAM_ERROR = -2;
    var Z_DATA_ERROR = -3;
    var Z_BUF_ERROR = -5;
    var Z_DEFAULT_COMPRESSION = -1;
    var Z_FILTERED = 1;
    var Z_HUFFMAN_ONLY = 2;
    var Z_RLE = 3;
    var Z_FIXED = 4;
    var Z_DEFAULT_STRATEGY = 0;
    var Z_UNKNOWN = 2;
    var Z_DEFLATED = 8;
    var MAX_MEM_LEVEL = 9;
    var MAX_WBITS = 15;
    var DEF_MEM_LEVEL = 8;
    var LENGTH_CODES = 29;
    var LITERALS = 256;
    var L_CODES = LITERALS + 1 + LENGTH_CODES;
    var D_CODES = 30;
    var BL_CODES = 19;
    var HEAP_SIZE = 2 * L_CODES + 1;
    var MAX_BITS = 15;
    var MIN_MATCH = 3;
    var MAX_MATCH = 258;
    var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
    var PRESET_DICT = 32;
    var INIT_STATE = 42;
    var EXTRA_STATE = 69;
    var NAME_STATE = 73;
    var COMMENT_STATE = 91;
    var HCRC_STATE = 103;
    var BUSY_STATE = 113;
    var FINISH_STATE = 666;
    var BS_NEED_MORE = 1;
    var BS_BLOCK_DONE = 2;
    var BS_FINISH_STARTED = 3;
    var BS_FINISH_DONE = 4;
    var OS_CODE = 3;
    function err(strm, errorCode) {
      strm.msg = msg[errorCode];
      return errorCode;
    }
    function rank(f) {
      return (f << 1) - (f > 4 ? 9 : 0);
    }
    function zero(buf) {
      var len = buf.length;
      while (--len >= 0) {
        buf[len] = 0;
      }
    }
    function flush_pending(strm) {
      var s = strm.state;
      var len = s.pending;
      if (len > strm.avail_out) {
        len = strm.avail_out;
      }
      if (len === 0) {
        return;
      }
      utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);
      strm.next_out += len;
      s.pending_out += len;
      strm.total_out += len;
      strm.avail_out -= len;
      s.pending -= len;
      if (s.pending === 0) {
        s.pending_out = 0;
      }
    }
    function flush_block_only(s, last) {
      trees._tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);
      s.block_start = s.strstart;
      flush_pending(s.strm);
    }
    function put_byte(s, b) {
      s.pending_buf[s.pending++] = b;
    }
    function putShortMSB(s, b) {
      s.pending_buf[s.pending++] = b >>> 8 & 255;
      s.pending_buf[s.pending++] = b & 255;
    }
    function read_buf(strm, buf, start, size) {
      var len = strm.avail_in;
      if (len > size) {
        len = size;
      }
      if (len === 0) {
        return 0;
      }
      strm.avail_in -= len;
      utils.arraySet(buf, strm.input, strm.next_in, len, start);
      if (strm.state.wrap === 1) {
        strm.adler = adler32(strm.adler, buf, len, start);
      } else if (strm.state.wrap === 2) {
        strm.adler = crc32(strm.adler, buf, len, start);
      }
      strm.next_in += len;
      strm.total_in += len;
      return len;
    }
    function longest_match(s, cur_match) {
      var chain_length = s.max_chain_length;
      var scan = s.strstart;
      var match2;
      var len;
      var best_len = s.prev_length;
      var nice_match = s.nice_match;
      var limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0;
      var _win = s.window;
      var wmask = s.w_mask;
      var prev = s.prev;
      var strend = s.strstart + MAX_MATCH;
      var scan_end1 = _win[scan + best_len - 1];
      var scan_end = _win[scan + best_len];
      if (s.prev_length >= s.good_match) {
        chain_length >>= 2;
      }
      if (nice_match > s.lookahead) {
        nice_match = s.lookahead;
      }
      do {
        match2 = cur_match;
        if (_win[match2 + best_len] !== scan_end || _win[match2 + best_len - 1] !== scan_end1 || _win[match2] !== _win[scan] || _win[++match2] !== _win[scan + 1]) {
          continue;
        }
        scan += 2;
        match2++;
        do {
        } while (_win[++scan] === _win[++match2] && _win[++scan] === _win[++match2] && _win[++scan] === _win[++match2] && _win[++scan] === _win[++match2] && _win[++scan] === _win[++match2] && _win[++scan] === _win[++match2] && _win[++scan] === _win[++match2] && _win[++scan] === _win[++match2] && scan < strend);
        len = MAX_MATCH - (strend - scan);
        scan = strend - MAX_MATCH;
        if (len > best_len) {
          s.match_start = cur_match;
          best_len = len;
          if (len >= nice_match) {
            break;
          }
          scan_end1 = _win[scan + best_len - 1];
          scan_end = _win[scan + best_len];
        }
      } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
      if (best_len <= s.lookahead) {
        return best_len;
      }
      return s.lookahead;
    }
    function fill_window(s) {
      var _w_size = s.w_size;
      var p, n, m, more, str;
      do {
        more = s.window_size - s.lookahead - s.strstart;
        if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
          utils.arraySet(s.window, s.window, _w_size, _w_size, 0);
          s.match_start -= _w_size;
          s.strstart -= _w_size;
          s.block_start -= _w_size;
          n = s.hash_size;
          p = n;
          do {
            m = s.head[--p];
            s.head[p] = m >= _w_size ? m - _w_size : 0;
          } while (--n);
          n = _w_size;
          p = n;
          do {
            m = s.prev[--p];
            s.prev[p] = m >= _w_size ? m - _w_size : 0;
          } while (--n);
          more += _w_size;
        }
        if (s.strm.avail_in === 0) {
          break;
        }
        n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
        s.lookahead += n;
        if (s.lookahead + s.insert >= MIN_MATCH) {
          str = s.strstart - s.insert;
          s.ins_h = s.window[str];
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + 1]) & s.hash_mask;
          while (s.insert) {
            s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
            s.prev[str & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = str;
            str++;
            s.insert--;
            if (s.lookahead + s.insert < MIN_MATCH) {
              break;
            }
          }
        }
      } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);
    }
    function deflate_stored(s, flush) {
      var max_block_size = 65535;
      if (max_block_size > s.pending_buf_size - 5) {
        max_block_size = s.pending_buf_size - 5;
      }
      for (; ; ) {
        if (s.lookahead <= 1) {
          fill_window(s);
          if (s.lookahead === 0 && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break;
          }
        }
        s.strstart += s.lookahead;
        s.lookahead = 0;
        var max_start = s.block_start + max_block_size;
        if (s.strstart === 0 || s.strstart >= max_start) {
          s.lookahead = s.strstart - max_start;
          s.strstart = max_start;
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
        if (s.strstart - s.block_start >= s.w_size - MIN_LOOKAHEAD) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s.insert = 0;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.strstart > s.block_start) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_NEED_MORE;
    }
    function deflate_fast(s, flush) {
      var hash_head;
      var bflush;
      for (; ; ) {
        if (s.lookahead < MIN_LOOKAHEAD) {
          fill_window(s);
          if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break;
          }
        }
        hash_head = 0;
        if (s.lookahead >= MIN_MATCH) {
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        }
        if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
          s.match_length = longest_match(s, hash_head);
        }
        if (s.match_length >= MIN_MATCH) {
          bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);
          s.lookahead -= s.match_length;
          if (s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH) {
            s.match_length--;
            do {
              s.strstart++;
              s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
              hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
              s.head[s.ins_h] = s.strstart;
            } while (--s.match_length !== 0);
            s.strstart++;
          } else {
            s.strstart += s.match_length;
            s.match_length = 0;
            s.ins_h = s.window[s.strstart];
            s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + 1]) & s.hash_mask;
          }
        } else {
          bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
          s.lookahead--;
          s.strstart++;
        }
        if (bflush) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.last_lit) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    }
    function deflate_slow(s, flush) {
      var hash_head;
      var bflush;
      var max_insert;
      for (; ; ) {
        if (s.lookahead < MIN_LOOKAHEAD) {
          fill_window(s);
          if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break;
          }
        }
        hash_head = 0;
        if (s.lookahead >= MIN_MATCH) {
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        }
        s.prev_length = s.match_length;
        s.prev_match = s.match_start;
        s.match_length = MIN_MATCH - 1;
        if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
          s.match_length = longest_match(s, hash_head);
          if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096)) {
            s.match_length = MIN_MATCH - 1;
          }
        }
        if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
          max_insert = s.strstart + s.lookahead - MIN_MATCH;
          bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
          s.lookahead -= s.prev_length - 1;
          s.prev_length -= 2;
          do {
            if (++s.strstart <= max_insert) {
              s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
              hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
              s.head[s.ins_h] = s.strstart;
            }
          } while (--s.prev_length !== 0);
          s.match_available = 0;
          s.match_length = MIN_MATCH - 1;
          s.strstart++;
          if (bflush) {
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
        } else if (s.match_available) {
          bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
          if (bflush) {
            flush_block_only(s, false);
          }
          s.strstart++;
          s.lookahead--;
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        } else {
          s.match_available = 1;
          s.strstart++;
          s.lookahead--;
        }
      }
      if (s.match_available) {
        bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
        s.match_available = 0;
      }
      s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.last_lit) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    }
    function deflate_rle(s, flush) {
      var bflush;
      var prev;
      var scan, strend;
      var _win = s.window;
      for (; ; ) {
        if (s.lookahead <= MAX_MATCH) {
          fill_window(s);
          if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break;
          }
        }
        s.match_length = 0;
        if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
          scan = s.strstart - 1;
          prev = _win[scan];
          if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
            strend = s.strstart + MAX_MATCH;
            do {
            } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
            s.match_length = MAX_MATCH - (strend - scan);
            if (s.match_length > s.lookahead) {
              s.match_length = s.lookahead;
            }
          }
        }
        if (s.match_length >= MIN_MATCH) {
          bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);
          s.lookahead -= s.match_length;
          s.strstart += s.match_length;
          s.match_length = 0;
        } else {
          bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
          s.lookahead--;
          s.strstart++;
        }
        if (bflush) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s.insert = 0;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.last_lit) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    }
    function deflate_huff(s, flush) {
      var bflush;
      for (; ; ) {
        if (s.lookahead === 0) {
          fill_window(s);
          if (s.lookahead === 0) {
            if (flush === Z_NO_FLUSH) {
              return BS_NEED_MORE;
            }
            break;
          }
        }
        s.match_length = 0;
        bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
        s.lookahead--;
        s.strstart++;
        if (bflush) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s.insert = 0;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.last_lit) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    }
    function Config(good_length, max_lazy, nice_length, max_chain, func) {
      this.good_length = good_length;
      this.max_lazy = max_lazy;
      this.nice_length = nice_length;
      this.max_chain = max_chain;
      this.func = func;
    }
    var configuration_table;
    configuration_table = [
      /*      good lazy nice chain */
      new Config(0, 0, 0, 0, deflate_stored),
      /* 0 store only */
      new Config(4, 4, 8, 4, deflate_fast),
      /* 1 max speed, no lazy matches */
      new Config(4, 5, 16, 8, deflate_fast),
      /* 2 */
      new Config(4, 6, 32, 32, deflate_fast),
      /* 3 */
      new Config(4, 4, 16, 16, deflate_slow),
      /* 4 lazy matches */
      new Config(8, 16, 32, 32, deflate_slow),
      /* 5 */
      new Config(8, 16, 128, 128, deflate_slow),
      /* 6 */
      new Config(8, 32, 128, 256, deflate_slow),
      /* 7 */
      new Config(32, 128, 258, 1024, deflate_slow),
      /* 8 */
      new Config(32, 258, 258, 4096, deflate_slow)
    ];
    function lm_init(s) {
      s.window_size = 2 * s.w_size;
      zero(s.head);
      s.max_lazy_match = configuration_table[s.level].max_lazy;
      s.good_match = configuration_table[s.level].good_length;
      s.nice_match = configuration_table[s.level].nice_length;
      s.max_chain_length = configuration_table[s.level].max_chain;
      s.strstart = 0;
      s.block_start = 0;
      s.lookahead = 0;
      s.insert = 0;
      s.match_length = s.prev_length = MIN_MATCH - 1;
      s.match_available = 0;
      s.ins_h = 0;
    }
    function DeflateState() {
      this.strm = null;
      this.status = 0;
      this.pending_buf = null;
      this.pending_buf_size = 0;
      this.pending_out = 0;
      this.pending = 0;
      this.wrap = 0;
      this.gzhead = null;
      this.gzindex = 0;
      this.method = Z_DEFLATED;
      this.last_flush = -1;
      this.w_size = 0;
      this.w_bits = 0;
      this.w_mask = 0;
      this.window = null;
      this.window_size = 0;
      this.prev = null;
      this.head = null;
      this.ins_h = 0;
      this.hash_size = 0;
      this.hash_bits = 0;
      this.hash_mask = 0;
      this.hash_shift = 0;
      this.block_start = 0;
      this.match_length = 0;
      this.prev_match = 0;
      this.match_available = 0;
      this.strstart = 0;
      this.match_start = 0;
      this.lookahead = 0;
      this.prev_length = 0;
      this.max_chain_length = 0;
      this.max_lazy_match = 0;
      this.level = 0;
      this.strategy = 0;
      this.good_match = 0;
      this.nice_match = 0;
      this.dyn_ltree = new utils.Buf16(HEAP_SIZE * 2);
      this.dyn_dtree = new utils.Buf16((2 * D_CODES + 1) * 2);
      this.bl_tree = new utils.Buf16((2 * BL_CODES + 1) * 2);
      zero(this.dyn_ltree);
      zero(this.dyn_dtree);
      zero(this.bl_tree);
      this.l_desc = null;
      this.d_desc = null;
      this.bl_desc = null;
      this.bl_count = new utils.Buf16(MAX_BITS + 1);
      this.heap = new utils.Buf16(2 * L_CODES + 1);
      zero(this.heap);
      this.heap_len = 0;
      this.heap_max = 0;
      this.depth = new utils.Buf16(2 * L_CODES + 1);
      zero(this.depth);
      this.l_buf = 0;
      this.lit_bufsize = 0;
      this.last_lit = 0;
      this.d_buf = 0;
      this.opt_len = 0;
      this.static_len = 0;
      this.matches = 0;
      this.insert = 0;
      this.bi_buf = 0;
      this.bi_valid = 0;
    }
    function deflateResetKeep(strm) {
      var s;
      if (!strm || !strm.state) {
        return err(strm, Z_STREAM_ERROR);
      }
      strm.total_in = strm.total_out = 0;
      strm.data_type = Z_UNKNOWN;
      s = strm.state;
      s.pending = 0;
      s.pending_out = 0;
      if (s.wrap < 0) {
        s.wrap = -s.wrap;
      }
      s.status = s.wrap ? INIT_STATE : BUSY_STATE;
      strm.adler = s.wrap === 2 ? 0 : 1;
      s.last_flush = Z_NO_FLUSH;
      trees._tr_init(s);
      return Z_OK;
    }
    function deflateReset(strm) {
      var ret = deflateResetKeep(strm);
      if (ret === Z_OK) {
        lm_init(strm.state);
      }
      return ret;
    }
    function deflateSetHeader(strm, head) {
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      if (strm.state.wrap !== 2) {
        return Z_STREAM_ERROR;
      }
      strm.state.gzhead = head;
      return Z_OK;
    }
    function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
      if (!strm) {
        return Z_STREAM_ERROR;
      }
      var wrap = 1;
      if (level === Z_DEFAULT_COMPRESSION) {
        level = 6;
      }
      if (windowBits < 0) {
        wrap = 0;
        windowBits = -windowBits;
      } else if (windowBits > 15) {
        wrap = 2;
        windowBits -= 16;
      }
      if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {
        return err(strm, Z_STREAM_ERROR);
      }
      if (windowBits === 8) {
        windowBits = 9;
      }
      var s = new DeflateState();
      strm.state = s;
      s.strm = strm;
      s.wrap = wrap;
      s.gzhead = null;
      s.w_bits = windowBits;
      s.w_size = 1 << s.w_bits;
      s.w_mask = s.w_size - 1;
      s.hash_bits = memLevel + 7;
      s.hash_size = 1 << s.hash_bits;
      s.hash_mask = s.hash_size - 1;
      s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
      s.window = new utils.Buf8(s.w_size * 2);
      s.head = new utils.Buf16(s.hash_size);
      s.prev = new utils.Buf16(s.w_size);
      s.lit_bufsize = 1 << memLevel + 6;
      s.pending_buf_size = s.lit_bufsize * 4;
      s.pending_buf = new utils.Buf8(s.pending_buf_size);
      s.d_buf = 1 * s.lit_bufsize;
      s.l_buf = (1 + 2) * s.lit_bufsize;
      s.level = level;
      s.strategy = strategy;
      s.method = method;
      return deflateReset(strm);
    }
    function deflateInit(strm, level) {
      return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
    }
    function deflate(strm, flush) {
      var old_flush, s;
      var beg, val;
      if (!strm || !strm.state || flush > Z_BLOCK || flush < 0) {
        return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
      }
      s = strm.state;
      if (!strm.output || !strm.input && strm.avail_in !== 0 || s.status === FINISH_STATE && flush !== Z_FINISH) {
        return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR : Z_STREAM_ERROR);
      }
      s.strm = strm;
      old_flush = s.last_flush;
      s.last_flush = flush;
      if (s.status === INIT_STATE) {
        if (s.wrap === 2) {
          strm.adler = 0;
          put_byte(s, 31);
          put_byte(s, 139);
          put_byte(s, 8);
          if (!s.gzhead) {
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
            put_byte(s, OS_CODE);
            s.status = BUSY_STATE;
          } else {
            put_byte(s, (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16));
            put_byte(s, s.gzhead.time & 255);
            put_byte(s, s.gzhead.time >> 8 & 255);
            put_byte(s, s.gzhead.time >> 16 & 255);
            put_byte(s, s.gzhead.time >> 24 & 255);
            put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
            put_byte(s, s.gzhead.os & 255);
            if (s.gzhead.extra && s.gzhead.extra.length) {
              put_byte(s, s.gzhead.extra.length & 255);
              put_byte(s, s.gzhead.extra.length >> 8 & 255);
            }
            if (s.gzhead.hcrc) {
              strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);
            }
            s.gzindex = 0;
            s.status = EXTRA_STATE;
          }
        } else {
          var header = Z_DEFLATED + (s.w_bits - 8 << 4) << 8;
          var level_flags = -1;
          if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
            level_flags = 0;
          } else if (s.level < 6) {
            level_flags = 1;
          } else if (s.level === 6) {
            level_flags = 2;
          } else {
            level_flags = 3;
          }
          header |= level_flags << 6;
          if (s.strstart !== 0) {
            header |= PRESET_DICT;
          }
          header += 31 - header % 31;
          s.status = BUSY_STATE;
          putShortMSB(s, header);
          if (s.strstart !== 0) {
            putShortMSB(s, strm.adler >>> 16);
            putShortMSB(s, strm.adler & 65535);
          }
          strm.adler = 1;
        }
      }
      if (s.status === EXTRA_STATE) {
        if (s.gzhead.extra) {
          beg = s.pending;
          while (s.gzindex < (s.gzhead.extra.length & 65535)) {
            if (s.pending === s.pending_buf_size) {
              if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
              }
              flush_pending(strm);
              beg = s.pending;
              if (s.pending === s.pending_buf_size) {
                break;
              }
            }
            put_byte(s, s.gzhead.extra[s.gzindex] & 255);
            s.gzindex++;
          }
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          if (s.gzindex === s.gzhead.extra.length) {
            s.gzindex = 0;
            s.status = NAME_STATE;
          }
        } else {
          s.status = NAME_STATE;
        }
      }
      if (s.status === NAME_STATE) {
        if (s.gzhead.name) {
          beg = s.pending;
          do {
            if (s.pending === s.pending_buf_size) {
              if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
              }
              flush_pending(strm);
              beg = s.pending;
              if (s.pending === s.pending_buf_size) {
                val = 1;
                break;
              }
            }
            if (s.gzindex < s.gzhead.name.length) {
              val = s.gzhead.name.charCodeAt(s.gzindex++) & 255;
            } else {
              val = 0;
            }
            put_byte(s, val);
          } while (val !== 0);
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          if (val === 0) {
            s.gzindex = 0;
            s.status = COMMENT_STATE;
          }
        } else {
          s.status = COMMENT_STATE;
        }
      }
      if (s.status === COMMENT_STATE) {
        if (s.gzhead.comment) {
          beg = s.pending;
          do {
            if (s.pending === s.pending_buf_size) {
              if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
              }
              flush_pending(strm);
              beg = s.pending;
              if (s.pending === s.pending_buf_size) {
                val = 1;
                break;
              }
            }
            if (s.gzindex < s.gzhead.comment.length) {
              val = s.gzhead.comment.charCodeAt(s.gzindex++) & 255;
            } else {
              val = 0;
            }
            put_byte(s, val);
          } while (val !== 0);
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          if (val === 0) {
            s.status = HCRC_STATE;
          }
        } else {
          s.status = HCRC_STATE;
        }
      }
      if (s.status === HCRC_STATE) {
        if (s.gzhead.hcrc) {
          if (s.pending + 2 > s.pending_buf_size) {
            flush_pending(strm);
          }
          if (s.pending + 2 <= s.pending_buf_size) {
            put_byte(s, strm.adler & 255);
            put_byte(s, strm.adler >> 8 & 255);
            strm.adler = 0;
            s.status = BUSY_STATE;
          }
        } else {
          s.status = BUSY_STATE;
        }
      }
      if (s.pending !== 0) {
        flush_pending(strm);
        if (strm.avail_out === 0) {
          s.last_flush = -1;
          return Z_OK;
        }
      } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH) {
        return err(strm, Z_BUF_ERROR);
      }
      if (s.status === FINISH_STATE && strm.avail_in !== 0) {
        return err(strm, Z_BUF_ERROR);
      }
      if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH && s.status !== FINISH_STATE) {
        var bstate = s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);
        if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
          s.status = FINISH_STATE;
        }
        if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
          if (strm.avail_out === 0) {
            s.last_flush = -1;
          }
          return Z_OK;
        }
        if (bstate === BS_BLOCK_DONE) {
          if (flush === Z_PARTIAL_FLUSH) {
            trees._tr_align(s);
          } else if (flush !== Z_BLOCK) {
            trees._tr_stored_block(s, 0, 0, false);
            if (flush === Z_FULL_FLUSH) {
              zero(s.head);
              if (s.lookahead === 0) {
                s.strstart = 0;
                s.block_start = 0;
                s.insert = 0;
              }
            }
          }
          flush_pending(strm);
          if (strm.avail_out === 0) {
            s.last_flush = -1;
            return Z_OK;
          }
        }
      }
      if (flush !== Z_FINISH) {
        return Z_OK;
      }
      if (s.wrap <= 0) {
        return Z_STREAM_END;
      }
      if (s.wrap === 2) {
        put_byte(s, strm.adler & 255);
        put_byte(s, strm.adler >> 8 & 255);
        put_byte(s, strm.adler >> 16 & 255);
        put_byte(s, strm.adler >> 24 & 255);
        put_byte(s, strm.total_in & 255);
        put_byte(s, strm.total_in >> 8 & 255);
        put_byte(s, strm.total_in >> 16 & 255);
        put_byte(s, strm.total_in >> 24 & 255);
      } else {
        putShortMSB(s, strm.adler >>> 16);
        putShortMSB(s, strm.adler & 65535);
      }
      flush_pending(strm);
      if (s.wrap > 0) {
        s.wrap = -s.wrap;
      }
      return s.pending !== 0 ? Z_OK : Z_STREAM_END;
    }
    function deflateEnd(strm) {
      var status;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      status = strm.state.status;
      if (status !== INIT_STATE && status !== EXTRA_STATE && status !== NAME_STATE && status !== COMMENT_STATE && status !== HCRC_STATE && status !== BUSY_STATE && status !== FINISH_STATE) {
        return err(strm, Z_STREAM_ERROR);
      }
      strm.state = null;
      return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
    }
    function deflateSetDictionary(strm, dictionary) {
      var dictLength = dictionary.length;
      var s;
      var str, n;
      var wrap;
      var avail;
      var next;
      var input;
      var tmpDict;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      s = strm.state;
      wrap = s.wrap;
      if (wrap === 2 || wrap === 1 && s.status !== INIT_STATE || s.lookahead) {
        return Z_STREAM_ERROR;
      }
      if (wrap === 1) {
        strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
      }
      s.wrap = 0;
      if (dictLength >= s.w_size) {
        if (wrap === 0) {
          zero(s.head);
          s.strstart = 0;
          s.block_start = 0;
          s.insert = 0;
        }
        tmpDict = new utils.Buf8(s.w_size);
        utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);
        dictionary = tmpDict;
        dictLength = s.w_size;
      }
      avail = strm.avail_in;
      next = strm.next_in;
      input = strm.input;
      strm.avail_in = dictLength;
      strm.next_in = 0;
      strm.input = dictionary;
      fill_window(s);
      while (s.lookahead >= MIN_MATCH) {
        str = s.strstart;
        n = s.lookahead - (MIN_MATCH - 1);
        do {
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
          s.prev[str & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = str;
          str++;
        } while (--n);
        s.strstart = str;
        s.lookahead = MIN_MATCH - 1;
        fill_window(s);
      }
      s.strstart += s.lookahead;
      s.block_start = s.strstart;
      s.insert = s.lookahead;
      s.lookahead = 0;
      s.match_length = s.prev_length = MIN_MATCH - 1;
      s.match_available = 0;
      strm.next_in = next;
      strm.input = input;
      strm.avail_in = avail;
      s.wrap = wrap;
      return Z_OK;
    }
    exports.deflateInit = deflateInit;
    exports.deflateInit2 = deflateInit2;
    exports.deflateReset = deflateReset;
    exports.deflateResetKeep = deflateResetKeep;
    exports.deflateSetHeader = deflateSetHeader;
    exports.deflate = deflate;
    exports.deflateEnd = deflateEnd;
    exports.deflateSetDictionary = deflateSetDictionary;
    exports.deflateInfo = "pako deflate (from Nodeca project)";
  }
});

// ../../../../../node_modules/.deno/pako@1.0.11/node_modules/pako/lib/utils/strings.js
var require_strings = __commonJS({
  "../../../../../node_modules/.deno/pako@1.0.11/node_modules/pako/lib/utils/strings.js"(exports) {
    "use strict";
    var utils = require_common();
    var STR_APPLY_OK = true;
    var STR_APPLY_UIA_OK = true;
    try {
      String.fromCharCode.apply(null, [
        0
      ]);
    } catch (__) {
      STR_APPLY_OK = false;
    }
    try {
      String.fromCharCode.apply(null, new Uint8Array(1));
    } catch (__) {
      STR_APPLY_UIA_OK = false;
    }
    var _utf8len = new utils.Buf8(256);
    for (q = 0; q < 256; q++) {
      _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
    }
    var q;
    _utf8len[254] = _utf8len[254] = 1;
    exports.string2buf = function(str) {
      var buf, c, c2, m_pos, i2, str_len = str.length, buf_len = 0;
      for (m_pos = 0; m_pos < str_len; m_pos++) {
        c = str.charCodeAt(m_pos);
        if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
          c2 = str.charCodeAt(m_pos + 1);
          if ((c2 & 64512) === 56320) {
            c = 65536 + (c - 55296 << 10) + (c2 - 56320);
            m_pos++;
          }
        }
        buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;
      }
      buf = new utils.Buf8(buf_len);
      for (i2 = 0, m_pos = 0; i2 < buf_len; m_pos++) {
        c = str.charCodeAt(m_pos);
        if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
          c2 = str.charCodeAt(m_pos + 1);
          if ((c2 & 64512) === 56320) {
            c = 65536 + (c - 55296 << 10) + (c2 - 56320);
            m_pos++;
          }
        }
        if (c < 128) {
          buf[i2++] = c;
        } else if (c < 2048) {
          buf[i2++] = 192 | c >>> 6;
          buf[i2++] = 128 | c & 63;
        } else if (c < 65536) {
          buf[i2++] = 224 | c >>> 12;
          buf[i2++] = 128 | c >>> 6 & 63;
          buf[i2++] = 128 | c & 63;
        } else {
          buf[i2++] = 240 | c >>> 18;
          buf[i2++] = 128 | c >>> 12 & 63;
          buf[i2++] = 128 | c >>> 6 & 63;
          buf[i2++] = 128 | c & 63;
        }
      }
      return buf;
    };
    function buf2binstring(buf, len) {
      if (len < 65534) {
        if (buf.subarray && STR_APPLY_UIA_OK || !buf.subarray && STR_APPLY_OK) {
          return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len));
        }
      }
      var result = "";
      for (var i2 = 0; i2 < len; i2++) {
        result += String.fromCharCode(buf[i2]);
      }
      return result;
    }
    exports.buf2binstring = function(buf) {
      return buf2binstring(buf, buf.length);
    };
    exports.binstring2buf = function(str) {
      var buf = new utils.Buf8(str.length);
      for (var i2 = 0, len = buf.length; i2 < len; i2++) {
        buf[i2] = str.charCodeAt(i2);
      }
      return buf;
    };
    exports.buf2string = function(buf, max) {
      var i2, out, c, c_len;
      var len = max || buf.length;
      var utf16buf = new Array(len * 2);
      for (out = 0, i2 = 0; i2 < len; ) {
        c = buf[i2++];
        if (c < 128) {
          utf16buf[out++] = c;
          continue;
        }
        c_len = _utf8len[c];
        if (c_len > 4) {
          utf16buf[out++] = 65533;
          i2 += c_len - 1;
          continue;
        }
        c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
        while (c_len > 1 && i2 < len) {
          c = c << 6 | buf[i2++] & 63;
          c_len--;
        }
        if (c_len > 1) {
          utf16buf[out++] = 65533;
          continue;
        }
        if (c < 65536) {
          utf16buf[out++] = c;
        } else {
          c -= 65536;
          utf16buf[out++] = 55296 | c >> 10 & 1023;
          utf16buf[out++] = 56320 | c & 1023;
        }
      }
      return buf2binstring(utf16buf, out);
    };
    exports.utf8border = function(buf, max) {
      var pos;
      max = max || buf.length;
      if (max > buf.length) {
        max = buf.length;
      }
      pos = max - 1;
      while (pos >= 0 && (buf[pos] & 192) === 128) {
        pos--;
      }
      if (pos < 0) {
        return max;
      }
      if (pos === 0) {
        return max;
      }
      return pos + _utf8len[buf[pos]] > max ? pos : max;
    };
  }
});

// ../../../../../node_modules/.deno/pako@1.0.11/node_modules/pako/lib/zlib/zstream.js
var require_zstream = __commonJS({
  "../../../../../node_modules/.deno/pako@1.0.11/node_modules/pako/lib/zlib/zstream.js"(exports, module) {
    "use strict";
    function ZStream() {
      this.input = null;
      this.next_in = 0;
      this.avail_in = 0;
      this.total_in = 0;
      this.output = null;
      this.next_out = 0;
      this.avail_out = 0;
      this.total_out = 0;
      this.msg = "";
      this.state = null;
      this.data_type = 2;
      this.adler = 0;
    }
    module.exports = ZStream;
  }
});

// ../../../../../node_modules/.deno/pako@1.0.11/node_modules/pako/lib/deflate.js
var require_deflate2 = __commonJS({
  "../../../../../node_modules/.deno/pako@1.0.11/node_modules/pako/lib/deflate.js"(exports) {
    "use strict";
    var zlib_deflate = require_deflate();
    var utils = require_common();
    var strings = require_strings();
    var msg = require_messages();
    var ZStream = require_zstream();
    var toString = Object.prototype.toString;
    var Z_NO_FLUSH = 0;
    var Z_FINISH = 4;
    var Z_OK = 0;
    var Z_STREAM_END = 1;
    var Z_SYNC_FLUSH = 2;
    var Z_DEFAULT_COMPRESSION = -1;
    var Z_DEFAULT_STRATEGY = 0;
    var Z_DEFLATED = 8;
    function Deflate(options) {
      if (!(this instanceof Deflate)) return new Deflate(options);
      this.options = utils.assign({
        level: Z_DEFAULT_COMPRESSION,
        method: Z_DEFLATED,
        chunkSize: 16384,
        windowBits: 15,
        memLevel: 8,
        strategy: Z_DEFAULT_STRATEGY,
        to: ""
      }, options || {});
      var opt = this.options;
      if (opt.raw && opt.windowBits > 0) {
        opt.windowBits = -opt.windowBits;
      } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
        opt.windowBits += 16;
      }
      this.err = 0;
      this.msg = "";
      this.ended = false;
      this.chunks = [];
      this.strm = new ZStream();
      this.strm.avail_out = 0;
      var status = zlib_deflate.deflateInit2(this.strm, opt.level, opt.method, opt.windowBits, opt.memLevel, opt.strategy);
      if (status !== Z_OK) {
        throw new Error(msg[status]);
      }
      if (opt.header) {
        zlib_deflate.deflateSetHeader(this.strm, opt.header);
      }
      if (opt.dictionary) {
        var dict;
        if (typeof opt.dictionary === "string") {
          dict = strings.string2buf(opt.dictionary);
        } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
          dict = new Uint8Array(opt.dictionary);
        } else {
          dict = opt.dictionary;
        }
        status = zlib_deflate.deflateSetDictionary(this.strm, dict);
        if (status !== Z_OK) {
          throw new Error(msg[status]);
        }
        this._dict_set = true;
      }
    }
    Deflate.prototype.push = function(data, mode) {
      var strm = this.strm;
      var chunkSize = this.options.chunkSize;
      var status, _mode;
      if (this.ended) {
        return false;
      }
      _mode = mode === ~~mode ? mode : mode === true ? Z_FINISH : Z_NO_FLUSH;
      if (typeof data === "string") {
        strm.input = strings.string2buf(data);
      } else if (toString.call(data) === "[object ArrayBuffer]") {
        strm.input = new Uint8Array(data);
      } else {
        strm.input = data;
      }
      strm.next_in = 0;
      strm.avail_in = strm.input.length;
      do {
        if (strm.avail_out === 0) {
          strm.output = new utils.Buf8(chunkSize);
          strm.next_out = 0;
          strm.avail_out = chunkSize;
        }
        status = zlib_deflate.deflate(strm, _mode);
        if (status !== Z_STREAM_END && status !== Z_OK) {
          this.onEnd(status);
          this.ended = true;
          return false;
        }
        if (strm.avail_out === 0 || strm.avail_in === 0 && (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH)) {
          if (this.options.to === "string") {
            this.onData(strings.buf2binstring(utils.shrinkBuf(strm.output, strm.next_out)));
          } else {
            this.onData(utils.shrinkBuf(strm.output, strm.next_out));
          }
        }
      } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END);
      if (_mode === Z_FINISH) {
        status = zlib_deflate.deflateEnd(this.strm);
        this.onEnd(status);
        this.ended = true;
        return status === Z_OK;
      }
      if (_mode === Z_SYNC_FLUSH) {
        this.onEnd(Z_OK);
        strm.avail_out = 0;
        return true;
      }
      return true;
    };
    Deflate.prototype.onData = function(chunk) {
      this.chunks.push(chunk);
    };
    Deflate.prototype.onEnd = function(status) {
      if (status === Z_OK) {
        if (this.options.to === "string") {
          this.result = this.chunks.join("");
        } else {
          this.result = utils.flattenChunks(this.chunks);
        }
      }
      this.chunks = [];
      this.err = status;
      this.msg = this.strm.msg;
    };
    function deflate(input, options) {
      var deflator = new Deflate(options);
      deflator.push(input, true);
      if (deflator.err) {
        throw deflator.msg || msg[deflator.err];
      }
      return deflator.result;
    }
    function deflateRaw(input, options) {
      options = options || {};
      options.raw = true;
      return deflate(input, options);
    }
    function gzip(input, options) {
      options = options || {};
      options.gzip = true;
      return deflate(input, options);
    }
    exports.Deflate = Deflate;
    exports.deflate = deflate;
    exports.deflateRaw = deflateRaw;
    exports.gzip = gzip;
  }
});

// ../../../../../node_modules/.deno/pako@1.0.11/node_modules/pako/lib/zlib/inffast.js
var require_inffast = __commonJS({
  "../../../../../node_modules/.deno/pako@1.0.11/node_modules/pako/lib/zlib/inffast.js"(exports, module) {
    "use strict";
    var BAD = 30;
    var TYPE2 = 12;
    module.exports = function inflate_fast(strm, start) {
      var state;
      var _in;
      var last;
      var _out;
      var beg;
      var end;
      var dmax;
      var wsize;
      var whave;
      var wnext;
      var s_window;
      var hold;
      var bits;
      var lcode;
      var dcode;
      var lmask;
      var dmask;
      var here;
      var op;
      var len;
      var dist;
      var from;
      var from_source;
      var input, output;
      state = strm.state;
      _in = strm.next_in;
      input = strm.input;
      last = _in + (strm.avail_in - 5);
      _out = strm.next_out;
      output = strm.output;
      beg = _out - (start - strm.avail_out);
      end = _out + (strm.avail_out - 257);
      dmax = state.dmax;
      wsize = state.wsize;
      whave = state.whave;
      wnext = state.wnext;
      s_window = state.window;
      hold = state.hold;
      bits = state.bits;
      lcode = state.lencode;
      dcode = state.distcode;
      lmask = (1 << state.lenbits) - 1;
      dmask = (1 << state.distbits) - 1;
      top: do {
        if (bits < 15) {
          hold += input[_in++] << bits;
          bits += 8;
          hold += input[_in++] << bits;
          bits += 8;
        }
        here = lcode[hold & lmask];
        dolen: for (; ; ) {
          op = here >>> 24;
          hold >>>= op;
          bits -= op;
          op = here >>> 16 & 255;
          if (op === 0) {
            output[_out++] = here & 65535;
          } else if (op & 16) {
            len = here & 65535;
            op &= 15;
            if (op) {
              if (bits < op) {
                hold += input[_in++] << bits;
                bits += 8;
              }
              len += hold & (1 << op) - 1;
              hold >>>= op;
              bits -= op;
            }
            if (bits < 15) {
              hold += input[_in++] << bits;
              bits += 8;
              hold += input[_in++] << bits;
              bits += 8;
            }
            here = dcode[hold & dmask];
            dodist: for (; ; ) {
              op = here >>> 24;
              hold >>>= op;
              bits -= op;
              op = here >>> 16 & 255;
              if (op & 16) {
                dist = here & 65535;
                op &= 15;
                if (bits < op) {
                  hold += input[_in++] << bits;
                  bits += 8;
                  if (bits < op) {
                    hold += input[_in++] << bits;
                    bits += 8;
                  }
                }
                dist += hold & (1 << op) - 1;
                if (dist > dmax) {
                  strm.msg = "invalid distance too far back";
                  state.mode = BAD;
                  break top;
                }
                hold >>>= op;
                bits -= op;
                op = _out - beg;
                if (dist > op) {
                  op = dist - op;
                  if (op > whave) {
                    if (state.sane) {
                      strm.msg = "invalid distance too far back";
                      state.mode = BAD;
                      break top;
                    }
                  }
                  from = 0;
                  from_source = s_window;
                  if (wnext === 0) {
                    from += wsize - op;
                    if (op < len) {
                      len -= op;
                      do {
                        output[_out++] = s_window[from++];
                      } while (--op);
                      from = _out - dist;
                      from_source = output;
                    }
                  } else if (wnext < op) {
                    from += wsize + wnext - op;
                    op -= wnext;
                    if (op < len) {
                      len -= op;
                      do {
                        output[_out++] = s_window[from++];
                      } while (--op);
                      from = 0;
                      if (wnext < len) {
                        op = wnext;
                        len -= op;
                        do {
                          output[_out++] = s_window[from++];
                        } while (--op);
                        from = _out - dist;
                        from_source = output;
                      }
                    }
                  } else {
                    from += wnext - op;
                    if (op < len) {
                      len -= op;
                      do {
                        output[_out++] = s_window[from++];
                      } while (--op);
                      from = _out - dist;
                      from_source = output;
                    }
                  }
                  while (len > 2) {
                    output[_out++] = from_source[from++];
                    output[_out++] = from_source[from++];
                    output[_out++] = from_source[from++];
                    len -= 3;
                  }
                  if (len) {
                    output[_out++] = from_source[from++];
                    if (len > 1) {
                      output[_out++] = from_source[from++];
                    }
                  }
                } else {
                  from = _out - dist;
                  do {
                    output[_out++] = output[from++];
                    output[_out++] = output[from++];
                    output[_out++] = output[from++];
                    len -= 3;
                  } while (len > 2);
                  if (len) {
                    output[_out++] = output[from++];
                    if (len > 1) {
                      output[_out++] = output[from++];
                    }
                  }
                }
              } else if ((op & 64) === 0) {
                here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                continue dodist;
              } else {
                strm.msg = "invalid distance code";
                state.mode = BAD;
                break top;
              }
              break;
            }
          } else if ((op & 64) === 0) {
            here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
            continue dolen;
          } else if (op & 32) {
            state.mode = TYPE2;
            break top;
          } else {
            strm.msg = "invalid literal/length code";
            state.mode = BAD;
            break top;
          }
          break;
        }
      } while (_in < last && _out < end);
      len = bits >> 3;
      _in -= len;
      bits -= len << 3;
      hold &= (1 << bits) - 1;
      strm.next_in = _in;
      strm.next_out = _out;
      strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
      strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
      state.hold = hold;
      state.bits = bits;
      return;
    };
  }
});

// ../../../../../node_modules/.deno/pako@1.0.11/node_modules/pako/lib/zlib/inftrees.js
var require_inftrees = __commonJS({
  "../../../../../node_modules/.deno/pako@1.0.11/node_modules/pako/lib/zlib/inftrees.js"(exports, module) {
    "use strict";
    var utils = require_common();
    var MAXBITS = 15;
    var ENOUGH_LENS = 852;
    var ENOUGH_DISTS = 592;
    var CODES = 0;
    var LENS = 1;
    var DISTS = 2;
    var lbase = [
      /* Length codes 257..285 base */
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      13,
      15,
      17,
      19,
      23,
      27,
      31,
      35,
      43,
      51,
      59,
      67,
      83,
      99,
      115,
      131,
      163,
      195,
      227,
      258,
      0,
      0
    ];
    var lext = [
      /* Length codes 257..285 extra */
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      17,
      17,
      17,
      17,
      18,
      18,
      18,
      18,
      19,
      19,
      19,
      19,
      20,
      20,
      20,
      20,
      21,
      21,
      21,
      21,
      16,
      72,
      78
    ];
    var dbase = [
      /* Distance codes 0..29 base */
      1,
      2,
      3,
      4,
      5,
      7,
      9,
      13,
      17,
      25,
      33,
      49,
      65,
      97,
      129,
      193,
      257,
      385,
      513,
      769,
      1025,
      1537,
      2049,
      3073,
      4097,
      6145,
      8193,
      12289,
      16385,
      24577,
      0,
      0
    ];
    var dext = [
      /* Distance codes 0..29 extra */
      16,
      16,
      16,
      16,
      17,
      17,
      18,
      18,
      19,
      19,
      20,
      20,
      21,
      21,
      22,
      22,
      23,
      23,
      24,
      24,
      25,
      25,
      26,
      26,
      27,
      27,
      28,
      28,
      29,
      29,
      64,
      64
    ];
    module.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts) {
      var bits = opts.bits;
      var len = 0;
      var sym = 0;
      var min = 0, max = 0;
      var root = 0;
      var curr2 = 0;
      var drop = 0;
      var left = 0;
      var used = 0;
      var huff = 0;
      var incr;
      var fill;
      var low;
      var mask;
      var next;
      var base = null;
      var base_index = 0;
      var end;
      var count = new utils.Buf16(MAXBITS + 1);
      var offs = new utils.Buf16(MAXBITS + 1);
      var extra = null;
      var extra_index = 0;
      var here_bits, here_op, here_val;
      for (len = 0; len <= MAXBITS; len++) {
        count[len] = 0;
      }
      for (sym = 0; sym < codes; sym++) {
        count[lens[lens_index + sym]]++;
      }
      root = bits;
      for (max = MAXBITS; max >= 1; max--) {
        if (count[max] !== 0) {
          break;
        }
      }
      if (root > max) {
        root = max;
      }
      if (max === 0) {
        table[table_index++] = 1 << 24 | 64 << 16 | 0;
        table[table_index++] = 1 << 24 | 64 << 16 | 0;
        opts.bits = 1;
        return 0;
      }
      for (min = 1; min < max; min++) {
        if (count[min] !== 0) {
          break;
        }
      }
      if (root < min) {
        root = min;
      }
      left = 1;
      for (len = 1; len <= MAXBITS; len++) {
        left <<= 1;
        left -= count[len];
        if (left < 0) {
          return -1;
        }
      }
      if (left > 0 && (type === CODES || max !== 1)) {
        return -1;
      }
      offs[1] = 0;
      for (len = 1; len < MAXBITS; len++) {
        offs[len + 1] = offs[len] + count[len];
      }
      for (sym = 0; sym < codes; sym++) {
        if (lens[lens_index + sym] !== 0) {
          work[offs[lens[lens_index + sym]]++] = sym;
        }
      }
      if (type === CODES) {
        base = extra = work;
        end = 19;
      } else if (type === LENS) {
        base = lbase;
        base_index -= 257;
        extra = lext;
        extra_index -= 257;
        end = 256;
      } else {
        base = dbase;
        extra = dext;
        end = -1;
      }
      huff = 0;
      sym = 0;
      len = min;
      next = table_index;
      curr2 = root;
      drop = 0;
      low = -1;
      used = 1 << root;
      mask = used - 1;
      if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
        return 1;
      }
      for (; ; ) {
        here_bits = len - drop;
        if (work[sym] < end) {
          here_op = 0;
          here_val = work[sym];
        } else if (work[sym] > end) {
          here_op = extra[extra_index + work[sym]];
          here_val = base[base_index + work[sym]];
        } else {
          here_op = 32 + 64;
          here_val = 0;
        }
        incr = 1 << len - drop;
        fill = 1 << curr2;
        min = fill;
        do {
          fill -= incr;
          table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
        } while (fill !== 0);
        incr = 1 << len - 1;
        while (huff & incr) {
          incr >>= 1;
        }
        if (incr !== 0) {
          huff &= incr - 1;
          huff += incr;
        } else {
          huff = 0;
        }
        sym++;
        if (--count[len] === 0) {
          if (len === max) {
            break;
          }
          len = lens[lens_index + work[sym]];
        }
        if (len > root && (huff & mask) !== low) {
          if (drop === 0) {
            drop = root;
          }
          next += min;
          curr2 = len - drop;
          left = 1 << curr2;
          while (curr2 + drop < max) {
            left -= count[curr2 + drop];
            if (left <= 0) {
              break;
            }
            curr2++;
            left <<= 1;
          }
          used += 1 << curr2;
          if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
            return 1;
          }
          low = huff & mask;
          table[low] = root << 24 | curr2 << 16 | next - table_index | 0;
        }
      }
      if (huff !== 0) {
        table[next + huff] = len - drop << 24 | 64 << 16 | 0;
      }
      opts.bits = root;
      return 0;
    };
  }
});

// ../../../../../node_modules/.deno/pako@1.0.11/node_modules/pako/lib/zlib/inflate.js
var require_inflate = __commonJS({
  "../../../../../node_modules/.deno/pako@1.0.11/node_modules/pako/lib/zlib/inflate.js"(exports) {
    "use strict";
    var utils = require_common();
    var adler32 = require_adler32();
    var crc32 = require_crc32();
    var inflate_fast = require_inffast();
    var inflate_table = require_inftrees();
    var CODES = 0;
    var LENS = 1;
    var DISTS = 2;
    var Z_FINISH = 4;
    var Z_BLOCK = 5;
    var Z_TREES = 6;
    var Z_OK = 0;
    var Z_STREAM_END = 1;
    var Z_NEED_DICT = 2;
    var Z_STREAM_ERROR = -2;
    var Z_DATA_ERROR = -3;
    var Z_MEM_ERROR = -4;
    var Z_BUF_ERROR = -5;
    var Z_DEFLATED = 8;
    var HEAD = 1;
    var FLAGS = 2;
    var TIME = 3;
    var OS = 4;
    var EXLEN = 5;
    var EXTRA = 6;
    var NAME = 7;
    var COMMENT = 8;
    var HCRC = 9;
    var DICTID = 10;
    var DICT = 11;
    var TYPE2 = 12;
    var TYPEDO = 13;
    var STORED = 14;
    var COPY_ = 15;
    var COPY = 16;
    var TABLE = 17;
    var LENLENS = 18;
    var CODELENS = 19;
    var LEN_ = 20;
    var LEN = 21;
    var LENEXT = 22;
    var DIST = 23;
    var DISTEXT = 24;
    var MATCH = 25;
    var LIT = 26;
    var CHECK = 27;
    var LENGTH = 28;
    var DONE = 29;
    var BAD = 30;
    var MEM = 31;
    var SYNC = 32;
    var ENOUGH_LENS = 852;
    var ENOUGH_DISTS = 592;
    var MAX_WBITS = 15;
    var DEF_WBITS = MAX_WBITS;
    function zswap32(q) {
      return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
    }
    function InflateState() {
      this.mode = 0;
      this.last = false;
      this.wrap = 0;
      this.havedict = false;
      this.flags = 0;
      this.dmax = 0;
      this.check = 0;
      this.total = 0;
      this.head = null;
      this.wbits = 0;
      this.wsize = 0;
      this.whave = 0;
      this.wnext = 0;
      this.window = null;
      this.hold = 0;
      this.bits = 0;
      this.length = 0;
      this.offset = 0;
      this.extra = 0;
      this.lencode = null;
      this.distcode = null;
      this.lenbits = 0;
      this.distbits = 0;
      this.ncode = 0;
      this.nlen = 0;
      this.ndist = 0;
      this.have = 0;
      this.next = null;
      this.lens = new utils.Buf16(320);
      this.work = new utils.Buf16(288);
      this.lendyn = null;
      this.distdyn = null;
      this.sane = 0;
      this.back = 0;
      this.was = 0;
    }
    function inflateResetKeep(strm) {
      var state;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      strm.total_in = strm.total_out = state.total = 0;
      strm.msg = "";
      if (state.wrap) {
        strm.adler = state.wrap & 1;
      }
      state.mode = HEAD;
      state.last = 0;
      state.havedict = 0;
      state.dmax = 32768;
      state.head = null;
      state.hold = 0;
      state.bits = 0;
      state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);
      state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);
      state.sane = 1;
      state.back = -1;
      return Z_OK;
    }
    function inflateReset(strm) {
      var state;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      state.wsize = 0;
      state.whave = 0;
      state.wnext = 0;
      return inflateResetKeep(strm);
    }
    function inflateReset2(strm, windowBits) {
      var wrap;
      var state;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if (windowBits < 0) {
        wrap = 0;
        windowBits = -windowBits;
      } else {
        wrap = (windowBits >> 4) + 1;
        if (windowBits < 48) {
          windowBits &= 15;
        }
      }
      if (windowBits && (windowBits < 8 || windowBits > 15)) {
        return Z_STREAM_ERROR;
      }
      if (state.window !== null && state.wbits !== windowBits) {
        state.window = null;
      }
      state.wrap = wrap;
      state.wbits = windowBits;
      return inflateReset(strm);
    }
    function inflateInit2(strm, windowBits) {
      var ret;
      var state;
      if (!strm) {
        return Z_STREAM_ERROR;
      }
      state = new InflateState();
      strm.state = state;
      state.window = null;
      ret = inflateReset2(strm, windowBits);
      if (ret !== Z_OK) {
        strm.state = null;
      }
      return ret;
    }
    function inflateInit(strm) {
      return inflateInit2(strm, DEF_WBITS);
    }
    var virgin = true;
    var lenfix;
    var distfix;
    function fixedtables(state) {
      if (virgin) {
        var sym;
        lenfix = new utils.Buf32(512);
        distfix = new utils.Buf32(32);
        sym = 0;
        while (sym < 144) {
          state.lens[sym++] = 8;
        }
        while (sym < 256) {
          state.lens[sym++] = 9;
        }
        while (sym < 280) {
          state.lens[sym++] = 7;
        }
        while (sym < 288) {
          state.lens[sym++] = 8;
        }
        inflate_table(LENS, state.lens, 0, 288, lenfix, 0, state.work, {
          bits: 9
        });
        sym = 0;
        while (sym < 32) {
          state.lens[sym++] = 5;
        }
        inflate_table(DISTS, state.lens, 0, 32, distfix, 0, state.work, {
          bits: 5
        });
        virgin = false;
      }
      state.lencode = lenfix;
      state.lenbits = 9;
      state.distcode = distfix;
      state.distbits = 5;
    }
    function updatewindow(strm, src, end, copy) {
      var dist;
      var state = strm.state;
      if (state.window === null) {
        state.wsize = 1 << state.wbits;
        state.wnext = 0;
        state.whave = 0;
        state.window = new utils.Buf8(state.wsize);
      }
      if (copy >= state.wsize) {
        utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);
        state.wnext = 0;
        state.whave = state.wsize;
      } else {
        dist = state.wsize - state.wnext;
        if (dist > copy) {
          dist = copy;
        }
        utils.arraySet(state.window, src, end - copy, dist, state.wnext);
        copy -= dist;
        if (copy) {
          utils.arraySet(state.window, src, end - copy, copy, 0);
          state.wnext = copy;
          state.whave = state.wsize;
        } else {
          state.wnext += dist;
          if (state.wnext === state.wsize) {
            state.wnext = 0;
          }
          if (state.whave < state.wsize) {
            state.whave += dist;
          }
        }
      }
      return 0;
    }
    function inflate(strm, flush) {
      var state;
      var input, output;
      var next;
      var put;
      var have, left;
      var hold;
      var bits;
      var _in, _out;
      var copy;
      var from;
      var from_source;
      var here = 0;
      var here_bits, here_op, here_val;
      var last_bits, last_op, last_val;
      var len;
      var ret;
      var hbuf = new utils.Buf8(4);
      var opts;
      var n;
      var order = (
        /* permutation of code lengths */
        [
          16,
          17,
          18,
          0,
          8,
          7,
          9,
          6,
          10,
          5,
          11,
          4,
          12,
          3,
          13,
          2,
          14,
          1,
          15
        ]
      );
      if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if (state.mode === TYPE2) {
        state.mode = TYPEDO;
      }
      put = strm.next_out;
      output = strm.output;
      left = strm.avail_out;
      next = strm.next_in;
      input = strm.input;
      have = strm.avail_in;
      hold = state.hold;
      bits = state.bits;
      _in = have;
      _out = left;
      ret = Z_OK;
      inf_leave: for (; ; ) {
        switch (state.mode) {
          case HEAD:
            if (state.wrap === 0) {
              state.mode = TYPEDO;
              break;
            }
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.wrap & 2 && hold === 35615) {
              state.check = 0;
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = crc32(state.check, hbuf, 2, 0);
              hold = 0;
              bits = 0;
              state.mode = FLAGS;
              break;
            }
            state.flags = 0;
            if (state.head) {
              state.head.done = false;
            }
            if (!(state.wrap & 1) || /* check if zlib header allowed */
            (((hold & 255) << 8) + (hold >> 8)) % 31) {
              strm.msg = "incorrect header check";
              state.mode = BAD;
              break;
            }
            if ((hold & 15) !== Z_DEFLATED) {
              strm.msg = "unknown compression method";
              state.mode = BAD;
              break;
            }
            hold >>>= 4;
            bits -= 4;
            len = (hold & 15) + 8;
            if (state.wbits === 0) {
              state.wbits = len;
            } else if (len > state.wbits) {
              strm.msg = "invalid window size";
              state.mode = BAD;
              break;
            }
            state.dmax = 1 << len;
            strm.adler = state.check = 1;
            state.mode = hold & 512 ? DICTID : TYPE2;
            hold = 0;
            bits = 0;
            break;
          case FLAGS:
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.flags = hold;
            if ((state.flags & 255) !== Z_DEFLATED) {
              strm.msg = "unknown compression method";
              state.mode = BAD;
              break;
            }
            if (state.flags & 57344) {
              strm.msg = "unknown header flags set";
              state.mode = BAD;
              break;
            }
            if (state.head) {
              state.head.text = hold >> 8 & 1;
            }
            if (state.flags & 512) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = crc32(state.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
            state.mode = TIME;
          /* falls through */
          case TIME:
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.head) {
              state.head.time = hold;
            }
            if (state.flags & 512) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              hbuf[2] = hold >>> 16 & 255;
              hbuf[3] = hold >>> 24 & 255;
              state.check = crc32(state.check, hbuf, 4, 0);
            }
            hold = 0;
            bits = 0;
            state.mode = OS;
          /* falls through */
          case OS:
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.head) {
              state.head.xflags = hold & 255;
              state.head.os = hold >> 8;
            }
            if (state.flags & 512) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = crc32(state.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
            state.mode = EXLEN;
          /* falls through */
          case EXLEN:
            if (state.flags & 1024) {
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.length = hold;
              if (state.head) {
                state.head.extra_len = hold;
              }
              if (state.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32(state.check, hbuf, 2, 0);
              }
              hold = 0;
              bits = 0;
            } else if (state.head) {
              state.head.extra = null;
            }
            state.mode = EXTRA;
          /* falls through */
          case EXTRA:
            if (state.flags & 1024) {
              copy = state.length;
              if (copy > have) {
                copy = have;
              }
              if (copy) {
                if (state.head) {
                  len = state.head.extra_len - state.length;
                  if (!state.head.extra) {
                    state.head.extra = new Array(state.head.extra_len);
                  }
                  utils.arraySet(
                    state.head.extra,
                    input,
                    next,
                    // extra field is limited to 65536 bytes
                    // - no need for additional size check
                    copy,
                    /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                    len
                  );
                }
                if (state.flags & 512) {
                  state.check = crc32(state.check, input, copy, next);
                }
                have -= copy;
                next += copy;
                state.length -= copy;
              }
              if (state.length) {
                break inf_leave;
              }
            }
            state.length = 0;
            state.mode = NAME;
          /* falls through */
          case NAME:
            if (state.flags & 2048) {
              if (have === 0) {
                break inf_leave;
              }
              copy = 0;
              do {
                len = input[next + copy++];
                if (state.head && len && state.length < 65536) {
                  state.head.name += String.fromCharCode(len);
                }
              } while (len && copy < have);
              if (state.flags & 512) {
                state.check = crc32(state.check, input, copy, next);
              }
              have -= copy;
              next += copy;
              if (len) {
                break inf_leave;
              }
            } else if (state.head) {
              state.head.name = null;
            }
            state.length = 0;
            state.mode = COMMENT;
          /* falls through */
          case COMMENT:
            if (state.flags & 4096) {
              if (have === 0) {
                break inf_leave;
              }
              copy = 0;
              do {
                len = input[next + copy++];
                if (state.head && len && state.length < 65536) {
                  state.head.comment += String.fromCharCode(len);
                }
              } while (len && copy < have);
              if (state.flags & 512) {
                state.check = crc32(state.check, input, copy, next);
              }
              have -= copy;
              next += copy;
              if (len) {
                break inf_leave;
              }
            } else if (state.head) {
              state.head.comment = null;
            }
            state.mode = HCRC;
          /* falls through */
          case HCRC:
            if (state.flags & 512) {
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (hold !== (state.check & 65535)) {
                strm.msg = "header crc mismatch";
                state.mode = BAD;
                break;
              }
              hold = 0;
              bits = 0;
            }
            if (state.head) {
              state.head.hcrc = state.flags >> 9 & 1;
              state.head.done = true;
            }
            strm.adler = state.check = 0;
            state.mode = TYPE2;
            break;
          case DICTID:
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            strm.adler = state.check = zswap32(hold);
            hold = 0;
            bits = 0;
            state.mode = DICT;
          /* falls through */
          case DICT:
            if (state.havedict === 0) {
              strm.next_out = put;
              strm.avail_out = left;
              strm.next_in = next;
              strm.avail_in = have;
              state.hold = hold;
              state.bits = bits;
              return Z_NEED_DICT;
            }
            strm.adler = state.check = 1;
            state.mode = TYPE2;
          /* falls through */
          case TYPE2:
            if (flush === Z_BLOCK || flush === Z_TREES) {
              break inf_leave;
            }
          /* falls through */
          case TYPEDO:
            if (state.last) {
              hold >>>= bits & 7;
              bits -= bits & 7;
              state.mode = CHECK;
              break;
            }
            while (bits < 3) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.last = hold & 1;
            hold >>>= 1;
            bits -= 1;
            switch (hold & 3) {
              case 0:
                state.mode = STORED;
                break;
              case 1:
                fixedtables(state);
                state.mode = LEN_;
                if (flush === Z_TREES) {
                  hold >>>= 2;
                  bits -= 2;
                  break inf_leave;
                }
                break;
              case 2:
                state.mode = TABLE;
                break;
              case 3:
                strm.msg = "invalid block type";
                state.mode = BAD;
            }
            hold >>>= 2;
            bits -= 2;
            break;
          case STORED:
            hold >>>= bits & 7;
            bits -= bits & 7;
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
              strm.msg = "invalid stored block lengths";
              state.mode = BAD;
              break;
            }
            state.length = hold & 65535;
            hold = 0;
            bits = 0;
            state.mode = COPY_;
            if (flush === Z_TREES) {
              break inf_leave;
            }
          /* falls through */
          case COPY_:
            state.mode = COPY;
          /* falls through */
          case COPY:
            copy = state.length;
            if (copy) {
              if (copy > have) {
                copy = have;
              }
              if (copy > left) {
                copy = left;
              }
              if (copy === 0) {
                break inf_leave;
              }
              utils.arraySet(output, input, next, copy, put);
              have -= copy;
              next += copy;
              left -= copy;
              put += copy;
              state.length -= copy;
              break;
            }
            state.mode = TYPE2;
            break;
          case TABLE:
            while (bits < 14) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.nlen = (hold & 31) + 257;
            hold >>>= 5;
            bits -= 5;
            state.ndist = (hold & 31) + 1;
            hold >>>= 5;
            bits -= 5;
            state.ncode = (hold & 15) + 4;
            hold >>>= 4;
            bits -= 4;
            if (state.nlen > 286 || state.ndist > 30) {
              strm.msg = "too many length or distance symbols";
              state.mode = BAD;
              break;
            }
            state.have = 0;
            state.mode = LENLENS;
          /* falls through */
          case LENLENS:
            while (state.have < state.ncode) {
              while (bits < 3) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.lens[order[state.have++]] = hold & 7;
              hold >>>= 3;
              bits -= 3;
            }
            while (state.have < 19) {
              state.lens[order[state.have++]] = 0;
            }
            state.lencode = state.lendyn;
            state.lenbits = 7;
            opts = {
              bits: state.lenbits
            };
            ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
            state.lenbits = opts.bits;
            if (ret) {
              strm.msg = "invalid code lengths set";
              state.mode = BAD;
              break;
            }
            state.have = 0;
            state.mode = CODELENS;
          /* falls through */
          case CODELENS:
            while (state.have < state.nlen + state.ndist) {
              for (; ; ) {
                here = state.lencode[hold & (1 << state.lenbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (here_val < 16) {
                hold >>>= here_bits;
                bits -= here_bits;
                state.lens[state.have++] = here_val;
              } else {
                if (here_val === 16) {
                  n = here_bits + 2;
                  while (bits < n) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  if (state.have === 0) {
                    strm.msg = "invalid bit length repeat";
                    state.mode = BAD;
                    break;
                  }
                  len = state.lens[state.have - 1];
                  copy = 3 + (hold & 3);
                  hold >>>= 2;
                  bits -= 2;
                } else if (here_val === 17) {
                  n = here_bits + 3;
                  while (bits < n) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  len = 0;
                  copy = 3 + (hold & 7);
                  hold >>>= 3;
                  bits -= 3;
                } else {
                  n = here_bits + 7;
                  while (bits < n) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  len = 0;
                  copy = 11 + (hold & 127);
                  hold >>>= 7;
                  bits -= 7;
                }
                if (state.have + copy > state.nlen + state.ndist) {
                  strm.msg = "invalid bit length repeat";
                  state.mode = BAD;
                  break;
                }
                while (copy--) {
                  state.lens[state.have++] = len;
                }
              }
            }
            if (state.mode === BAD) {
              break;
            }
            if (state.lens[256] === 0) {
              strm.msg = "invalid code -- missing end-of-block";
              state.mode = BAD;
              break;
            }
            state.lenbits = 9;
            opts = {
              bits: state.lenbits
            };
            ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
            state.lenbits = opts.bits;
            if (ret) {
              strm.msg = "invalid literal/lengths set";
              state.mode = BAD;
              break;
            }
            state.distbits = 6;
            state.distcode = state.distdyn;
            opts = {
              bits: state.distbits
            };
            ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
            state.distbits = opts.bits;
            if (ret) {
              strm.msg = "invalid distances set";
              state.mode = BAD;
              break;
            }
            state.mode = LEN_;
            if (flush === Z_TREES) {
              break inf_leave;
            }
          /* falls through */
          case LEN_:
            state.mode = LEN;
          /* falls through */
          case LEN:
            if (have >= 6 && left >= 258) {
              strm.next_out = put;
              strm.avail_out = left;
              strm.next_in = next;
              strm.avail_in = have;
              state.hold = hold;
              state.bits = bits;
              inflate_fast(strm, _out);
              put = strm.next_out;
              output = strm.output;
              left = strm.avail_out;
              next = strm.next_in;
              input = strm.input;
              have = strm.avail_in;
              hold = state.hold;
              bits = state.bits;
              if (state.mode === TYPE2) {
                state.back = -1;
              }
              break;
            }
            state.back = 0;
            for (; ; ) {
              here = state.lencode[hold & (1 << state.lenbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (here_op && (here_op & 240) === 0) {
              last_bits = here_bits;
              last_op = here_op;
              last_val = here_val;
              for (; ; ) {
                here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (last_bits + here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              hold >>>= last_bits;
              bits -= last_bits;
              state.back += last_bits;
            }
            hold >>>= here_bits;
            bits -= here_bits;
            state.back += here_bits;
            state.length = here_val;
            if (here_op === 0) {
              state.mode = LIT;
              break;
            }
            if (here_op & 32) {
              state.back = -1;
              state.mode = TYPE2;
              break;
            }
            if (here_op & 64) {
              strm.msg = "invalid literal/length code";
              state.mode = BAD;
              break;
            }
            state.extra = here_op & 15;
            state.mode = LENEXT;
          /* falls through */
          case LENEXT:
            if (state.extra) {
              n = state.extra;
              while (bits < n) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.length += hold & (1 << state.extra) - 1;
              hold >>>= state.extra;
              bits -= state.extra;
              state.back += state.extra;
            }
            state.was = state.length;
            state.mode = DIST;
          /* falls through */
          case DIST:
            for (; ; ) {
              here = state.distcode[hold & (1 << state.distbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if ((here_op & 240) === 0) {
              last_bits = here_bits;
              last_op = here_op;
              last_val = here_val;
              for (; ; ) {
                here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (last_bits + here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              hold >>>= last_bits;
              bits -= last_bits;
              state.back += last_bits;
            }
            hold >>>= here_bits;
            bits -= here_bits;
            state.back += here_bits;
            if (here_op & 64) {
              strm.msg = "invalid distance code";
              state.mode = BAD;
              break;
            }
            state.offset = here_val;
            state.extra = here_op & 15;
            state.mode = DISTEXT;
          /* falls through */
          case DISTEXT:
            if (state.extra) {
              n = state.extra;
              while (bits < n) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.offset += hold & (1 << state.extra) - 1;
              hold >>>= state.extra;
              bits -= state.extra;
              state.back += state.extra;
            }
            if (state.offset > state.dmax) {
              strm.msg = "invalid distance too far back";
              state.mode = BAD;
              break;
            }
            state.mode = MATCH;
          /* falls through */
          case MATCH:
            if (left === 0) {
              break inf_leave;
            }
            copy = _out - left;
            if (state.offset > copy) {
              copy = state.offset - copy;
              if (copy > state.whave) {
                if (state.sane) {
                  strm.msg = "invalid distance too far back";
                  state.mode = BAD;
                  break;
                }
              }
              if (copy > state.wnext) {
                copy -= state.wnext;
                from = state.wsize - copy;
              } else {
                from = state.wnext - copy;
              }
              if (copy > state.length) {
                copy = state.length;
              }
              from_source = state.window;
            } else {
              from_source = output;
              from = put - state.offset;
              copy = state.length;
            }
            if (copy > left) {
              copy = left;
            }
            left -= copy;
            state.length -= copy;
            do {
              output[put++] = from_source[from++];
            } while (--copy);
            if (state.length === 0) {
              state.mode = LEN;
            }
            break;
          case LIT:
            if (left === 0) {
              break inf_leave;
            }
            output[put++] = state.length;
            left--;
            state.mode = LEN;
            break;
          case CHECK:
            if (state.wrap) {
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold |= input[next++] << bits;
                bits += 8;
              }
              _out -= left;
              strm.total_out += _out;
              state.total += _out;
              if (_out) {
                strm.adler = state.check = /*UPDATE(state.check, put - _out, _out);*/
                state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out);
              }
              _out = left;
              if ((state.flags ? hold : zswap32(hold)) !== state.check) {
                strm.msg = "incorrect data check";
                state.mode = BAD;
                break;
              }
              hold = 0;
              bits = 0;
            }
            state.mode = LENGTH;
          /* falls through */
          case LENGTH:
            if (state.wrap && state.flags) {
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (hold !== (state.total & 4294967295)) {
                strm.msg = "incorrect length check";
                state.mode = BAD;
                break;
              }
              hold = 0;
              bits = 0;
            }
            state.mode = DONE;
          /* falls through */
          case DONE:
            ret = Z_STREAM_END;
            break inf_leave;
          case BAD:
            ret = Z_DATA_ERROR;
            break inf_leave;
          case MEM:
            return Z_MEM_ERROR;
          case SYNC:
          /* falls through */
          default:
            return Z_STREAM_ERROR;
        }
      }
      strm.next_out = put;
      strm.avail_out = left;
      strm.next_in = next;
      strm.avail_in = have;
      state.hold = hold;
      state.bits = bits;
      if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH)) {
        if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
          state.mode = MEM;
          return Z_MEM_ERROR;
        }
      }
      _in -= strm.avail_in;
      _out -= strm.avail_out;
      strm.total_in += _in;
      strm.total_out += _out;
      state.total += _out;
      if (state.wrap && _out) {
        strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
        state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out);
      }
      strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE2 ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
      if ((_in === 0 && _out === 0 || flush === Z_FINISH) && ret === Z_OK) {
        ret = Z_BUF_ERROR;
      }
      return ret;
    }
    function inflateEnd(strm) {
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      var state = strm.state;
      if (state.window) {
        state.window = null;
      }
      strm.state = null;
      return Z_OK;
    }
    function inflateGetHeader(strm, head) {
      var state;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if ((state.wrap & 2) === 0) {
        return Z_STREAM_ERROR;
      }
      state.head = head;
      head.done = false;
      return Z_OK;
    }
    function inflateSetDictionary(strm, dictionary) {
      var dictLength = dictionary.length;
      var state;
      var dictid;
      var ret;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if (state.wrap !== 0 && state.mode !== DICT) {
        return Z_STREAM_ERROR;
      }
      if (state.mode === DICT) {
        dictid = 1;
        dictid = adler32(dictid, dictionary, dictLength, 0);
        if (dictid !== state.check) {
          return Z_DATA_ERROR;
        }
      }
      ret = updatewindow(strm, dictionary, dictLength, dictLength);
      if (ret) {
        state.mode = MEM;
        return Z_MEM_ERROR;
      }
      state.havedict = 1;
      return Z_OK;
    }
    exports.inflateReset = inflateReset;
    exports.inflateReset2 = inflateReset2;
    exports.inflateResetKeep = inflateResetKeep;
    exports.inflateInit = inflateInit;
    exports.inflateInit2 = inflateInit2;
    exports.inflate = inflate;
    exports.inflateEnd = inflateEnd;
    exports.inflateGetHeader = inflateGetHeader;
    exports.inflateSetDictionary = inflateSetDictionary;
    exports.inflateInfo = "pako inflate (from Nodeca project)";
  }
});

// ../../../../../node_modules/.deno/pako@1.0.11/node_modules/pako/lib/zlib/constants.js
var require_constants = __commonJS({
  "../../../../../node_modules/.deno/pako@1.0.11/node_modules/pako/lib/zlib/constants.js"(exports, module) {
    "use strict";
    module.exports = {
      /* Allowed flush values; see deflate() and inflate() below for details */
      Z_NO_FLUSH: 0,
      Z_PARTIAL_FLUSH: 1,
      Z_SYNC_FLUSH: 2,
      Z_FULL_FLUSH: 3,
      Z_FINISH: 4,
      Z_BLOCK: 5,
      Z_TREES: 6,
      /* Return codes for the compression/decompression functions. Negative values
      * are errors, positive values are used for special but normal events.
      */
      Z_OK: 0,
      Z_STREAM_END: 1,
      Z_NEED_DICT: 2,
      Z_ERRNO: -1,
      Z_STREAM_ERROR: -2,
      Z_DATA_ERROR: -3,
      //Z_MEM_ERROR:     -4,
      Z_BUF_ERROR: -5,
      //Z_VERSION_ERROR: -6,
      /* compression levels */
      Z_NO_COMPRESSION: 0,
      Z_BEST_SPEED: 1,
      Z_BEST_COMPRESSION: 9,
      Z_DEFAULT_COMPRESSION: -1,
      Z_FILTERED: 1,
      Z_HUFFMAN_ONLY: 2,
      Z_RLE: 3,
      Z_FIXED: 4,
      Z_DEFAULT_STRATEGY: 0,
      /* Possible values of the data_type field (though see inflate()) */
      Z_BINARY: 0,
      Z_TEXT: 1,
      //Z_ASCII:                1, // = Z_TEXT (deprecated)
      Z_UNKNOWN: 2,
      /* The deflate compression method */
      Z_DEFLATED: 8
    };
  }
});

// ../../../../../node_modules/.deno/pako@1.0.11/node_modules/pako/lib/zlib/gzheader.js
var require_gzheader = __commonJS({
  "../../../../../node_modules/.deno/pako@1.0.11/node_modules/pako/lib/zlib/gzheader.js"(exports, module) {
    "use strict";
    function GZheader() {
      this.text = 0;
      this.time = 0;
      this.xflags = 0;
      this.os = 0;
      this.extra = null;
      this.extra_len = 0;
      this.name = "";
      this.comment = "";
      this.hcrc = 0;
      this.done = false;
    }
    module.exports = GZheader;
  }
});

// ../../../../../node_modules/.deno/pako@1.0.11/node_modules/pako/lib/inflate.js
var require_inflate2 = __commonJS({
  "../../../../../node_modules/.deno/pako@1.0.11/node_modules/pako/lib/inflate.js"(exports) {
    "use strict";
    var zlib_inflate = require_inflate();
    var utils = require_common();
    var strings = require_strings();
    var c = require_constants();
    var msg = require_messages();
    var ZStream = require_zstream();
    var GZheader = require_gzheader();
    var toString = Object.prototype.toString;
    function Inflate(options) {
      if (!(this instanceof Inflate)) return new Inflate(options);
      this.options = utils.assign({
        chunkSize: 16384,
        windowBits: 0,
        to: ""
      }, options || {});
      var opt = this.options;
      if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
        opt.windowBits = -opt.windowBits;
        if (opt.windowBits === 0) {
          opt.windowBits = -15;
        }
      }
      if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
        opt.windowBits += 32;
      }
      if (opt.windowBits > 15 && opt.windowBits < 48) {
        if ((opt.windowBits & 15) === 0) {
          opt.windowBits |= 15;
        }
      }
      this.err = 0;
      this.msg = "";
      this.ended = false;
      this.chunks = [];
      this.strm = new ZStream();
      this.strm.avail_out = 0;
      var status = zlib_inflate.inflateInit2(this.strm, opt.windowBits);
      if (status !== c.Z_OK) {
        throw new Error(msg[status]);
      }
      this.header = new GZheader();
      zlib_inflate.inflateGetHeader(this.strm, this.header);
      if (opt.dictionary) {
        if (typeof opt.dictionary === "string") {
          opt.dictionary = strings.string2buf(opt.dictionary);
        } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
          opt.dictionary = new Uint8Array(opt.dictionary);
        }
        if (opt.raw) {
          status = zlib_inflate.inflateSetDictionary(this.strm, opt.dictionary);
          if (status !== c.Z_OK) {
            throw new Error(msg[status]);
          }
        }
      }
    }
    Inflate.prototype.push = function(data, mode) {
      var strm = this.strm;
      var chunkSize = this.options.chunkSize;
      var dictionary = this.options.dictionary;
      var status, _mode;
      var next_out_utf8, tail, utf8str;
      var allowBufError = false;
      if (this.ended) {
        return false;
      }
      _mode = mode === ~~mode ? mode : mode === true ? c.Z_FINISH : c.Z_NO_FLUSH;
      if (typeof data === "string") {
        strm.input = strings.binstring2buf(data);
      } else if (toString.call(data) === "[object ArrayBuffer]") {
        strm.input = new Uint8Array(data);
      } else {
        strm.input = data;
      }
      strm.next_in = 0;
      strm.avail_in = strm.input.length;
      do {
        if (strm.avail_out === 0) {
          strm.output = new utils.Buf8(chunkSize);
          strm.next_out = 0;
          strm.avail_out = chunkSize;
        }
        status = zlib_inflate.inflate(strm, c.Z_NO_FLUSH);
        if (status === c.Z_NEED_DICT && dictionary) {
          status = zlib_inflate.inflateSetDictionary(this.strm, dictionary);
        }
        if (status === c.Z_BUF_ERROR && allowBufError === true) {
          status = c.Z_OK;
          allowBufError = false;
        }
        if (status !== c.Z_STREAM_END && status !== c.Z_OK) {
          this.onEnd(status);
          this.ended = true;
          return false;
        }
        if (strm.next_out) {
          if (strm.avail_out === 0 || status === c.Z_STREAM_END || strm.avail_in === 0 && (_mode === c.Z_FINISH || _mode === c.Z_SYNC_FLUSH)) {
            if (this.options.to === "string") {
              next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
              tail = strm.next_out - next_out_utf8;
              utf8str = strings.buf2string(strm.output, next_out_utf8);
              strm.next_out = tail;
              strm.avail_out = chunkSize - tail;
              if (tail) {
                utils.arraySet(strm.output, strm.output, next_out_utf8, tail, 0);
              }
              this.onData(utf8str);
            } else {
              this.onData(utils.shrinkBuf(strm.output, strm.next_out));
            }
          }
        }
        if (strm.avail_in === 0 && strm.avail_out === 0) {
          allowBufError = true;
        }
      } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== c.Z_STREAM_END);
      if (status === c.Z_STREAM_END) {
        _mode = c.Z_FINISH;
      }
      if (_mode === c.Z_FINISH) {
        status = zlib_inflate.inflateEnd(this.strm);
        this.onEnd(status);
        this.ended = true;
        return status === c.Z_OK;
      }
      if (_mode === c.Z_SYNC_FLUSH) {
        this.onEnd(c.Z_OK);
        strm.avail_out = 0;
        return true;
      }
      return true;
    };
    Inflate.prototype.onData = function(chunk) {
      this.chunks.push(chunk);
    };
    Inflate.prototype.onEnd = function(status) {
      if (status === c.Z_OK) {
        if (this.options.to === "string") {
          this.result = this.chunks.join("");
        } else {
          this.result = utils.flattenChunks(this.chunks);
        }
      }
      this.chunks = [];
      this.err = status;
      this.msg = this.strm.msg;
    };
    function inflate(input, options) {
      var inflator = new Inflate(options);
      inflator.push(input, true);
      if (inflator.err) {
        throw inflator.msg || msg[inflator.err];
      }
      return inflator.result;
    }
    function inflateRaw(input, options) {
      options = options || {};
      options.raw = true;
      return inflate(input, options);
    }
    exports.Inflate = Inflate;
    exports.inflate = inflate;
    exports.inflateRaw = inflateRaw;
    exports.ungzip = inflate;
  }
});

// ../../../../../node_modules/.deno/pako@1.0.11/node_modules/pako/index.js
var require_pako = __commonJS({
  "../../../../../node_modules/.deno/pako@1.0.11/node_modules/pako/index.js"(exports, module) {
    "use strict";
    var assign = require_common().assign;
    var deflate = require_deflate2();
    var inflate = require_inflate2();
    var constants = require_constants();
    var pako = {};
    assign(pako, deflate, inflate, constants);
    module.exports = pako;
  }
});

// ../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/nodes/identity.js
var require_identity = __commonJS({
  "../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/nodes/identity.js"(exports) {
    "use strict";
    var ALIAS = Symbol.for("yaml.alias");
    var DOC = Symbol.for("yaml.document");
    var MAP2 = Symbol.for("yaml.map");
    var PAIR = Symbol.for("yaml.pair");
    var SCALAR = Symbol.for("yaml.scalar");
    var SEQ = Symbol.for("yaml.seq");
    var NODE_TYPE = Symbol.for("yaml.node.type");
    var isAlias = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === ALIAS;
    var isDocument = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === DOC;
    var isMap = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === MAP2;
    var isPair = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === PAIR;
    var isScalar = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === SCALAR;
    var isSeq = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === SEQ;
    function isCollection(node) {
      if (node && typeof node === "object") switch (node[NODE_TYPE]) {
        case MAP2:
        case SEQ:
          return true;
      }
      return false;
    }
    function isNode(node) {
      if (node && typeof node === "object") switch (node[NODE_TYPE]) {
        case ALIAS:
        case MAP2:
        case SCALAR:
        case SEQ:
          return true;
      }
      return false;
    }
    var hasAnchor = (node) => (isScalar(node) || isCollection(node)) && !!node.anchor;
    exports.ALIAS = ALIAS;
    exports.DOC = DOC;
    exports.MAP = MAP2;
    exports.NODE_TYPE = NODE_TYPE;
    exports.PAIR = PAIR;
    exports.SCALAR = SCALAR;
    exports.SEQ = SEQ;
    exports.hasAnchor = hasAnchor;
    exports.isAlias = isAlias;
    exports.isCollection = isCollection;
    exports.isDocument = isDocument;
    exports.isMap = isMap;
    exports.isNode = isNode;
    exports.isPair = isPair;
    exports.isScalar = isScalar;
    exports.isSeq = isSeq;
  }
});

// ../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/visit.js
var require_visit = __commonJS({
  "../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/visit.js"(exports) {
    "use strict";
    var identity = require_identity();
    var BREAK = Symbol("break visit");
    var SKIP = Symbol("skip children");
    var REMOVE = Symbol("remove node");
    function visit(node, visitor) {
      const visitor_ = initVisitor(visitor);
      if (identity.isDocument(node)) {
        const cd = visit_(null, node.contents, visitor_, Object.freeze([
          node
        ]));
        if (cd === REMOVE) node.contents = null;
      } else visit_(null, node, visitor_, Object.freeze([]));
    }
    visit.BREAK = BREAK;
    visit.SKIP = SKIP;
    visit.REMOVE = REMOVE;
    function visit_(key, node, visitor, path2) {
      const ctrl = callVisitor(key, node, visitor, path2);
      if (identity.isNode(ctrl) || identity.isPair(ctrl)) {
        replaceNode(key, path2, ctrl);
        return visit_(key, ctrl, visitor, path2);
      }
      if (typeof ctrl !== "symbol") {
        if (identity.isCollection(node)) {
          path2 = Object.freeze(path2.concat(node));
          for (let i2 = 0; i2 < node.items.length; ++i2) {
            const ci = visit_(i2, node.items[i2], visitor, path2);
            if (typeof ci === "number") i2 = ci - 1;
            else if (ci === BREAK) return BREAK;
            else if (ci === REMOVE) {
              node.items.splice(i2, 1);
              i2 -= 1;
            }
          }
        } else if (identity.isPair(node)) {
          path2 = Object.freeze(path2.concat(node));
          const ck = visit_("key", node.key, visitor, path2);
          if (ck === BREAK) return BREAK;
          else if (ck === REMOVE) node.key = null;
          const cv = visit_("value", node.value, visitor, path2);
          if (cv === BREAK) return BREAK;
          else if (cv === REMOVE) node.value = null;
        }
      }
      return ctrl;
    }
    async function visitAsync(node, visitor) {
      const visitor_ = initVisitor(visitor);
      if (identity.isDocument(node)) {
        const cd = await visitAsync_(null, node.contents, visitor_, Object.freeze([
          node
        ]));
        if (cd === REMOVE) node.contents = null;
      } else await visitAsync_(null, node, visitor_, Object.freeze([]));
    }
    visitAsync.BREAK = BREAK;
    visitAsync.SKIP = SKIP;
    visitAsync.REMOVE = REMOVE;
    async function visitAsync_(key, node, visitor, path2) {
      const ctrl = await callVisitor(key, node, visitor, path2);
      if (identity.isNode(ctrl) || identity.isPair(ctrl)) {
        replaceNode(key, path2, ctrl);
        return visitAsync_(key, ctrl, visitor, path2);
      }
      if (typeof ctrl !== "symbol") {
        if (identity.isCollection(node)) {
          path2 = Object.freeze(path2.concat(node));
          for (let i2 = 0; i2 < node.items.length; ++i2) {
            const ci = await visitAsync_(i2, node.items[i2], visitor, path2);
            if (typeof ci === "number") i2 = ci - 1;
            else if (ci === BREAK) return BREAK;
            else if (ci === REMOVE) {
              node.items.splice(i2, 1);
              i2 -= 1;
            }
          }
        } else if (identity.isPair(node)) {
          path2 = Object.freeze(path2.concat(node));
          const ck = await visitAsync_("key", node.key, visitor, path2);
          if (ck === BREAK) return BREAK;
          else if (ck === REMOVE) node.key = null;
          const cv = await visitAsync_("value", node.value, visitor, path2);
          if (cv === BREAK) return BREAK;
          else if (cv === REMOVE) node.value = null;
        }
      }
      return ctrl;
    }
    function initVisitor(visitor) {
      if (typeof visitor === "object" && (visitor.Collection || visitor.Node || visitor.Value)) {
        return Object.assign({
          Alias: visitor.Node,
          Map: visitor.Node,
          Scalar: visitor.Node,
          Seq: visitor.Node
        }, visitor.Value && {
          Map: visitor.Value,
          Scalar: visitor.Value,
          Seq: visitor.Value
        }, visitor.Collection && {
          Map: visitor.Collection,
          Seq: visitor.Collection
        }, visitor);
      }
      return visitor;
    }
    function callVisitor(key, node, visitor, path2) {
      if (typeof visitor === "function") return visitor(key, node, path2);
      if (identity.isMap(node)) return visitor.Map?.(key, node, path2);
      if (identity.isSeq(node)) return visitor.Seq?.(key, node, path2);
      if (identity.isPair(node)) return visitor.Pair?.(key, node, path2);
      if (identity.isScalar(node)) return visitor.Scalar?.(key, node, path2);
      if (identity.isAlias(node)) return visitor.Alias?.(key, node, path2);
      return void 0;
    }
    function replaceNode(key, path2, node) {
      const parent = path2[path2.length - 1];
      if (identity.isCollection(parent)) {
        parent.items[key] = node;
      } else if (identity.isPair(parent)) {
        if (key === "key") parent.key = node;
        else parent.value = node;
      } else if (identity.isDocument(parent)) {
        parent.contents = node;
      } else {
        const pt = identity.isAlias(parent) ? "alias" : "scalar";
        throw new Error(`Cannot replace node with ${pt} parent`);
      }
    }
    exports.visit = visit;
    exports.visitAsync = visitAsync;
  }
});

// ../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/doc/directives.js
var require_directives = __commonJS({
  "../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/doc/directives.js"(exports) {
    "use strict";
    var identity = require_identity();
    var visit = require_visit();
    var escapeChars = {
      "!": "%21",
      ",": "%2C",
      "[": "%5B",
      "]": "%5D",
      "{": "%7B",
      "}": "%7D"
    };
    var escapeTagName = (tn) => tn.replace(/[!,[\]{}]/g, (ch) => escapeChars[ch]);
    var Directives = class _Directives {
      constructor(yaml, tags) {
        this.docStart = null;
        this.docEnd = false;
        this.yaml = Object.assign({}, _Directives.defaultYaml, yaml);
        this.tags = Object.assign({}, _Directives.defaultTags, tags);
      }
      clone() {
        const copy = new _Directives(this.yaml, this.tags);
        copy.docStart = this.docStart;
        return copy;
      }
      /**
         * During parsing, get a Directives instance for the current document and
         * update the stream state according to the current version's spec.
         */
      atDocument() {
        const res = new _Directives(this.yaml, this.tags);
        switch (this.yaml.version) {
          case "1.1":
            this.atNextDocument = true;
            break;
          case "1.2":
            this.atNextDocument = false;
            this.yaml = {
              explicit: _Directives.defaultYaml.explicit,
              version: "1.2"
            };
            this.tags = Object.assign({}, _Directives.defaultTags);
            break;
        }
        return res;
      }
      /**
         * @param onError - May be called even if the action was successful
         * @returns `true` on success
         */
      add(line, onError) {
        if (this.atNextDocument) {
          this.yaml = {
            explicit: _Directives.defaultYaml.explicit,
            version: "1.1"
          };
          this.tags = Object.assign({}, _Directives.defaultTags);
          this.atNextDocument = false;
        }
        const parts = line.trim().split(/[ \t]+/);
        const name = parts.shift();
        switch (name) {
          case "%TAG": {
            if (parts.length !== 2) {
              onError(0, "%TAG directive should contain exactly two parts");
              if (parts.length < 2) return false;
            }
            const [handle, prefix] = parts;
            this.tags[handle] = prefix;
            return true;
          }
          case "%YAML": {
            this.yaml.explicit = true;
            if (parts.length !== 1) {
              onError(0, "%YAML directive should contain exactly one part");
              return false;
            }
            const [version] = parts;
            if (version === "1.1" || version === "1.2") {
              this.yaml.version = version;
              return true;
            } else {
              const isValid = /^\d+\.\d+$/.test(version);
              onError(6, `Unsupported YAML version ${version}`, isValid);
              return false;
            }
          }
          default:
            onError(0, `Unknown directive ${name}`, true);
            return false;
        }
      }
      /**
         * Resolves a tag, matching handles to those defined in %TAG directives.
         *
         * @returns Resolved tag, which may also be the non-specific tag `'!'` or a
         *   `'!local'` tag, or `null` if unresolvable.
         */
      tagName(source, onError) {
        if (source === "!") return "!";
        if (source[0] !== "!") {
          onError(`Not a valid tag: ${source}`);
          return null;
        }
        if (source[1] === "<") {
          const verbatim = source.slice(2, -1);
          if (verbatim === "!" || verbatim === "!!") {
            onError(`Verbatim tags aren't resolved, so ${source} is invalid.`);
            return null;
          }
          if (source[source.length - 1] !== ">") onError("Verbatim tags must end with a >");
          return verbatim;
        }
        const [, handle, suffix] = source.match(/^(.*!)([^!]*)$/s);
        if (!suffix) onError(`The ${source} tag has no suffix`);
        const prefix = this.tags[handle];
        if (prefix) {
          try {
            return prefix + decodeURIComponent(suffix);
          } catch (error) {
            onError(String(error));
            return null;
          }
        }
        if (handle === "!") return source;
        onError(`Could not resolve tag: ${source}`);
        return null;
      }
      /**
         * Given a fully resolved tag, returns its printable string form,
         * taking into account current tag prefixes and defaults.
         */
      tagString(tag) {
        for (const [handle, prefix] of Object.entries(this.tags)) {
          if (tag.startsWith(prefix)) return handle + escapeTagName(tag.substring(prefix.length));
        }
        return tag[0] === "!" ? tag : `!<${tag}>`;
      }
      toString(doc) {
        const lines = this.yaml.explicit ? [
          `%YAML ${this.yaml.version || "1.2"}`
        ] : [];
        const tagEntries = Object.entries(this.tags);
        let tagNames;
        if (doc && tagEntries.length > 0 && identity.isNode(doc.contents)) {
          const tags = {};
          visit.visit(doc.contents, (_key, node) => {
            if (identity.isNode(node) && node.tag) tags[node.tag] = true;
          });
          tagNames = Object.keys(tags);
        } else tagNames = [];
        for (const [handle, prefix] of tagEntries) {
          if (handle === "!!" && prefix === "tag:yaml.org,2002:") continue;
          if (!doc || tagNames.some((tn) => tn.startsWith(prefix))) lines.push(`%TAG ${handle} ${prefix}`);
        }
        return lines.join("\n");
      }
    };
    Directives.defaultYaml = {
      explicit: false,
      version: "1.2"
    };
    Directives.defaultTags = {
      "!!": "tag:yaml.org,2002:"
    };
    exports.Directives = Directives;
  }
});

// ../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/doc/anchors.js
var require_anchors = __commonJS({
  "../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/doc/anchors.js"(exports) {
    "use strict";
    var identity = require_identity();
    var visit = require_visit();
    function anchorIsValid(anchor) {
      if (/[\x00-\x19\s,[\]{}]/.test(anchor)) {
        const sa = JSON.stringify(anchor);
        const msg = `Anchor must not contain whitespace or control characters: ${sa}`;
        throw new Error(msg);
      }
      return true;
    }
    function anchorNames(root) {
      const anchors = /* @__PURE__ */ new Set();
      visit.visit(root, {
        Value(_key, node) {
          if (node.anchor) anchors.add(node.anchor);
        }
      });
      return anchors;
    }
    function findNewAnchor(prefix, exclude) {
      for (let i2 = 1; true; ++i2) {
        const name = `${prefix}${i2}`;
        if (!exclude.has(name)) return name;
      }
    }
    function createNodeAnchors(doc, prefix) {
      const aliasObjects = [];
      const sourceObjects = /* @__PURE__ */ new Map();
      let prevAnchors = null;
      return {
        onAnchor: (source) => {
          aliasObjects.push(source);
          prevAnchors ?? (prevAnchors = anchorNames(doc));
          const anchor = findNewAnchor(prefix, prevAnchors);
          prevAnchors.add(anchor);
          return anchor;
        },
        /**
             * With circular references, the source node is only resolved after all
             * of its child nodes are. This is why anchors are set only after all of
             * the nodes have been created.
             */
        setAnchors: () => {
          for (const source of aliasObjects) {
            const ref = sourceObjects.get(source);
            if (typeof ref === "object" && ref.anchor && (identity.isScalar(ref.node) || identity.isCollection(ref.node))) {
              ref.node.anchor = ref.anchor;
            } else {
              const error = new Error("Failed to resolve repeated object (this should not happen)");
              error.source = source;
              throw error;
            }
          }
        },
        sourceObjects
      };
    }
    exports.anchorIsValid = anchorIsValid;
    exports.anchorNames = anchorNames;
    exports.createNodeAnchors = createNodeAnchors;
    exports.findNewAnchor = findNewAnchor;
  }
});

// ../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/doc/applyReviver.js
var require_applyReviver = __commonJS({
  "../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/doc/applyReviver.js"(exports) {
    "use strict";
    function applyReviver(reviver, obj2, key, val) {
      if (val && typeof val === "object") {
        if (Array.isArray(val)) {
          for (let i2 = 0, len = val.length; i2 < len; ++i2) {
            const v0 = val[i2];
            const v1 = applyReviver(reviver, val, String(i2), v0);
            if (v1 === void 0) delete val[i2];
            else if (v1 !== v0) val[i2] = v1;
          }
        } else if (val instanceof Map) {
          for (const k of Array.from(val.keys())) {
            const v0 = val.get(k);
            const v1 = applyReviver(reviver, val, k, v0);
            if (v1 === void 0) val.delete(k);
            else if (v1 !== v0) val.set(k, v1);
          }
        } else if (val instanceof Set) {
          for (const v0 of Array.from(val)) {
            const v1 = applyReviver(reviver, val, v0, v0);
            if (v1 === void 0) val.delete(v0);
            else if (v1 !== v0) {
              val.delete(v0);
              val.add(v1);
            }
          }
        } else {
          for (const [k, v0] of Object.entries(val)) {
            const v1 = applyReviver(reviver, val, k, v0);
            if (v1 === void 0) delete val[k];
            else if (v1 !== v0) val[k] = v1;
          }
        }
      }
      return reviver.call(obj2, key, val);
    }
    exports.applyReviver = applyReviver;
  }
});

// ../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/nodes/toJS.js
var require_toJS = __commonJS({
  "../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/nodes/toJS.js"(exports) {
    "use strict";
    var identity = require_identity();
    function toJS(value, arg, ctx) {
      if (Array.isArray(value)) return value.map((v, i2) => toJS(v, String(i2), ctx));
      if (value && typeof value.toJSON === "function") {
        if (!ctx || !identity.hasAnchor(value)) return value.toJSON(arg, ctx);
        const data = {
          aliasCount: 0,
          count: 1,
          res: void 0
        };
        ctx.anchors.set(value, data);
        ctx.onCreate = (res2) => {
          data.res = res2;
          delete ctx.onCreate;
        };
        const res = value.toJSON(arg, ctx);
        if (ctx.onCreate) ctx.onCreate(res);
        return res;
      }
      if (typeof value === "bigint" && !ctx?.keep) return Number(value);
      return value;
    }
    exports.toJS = toJS;
  }
});

// ../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/nodes/Node.js
var require_Node = __commonJS({
  "../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/nodes/Node.js"(exports) {
    "use strict";
    var applyReviver = require_applyReviver();
    var identity = require_identity();
    var toJS = require_toJS();
    var NodeBase = class {
      constructor(type) {
        Object.defineProperty(this, identity.NODE_TYPE, {
          value: type
        });
      }
      /** Create a copy of this node.  */
      clone() {
        const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
        if (this.range) copy.range = this.range.slice();
        return copy;
      }
      /** A plain JavaScript representation of this node. */
      toJS(doc, { mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
        if (!identity.isDocument(doc)) throw new TypeError("A document argument is required");
        const ctx = {
          anchors: /* @__PURE__ */ new Map(),
          doc,
          keep: true,
          mapAsMap: mapAsMap === true,
          mapKeyWarned: false,
          maxAliasCount: typeof maxAliasCount === "number" ? maxAliasCount : 100
        };
        const res = toJS.toJS(this, "", ctx);
        if (typeof onAnchor === "function") for (const { count, res: res2 } of ctx.anchors.values()) onAnchor(res2, count);
        return typeof reviver === "function" ? applyReviver.applyReviver(reviver, {
          "": res
        }, "", res) : res;
      }
    };
    exports.NodeBase = NodeBase;
  }
});

// ../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/nodes/Alias.js
var require_Alias = __commonJS({
  "../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/nodes/Alias.js"(exports) {
    "use strict";
    var anchors = require_anchors();
    var visit = require_visit();
    var identity = require_identity();
    var Node = require_Node();
    var toJS = require_toJS();
    var Alias = class extends Node.NodeBase {
      constructor(source) {
        super(identity.ALIAS);
        this.source = source;
        Object.defineProperty(this, "tag", {
          set() {
            throw new Error("Alias nodes cannot have tags");
          }
        });
      }
      /**
         * Resolve the value of this alias within `doc`, finding the last
         * instance of the `source` anchor before this node.
         */
      resolve(doc, ctx) {
        let nodes;
        if (ctx?.aliasResolveCache) {
          nodes = ctx.aliasResolveCache;
        } else {
          nodes = [];
          visit.visit(doc, {
            Node: (_key, node) => {
              if (identity.isAlias(node) || identity.hasAnchor(node)) nodes.push(node);
            }
          });
          if (ctx) ctx.aliasResolveCache = nodes;
        }
        let found = void 0;
        for (const node of nodes) {
          if (node === this) break;
          if (node.anchor === this.source) found = node;
        }
        return found;
      }
      toJSON(_arg, ctx) {
        if (!ctx) return {
          source: this.source
        };
        const { anchors: anchors2, doc, maxAliasCount } = ctx;
        const source = this.resolve(doc, ctx);
        if (!source) {
          const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
          throw new ReferenceError(msg);
        }
        let data = anchors2.get(source);
        if (!data) {
          toJS.toJS(source, null, ctx);
          data = anchors2.get(source);
        }
        if (!data || data.res === void 0) {
          const msg = "This should not happen: Alias anchor was not resolved?";
          throw new ReferenceError(msg);
        }
        if (maxAliasCount >= 0) {
          data.count += 1;
          if (data.aliasCount === 0) data.aliasCount = getAliasCount(doc, source, anchors2);
          if (data.count * data.aliasCount > maxAliasCount) {
            const msg = "Excessive alias count indicates a resource exhaustion attack";
            throw new ReferenceError(msg);
          }
        }
        return data.res;
      }
      toString(ctx, _onComment, _onChompKeep) {
        const src = `*${this.source}`;
        if (ctx) {
          anchors.anchorIsValid(this.source);
          if (ctx.options.verifyAliasOrder && !ctx.anchors.has(this.source)) {
            const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
            throw new Error(msg);
          }
          if (ctx.implicitKey) return `${src} `;
        }
        return src;
      }
    };
    function getAliasCount(doc, node, anchors2) {
      if (identity.isAlias(node)) {
        const source = node.resolve(doc);
        const anchor = anchors2 && source && anchors2.get(source);
        return anchor ? anchor.count * anchor.aliasCount : 0;
      } else if (identity.isCollection(node)) {
        let count = 0;
        for (const item of node.items) {
          const c = getAliasCount(doc, item, anchors2);
          if (c > count) count = c;
        }
        return count;
      } else if (identity.isPair(node)) {
        const kc = getAliasCount(doc, node.key, anchors2);
        const vc = getAliasCount(doc, node.value, anchors2);
        return Math.max(kc, vc);
      }
      return 1;
    }
    exports.Alias = Alias;
  }
});

// ../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/nodes/Scalar.js
var require_Scalar = __commonJS({
  "../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/nodes/Scalar.js"(exports) {
    "use strict";
    var identity = require_identity();
    var Node = require_Node();
    var toJS = require_toJS();
    var isScalarValue = (value) => !value || typeof value !== "function" && typeof value !== "object";
    var Scalar = class extends Node.NodeBase {
      constructor(value) {
        super(identity.SCALAR);
        this.value = value;
      }
      toJSON(arg, ctx) {
        return ctx?.keep ? this.value : toJS.toJS(this.value, arg, ctx);
      }
      toString() {
        return String(this.value);
      }
    };
    Scalar.BLOCK_FOLDED = "BLOCK_FOLDED";
    Scalar.BLOCK_LITERAL = "BLOCK_LITERAL";
    Scalar.PLAIN = "PLAIN";
    Scalar.QUOTE_DOUBLE = "QUOTE_DOUBLE";
    Scalar.QUOTE_SINGLE = "QUOTE_SINGLE";
    exports.Scalar = Scalar;
    exports.isScalarValue = isScalarValue;
  }
});

// ../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/doc/createNode.js
var require_createNode = __commonJS({
  "../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/doc/createNode.js"(exports) {
    "use strict";
    var Alias = require_Alias();
    var identity = require_identity();
    var Scalar = require_Scalar();
    var defaultTagPrefix = "tag:yaml.org,2002:";
    function findTagObject(value, tagName, tags) {
      if (tagName) {
        const match2 = tags.filter((t) => t.tag === tagName);
        const tagObj = match2.find((t) => !t.format) ?? match2[0];
        if (!tagObj) throw new Error(`Tag ${tagName} not found`);
        return tagObj;
      }
      return tags.find((t) => t.identify?.(value) && !t.format);
    }
    function createNode(value, tagName, ctx) {
      if (identity.isDocument(value)) value = value.contents;
      if (identity.isNode(value)) return value;
      if (identity.isPair(value)) {
        const map = ctx.schema[identity.MAP].createNode?.(ctx.schema, null, ctx);
        map.items.push(value);
        return map;
      }
      if (value instanceof String || value instanceof Number || value instanceof Boolean || typeof BigInt !== "undefined" && value instanceof BigInt) {
        value = value.valueOf();
      }
      const { aliasDuplicateObjects, onAnchor, onTagObj, schema, sourceObjects } = ctx;
      let ref = void 0;
      if (aliasDuplicateObjects && value && typeof value === "object") {
        ref = sourceObjects.get(value);
        if (ref) {
          ref.anchor ?? (ref.anchor = onAnchor(value));
          return new Alias.Alias(ref.anchor);
        } else {
          ref = {
            anchor: null,
            node: null
          };
          sourceObjects.set(value, ref);
        }
      }
      if (tagName?.startsWith("!!")) tagName = defaultTagPrefix + tagName.slice(2);
      let tagObj = findTagObject(value, tagName, schema.tags);
      if (!tagObj) {
        if (value && typeof value.toJSON === "function") {
          value = value.toJSON();
        }
        if (!value || typeof value !== "object") {
          const node2 = new Scalar.Scalar(value);
          if (ref) ref.node = node2;
          return node2;
        }
        tagObj = value instanceof Map ? schema[identity.MAP] : Symbol.iterator in Object(value) ? schema[identity.SEQ] : schema[identity.MAP];
      }
      if (onTagObj) {
        onTagObj(tagObj);
        delete ctx.onTagObj;
      }
      const node = tagObj?.createNode ? tagObj.createNode(ctx.schema, value, ctx) : typeof tagObj?.nodeClass?.from === "function" ? tagObj.nodeClass.from(ctx.schema, value, ctx) : new Scalar.Scalar(value);
      if (tagName) node.tag = tagName;
      else if (!tagObj.default) node.tag = tagObj.tag;
      if (ref) ref.node = node;
      return node;
    }
    exports.createNode = createNode;
  }
});

// ../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/nodes/Collection.js
var require_Collection = __commonJS({
  "../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/nodes/Collection.js"(exports) {
    "use strict";
    var createNode = require_createNode();
    var identity = require_identity();
    var Node = require_Node();
    function collectionFromPath(schema, path2, value) {
      let v = value;
      for (let i2 = path2.length - 1; i2 >= 0; --i2) {
        const k = path2[i2];
        if (typeof k === "number" && Number.isInteger(k) && k >= 0) {
          const a = [];
          a[k] = v;
          v = a;
        } else {
          v = /* @__PURE__ */ new Map([
            [
              k,
              v
            ]
          ]);
        }
      }
      return createNode.createNode(v, void 0, {
        aliasDuplicateObjects: false,
        keepUndefined: false,
        onAnchor: () => {
          throw new Error("This should not happen, please report a bug.");
        },
        schema,
        sourceObjects: /* @__PURE__ */ new Map()
      });
    }
    var isEmptyPath = (path2) => path2 == null || typeof path2 === "object" && !!path2[Symbol.iterator]().next().done;
    var Collection = class extends Node.NodeBase {
      constructor(type, schema) {
        super(type);
        Object.defineProperty(this, "schema", {
          value: schema,
          configurable: true,
          enumerable: false,
          writable: true
        });
      }
      /**
         * Create a copy of this collection.
         *
         * @param schema - If defined, overwrites the original's schema
         */
      clone(schema) {
        const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
        if (schema) copy.schema = schema;
        copy.items = copy.items.map((it) => identity.isNode(it) || identity.isPair(it) ? it.clone(schema) : it);
        if (this.range) copy.range = this.range.slice();
        return copy;
      }
      /**
         * Adds a value to the collection. For `!!map` and `!!omap` the value must
         * be a Pair instance or a `{ key, value }` object, which may not have a key
         * that already exists in the map.
         */
      addIn(path2, value) {
        if (isEmptyPath(path2)) this.add(value);
        else {
          const [key, ...rest] = path2;
          const node = this.get(key, true);
          if (identity.isCollection(node)) node.addIn(rest, value);
          else if (node === void 0 && this.schema) this.set(key, collectionFromPath(this.schema, rest, value));
          else throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
        }
      }
      /**
         * Removes a value from the collection.
         * @returns `true` if the item was found and removed.
         */
      deleteIn(path2) {
        const [key, ...rest] = path2;
        if (rest.length === 0) return this.delete(key);
        const node = this.get(key, true);
        if (identity.isCollection(node)) return node.deleteIn(rest);
        else throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
      }
      /**
         * Returns item at `key`, or `undefined` if not found. By default unwraps
         * scalar values from their surrounding node; to disable set `keepScalar` to
         * `true` (collections are always returned intact).
         */
      getIn(path2, keepScalar) {
        const [key, ...rest] = path2;
        const node = this.get(key, true);
        if (rest.length === 0) return !keepScalar && identity.isScalar(node) ? node.value : node;
        else return identity.isCollection(node) ? node.getIn(rest, keepScalar) : void 0;
      }
      hasAllNullValues(allowScalar) {
        return this.items.every((node) => {
          if (!identity.isPair(node)) return false;
          const n = node.value;
          return n == null || allowScalar && identity.isScalar(n) && n.value == null && !n.commentBefore && !n.comment && !n.tag;
        });
      }
      /**
         * Checks if the collection includes a value with the key `key`.
         */
      hasIn(path2) {
        const [key, ...rest] = path2;
        if (rest.length === 0) return this.has(key);
        const node = this.get(key, true);
        return identity.isCollection(node) ? node.hasIn(rest) : false;
      }
      /**
         * Sets a value in this collection. For `!!set`, `value` needs to be a
         * boolean to add/remove the item from the set.
         */
      setIn(path2, value) {
        const [key, ...rest] = path2;
        if (rest.length === 0) {
          this.set(key, value);
        } else {
          const node = this.get(key, true);
          if (identity.isCollection(node)) node.setIn(rest, value);
          else if (node === void 0 && this.schema) this.set(key, collectionFromPath(this.schema, rest, value));
          else throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
        }
      }
    };
    exports.Collection = Collection;
    exports.collectionFromPath = collectionFromPath;
    exports.isEmptyPath = isEmptyPath;
  }
});

// ../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/stringify/stringifyComment.js
var require_stringifyComment = __commonJS({
  "../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/stringify/stringifyComment.js"(exports) {
    "use strict";
    var stringifyComment = (str) => str.replace(/^(?!$)(?: $)?/gm, "#");
    function indentComment(comment, indent) {
      if (/^\n+$/.test(comment)) return comment.substring(1);
      return indent ? comment.replace(/^(?! *$)/gm, indent) : comment;
    }
    var lineComment = (str, indent, comment) => str.endsWith("\n") ? indentComment(comment, indent) : comment.includes("\n") ? "\n" + indentComment(comment, indent) : (str.endsWith(" ") ? "" : " ") + comment;
    exports.indentComment = indentComment;
    exports.lineComment = lineComment;
    exports.stringifyComment = stringifyComment;
  }
});

// ../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/stringify/foldFlowLines.js
var require_foldFlowLines = __commonJS({
  "../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/stringify/foldFlowLines.js"(exports) {
    "use strict";
    var FOLD_FLOW = "flow";
    var FOLD_BLOCK = "block";
    var FOLD_QUOTED = "quoted";
    function foldFlowLines(text, indent, mode = "flow", { indentAtStart, lineWidth = 80, minContentWidth = 20, onFold, onOverflow } = {}) {
      if (!lineWidth || lineWidth < 0) return text;
      if (lineWidth < minContentWidth) minContentWidth = 0;
      const endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent.length);
      if (text.length <= endStep) return text;
      const folds = [];
      const escapedFolds = {};
      let end = lineWidth - indent.length;
      if (typeof indentAtStart === "number") {
        if (indentAtStart > lineWidth - Math.max(2, minContentWidth)) folds.push(0);
        else end = lineWidth - indentAtStart;
      }
      let split = void 0;
      let prev = void 0;
      let overflow = false;
      let i2 = -1;
      let escStart = -1;
      let escEnd = -1;
      if (mode === FOLD_BLOCK) {
        i2 = consumeMoreIndentedLines(text, i2, indent.length);
        if (i2 !== -1) end = i2 + endStep;
      }
      for (let ch; ch = text[i2 += 1]; ) {
        if (mode === FOLD_QUOTED && ch === "\\") {
          escStart = i2;
          switch (text[i2 + 1]) {
            case "x":
              i2 += 3;
              break;
            case "u":
              i2 += 5;
              break;
            case "U":
              i2 += 9;
              break;
            default:
              i2 += 1;
          }
          escEnd = i2;
        }
        if (ch === "\n") {
          if (mode === FOLD_BLOCK) i2 = consumeMoreIndentedLines(text, i2, indent.length);
          end = i2 + indent.length + endStep;
          split = void 0;
        } else {
          if (ch === " " && prev && prev !== " " && prev !== "\n" && prev !== "	") {
            const next = text[i2 + 1];
            if (next && next !== " " && next !== "\n" && next !== "	") split = i2;
          }
          if (i2 >= end) {
            if (split) {
              folds.push(split);
              end = split + endStep;
              split = void 0;
            } else if (mode === FOLD_QUOTED) {
              while (prev === " " || prev === "	") {
                prev = ch;
                ch = text[i2 += 1];
                overflow = true;
              }
              const j = i2 > escEnd + 1 ? i2 - 2 : escStart - 1;
              if (escapedFolds[j]) return text;
              folds.push(j);
              escapedFolds[j] = true;
              end = j + endStep;
              split = void 0;
            } else {
              overflow = true;
            }
          }
        }
        prev = ch;
      }
      if (overflow && onOverflow) onOverflow();
      if (folds.length === 0) return text;
      if (onFold) onFold();
      let res = text.slice(0, folds[0]);
      for (let i3 = 0; i3 < folds.length; ++i3) {
        const fold = folds[i3];
        const end2 = folds[i3 + 1] || text.length;
        if (fold === 0) res = `
${indent}${text.slice(0, end2)}`;
        else {
          if (mode === FOLD_QUOTED && escapedFolds[fold]) res += `${text[fold]}\\`;
          res += `
${indent}${text.slice(fold + 1, end2)}`;
        }
      }
      return res;
    }
    function consumeMoreIndentedLines(text, i2, indent) {
      let end = i2;
      let start = i2 + 1;
      let ch = text[start];
      while (ch === " " || ch === "	") {
        if (i2 < start + indent) {
          ch = text[++i2];
        } else {
          do {
            ch = text[++i2];
          } while (ch && ch !== "\n");
          end = i2;
          start = i2 + 1;
          ch = text[start];
        }
      }
      return end;
    }
    exports.FOLD_BLOCK = FOLD_BLOCK;
    exports.FOLD_FLOW = FOLD_FLOW;
    exports.FOLD_QUOTED = FOLD_QUOTED;
    exports.foldFlowLines = foldFlowLines;
  }
});

// ../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/stringify/stringifyString.js
var require_stringifyString = __commonJS({
  "../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/stringify/stringifyString.js"(exports) {
    "use strict";
    var Scalar = require_Scalar();
    var foldFlowLines = require_foldFlowLines();
    var getFoldOptions = (ctx, isBlock) => ({
      indentAtStart: isBlock ? ctx.indent.length : ctx.indentAtStart,
      lineWidth: ctx.options.lineWidth,
      minContentWidth: ctx.options.minContentWidth
    });
    var containsDocumentMarker = (str) => /^(%|---|\.\.\.)/m.test(str);
    function lineLengthOverLimit(str, lineWidth, indentLength) {
      if (!lineWidth || lineWidth < 0) return false;
      const limit = lineWidth - indentLength;
      const strLen = str.length;
      if (strLen <= limit) return false;
      for (let i2 = 0, start = 0; i2 < strLen; ++i2) {
        if (str[i2] === "\n") {
          if (i2 - start > limit) return true;
          start = i2 + 1;
          if (strLen - start <= limit) return false;
        }
      }
      return true;
    }
    function doubleQuotedString(value, ctx) {
      const json = JSON.stringify(value);
      if (ctx.options.doubleQuotedAsJSON) return json;
      const { implicitKey } = ctx;
      const minMultiLineLength = ctx.options.doubleQuotedMinMultiLineLength;
      const indent = ctx.indent || (containsDocumentMarker(value) ? "  " : "");
      let str = "";
      let start = 0;
      for (let i2 = 0, ch = json[i2]; ch; ch = json[++i2]) {
        if (ch === " " && json[i2 + 1] === "\\" && json[i2 + 2] === "n") {
          str += json.slice(start, i2) + "\\ ";
          i2 += 1;
          start = i2;
          ch = "\\";
        }
        if (ch === "\\") switch (json[i2 + 1]) {
          case "u":
            {
              str += json.slice(start, i2);
              const code = json.substr(i2 + 2, 4);
              switch (code) {
                case "0000":
                  str += "\\0";
                  break;
                case "0007":
                  str += "\\a";
                  break;
                case "000b":
                  str += "\\v";
                  break;
                case "001b":
                  str += "\\e";
                  break;
                case "0085":
                  str += "\\N";
                  break;
                case "00a0":
                  str += "\\_";
                  break;
                case "2028":
                  str += "\\L";
                  break;
                case "2029":
                  str += "\\P";
                  break;
                default:
                  if (code.substr(0, 2) === "00") str += "\\x" + code.substr(2);
                  else str += json.substr(i2, 6);
              }
              i2 += 5;
              start = i2 + 1;
            }
            break;
          case "n":
            if (implicitKey || json[i2 + 2] === '"' || json.length < minMultiLineLength) {
              i2 += 1;
            } else {
              str += json.slice(start, i2) + "\n\n";
              while (json[i2 + 2] === "\\" && json[i2 + 3] === "n" && json[i2 + 4] !== '"') {
                str += "\n";
                i2 += 2;
              }
              str += indent;
              if (json[i2 + 2] === " ") str += "\\";
              i2 += 1;
              start = i2 + 1;
            }
            break;
          default:
            i2 += 1;
        }
      }
      str = start ? str + json.slice(start) : json;
      return implicitKey ? str : foldFlowLines.foldFlowLines(str, indent, foldFlowLines.FOLD_QUOTED, getFoldOptions(ctx, false));
    }
    function singleQuotedString(value, ctx) {
      if (ctx.options.singleQuote === false || ctx.implicitKey && value.includes("\n") || /[ \t]\n|\n[ \t]/.test(value)) return doubleQuotedString(value, ctx);
      const indent = ctx.indent || (containsDocumentMarker(value) ? "  " : "");
      const res = "'" + value.replace(/'/g, "''").replace(/\n+/g, `$&
${indent}`) + "'";
      return ctx.implicitKey ? res : foldFlowLines.foldFlowLines(res, indent, foldFlowLines.FOLD_FLOW, getFoldOptions(ctx, false));
    }
    function quotedString(value, ctx) {
      const { singleQuote } = ctx.options;
      let qs;
      if (singleQuote === false) qs = doubleQuotedString;
      else {
        const hasDouble = value.includes('"');
        const hasSingle = value.includes("'");
        if (hasDouble && !hasSingle) qs = singleQuotedString;
        else if (hasSingle && !hasDouble) qs = doubleQuotedString;
        else qs = singleQuote ? singleQuotedString : doubleQuotedString;
      }
      return qs(value, ctx);
    }
    var blockEndNewlines;
    try {
      blockEndNewlines = new RegExp("(^|(?<!\n))\n+(?!\n|$)", "g");
    } catch {
      blockEndNewlines = /\n+(?!\n|$)/g;
    }
    function blockString({ comment, type, value }, ctx, onComment, onChompKeep) {
      const { blockQuote, commentString, lineWidth } = ctx.options;
      if (!blockQuote || /\n[\t ]+$/.test(value) || /^\s*$/.test(value)) {
        return quotedString(value, ctx);
      }
      const indent = ctx.indent || (ctx.forceBlockIndent || containsDocumentMarker(value) ? "  " : "");
      const literal = blockQuote === "literal" ? true : blockQuote === "folded" || type === Scalar.Scalar.BLOCK_FOLDED ? false : type === Scalar.Scalar.BLOCK_LITERAL ? true : !lineLengthOverLimit(value, lineWidth, indent.length);
      if (!value) return literal ? "|\n" : ">\n";
      let chomp;
      let endStart;
      for (endStart = value.length; endStart > 0; --endStart) {
        const ch = value[endStart - 1];
        if (ch !== "\n" && ch !== "	" && ch !== " ") break;
      }
      let end = value.substring(endStart);
      const endNlPos = end.indexOf("\n");
      if (endNlPos === -1) {
        chomp = "-";
      } else if (value === end || endNlPos !== end.length - 1) {
        chomp = "+";
        if (onChompKeep) onChompKeep();
      } else {
        chomp = "";
      }
      if (end) {
        value = value.slice(0, -end.length);
        if (end[end.length - 1] === "\n") end = end.slice(0, -1);
        end = end.replace(blockEndNewlines, `$&${indent}`);
      }
      let startWithSpace = false;
      let startEnd;
      let startNlPos = -1;
      for (startEnd = 0; startEnd < value.length; ++startEnd) {
        const ch = value[startEnd];
        if (ch === " ") startWithSpace = true;
        else if (ch === "\n") startNlPos = startEnd;
        else break;
      }
      let start = value.substring(0, startNlPos < startEnd ? startNlPos + 1 : startEnd);
      if (start) {
        value = value.substring(start.length);
        start = start.replace(/\n+/g, `$&${indent}`);
      }
      const indentSize = indent ? "2" : "1";
      let header = (startWithSpace ? indentSize : "") + chomp;
      if (comment) {
        header += " " + commentString(comment.replace(/ ?[\r\n]+/g, " "));
        if (onComment) onComment();
      }
      if (!literal) {
        const foldedValue = value.replace(/\n+/g, "\n$&").replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, "$1$2").replace(/\n+/g, `$&${indent}`);
        let literalFallback = false;
        const foldOptions = getFoldOptions(ctx, true);
        if (blockQuote !== "folded" && type !== Scalar.Scalar.BLOCK_FOLDED) {
          foldOptions.onOverflow = () => {
            literalFallback = true;
          };
        }
        const body = foldFlowLines.foldFlowLines(`${start}${foldedValue}${end}`, indent, foldFlowLines.FOLD_BLOCK, foldOptions);
        if (!literalFallback) return `>${header}
${indent}${body}`;
      }
      value = value.replace(/\n+/g, `$&${indent}`);
      return `|${header}
${indent}${start}${value}${end}`;
    }
    function plainString(item, ctx, onComment, onChompKeep) {
      const { type, value } = item;
      const { actualString, implicitKey, indent, indentStep, inFlow } = ctx;
      if (implicitKey && value.includes("\n") || inFlow && /[[\]{},]/.test(value)) {
        return quotedString(value, ctx);
      }
      if (/^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(value)) {
        return implicitKey || inFlow || !value.includes("\n") ? quotedString(value, ctx) : blockString(item, ctx, onComment, onChompKeep);
      }
      if (!implicitKey && !inFlow && type !== Scalar.Scalar.PLAIN && value.includes("\n")) {
        return blockString(item, ctx, onComment, onChompKeep);
      }
      if (containsDocumentMarker(value)) {
        if (indent === "") {
          ctx.forceBlockIndent = true;
          return blockString(item, ctx, onComment, onChompKeep);
        } else if (implicitKey && indent === indentStep) {
          return quotedString(value, ctx);
        }
      }
      const str = value.replace(/\n+/g, `$&
${indent}`);
      if (actualString) {
        const test = (tag) => tag.default && tag.tag !== "tag:yaml.org,2002:str" && tag.test?.test(str);
        const { compat, tags } = ctx.doc.schema;
        if (tags.some(test) || compat?.some(test)) return quotedString(value, ctx);
      }
      return implicitKey ? str : foldFlowLines.foldFlowLines(str, indent, foldFlowLines.FOLD_FLOW, getFoldOptions(ctx, false));
    }
    function stringifyString(item, ctx, onComment, onChompKeep) {
      const { implicitKey, inFlow } = ctx;
      const ss = typeof item.value === "string" ? item : Object.assign({}, item, {
        value: String(item.value)
      });
      let { type } = item;
      if (type !== Scalar.Scalar.QUOTE_DOUBLE) {
        if (/[\x00-\x08\x0b-\x1f\x7f-\x9f\u{D800}-\u{DFFF}]/u.test(ss.value)) type = Scalar.Scalar.QUOTE_DOUBLE;
      }
      const _stringify = (_type) => {
        switch (_type) {
          case Scalar.Scalar.BLOCK_FOLDED:
          case Scalar.Scalar.BLOCK_LITERAL:
            return implicitKey || inFlow ? quotedString(ss.value, ctx) : blockString(ss, ctx, onComment, onChompKeep);
          case Scalar.Scalar.QUOTE_DOUBLE:
            return doubleQuotedString(ss.value, ctx);
          case Scalar.Scalar.QUOTE_SINGLE:
            return singleQuotedString(ss.value, ctx);
          case Scalar.Scalar.PLAIN:
            return plainString(ss, ctx, onComment, onChompKeep);
          default:
            return null;
        }
      };
      let res = _stringify(type);
      if (res === null) {
        const { defaultKeyType, defaultStringType } = ctx.options;
        const t = implicitKey && defaultKeyType || defaultStringType;
        res = _stringify(t);
        if (res === null) throw new Error(`Unsupported default string type ${t}`);
      }
      return res;
    }
    exports.stringifyString = stringifyString;
  }
});

// ../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/stringify/stringify.js
var require_stringify = __commonJS({
  "../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/stringify/stringify.js"(exports) {
    "use strict";
    var anchors = require_anchors();
    var identity = require_identity();
    var stringifyComment = require_stringifyComment();
    var stringifyString = require_stringifyString();
    function createStringifyContext(doc, options) {
      const opt = Object.assign({
        blockQuote: true,
        commentString: stringifyComment.stringifyComment,
        defaultKeyType: null,
        defaultStringType: "PLAIN",
        directives: null,
        doubleQuotedAsJSON: false,
        doubleQuotedMinMultiLineLength: 40,
        falseStr: "false",
        flowCollectionPadding: true,
        indentSeq: true,
        lineWidth: 80,
        minContentWidth: 20,
        nullStr: "null",
        simpleKeys: false,
        singleQuote: null,
        trueStr: "true",
        verifyAliasOrder: true
      }, doc.schema.toStringOptions, options);
      let inFlow;
      switch (opt.collectionStyle) {
        case "block":
          inFlow = false;
          break;
        case "flow":
          inFlow = true;
          break;
        default:
          inFlow = null;
      }
      return {
        anchors: /* @__PURE__ */ new Set(),
        doc,
        flowCollectionPadding: opt.flowCollectionPadding ? " " : "",
        indent: "",
        indentStep: typeof opt.indent === "number" ? " ".repeat(opt.indent) : "  ",
        inFlow,
        options: opt
      };
    }
    function getTagObject(tags, item) {
      if (item.tag) {
        const match2 = tags.filter((t) => t.tag === item.tag);
        if (match2.length > 0) return match2.find((t) => t.format === item.format) ?? match2[0];
      }
      let tagObj = void 0;
      let obj2;
      if (identity.isScalar(item)) {
        obj2 = item.value;
        let match2 = tags.filter((t) => t.identify?.(obj2));
        if (match2.length > 1) {
          const testMatch = match2.filter((t) => t.test);
          if (testMatch.length > 0) match2 = testMatch;
        }
        tagObj = match2.find((t) => t.format === item.format) ?? match2.find((t) => !t.format);
      } else {
        obj2 = item;
        tagObj = tags.find((t) => t.nodeClass && obj2 instanceof t.nodeClass);
      }
      if (!tagObj) {
        const name = obj2?.constructor?.name ?? (obj2 === null ? "null" : typeof obj2);
        throw new Error(`Tag not resolved for ${name} value`);
      }
      return tagObj;
    }
    function stringifyProps(node, tagObj, { anchors: anchors$1, doc }) {
      if (!doc.directives) return "";
      const props = [];
      const anchor = (identity.isScalar(node) || identity.isCollection(node)) && node.anchor;
      if (anchor && anchors.anchorIsValid(anchor)) {
        anchors$1.add(anchor);
        props.push(`&${anchor}`);
      }
      const tag = node.tag ?? (tagObj.default ? null : tagObj.tag);
      if (tag) props.push(doc.directives.tagString(tag));
      return props.join(" ");
    }
    function stringify(item, ctx, onComment, onChompKeep) {
      if (identity.isPair(item)) return item.toString(ctx, onComment, onChompKeep);
      if (identity.isAlias(item)) {
        if (ctx.doc.directives) return item.toString(ctx);
        if (ctx.resolvedAliases?.has(item)) {
          throw new TypeError(`Cannot stringify circular structure without alias nodes`);
        } else {
          if (ctx.resolvedAliases) ctx.resolvedAliases.add(item);
          else ctx.resolvedAliases = /* @__PURE__ */ new Set([
            item
          ]);
          item = item.resolve(ctx.doc);
        }
      }
      let tagObj = void 0;
      const node = identity.isNode(item) ? item : ctx.doc.createNode(item, {
        onTagObj: (o) => tagObj = o
      });
      tagObj ?? (tagObj = getTagObject(ctx.doc.schema.tags, node));
      const props = stringifyProps(node, tagObj, ctx);
      if (props.length > 0) ctx.indentAtStart = (ctx.indentAtStart ?? 0) + props.length + 1;
      const str = typeof tagObj.stringify === "function" ? tagObj.stringify(node, ctx, onComment, onChompKeep) : identity.isScalar(node) ? stringifyString.stringifyString(node, ctx, onComment, onChompKeep) : node.toString(ctx, onComment, onChompKeep);
      if (!props) return str;
      return identity.isScalar(node) || str[0] === "{" || str[0] === "[" ? `${props} ${str}` : `${props}
${ctx.indent}${str}`;
    }
    exports.createStringifyContext = createStringifyContext;
    exports.stringify = stringify;
  }
});

// ../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/stringify/stringifyPair.js
var require_stringifyPair = __commonJS({
  "../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/stringify/stringifyPair.js"(exports) {
    "use strict";
    var identity = require_identity();
    var Scalar = require_Scalar();
    var stringify = require_stringify();
    var stringifyComment = require_stringifyComment();
    function stringifyPair({ key, value }, ctx, onComment, onChompKeep) {
      const { allNullValues, doc, indent, indentStep, options: { commentString, indentSeq, simpleKeys } } = ctx;
      let keyComment = identity.isNode(key) && key.comment || null;
      if (simpleKeys) {
        if (keyComment) {
          throw new Error("With simple keys, key nodes cannot have comments");
        }
        if (identity.isCollection(key) || !identity.isNode(key) && typeof key === "object") {
          const msg = "With simple keys, collection cannot be used as a key value";
          throw new Error(msg);
        }
      }
      let explicitKey = !simpleKeys && (!key || keyComment && value == null && !ctx.inFlow || identity.isCollection(key) || (identity.isScalar(key) ? key.type === Scalar.Scalar.BLOCK_FOLDED || key.type === Scalar.Scalar.BLOCK_LITERAL : typeof key === "object"));
      ctx = Object.assign({}, ctx, {
        allNullValues: false,
        implicitKey: !explicitKey && (simpleKeys || !allNullValues),
        indent: indent + indentStep
      });
      let keyCommentDone = false;
      let chompKeep = false;
      let str = stringify.stringify(key, ctx, () => keyCommentDone = true, () => chompKeep = true);
      if (!explicitKey && !ctx.inFlow && str.length > 1024) {
        if (simpleKeys) throw new Error("With simple keys, single line scalar must not span more than 1024 characters");
        explicitKey = true;
      }
      if (ctx.inFlow) {
        if (allNullValues || value == null) {
          if (keyCommentDone && onComment) onComment();
          return str === "" ? "?" : explicitKey ? `? ${str}` : str;
        }
      } else if (allNullValues && !simpleKeys || value == null && explicitKey) {
        str = `? ${str}`;
        if (keyComment && !keyCommentDone) {
          str += stringifyComment.lineComment(str, ctx.indent, commentString(keyComment));
        } else if (chompKeep && onChompKeep) onChompKeep();
        return str;
      }
      if (keyCommentDone) keyComment = null;
      if (explicitKey) {
        if (keyComment) str += stringifyComment.lineComment(str, ctx.indent, commentString(keyComment));
        str = `? ${str}
${indent}:`;
      } else {
        str = `${str}:`;
        if (keyComment) str += stringifyComment.lineComment(str, ctx.indent, commentString(keyComment));
      }
      let vsb, vcb, valueComment;
      if (identity.isNode(value)) {
        vsb = !!value.spaceBefore;
        vcb = value.commentBefore;
        valueComment = value.comment;
      } else {
        vsb = false;
        vcb = null;
        valueComment = null;
        if (value && typeof value === "object") value = doc.createNode(value);
      }
      ctx.implicitKey = false;
      if (!explicitKey && !keyComment && identity.isScalar(value)) ctx.indentAtStart = str.length + 1;
      chompKeep = false;
      if (!indentSeq && indentStep.length >= 2 && !ctx.inFlow && !explicitKey && identity.isSeq(value) && !value.flow && !value.tag && !value.anchor) {
        ctx.indent = ctx.indent.substring(2);
      }
      let valueCommentDone = false;
      const valueStr = stringify.stringify(value, ctx, () => valueCommentDone = true, () => chompKeep = true);
      let ws = " ";
      if (keyComment || vsb || vcb) {
        ws = vsb ? "\n" : "";
        if (vcb) {
          const cs = commentString(vcb);
          ws += `
${stringifyComment.indentComment(cs, ctx.indent)}`;
        }
        if (valueStr === "" && !ctx.inFlow) {
          if (ws === "\n") ws = "\n\n";
        } else {
          ws += `
${ctx.indent}`;
        }
      } else if (!explicitKey && identity.isCollection(value)) {
        const vs0 = valueStr[0];
        const nl0 = valueStr.indexOf("\n");
        const hasNewline = nl0 !== -1;
        const flow = ctx.inFlow ?? value.flow ?? value.items.length === 0;
        if (hasNewline || !flow) {
          let hasPropsLine = false;
          if (hasNewline && (vs0 === "&" || vs0 === "!")) {
            let sp0 = valueStr.indexOf(" ");
            if (vs0 === "&" && sp0 !== -1 && sp0 < nl0 && valueStr[sp0 + 1] === "!") {
              sp0 = valueStr.indexOf(" ", sp0 + 1);
            }
            if (sp0 === -1 || nl0 < sp0) hasPropsLine = true;
          }
          if (!hasPropsLine) ws = `
${ctx.indent}`;
        }
      } else if (valueStr === "" || valueStr[0] === "\n") {
        ws = "";
      }
      str += ws + valueStr;
      if (ctx.inFlow) {
        if (valueCommentDone && onComment) onComment();
      } else if (valueComment && !valueCommentDone) {
        str += stringifyComment.lineComment(str, ctx.indent, commentString(valueComment));
      } else if (chompKeep && onChompKeep) {
        onChompKeep();
      }
      return str;
    }
    exports.stringifyPair = stringifyPair;
  }
});

// ../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/log.js
var require_log = __commonJS({
  "../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/log.js"(exports) {
    "use strict";
    var node_process = __require("node:process");
    function debug(logLevel, ...messages) {
      if (logLevel === "debug") console.log(...messages);
    }
    function warn(logLevel, warning) {
      if (logLevel === "debug" || logLevel === "warn") {
        if (typeof node_process.emitWarning === "function") node_process.emitWarning(warning);
        else console.warn(warning);
      }
    }
    exports.debug = debug;
    exports.warn = warn;
  }
});

// ../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/schema/yaml-1.1/merge.js
var require_merge = __commonJS({
  "../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/schema/yaml-1.1/merge.js"(exports) {
    "use strict";
    var identity = require_identity();
    var Scalar = require_Scalar();
    var MERGE_KEY = "<<";
    var merge = {
      identify: (value) => value === MERGE_KEY || typeof value === "symbol" && value.description === MERGE_KEY,
      default: "key",
      tag: "tag:yaml.org,2002:merge",
      test: /^<<$/,
      resolve: () => Object.assign(new Scalar.Scalar(Symbol(MERGE_KEY)), {
        addToJSMap: addMergeToJSMap
      }),
      stringify: () => MERGE_KEY
    };
    var isMergeKey = (ctx, key) => (merge.identify(key) || identity.isScalar(key) && (!key.type || key.type === Scalar.Scalar.PLAIN) && merge.identify(key.value)) && ctx?.doc.schema.tags.some((tag) => tag.tag === merge.tag && tag.default);
    function addMergeToJSMap(ctx, map, value) {
      value = ctx && identity.isAlias(value) ? value.resolve(ctx.doc) : value;
      if (identity.isSeq(value)) for (const it of value.items) mergeValue(ctx, map, it);
      else if (Array.isArray(value)) for (const it of value) mergeValue(ctx, map, it);
      else mergeValue(ctx, map, value);
    }
    function mergeValue(ctx, map, value) {
      const source = ctx && identity.isAlias(value) ? value.resolve(ctx.doc) : value;
      if (!identity.isMap(source)) throw new Error("Merge sources must be maps or map aliases");
      const srcMap = source.toJSON(null, ctx, Map);
      for (const [key, value2] of srcMap) {
        if (map instanceof Map) {
          if (!map.has(key)) map.set(key, value2);
        } else if (map instanceof Set) {
          map.add(key);
        } else if (!Object.prototype.hasOwnProperty.call(map, key)) {
          Object.defineProperty(map, key, {
            value: value2,
            writable: true,
            enumerable: true,
            configurable: true
          });
        }
      }
      return map;
    }
    exports.addMergeToJSMap = addMergeToJSMap;
    exports.isMergeKey = isMergeKey;
    exports.merge = merge;
  }
});

// ../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/nodes/addPairToJSMap.js
var require_addPairToJSMap = __commonJS({
  "../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/nodes/addPairToJSMap.js"(exports) {
    "use strict";
    var log = require_log();
    var merge = require_merge();
    var stringify = require_stringify();
    var identity = require_identity();
    var toJS = require_toJS();
    function addPairToJSMap(ctx, map, { key, value }) {
      if (identity.isNode(key) && key.addToJSMap) key.addToJSMap(ctx, map, value);
      else if (merge.isMergeKey(ctx, key)) merge.addMergeToJSMap(ctx, map, value);
      else {
        const jsKey = toJS.toJS(key, "", ctx);
        if (map instanceof Map) {
          map.set(jsKey, toJS.toJS(value, jsKey, ctx));
        } else if (map instanceof Set) {
          map.add(jsKey);
        } else {
          const stringKey = stringifyKey(key, jsKey, ctx);
          const jsValue = toJS.toJS(value, stringKey, ctx);
          if (stringKey in map) Object.defineProperty(map, stringKey, {
            value: jsValue,
            writable: true,
            enumerable: true,
            configurable: true
          });
          else map[stringKey] = jsValue;
        }
      }
      return map;
    }
    function stringifyKey(key, jsKey, ctx) {
      if (jsKey === null) return "";
      if (typeof jsKey !== "object") return String(jsKey);
      if (identity.isNode(key) && ctx?.doc) {
        const strCtx = stringify.createStringifyContext(ctx.doc, {});
        strCtx.anchors = /* @__PURE__ */ new Set();
        for (const node of ctx.anchors.keys()) strCtx.anchors.add(node.anchor);
        strCtx.inFlow = true;
        strCtx.inStringifyKey = true;
        const strKey = key.toString(strCtx);
        if (!ctx.mapKeyWarned) {
          let jsonStr = JSON.stringify(strKey);
          if (jsonStr.length > 40) jsonStr = jsonStr.substring(0, 36) + '..."';
          log.warn(ctx.doc.options.logLevel, `Keys with collection values will be stringified due to JS Object restrictions: ${jsonStr}. Set mapAsMap: true to use object keys.`);
          ctx.mapKeyWarned = true;
        }
        return strKey;
      }
      return JSON.stringify(jsKey);
    }
    exports.addPairToJSMap = addPairToJSMap;
  }
});

// ../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/nodes/Pair.js
var require_Pair = __commonJS({
  "../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/nodes/Pair.js"(exports) {
    "use strict";
    var createNode = require_createNode();
    var stringifyPair = require_stringifyPair();
    var addPairToJSMap = require_addPairToJSMap();
    var identity = require_identity();
    function createPair(key, value, ctx) {
      const k = createNode.createNode(key, void 0, ctx);
      const v = createNode.createNode(value, void 0, ctx);
      return new Pair(k, v);
    }
    var Pair = class _Pair {
      constructor(key, value = null) {
        Object.defineProperty(this, identity.NODE_TYPE, {
          value: identity.PAIR
        });
        this.key = key;
        this.value = value;
      }
      clone(schema) {
        let { key, value } = this;
        if (identity.isNode(key)) key = key.clone(schema);
        if (identity.isNode(value)) value = value.clone(schema);
        return new _Pair(key, value);
      }
      toJSON(_, ctx) {
        const pair = ctx?.mapAsMap ? /* @__PURE__ */ new Map() : {};
        return addPairToJSMap.addPairToJSMap(ctx, pair, this);
      }
      toString(ctx, onComment, onChompKeep) {
        return ctx?.doc ? stringifyPair.stringifyPair(this, ctx, onComment, onChompKeep) : JSON.stringify(this);
      }
    };
    exports.Pair = Pair;
    exports.createPair = createPair;
  }
});

// ../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/stringify/stringifyCollection.js
var require_stringifyCollection = __commonJS({
  "../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/stringify/stringifyCollection.js"(exports) {
    "use strict";
    var identity = require_identity();
    var stringify = require_stringify();
    var stringifyComment = require_stringifyComment();
    function stringifyCollection(collection, ctx, options) {
      const flow = ctx.inFlow ?? collection.flow;
      const stringify2 = flow ? stringifyFlowCollection : stringifyBlockCollection;
      return stringify2(collection, ctx, options);
    }
    function stringifyBlockCollection({ comment, items }, ctx, { blockItemPrefix, flowChars, itemIndent, onChompKeep, onComment }) {
      const { indent, options: { commentString } } = ctx;
      const itemCtx = Object.assign({}, ctx, {
        indent: itemIndent,
        type: null
      });
      let chompKeep = false;
      const lines = [];
      for (let i2 = 0; i2 < items.length; ++i2) {
        const item = items[i2];
        let comment2 = null;
        if (identity.isNode(item)) {
          if (!chompKeep && item.spaceBefore) lines.push("");
          addCommentBefore(ctx, lines, item.commentBefore, chompKeep);
          if (item.comment) comment2 = item.comment;
        } else if (identity.isPair(item)) {
          const ik = identity.isNode(item.key) ? item.key : null;
          if (ik) {
            if (!chompKeep && ik.spaceBefore) lines.push("");
            addCommentBefore(ctx, lines, ik.commentBefore, chompKeep);
          }
        }
        chompKeep = false;
        let str2 = stringify.stringify(item, itemCtx, () => comment2 = null, () => chompKeep = true);
        if (comment2) str2 += stringifyComment.lineComment(str2, itemIndent, commentString(comment2));
        if (chompKeep && comment2) chompKeep = false;
        lines.push(blockItemPrefix + str2);
      }
      let str;
      if (lines.length === 0) {
        str = flowChars.start + flowChars.end;
      } else {
        str = lines[0];
        for (let i2 = 1; i2 < lines.length; ++i2) {
          const line = lines[i2];
          str += line ? `
${indent}${line}` : "\n";
        }
      }
      if (comment) {
        str += "\n" + stringifyComment.indentComment(commentString(comment), indent);
        if (onComment) onComment();
      } else if (chompKeep && onChompKeep) onChompKeep();
      return str;
    }
    function stringifyFlowCollection({ items }, ctx, { flowChars, itemIndent }) {
      const { indent, indentStep, flowCollectionPadding: fcPadding, options: { commentString } } = ctx;
      itemIndent += indentStep;
      const itemCtx = Object.assign({}, ctx, {
        indent: itemIndent,
        inFlow: true,
        type: null
      });
      let reqNewline = false;
      let linesAtValue = 0;
      const lines = [];
      for (let i2 = 0; i2 < items.length; ++i2) {
        const item = items[i2];
        let comment = null;
        if (identity.isNode(item)) {
          if (item.spaceBefore) lines.push("");
          addCommentBefore(ctx, lines, item.commentBefore, false);
          if (item.comment) comment = item.comment;
        } else if (identity.isPair(item)) {
          const ik = identity.isNode(item.key) ? item.key : null;
          if (ik) {
            if (ik.spaceBefore) lines.push("");
            addCommentBefore(ctx, lines, ik.commentBefore, false);
            if (ik.comment) reqNewline = true;
          }
          const iv = identity.isNode(item.value) ? item.value : null;
          if (iv) {
            if (iv.comment) comment = iv.comment;
            if (iv.commentBefore) reqNewline = true;
          } else if (item.value == null && ik?.comment) {
            comment = ik.comment;
          }
        }
        if (comment) reqNewline = true;
        let str = stringify.stringify(item, itemCtx, () => comment = null);
        if (i2 < items.length - 1) str += ",";
        if (comment) str += stringifyComment.lineComment(str, itemIndent, commentString(comment));
        if (!reqNewline && (lines.length > linesAtValue || str.includes("\n"))) reqNewline = true;
        lines.push(str);
        linesAtValue = lines.length;
      }
      const { start, end } = flowChars;
      if (lines.length === 0) {
        return start + end;
      } else {
        if (!reqNewline) {
          const len = lines.reduce((sum, line) => sum + line.length + 2, 2);
          reqNewline = ctx.options.lineWidth > 0 && len > ctx.options.lineWidth;
        }
        if (reqNewline) {
          let str = start;
          for (const line of lines) str += line ? `
${indentStep}${indent}${line}` : "\n";
          return `${str}
${indent}${end}`;
        } else {
          return `${start}${fcPadding}${lines.join(" ")}${fcPadding}${end}`;
        }
      }
    }
    function addCommentBefore({ indent, options: { commentString } }, lines, comment, chompKeep) {
      if (comment && chompKeep) comment = comment.replace(/^\n+/, "");
      if (comment) {
        const ic = stringifyComment.indentComment(commentString(comment), indent);
        lines.push(ic.trimStart());
      }
    }
    exports.stringifyCollection = stringifyCollection;
  }
});

// ../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/nodes/YAMLMap.js
var require_YAMLMap = __commonJS({
  "../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/nodes/YAMLMap.js"(exports) {
    "use strict";
    var stringifyCollection = require_stringifyCollection();
    var addPairToJSMap = require_addPairToJSMap();
    var Collection = require_Collection();
    var identity = require_identity();
    var Pair = require_Pair();
    var Scalar = require_Scalar();
    function findPair(items, key) {
      const k = identity.isScalar(key) ? key.value : key;
      for (const it of items) {
        if (identity.isPair(it)) {
          if (it.key === key || it.key === k) return it;
          if (identity.isScalar(it.key) && it.key.value === k) return it;
        }
      }
      return void 0;
    }
    var YAMLMap = class extends Collection.Collection {
      static get tagName() {
        return "tag:yaml.org,2002:map";
      }
      constructor(schema) {
        super(identity.MAP, schema);
        this.items = [];
      }
      /**
         * A generic collection parsing method that can be extended
         * to other node classes that inherit from YAMLMap
         */
      static from(schema, obj2, ctx) {
        const { keepUndefined, replacer } = ctx;
        const map = new this(schema);
        const add = (key, value) => {
          if (typeof replacer === "function") value = replacer.call(obj2, key, value);
          else if (Array.isArray(replacer) && !replacer.includes(key)) return;
          if (value !== void 0 || keepUndefined) map.items.push(Pair.createPair(key, value, ctx));
        };
        if (obj2 instanceof Map) {
          for (const [key, value] of obj2) add(key, value);
        } else if (obj2 && typeof obj2 === "object") {
          for (const key of Object.keys(obj2)) add(key, obj2[key]);
        }
        if (typeof schema.sortMapEntries === "function") {
          map.items.sort(schema.sortMapEntries);
        }
        return map;
      }
      /**
         * Adds a value to the collection.
         *
         * @param overwrite - If not set `true`, using a key that is already in the
         *   collection will throw. Otherwise, overwrites the previous value.
         */
      add(pair, overwrite) {
        let _pair;
        if (identity.isPair(pair)) _pair = pair;
        else if (!pair || typeof pair !== "object" || !("key" in pair)) {
          _pair = new Pair.Pair(pair, pair?.value);
        } else _pair = new Pair.Pair(pair.key, pair.value);
        const prev = findPair(this.items, _pair.key);
        const sortEntries = this.schema?.sortMapEntries;
        if (prev) {
          if (!overwrite) throw new Error(`Key ${_pair.key} already set`);
          if (identity.isScalar(prev.value) && Scalar.isScalarValue(_pair.value)) prev.value.value = _pair.value;
          else prev.value = _pair.value;
        } else if (sortEntries) {
          const i2 = this.items.findIndex((item) => sortEntries(_pair, item) < 0);
          if (i2 === -1) this.items.push(_pair);
          else this.items.splice(i2, 0, _pair);
        } else {
          this.items.push(_pair);
        }
      }
      delete(key) {
        const it = findPair(this.items, key);
        if (!it) return false;
        const del = this.items.splice(this.items.indexOf(it), 1);
        return del.length > 0;
      }
      get(key, keepScalar) {
        const it = findPair(this.items, key);
        const node = it?.value;
        return (!keepScalar && identity.isScalar(node) ? node.value : node) ?? void 0;
      }
      has(key) {
        return !!findPair(this.items, key);
      }
      set(key, value) {
        this.add(new Pair.Pair(key, value), true);
      }
      /**
         * @param ctx - Conversion context, originally set in Document#toJS()
         * @param {Class} Type - If set, forces the returned collection type
         * @returns Instance of Type, Map, or Object
         */
      toJSON(_, ctx, Type) {
        const map = Type ? new Type() : ctx?.mapAsMap ? /* @__PURE__ */ new Map() : {};
        if (ctx?.onCreate) ctx.onCreate(map);
        for (const item of this.items) addPairToJSMap.addPairToJSMap(ctx, map, item);
        return map;
      }
      toString(ctx, onComment, onChompKeep) {
        if (!ctx) return JSON.stringify(this);
        for (const item of this.items) {
          if (!identity.isPair(item)) throw new Error(`Map items must all be pairs; found ${JSON.stringify(item)} instead`);
        }
        if (!ctx.allNullValues && this.hasAllNullValues(false)) ctx = Object.assign({}, ctx, {
          allNullValues: true
        });
        return stringifyCollection.stringifyCollection(this, ctx, {
          blockItemPrefix: "",
          flowChars: {
            start: "{",
            end: "}"
          },
          itemIndent: ctx.indent || "",
          onChompKeep,
          onComment
        });
      }
    };
    exports.YAMLMap = YAMLMap;
    exports.findPair = findPair;
  }
});

// ../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/schema/common/map.js
var require_map = __commonJS({
  "../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/schema/common/map.js"(exports) {
    "use strict";
    var identity = require_identity();
    var YAMLMap = require_YAMLMap();
    var map = {
      collection: "map",
      default: true,
      nodeClass: YAMLMap.YAMLMap,
      tag: "tag:yaml.org,2002:map",
      resolve(map2, onError) {
        if (!identity.isMap(map2)) onError("Expected a mapping for this tag");
        return map2;
      },
      createNode: (schema, obj2, ctx) => YAMLMap.YAMLMap.from(schema, obj2, ctx)
    };
    exports.map = map;
  }
});

// ../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/nodes/YAMLSeq.js
var require_YAMLSeq = __commonJS({
  "../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/nodes/YAMLSeq.js"(exports) {
    "use strict";
    var createNode = require_createNode();
    var stringifyCollection = require_stringifyCollection();
    var Collection = require_Collection();
    var identity = require_identity();
    var Scalar = require_Scalar();
    var toJS = require_toJS();
    var YAMLSeq = class extends Collection.Collection {
      static get tagName() {
        return "tag:yaml.org,2002:seq";
      }
      constructor(schema) {
        super(identity.SEQ, schema);
        this.items = [];
      }
      add(value) {
        this.items.push(value);
      }
      /**
         * Removes a value from the collection.
         *
         * `key` must contain a representation of an integer for this to succeed.
         * It may be wrapped in a `Scalar`.
         *
         * @returns `true` if the item was found and removed.
         */
      delete(key) {
        const idx = asItemIndex(key);
        if (typeof idx !== "number") return false;
        const del = this.items.splice(idx, 1);
        return del.length > 0;
      }
      get(key, keepScalar) {
        const idx = asItemIndex(key);
        if (typeof idx !== "number") return void 0;
        const it = this.items[idx];
        return !keepScalar && identity.isScalar(it) ? it.value : it;
      }
      /**
         * Checks if the collection includes a value with the key `key`.
         *
         * `key` must contain a representation of an integer for this to succeed.
         * It may be wrapped in a `Scalar`.
         */
      has(key) {
        const idx = asItemIndex(key);
        return typeof idx === "number" && idx < this.items.length;
      }
      /**
         * Sets a value in this collection. For `!!set`, `value` needs to be a
         * boolean to add/remove the item from the set.
         *
         * If `key` does not contain a representation of an integer, this will throw.
         * It may be wrapped in a `Scalar`.
         */
      set(key, value) {
        const idx = asItemIndex(key);
        if (typeof idx !== "number") throw new Error(`Expected a valid index, not ${key}.`);
        const prev = this.items[idx];
        if (identity.isScalar(prev) && Scalar.isScalarValue(value)) prev.value = value;
        else this.items[idx] = value;
      }
      toJSON(_, ctx) {
        const seq = [];
        if (ctx?.onCreate) ctx.onCreate(seq);
        let i2 = 0;
        for (const item of this.items) seq.push(toJS.toJS(item, String(i2++), ctx));
        return seq;
      }
      toString(ctx, onComment, onChompKeep) {
        if (!ctx) return JSON.stringify(this);
        return stringifyCollection.stringifyCollection(this, ctx, {
          blockItemPrefix: "- ",
          flowChars: {
            start: "[",
            end: "]"
          },
          itemIndent: (ctx.indent || "") + "  ",
          onChompKeep,
          onComment
        });
      }
      static from(schema, obj2, ctx) {
        const { replacer } = ctx;
        const seq = new this(schema);
        if (obj2 && Symbol.iterator in Object(obj2)) {
          let i2 = 0;
          for (let it of obj2) {
            if (typeof replacer === "function") {
              const key = obj2 instanceof Set ? it : String(i2++);
              it = replacer.call(obj2, key, it);
            }
            seq.items.push(createNode.createNode(it, void 0, ctx));
          }
        }
        return seq;
      }
    };
    function asItemIndex(key) {
      let idx = identity.isScalar(key) ? key.value : key;
      if (idx && typeof idx === "string") idx = Number(idx);
      return typeof idx === "number" && Number.isInteger(idx) && idx >= 0 ? idx : null;
    }
    exports.YAMLSeq = YAMLSeq;
  }
});

// ../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/schema/common/seq.js
var require_seq = __commonJS({
  "../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/schema/common/seq.js"(exports) {
    "use strict";
    var identity = require_identity();
    var YAMLSeq = require_YAMLSeq();
    var seq = {
      collection: "seq",
      default: true,
      nodeClass: YAMLSeq.YAMLSeq,
      tag: "tag:yaml.org,2002:seq",
      resolve(seq2, onError) {
        if (!identity.isSeq(seq2)) onError("Expected a sequence for this tag");
        return seq2;
      },
      createNode: (schema, obj2, ctx) => YAMLSeq.YAMLSeq.from(schema, obj2, ctx)
    };
    exports.seq = seq;
  }
});

// ../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/schema/common/string.js
var require_string = __commonJS({
  "../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/schema/common/string.js"(exports) {
    "use strict";
    var stringifyString = require_stringifyString();
    var string = {
      identify: (value) => typeof value === "string",
      default: true,
      tag: "tag:yaml.org,2002:str",
      resolve: (str) => str,
      stringify(item, ctx, onComment, onChompKeep) {
        ctx = Object.assign({
          actualString: true
        }, ctx);
        return stringifyString.stringifyString(item, ctx, onComment, onChompKeep);
      }
    };
    exports.string = string;
  }
});

// ../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/schema/common/null.js
var require_null = __commonJS({
  "../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/schema/common/null.js"(exports) {
    "use strict";
    var Scalar = require_Scalar();
    var nullTag = {
      identify: (value) => value == null,
      createNode: () => new Scalar.Scalar(null),
      default: true,
      tag: "tag:yaml.org,2002:null",
      test: /^(?:~|[Nn]ull|NULL)?$/,
      resolve: () => new Scalar.Scalar(null),
      stringify: ({ source }, ctx) => typeof source === "string" && nullTag.test.test(source) ? source : ctx.options.nullStr
    };
    exports.nullTag = nullTag;
  }
});

// ../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/schema/core/bool.js
var require_bool = __commonJS({
  "../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/schema/core/bool.js"(exports) {
    "use strict";
    var Scalar = require_Scalar();
    var boolTag = {
      identify: (value) => typeof value === "boolean",
      default: true,
      tag: "tag:yaml.org,2002:bool",
      test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,
      resolve: (str) => new Scalar.Scalar(str[0] === "t" || str[0] === "T"),
      stringify({ source, value }, ctx) {
        if (source && boolTag.test.test(source)) {
          const sv = source[0] === "t" || source[0] === "T";
          if (value === sv) return source;
        }
        return value ? ctx.options.trueStr : ctx.options.falseStr;
      }
    };
    exports.boolTag = boolTag;
  }
});

// ../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/stringify/stringifyNumber.js
var require_stringifyNumber = __commonJS({
  "../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/stringify/stringifyNumber.js"(exports) {
    "use strict";
    function stringifyNumber({ format, minFractionDigits, tag, value }) {
      if (typeof value === "bigint") return String(value);
      const num = typeof value === "number" ? value : Number(value);
      if (!isFinite(num)) return isNaN(num) ? ".nan" : num < 0 ? "-.inf" : ".inf";
      let n = JSON.stringify(value);
      if (!format && minFractionDigits && (!tag || tag === "tag:yaml.org,2002:float") && /^\d/.test(n)) {
        let i2 = n.indexOf(".");
        if (i2 < 0) {
          i2 = n.length;
          n += ".";
        }
        let d = minFractionDigits - (n.length - i2 - 1);
        while (d-- > 0) n += "0";
      }
      return n;
    }
    exports.stringifyNumber = stringifyNumber;
  }
});

// ../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/schema/core/float.js
var require_float = __commonJS({
  "../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/schema/core/float.js"(exports) {
    "use strict";
    var Scalar = require_Scalar();
    var stringifyNumber = require_stringifyNumber();
    var floatNaN = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^(?:[-+]?\.(?:inf|Inf|INF)|\.nan|\.NaN|\.NAN)$/,
      resolve: (str) => str.slice(-3).toLowerCase() === "nan" ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
      stringify: stringifyNumber.stringifyNumber
    };
    var floatExp = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      format: "EXP",
      test: /^[-+]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)[eE][-+]?[0-9]+$/,
      resolve: (str) => parseFloat(str),
      stringify(node) {
        const num = Number(node.value);
        return isFinite(num) ? num.toExponential() : stringifyNumber.stringifyNumber(node);
      }
    };
    var float = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^[-+]?(?:\.[0-9]+|[0-9]+\.[0-9]*)$/,
      resolve(str) {
        const node = new Scalar.Scalar(parseFloat(str));
        const dot = str.indexOf(".");
        if (dot !== -1 && str[str.length - 1] === "0") node.minFractionDigits = str.length - dot - 1;
        return node;
      },
      stringify: stringifyNumber.stringifyNumber
    };
    exports.float = float;
    exports.floatExp = floatExp;
    exports.floatNaN = floatNaN;
  }
});

// ../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/schema/core/int.js
var require_int = __commonJS({
  "../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/schema/core/int.js"(exports) {
    "use strict";
    var stringifyNumber = require_stringifyNumber();
    var intIdentify = (value) => typeof value === "bigint" || Number.isInteger(value);
    var intResolve = (str, offset, radix, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str.substring(offset), radix);
    function intStringify(node, radix, prefix) {
      const { value } = node;
      if (intIdentify(value) && value >= 0) return prefix + value.toString(radix);
      return stringifyNumber.stringifyNumber(node);
    }
    var intOct = {
      identify: (value) => intIdentify(value) && value >= 0,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "OCT",
      test: /^0o[0-7]+$/,
      resolve: (str, _onError, opt) => intResolve(str, 2, 8, opt),
      stringify: (node) => intStringify(node, 8, "0o")
    };
    var int = {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      test: /^[-+]?[0-9]+$/,
      resolve: (str, _onError, opt) => intResolve(str, 0, 10, opt),
      stringify: stringifyNumber.stringifyNumber
    };
    var intHex = {
      identify: (value) => intIdentify(value) && value >= 0,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "HEX",
      test: /^0x[0-9a-fA-F]+$/,
      resolve: (str, _onError, opt) => intResolve(str, 2, 16, opt),
      stringify: (node) => intStringify(node, 16, "0x")
    };
    exports.int = int;
    exports.intHex = intHex;
    exports.intOct = intOct;
  }
});

// ../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/schema/core/schema.js
var require_schema = __commonJS({
  "../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/schema/core/schema.js"(exports) {
    "use strict";
    var map = require_map();
    var _null = require_null();
    var seq = require_seq();
    var string = require_string();
    var bool = require_bool();
    var float = require_float();
    var int = require_int();
    var schema = [
      map.map,
      seq.seq,
      string.string,
      _null.nullTag,
      bool.boolTag,
      int.intOct,
      int.int,
      int.intHex,
      float.floatNaN,
      float.floatExp,
      float.float
    ];
    exports.schema = schema;
  }
});

// ../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/schema/json/schema.js
var require_schema2 = __commonJS({
  "../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/schema/json/schema.js"(exports) {
    "use strict";
    var Scalar = require_Scalar();
    var map = require_map();
    var seq = require_seq();
    function intIdentify(value) {
      return typeof value === "bigint" || Number.isInteger(value);
    }
    var stringifyJSON = ({ value }) => JSON.stringify(value);
    var jsonScalars = [
      {
        identify: (value) => typeof value === "string",
        default: true,
        tag: "tag:yaml.org,2002:str",
        resolve: (str) => str,
        stringify: stringifyJSON
      },
      {
        identify: (value) => value == null,
        createNode: () => new Scalar.Scalar(null),
        default: true,
        tag: "tag:yaml.org,2002:null",
        test: /^null$/,
        resolve: () => null,
        stringify: stringifyJSON
      },
      {
        identify: (value) => typeof value === "boolean",
        default: true,
        tag: "tag:yaml.org,2002:bool",
        test: /^true$|^false$/,
        resolve: (str) => str === "true",
        stringify: stringifyJSON
      },
      {
        identify: intIdentify,
        default: true,
        tag: "tag:yaml.org,2002:int",
        test: /^-?(?:0|[1-9][0-9]*)$/,
        resolve: (str, _onError, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str, 10),
        stringify: ({ value }) => intIdentify(value) ? value.toString() : JSON.stringify(value)
      },
      {
        identify: (value) => typeof value === "number",
        default: true,
        tag: "tag:yaml.org,2002:float",
        test: /^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,
        resolve: (str) => parseFloat(str),
        stringify: stringifyJSON
      }
    ];
    var jsonError = {
      default: true,
      tag: "",
      test: /^/,
      resolve(str, onError) {
        onError(`Unresolved plain scalar ${JSON.stringify(str)}`);
        return str;
      }
    };
    var schema = [
      map.map,
      seq.seq
    ].concat(jsonScalars, jsonError);
    exports.schema = schema;
  }
});

// ../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/schema/yaml-1.1/binary.js
var require_binary = __commonJS({
  "../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/schema/yaml-1.1/binary.js"(exports) {
    "use strict";
    var node_buffer = __require("node:buffer");
    var Scalar = require_Scalar();
    var stringifyString = require_stringifyString();
    var binary = {
      identify: (value) => value instanceof Uint8Array,
      default: false,
      tag: "tag:yaml.org,2002:binary",
      /**
         * Returns a Buffer in node and an Uint8Array in browsers
         *
         * To use the resulting buffer as an image, you'll want to do something like:
         *
         *   const blob = new Blob([buffer], { type: 'image/jpeg' })
         *   document.querySelector('#photo').src = URL.createObjectURL(blob)
         */
      resolve(src, onError) {
        if (typeof node_buffer.Buffer === "function") {
          return node_buffer.Buffer.from(src, "base64");
        } else if (typeof atob === "function") {
          const str = atob(src.replace(/[\n\r]/g, ""));
          const buffer = new Uint8Array(str.length);
          for (let i2 = 0; i2 < str.length; ++i2) buffer[i2] = str.charCodeAt(i2);
          return buffer;
        } else {
          onError("This environment does not support reading binary tags; either Buffer or atob is required");
          return src;
        }
      },
      stringify({ comment, type, value }, ctx, onComment, onChompKeep) {
        if (!value) return "";
        const buf = value;
        let str;
        if (typeof node_buffer.Buffer === "function") {
          str = buf instanceof node_buffer.Buffer ? buf.toString("base64") : node_buffer.Buffer.from(buf.buffer).toString("base64");
        } else if (typeof btoa === "function") {
          let s = "";
          for (let i2 = 0; i2 < buf.length; ++i2) s += String.fromCharCode(buf[i2]);
          str = btoa(s);
        } else {
          throw new Error("This environment does not support writing binary tags; either Buffer or btoa is required");
        }
        type ?? (type = Scalar.Scalar.BLOCK_LITERAL);
        if (type !== Scalar.Scalar.QUOTE_DOUBLE) {
          const lineWidth = Math.max(ctx.options.lineWidth - ctx.indent.length, ctx.options.minContentWidth);
          const n = Math.ceil(str.length / lineWidth);
          const lines = new Array(n);
          for (let i2 = 0, o = 0; i2 < n; ++i2, o += lineWidth) {
            lines[i2] = str.substr(o, lineWidth);
          }
          str = lines.join(type === Scalar.Scalar.BLOCK_LITERAL ? "\n" : " ");
        }
        return stringifyString.stringifyString({
          comment,
          type,
          value: str
        }, ctx, onComment, onChompKeep);
      }
    };
    exports.binary = binary;
  }
});

// ../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/schema/yaml-1.1/pairs.js
var require_pairs = __commonJS({
  "../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/schema/yaml-1.1/pairs.js"(exports) {
    "use strict";
    var identity = require_identity();
    var Pair = require_Pair();
    var Scalar = require_Scalar();
    var YAMLSeq = require_YAMLSeq();
    function resolvePairs(seq, onError) {
      if (identity.isSeq(seq)) {
        for (let i2 = 0; i2 < seq.items.length; ++i2) {
          let item = seq.items[i2];
          if (identity.isPair(item)) continue;
          else if (identity.isMap(item)) {
            if (item.items.length > 1) onError("Each pair must have its own sequence indicator");
            const pair = item.items[0] || new Pair.Pair(new Scalar.Scalar(null));
            if (item.commentBefore) pair.key.commentBefore = pair.key.commentBefore ? `${item.commentBefore}
${pair.key.commentBefore}` : item.commentBefore;
            if (item.comment) {
              const cn = pair.value ?? pair.key;
              cn.comment = cn.comment ? `${item.comment}
${cn.comment}` : item.comment;
            }
            item = pair;
          }
          seq.items[i2] = identity.isPair(item) ? item : new Pair.Pair(item);
        }
      } else onError("Expected a sequence for this tag");
      return seq;
    }
    function createPairs(schema, iterable, ctx) {
      const { replacer } = ctx;
      const pairs2 = new YAMLSeq.YAMLSeq(schema);
      pairs2.tag = "tag:yaml.org,2002:pairs";
      let i2 = 0;
      if (iterable && Symbol.iterator in Object(iterable)) for (let it of iterable) {
        if (typeof replacer === "function") it = replacer.call(iterable, String(i2++), it);
        let key, value;
        if (Array.isArray(it)) {
          if (it.length === 2) {
            key = it[0];
            value = it[1];
          } else throw new TypeError(`Expected [key, value] tuple: ${it}`);
        } else if (it && it instanceof Object) {
          const keys = Object.keys(it);
          if (keys.length === 1) {
            key = keys[0];
            value = it[key];
          } else {
            throw new TypeError(`Expected tuple with one key, not ${keys.length} keys`);
          }
        } else {
          key = it;
        }
        pairs2.items.push(Pair.createPair(key, value, ctx));
      }
      return pairs2;
    }
    var pairs = {
      collection: "seq",
      default: false,
      tag: "tag:yaml.org,2002:pairs",
      resolve: resolvePairs,
      createNode: createPairs
    };
    exports.createPairs = createPairs;
    exports.pairs = pairs;
    exports.resolvePairs = resolvePairs;
  }
});

// ../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/schema/yaml-1.1/omap.js
var require_omap = __commonJS({
  "../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/schema/yaml-1.1/omap.js"(exports) {
    "use strict";
    var identity = require_identity();
    var toJS = require_toJS();
    var YAMLMap = require_YAMLMap();
    var YAMLSeq = require_YAMLSeq();
    var pairs = require_pairs();
    var YAMLOMap = class _YAMLOMap extends YAMLSeq.YAMLSeq {
      constructor() {
        super();
        this.add = YAMLMap.YAMLMap.prototype.add.bind(this);
        this.delete = YAMLMap.YAMLMap.prototype.delete.bind(this);
        this.get = YAMLMap.YAMLMap.prototype.get.bind(this);
        this.has = YAMLMap.YAMLMap.prototype.has.bind(this);
        this.set = YAMLMap.YAMLMap.prototype.set.bind(this);
        this.tag = _YAMLOMap.tag;
      }
      /**
         * If `ctx` is given, the return type is actually `Map<unknown, unknown>`,
         * but TypeScript won't allow widening the signature of a child method.
         */
      toJSON(_, ctx) {
        if (!ctx) return super.toJSON(_);
        const map = /* @__PURE__ */ new Map();
        if (ctx?.onCreate) ctx.onCreate(map);
        for (const pair of this.items) {
          let key, value;
          if (identity.isPair(pair)) {
            key = toJS.toJS(pair.key, "", ctx);
            value = toJS.toJS(pair.value, key, ctx);
          } else {
            key = toJS.toJS(pair, "", ctx);
          }
          if (map.has(key)) throw new Error("Ordered maps must not include duplicate keys");
          map.set(key, value);
        }
        return map;
      }
      static from(schema, iterable, ctx) {
        const pairs$1 = pairs.createPairs(schema, iterable, ctx);
        const omap2 = new this();
        omap2.items = pairs$1.items;
        return omap2;
      }
    };
    YAMLOMap.tag = "tag:yaml.org,2002:omap";
    var omap = {
      collection: "seq",
      identify: (value) => value instanceof Map,
      nodeClass: YAMLOMap,
      default: false,
      tag: "tag:yaml.org,2002:omap",
      resolve(seq, onError) {
        const pairs$1 = pairs.resolvePairs(seq, onError);
        const seenKeys = [];
        for (const { key } of pairs$1.items) {
          if (identity.isScalar(key)) {
            if (seenKeys.includes(key.value)) {
              onError(`Ordered maps must not include duplicate keys: ${key.value}`);
            } else {
              seenKeys.push(key.value);
            }
          }
        }
        return Object.assign(new YAMLOMap(), pairs$1);
      },
      createNode: (schema, iterable, ctx) => YAMLOMap.from(schema, iterable, ctx)
    };
    exports.YAMLOMap = YAMLOMap;
    exports.omap = omap;
  }
});

// ../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/schema/yaml-1.1/bool.js
var require_bool2 = __commonJS({
  "../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/schema/yaml-1.1/bool.js"(exports) {
    "use strict";
    var Scalar = require_Scalar();
    function boolStringify({ value, source }, ctx) {
      const boolObj = value ? trueTag : falseTag;
      if (source && boolObj.test.test(source)) return source;
      return value ? ctx.options.trueStr : ctx.options.falseStr;
    }
    var trueTag = {
      identify: (value) => value === true,
      default: true,
      tag: "tag:yaml.org,2002:bool",
      test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,
      resolve: () => new Scalar.Scalar(true),
      stringify: boolStringify
    };
    var falseTag = {
      identify: (value) => value === false,
      default: true,
      tag: "tag:yaml.org,2002:bool",
      test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/,
      resolve: () => new Scalar.Scalar(false),
      stringify: boolStringify
    };
    exports.falseTag = falseTag;
    exports.trueTag = trueTag;
  }
});

// ../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/schema/yaml-1.1/float.js
var require_float2 = __commonJS({
  "../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/schema/yaml-1.1/float.js"(exports) {
    "use strict";
    var Scalar = require_Scalar();
    var stringifyNumber = require_stringifyNumber();
    var floatNaN = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^(?:[-+]?\.(?:inf|Inf|INF)|\.nan|\.NaN|\.NAN)$/,
      resolve: (str) => str.slice(-3).toLowerCase() === "nan" ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
      stringify: stringifyNumber.stringifyNumber
    };
    var floatExp = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      format: "EXP",
      test: /^[-+]?(?:[0-9][0-9_]*)?(?:\.[0-9_]*)?[eE][-+]?[0-9]+$/,
      resolve: (str) => parseFloat(str.replace(/_/g, "")),
      stringify(node) {
        const num = Number(node.value);
        return isFinite(num) ? num.toExponential() : stringifyNumber.stringifyNumber(node);
      }
    };
    var float = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^[-+]?(?:[0-9][0-9_]*)?\.[0-9_]*$/,
      resolve(str) {
        const node = new Scalar.Scalar(parseFloat(str.replace(/_/g, "")));
        const dot = str.indexOf(".");
        if (dot !== -1) {
          const f = str.substring(dot + 1).replace(/_/g, "");
          if (f[f.length - 1] === "0") node.minFractionDigits = f.length;
        }
        return node;
      },
      stringify: stringifyNumber.stringifyNumber
    };
    exports.float = float;
    exports.floatExp = floatExp;
    exports.floatNaN = floatNaN;
  }
});

// ../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/schema/yaml-1.1/int.js
var require_int2 = __commonJS({
  "../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/schema/yaml-1.1/int.js"(exports) {
    "use strict";
    var stringifyNumber = require_stringifyNumber();
    var intIdentify = (value) => typeof value === "bigint" || Number.isInteger(value);
    function intResolve(str, offset, radix, { intAsBigInt }) {
      const sign = str[0];
      if (sign === "-" || sign === "+") offset += 1;
      str = str.substring(offset).replace(/_/g, "");
      if (intAsBigInt) {
        switch (radix) {
          case 2:
            str = `0b${str}`;
            break;
          case 8:
            str = `0o${str}`;
            break;
          case 16:
            str = `0x${str}`;
            break;
        }
        const n2 = BigInt(str);
        return sign === "-" ? BigInt(-1) * n2 : n2;
      }
      const n = parseInt(str, radix);
      return sign === "-" ? -1 * n : n;
    }
    function intStringify(node, radix, prefix) {
      const { value } = node;
      if (intIdentify(value)) {
        const str = value.toString(radix);
        return value < 0 ? "-" + prefix + str.substr(1) : prefix + str;
      }
      return stringifyNumber.stringifyNumber(node);
    }
    var intBin = {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "BIN",
      test: /^[-+]?0b[0-1_]+$/,
      resolve: (str, _onError, opt) => intResolve(str, 2, 2, opt),
      stringify: (node) => intStringify(node, 2, "0b")
    };
    var intOct = {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "OCT",
      test: /^[-+]?0[0-7_]+$/,
      resolve: (str, _onError, opt) => intResolve(str, 1, 8, opt),
      stringify: (node) => intStringify(node, 8, "0")
    };
    var int = {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      test: /^[-+]?[0-9][0-9_]*$/,
      resolve: (str, _onError, opt) => intResolve(str, 0, 10, opt),
      stringify: stringifyNumber.stringifyNumber
    };
    var intHex = {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "HEX",
      test: /^[-+]?0x[0-9a-fA-F_]+$/,
      resolve: (str, _onError, opt) => intResolve(str, 2, 16, opt),
      stringify: (node) => intStringify(node, 16, "0x")
    };
    exports.int = int;
    exports.intBin = intBin;
    exports.intHex = intHex;
    exports.intOct = intOct;
  }
});

// ../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/schema/yaml-1.1/set.js
var require_set = __commonJS({
  "../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/schema/yaml-1.1/set.js"(exports) {
    "use strict";
    var identity = require_identity();
    var Pair = require_Pair();
    var YAMLMap = require_YAMLMap();
    var YAMLSet = class _YAMLSet extends YAMLMap.YAMLMap {
      constructor(schema) {
        super(schema);
        this.tag = _YAMLSet.tag;
      }
      add(key) {
        let pair;
        if (identity.isPair(key)) pair = key;
        else if (key && typeof key === "object" && "key" in key && "value" in key && key.value === null) pair = new Pair.Pair(key.key, null);
        else pair = new Pair.Pair(key, null);
        const prev = YAMLMap.findPair(this.items, pair.key);
        if (!prev) this.items.push(pair);
      }
      /**
         * If `keepPair` is `true`, returns the Pair matching `key`.
         * Otherwise, returns the value of that Pair's key.
         */
      get(key, keepPair) {
        const pair = YAMLMap.findPair(this.items, key);
        return !keepPair && identity.isPair(pair) ? identity.isScalar(pair.key) ? pair.key.value : pair.key : pair;
      }
      set(key, value) {
        if (typeof value !== "boolean") throw new Error(`Expected boolean value for set(key, value) in a YAML set, not ${typeof value}`);
        const prev = YAMLMap.findPair(this.items, key);
        if (prev && !value) {
          this.items.splice(this.items.indexOf(prev), 1);
        } else if (!prev && value) {
          this.items.push(new Pair.Pair(key));
        }
      }
      toJSON(_, ctx) {
        return super.toJSON(_, ctx, Set);
      }
      toString(ctx, onComment, onChompKeep) {
        if (!ctx) return JSON.stringify(this);
        if (this.hasAllNullValues(true)) return super.toString(Object.assign({}, ctx, {
          allNullValues: true
        }), onComment, onChompKeep);
        else throw new Error("Set items must all have null values");
      }
      static from(schema, iterable, ctx) {
        const { replacer } = ctx;
        const set2 = new this(schema);
        if (iterable && Symbol.iterator in Object(iterable)) for (let value of iterable) {
          if (typeof replacer === "function") value = replacer.call(iterable, value, value);
          set2.items.push(Pair.createPair(value, null, ctx));
        }
        return set2;
      }
    };
    YAMLSet.tag = "tag:yaml.org,2002:set";
    var set = {
      collection: "map",
      identify: (value) => value instanceof Set,
      nodeClass: YAMLSet,
      default: false,
      tag: "tag:yaml.org,2002:set",
      createNode: (schema, iterable, ctx) => YAMLSet.from(schema, iterable, ctx),
      resolve(map, onError) {
        if (identity.isMap(map)) {
          if (map.hasAllNullValues(true)) return Object.assign(new YAMLSet(), map);
          else onError("Set items must all have null values");
        } else onError("Expected a mapping for this tag");
        return map;
      }
    };
    exports.YAMLSet = YAMLSet;
    exports.set = set;
  }
});

// ../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/schema/yaml-1.1/timestamp.js
var require_timestamp = __commonJS({
  "../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/schema/yaml-1.1/timestamp.js"(exports) {
    "use strict";
    var stringifyNumber = require_stringifyNumber();
    function parseSexagesimal(str, asBigInt) {
      const sign = str[0];
      const parts = sign === "-" || sign === "+" ? str.substring(1) : str;
      const num = (n) => asBigInt ? BigInt(n) : Number(n);
      const res = parts.replace(/_/g, "").split(":").reduce((res2, p) => res2 * num(60) + num(p), num(0));
      return sign === "-" ? num(-1) * res : res;
    }
    function stringifySexagesimal(node) {
      let { value } = node;
      let num = (n) => n;
      if (typeof value === "bigint") num = (n) => BigInt(n);
      else if (isNaN(value) || !isFinite(value)) return stringifyNumber.stringifyNumber(node);
      let sign = "";
      if (value < 0) {
        sign = "-";
        value *= num(-1);
      }
      const _60 = num(60);
      const parts = [
        value % _60
      ];
      if (value < 60) {
        parts.unshift(0);
      } else {
        value = (value - parts[0]) / _60;
        parts.unshift(value % _60);
        if (value >= 60) {
          value = (value - parts[0]) / _60;
          parts.unshift(value);
        }
      }
      return sign + parts.map((n) => String(n).padStart(2, "0")).join(":").replace(/000000\d*$/, "");
    }
    var intTime = {
      identify: (value) => typeof value === "bigint" || Number.isInteger(value),
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "TIME",
      test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+$/,
      resolve: (str, _onError, { intAsBigInt }) => parseSexagesimal(str, intAsBigInt),
      stringify: stringifySexagesimal
    };
    var floatTime = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      format: "TIME",
      test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*$/,
      resolve: (str) => parseSexagesimal(str, false),
      stringify: stringifySexagesimal
    };
    var timestamp = {
      identify: (value) => value instanceof Date,
      default: true,
      tag: "tag:yaml.org,2002:timestamp",
      // If the time zone is omitted, the timestamp is assumed to be specified in UTC. The time part
      // may be omitted altogether, resulting in a date format. In such a case, the time part is
      // assumed to be 00:00:00Z (start of day, UTC).
      test: RegExp("^([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})(?:(?:t|T|[ \\t]+)([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?)?$"),
      resolve(str) {
        const match2 = str.match(timestamp.test);
        if (!match2) throw new Error("!!timestamp expects a date, starting with yyyy-mm-dd");
        const [, year, month, day, hour, minute, second] = match2.map(Number);
        const millisec = match2[7] ? Number((match2[7] + "00").substr(1, 3)) : 0;
        let date = Date.UTC(year, month - 1, day, hour || 0, minute || 0, second || 0, millisec);
        const tz = match2[8];
        if (tz && tz !== "Z") {
          let d = parseSexagesimal(tz, false);
          if (Math.abs(d) < 30) d *= 60;
          date -= 6e4 * d;
        }
        return new Date(date);
      },
      stringify: ({ value }) => value?.toISOString().replace(/(T00:00:00)?\.000Z$/, "") ?? ""
    };
    exports.floatTime = floatTime;
    exports.intTime = intTime;
    exports.timestamp = timestamp;
  }
});

// ../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/schema/yaml-1.1/schema.js
var require_schema3 = __commonJS({
  "../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/schema/yaml-1.1/schema.js"(exports) {
    "use strict";
    var map = require_map();
    var _null = require_null();
    var seq = require_seq();
    var string = require_string();
    var binary = require_binary();
    var bool = require_bool2();
    var float = require_float2();
    var int = require_int2();
    var merge = require_merge();
    var omap = require_omap();
    var pairs = require_pairs();
    var set = require_set();
    var timestamp = require_timestamp();
    var schema = [
      map.map,
      seq.seq,
      string.string,
      _null.nullTag,
      bool.trueTag,
      bool.falseTag,
      int.intBin,
      int.intOct,
      int.int,
      int.intHex,
      float.floatNaN,
      float.floatExp,
      float.float,
      binary.binary,
      merge.merge,
      omap.omap,
      pairs.pairs,
      set.set,
      timestamp.intTime,
      timestamp.floatTime,
      timestamp.timestamp
    ];
    exports.schema = schema;
  }
});

// ../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/schema/tags.js
var require_tags = __commonJS({
  "../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/schema/tags.js"(exports) {
    "use strict";
    var map = require_map();
    var _null = require_null();
    var seq = require_seq();
    var string = require_string();
    var bool = require_bool();
    var float = require_float();
    var int = require_int();
    var schema = require_schema();
    var schema$1 = require_schema2();
    var binary = require_binary();
    var merge = require_merge();
    var omap = require_omap();
    var pairs = require_pairs();
    var schema$2 = require_schema3();
    var set = require_set();
    var timestamp = require_timestamp();
    var schemas = /* @__PURE__ */ new Map([
      [
        "core",
        schema.schema
      ],
      [
        "failsafe",
        [
          map.map,
          seq.seq,
          string.string
        ]
      ],
      [
        "json",
        schema$1.schema
      ],
      [
        "yaml11",
        schema$2.schema
      ],
      [
        "yaml-1.1",
        schema$2.schema
      ]
    ]);
    var tagsByName = {
      binary: binary.binary,
      bool: bool.boolTag,
      float: float.float,
      floatExp: float.floatExp,
      floatNaN: float.floatNaN,
      floatTime: timestamp.floatTime,
      int: int.int,
      intHex: int.intHex,
      intOct: int.intOct,
      intTime: timestamp.intTime,
      map: map.map,
      merge: merge.merge,
      null: _null.nullTag,
      omap: omap.omap,
      pairs: pairs.pairs,
      seq: seq.seq,
      set: set.set,
      timestamp: timestamp.timestamp
    };
    var coreKnownTags = {
      "tag:yaml.org,2002:binary": binary.binary,
      "tag:yaml.org,2002:merge": merge.merge,
      "tag:yaml.org,2002:omap": omap.omap,
      "tag:yaml.org,2002:pairs": pairs.pairs,
      "tag:yaml.org,2002:set": set.set,
      "tag:yaml.org,2002:timestamp": timestamp.timestamp
    };
    function getTags(customTags, schemaName, addMergeTag) {
      const schemaTags = schemas.get(schemaName);
      if (schemaTags && !customTags) {
        return addMergeTag && !schemaTags.includes(merge.merge) ? schemaTags.concat(merge.merge) : schemaTags.slice();
      }
      let tags = schemaTags;
      if (!tags) {
        if (Array.isArray(customTags)) tags = [];
        else {
          const keys = Array.from(schemas.keys()).filter((key) => key !== "yaml11").map((key) => JSON.stringify(key)).join(", ");
          throw new Error(`Unknown schema "${schemaName}"; use one of ${keys} or define customTags array`);
        }
      }
      if (Array.isArray(customTags)) {
        for (const tag of customTags) tags = tags.concat(tag);
      } else if (typeof customTags === "function") {
        tags = customTags(tags.slice());
      }
      if (addMergeTag) tags = tags.concat(merge.merge);
      return tags.reduce((tags2, tag) => {
        const tagObj = typeof tag === "string" ? tagsByName[tag] : tag;
        if (!tagObj) {
          const tagName = JSON.stringify(tag);
          const keys = Object.keys(tagsByName).map((key) => JSON.stringify(key)).join(", ");
          throw new Error(`Unknown custom tag ${tagName}; use one of ${keys}`);
        }
        if (!tags2.includes(tagObj)) tags2.push(tagObj);
        return tags2;
      }, []);
    }
    exports.coreKnownTags = coreKnownTags;
    exports.getTags = getTags;
  }
});

// ../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/schema/Schema.js
var require_Schema = __commonJS({
  "../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/schema/Schema.js"(exports) {
    "use strict";
    var identity = require_identity();
    var map = require_map();
    var seq = require_seq();
    var string = require_string();
    var tags = require_tags();
    var sortMapEntriesByKey = (a, b) => a.key < b.key ? -1 : a.key > b.key ? 1 : 0;
    var Schema = class _Schema {
      constructor({ compat, customTags, merge, resolveKnownTags, schema, sortMapEntries, toStringDefaults }) {
        this.compat = Array.isArray(compat) ? tags.getTags(compat, "compat") : compat ? tags.getTags(null, compat) : null;
        this.name = typeof schema === "string" && schema || "core";
        this.knownTags = resolveKnownTags ? tags.coreKnownTags : {};
        this.tags = tags.getTags(customTags, this.name, merge);
        this.toStringOptions = toStringDefaults ?? null;
        Object.defineProperty(this, identity.MAP, {
          value: map.map
        });
        Object.defineProperty(this, identity.SCALAR, {
          value: string.string
        });
        Object.defineProperty(this, identity.SEQ, {
          value: seq.seq
        });
        this.sortMapEntries = typeof sortMapEntries === "function" ? sortMapEntries : sortMapEntries === true ? sortMapEntriesByKey : null;
      }
      clone() {
        const copy = Object.create(_Schema.prototype, Object.getOwnPropertyDescriptors(this));
        copy.tags = this.tags.slice();
        return copy;
      }
    };
    exports.Schema = Schema;
  }
});

// ../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/stringify/stringifyDocument.js
var require_stringifyDocument = __commonJS({
  "../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/stringify/stringifyDocument.js"(exports) {
    "use strict";
    var identity = require_identity();
    var stringify = require_stringify();
    var stringifyComment = require_stringifyComment();
    function stringifyDocument(doc, options) {
      const lines = [];
      let hasDirectives = options.directives === true;
      if (options.directives !== false && doc.directives) {
        const dir = doc.directives.toString(doc);
        if (dir) {
          lines.push(dir);
          hasDirectives = true;
        } else if (doc.directives.docStart) hasDirectives = true;
      }
      if (hasDirectives) lines.push("---");
      const ctx = stringify.createStringifyContext(doc, options);
      const { commentString } = ctx.options;
      if (doc.commentBefore) {
        if (lines.length !== 1) lines.unshift("");
        const cs = commentString(doc.commentBefore);
        lines.unshift(stringifyComment.indentComment(cs, ""));
      }
      let chompKeep = false;
      let contentComment = null;
      if (doc.contents) {
        if (identity.isNode(doc.contents)) {
          if (doc.contents.spaceBefore && hasDirectives) lines.push("");
          if (doc.contents.commentBefore) {
            const cs = commentString(doc.contents.commentBefore);
            lines.push(stringifyComment.indentComment(cs, ""));
          }
          ctx.forceBlockIndent = !!doc.comment;
          contentComment = doc.contents.comment;
        }
        const onChompKeep = contentComment ? void 0 : () => chompKeep = true;
        let body = stringify.stringify(doc.contents, ctx, () => contentComment = null, onChompKeep);
        if (contentComment) body += stringifyComment.lineComment(body, "", commentString(contentComment));
        if ((body[0] === "|" || body[0] === ">") && lines[lines.length - 1] === "---") {
          lines[lines.length - 1] = `--- ${body}`;
        } else lines.push(body);
      } else {
        lines.push(stringify.stringify(doc.contents, ctx));
      }
      if (doc.directives?.docEnd) {
        if (doc.comment) {
          const cs = commentString(doc.comment);
          if (cs.includes("\n")) {
            lines.push("...");
            lines.push(stringifyComment.indentComment(cs, ""));
          } else {
            lines.push(`... ${cs}`);
          }
        } else {
          lines.push("...");
        }
      } else {
        let dc = doc.comment;
        if (dc && chompKeep) dc = dc.replace(/^\n+/, "");
        if (dc) {
          if ((!chompKeep || contentComment) && lines[lines.length - 1] !== "") lines.push("");
          lines.push(stringifyComment.indentComment(commentString(dc), ""));
        }
      }
      return lines.join("\n") + "\n";
    }
    exports.stringifyDocument = stringifyDocument;
  }
});

// ../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/doc/Document.js
var require_Document = __commonJS({
  "../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/doc/Document.js"(exports) {
    "use strict";
    var Alias = require_Alias();
    var Collection = require_Collection();
    var identity = require_identity();
    var Pair = require_Pair();
    var toJS = require_toJS();
    var Schema = require_Schema();
    var stringifyDocument = require_stringifyDocument();
    var anchors = require_anchors();
    var applyReviver = require_applyReviver();
    var createNode = require_createNode();
    var directives = require_directives();
    var Document = class _Document {
      constructor(value, replacer, options) {
        this.commentBefore = null;
        this.comment = null;
        this.errors = [];
        this.warnings = [];
        Object.defineProperty(this, identity.NODE_TYPE, {
          value: identity.DOC
        });
        let _replacer = null;
        if (typeof replacer === "function" || Array.isArray(replacer)) {
          _replacer = replacer;
        } else if (options === void 0 && replacer) {
          options = replacer;
          replacer = void 0;
        }
        const opt = Object.assign({
          intAsBigInt: false,
          keepSourceTokens: false,
          logLevel: "warn",
          prettyErrors: true,
          strict: true,
          stringKeys: false,
          uniqueKeys: true,
          version: "1.2"
        }, options);
        this.options = opt;
        let { version } = opt;
        if (options?._directives) {
          this.directives = options._directives.atDocument();
          if (this.directives.yaml.explicit) version = this.directives.yaml.version;
        } else this.directives = new directives.Directives({
          version
        });
        this.setSchema(version, options);
        this.contents = value === void 0 ? null : this.createNode(value, _replacer, options);
      }
      /**
         * Create a deep copy of this Document and its contents.
         *
         * Custom Node values that inherit from `Object` still refer to their original instances.
         */
      clone() {
        const copy = Object.create(_Document.prototype, {
          [identity.NODE_TYPE]: {
            value: identity.DOC
          }
        });
        copy.commentBefore = this.commentBefore;
        copy.comment = this.comment;
        copy.errors = this.errors.slice();
        copy.warnings = this.warnings.slice();
        copy.options = Object.assign({}, this.options);
        if (this.directives) copy.directives = this.directives.clone();
        copy.schema = this.schema.clone();
        copy.contents = identity.isNode(this.contents) ? this.contents.clone(copy.schema) : this.contents;
        if (this.range) copy.range = this.range.slice();
        return copy;
      }
      /** Adds a value to the document. */
      add(value) {
        if (assertCollection(this.contents)) this.contents.add(value);
      }
      /** Adds a value to the document. */
      addIn(path2, value) {
        if (assertCollection(this.contents)) this.contents.addIn(path2, value);
      }
      /**
         * Create a new `Alias` node, ensuring that the target `node` has the required anchor.
         *
         * If `node` already has an anchor, `name` is ignored.
         * Otherwise, the `node.anchor` value will be set to `name`,
         * or if an anchor with that name is already present in the document,
         * `name` will be used as a prefix for a new unique anchor.
         * If `name` is undefined, the generated anchor will use 'a' as a prefix.
         */
      createAlias(node, name) {
        if (!node.anchor) {
          const prev = anchors.anchorNames(this);
          node.anchor = // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
          !name || prev.has(name) ? anchors.findNewAnchor(name || "a", prev) : name;
        }
        return new Alias.Alias(node.anchor);
      }
      createNode(value, replacer, options) {
        let _replacer = void 0;
        if (typeof replacer === "function") {
          value = replacer.call({
            "": value
          }, "", value);
          _replacer = replacer;
        } else if (Array.isArray(replacer)) {
          const keyToStr = (v) => typeof v === "number" || v instanceof String || v instanceof Number;
          const asStr = replacer.filter(keyToStr).map(String);
          if (asStr.length > 0) replacer = replacer.concat(asStr);
          _replacer = replacer;
        } else if (options === void 0 && replacer) {
          options = replacer;
          replacer = void 0;
        }
        const { aliasDuplicateObjects, anchorPrefix, flow, keepUndefined, onTagObj, tag } = options ?? {};
        const { onAnchor, setAnchors, sourceObjects } = anchors.createNodeAnchors(
          this,
          // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
          anchorPrefix || "a"
        );
        const ctx = {
          aliasDuplicateObjects: aliasDuplicateObjects ?? true,
          keepUndefined: keepUndefined ?? false,
          onAnchor,
          onTagObj,
          replacer: _replacer,
          schema: this.schema,
          sourceObjects
        };
        const node = createNode.createNode(value, tag, ctx);
        if (flow && identity.isCollection(node)) node.flow = true;
        setAnchors();
        return node;
      }
      /**
         * Convert a key and a value into a `Pair` using the current schema,
         * recursively wrapping all values as `Scalar` or `Collection` nodes.
         */
      createPair(key, value, options = {}) {
        const k = this.createNode(key, null, options);
        const v = this.createNode(value, null, options);
        return new Pair.Pair(k, v);
      }
      /**
         * Removes a value from the document.
         * @returns `true` if the item was found and removed.
         */
      delete(key) {
        return assertCollection(this.contents) ? this.contents.delete(key) : false;
      }
      /**
         * Removes a value from the document.
         * @returns `true` if the item was found and removed.
         */
      deleteIn(path2) {
        if (Collection.isEmptyPath(path2)) {
          if (this.contents == null) return false;
          this.contents = null;
          return true;
        }
        return assertCollection(this.contents) ? this.contents.deleteIn(path2) : false;
      }
      /**
         * Returns item at `key`, or `undefined` if not found. By default unwraps
         * scalar values from their surrounding node; to disable set `keepScalar` to
         * `true` (collections are always returned intact).
         */
      get(key, keepScalar) {
        return identity.isCollection(this.contents) ? this.contents.get(key, keepScalar) : void 0;
      }
      /**
         * Returns item at `path`, or `undefined` if not found. By default unwraps
         * scalar values from their surrounding node; to disable set `keepScalar` to
         * `true` (collections are always returned intact).
         */
      getIn(path2, keepScalar) {
        if (Collection.isEmptyPath(path2)) return !keepScalar && identity.isScalar(this.contents) ? this.contents.value : this.contents;
        return identity.isCollection(this.contents) ? this.contents.getIn(path2, keepScalar) : void 0;
      }
      /**
         * Checks if the document includes a value with the key `key`.
         */
      has(key) {
        return identity.isCollection(this.contents) ? this.contents.has(key) : false;
      }
      /**
         * Checks if the document includes a value at `path`.
         */
      hasIn(path2) {
        if (Collection.isEmptyPath(path2)) return this.contents !== void 0;
        return identity.isCollection(this.contents) ? this.contents.hasIn(path2) : false;
      }
      /**
         * Sets a value in this document. For `!!set`, `value` needs to be a
         * boolean to add/remove the item from the set.
         */
      set(key, value) {
        if (this.contents == null) {
          this.contents = Collection.collectionFromPath(this.schema, [
            key
          ], value);
        } else if (assertCollection(this.contents)) {
          this.contents.set(key, value);
        }
      }
      /**
         * Sets a value in this document. For `!!set`, `value` needs to be a
         * boolean to add/remove the item from the set.
         */
      setIn(path2, value) {
        if (Collection.isEmptyPath(path2)) {
          this.contents = value;
        } else if (this.contents == null) {
          this.contents = Collection.collectionFromPath(this.schema, Array.from(path2), value);
        } else if (assertCollection(this.contents)) {
          this.contents.setIn(path2, value);
        }
      }
      /**
         * Change the YAML version and schema used by the document.
         * A `null` version disables support for directives, explicit tags, anchors, and aliases.
         * It also requires the `schema` option to be given as a `Schema` instance value.
         *
         * Overrides all previously set schema options.
         */
      setSchema(version, options = {}) {
        if (typeof version === "number") version = String(version);
        let opt;
        switch (version) {
          case "1.1":
            if (this.directives) this.directives.yaml.version = "1.1";
            else this.directives = new directives.Directives({
              version: "1.1"
            });
            opt = {
              resolveKnownTags: false,
              schema: "yaml-1.1"
            };
            break;
          case "1.2":
          case "next":
            if (this.directives) this.directives.yaml.version = version;
            else this.directives = new directives.Directives({
              version
            });
            opt = {
              resolveKnownTags: true,
              schema: "core"
            };
            break;
          case null:
            if (this.directives) delete this.directives;
            opt = null;
            break;
          default: {
            const sv = JSON.stringify(version);
            throw new Error(`Expected '1.1', '1.2' or null as first argument, but found: ${sv}`);
          }
        }
        if (options.schema instanceof Object) this.schema = options.schema;
        else if (opt) this.schema = new Schema.Schema(Object.assign(opt, options));
        else throw new Error(`With a null YAML version, the { schema: Schema } option is required`);
      }
      // json & jsonArg are only used from toJSON()
      toJS({ json, jsonArg, mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
        const ctx = {
          anchors: /* @__PURE__ */ new Map(),
          doc: this,
          keep: !json,
          mapAsMap: mapAsMap === true,
          mapKeyWarned: false,
          maxAliasCount: typeof maxAliasCount === "number" ? maxAliasCount : 100
        };
        const res = toJS.toJS(this.contents, jsonArg ?? "", ctx);
        if (typeof onAnchor === "function") for (const { count, res: res2 } of ctx.anchors.values()) onAnchor(res2, count);
        return typeof reviver === "function" ? applyReviver.applyReviver(reviver, {
          "": res
        }, "", res) : res;
      }
      /**
         * A JSON representation of the document `contents`.
         *
         * @param jsonArg Used by `JSON.stringify` to indicate the array index or
         *   property name.
         */
      toJSON(jsonArg, onAnchor) {
        return this.toJS({
          json: true,
          jsonArg,
          mapAsMap: false,
          onAnchor
        });
      }
      /** A YAML representation of the document. */
      toString(options = {}) {
        if (this.errors.length > 0) throw new Error("Document with errors cannot be stringified");
        if ("indent" in options && (!Number.isInteger(options.indent) || Number(options.indent) <= 0)) {
          const s = JSON.stringify(options.indent);
          throw new Error(`"indent" option must be a positive integer, not ${s}`);
        }
        return stringifyDocument.stringifyDocument(this, options);
      }
    };
    function assertCollection(contents) {
      if (identity.isCollection(contents)) return true;
      throw new Error("Expected a YAML collection as document contents");
    }
    exports.Document = Document;
  }
});

// ../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/errors.js
var require_errors = __commonJS({
  "../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/errors.js"(exports) {
    "use strict";
    var YAMLError = class extends Error {
      constructor(name, pos, code, message) {
        super();
        this.name = name;
        this.code = code;
        this.message = message;
        this.pos = pos;
      }
    };
    var YAMLParseError = class extends YAMLError {
      constructor(pos, code, message) {
        super("YAMLParseError", pos, code, message);
      }
    };
    var YAMLWarning = class extends YAMLError {
      constructor(pos, code, message) {
        super("YAMLWarning", pos, code, message);
      }
    };
    var prettifyError = (src, lc) => (error) => {
      if (error.pos[0] === -1) return;
      error.linePos = error.pos.map((pos) => lc.linePos(pos));
      const { line, col } = error.linePos[0];
      error.message += ` at line ${line}, column ${col}`;
      let ci = col - 1;
      let lineStr = src.substring(lc.lineStarts[line - 1], lc.lineStarts[line]).replace(/[\n\r]+$/, "");
      if (ci >= 60 && lineStr.length > 80) {
        const trimStart = Math.min(ci - 39, lineStr.length - 79);
        lineStr = "\u2026" + lineStr.substring(trimStart);
        ci -= trimStart - 1;
      }
      if (lineStr.length > 80) lineStr = lineStr.substring(0, 79) + "\u2026";
      if (line > 1 && /^ *$/.test(lineStr.substring(0, ci))) {
        let prev = src.substring(lc.lineStarts[line - 2], lc.lineStarts[line - 1]);
        if (prev.length > 80) prev = prev.substring(0, 79) + "\u2026\n";
        lineStr = prev + lineStr;
      }
      if (/[^ ]/.test(lineStr)) {
        let count = 1;
        const end = error.linePos[1];
        if (end && end.line === line && end.col > col) {
          count = Math.max(1, Math.min(end.col - col, 80 - ci));
        }
        const pointer = " ".repeat(ci) + "^".repeat(count);
        error.message += `:

${lineStr}
${pointer}
`;
      }
    };
    exports.YAMLError = YAMLError;
    exports.YAMLParseError = YAMLParseError;
    exports.YAMLWarning = YAMLWarning;
    exports.prettifyError = prettifyError;
  }
});

// ../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/compose/resolve-props.js
var require_resolve_props = __commonJS({
  "../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/compose/resolve-props.js"(exports) {
    "use strict";
    function resolveProps(tokens, { flow, indicator, next, offset, onError, parentIndent, startOnNewline }) {
      let spaceBefore = false;
      let atNewline = startOnNewline;
      let hasSpace = startOnNewline;
      let comment = "";
      let commentSep = "";
      let hasNewline = false;
      let reqSpace = false;
      let tab = null;
      let anchor = null;
      let tag = null;
      let newlineAfterProp = null;
      let comma = null;
      let found = null;
      let start = null;
      for (const token of tokens) {
        if (reqSpace) {
          if (token.type !== "space" && token.type !== "newline" && token.type !== "comma") onError(token.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space");
          reqSpace = false;
        }
        if (tab) {
          if (atNewline && token.type !== "comment" && token.type !== "newline") {
            onError(tab, "TAB_AS_INDENT", "Tabs are not allowed as indentation");
          }
          tab = null;
        }
        switch (token.type) {
          case "space":
            if (!flow && (indicator !== "doc-start" || next?.type !== "flow-collection") && token.source.includes("	")) {
              tab = token;
            }
            hasSpace = true;
            break;
          case "comment": {
            if (!hasSpace) onError(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
            const cb = token.source.substring(1) || " ";
            if (!comment) comment = cb;
            else comment += commentSep + cb;
            commentSep = "";
            atNewline = false;
            break;
          }
          case "newline":
            if (atNewline) {
              if (comment) comment += token.source;
              else if (!found || indicator !== "seq-item-ind") spaceBefore = true;
            } else commentSep += token.source;
            atNewline = true;
            hasNewline = true;
            if (anchor || tag) newlineAfterProp = token;
            hasSpace = true;
            break;
          case "anchor":
            if (anchor) onError(token, "MULTIPLE_ANCHORS", "A node can have at most one anchor");
            if (token.source.endsWith(":")) onError(token.offset + token.source.length - 1, "BAD_ALIAS", "Anchor ending in : is ambiguous", true);
            anchor = token;
            start ?? (start = token.offset);
            atNewline = false;
            hasSpace = false;
            reqSpace = true;
            break;
          case "tag": {
            if (tag) onError(token, "MULTIPLE_TAGS", "A node can have at most one tag");
            tag = token;
            start ?? (start = token.offset);
            atNewline = false;
            hasSpace = false;
            reqSpace = true;
            break;
          }
          case indicator:
            if (anchor || tag) onError(token, "BAD_PROP_ORDER", `Anchors and tags must be after the ${token.source} indicator`);
            if (found) onError(token, "UNEXPECTED_TOKEN", `Unexpected ${token.source} in ${flow ?? "collection"}`);
            found = token;
            atNewline = indicator === "seq-item-ind" || indicator === "explicit-key-ind";
            hasSpace = false;
            break;
          case "comma":
            if (flow) {
              if (comma) onError(token, "UNEXPECTED_TOKEN", `Unexpected , in ${flow}`);
              comma = token;
              atNewline = false;
              hasSpace = false;
              break;
            }
          // else fallthrough
          default:
            onError(token, "UNEXPECTED_TOKEN", `Unexpected ${token.type} token`);
            atNewline = false;
            hasSpace = false;
        }
      }
      const last = tokens[tokens.length - 1];
      const end = last ? last.offset + last.source.length : offset;
      if (reqSpace && next && next.type !== "space" && next.type !== "newline" && next.type !== "comma" && (next.type !== "scalar" || next.source !== "")) {
        onError(next.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space");
      }
      if (tab && (atNewline && tab.indent <= parentIndent || next?.type === "block-map" || next?.type === "block-seq")) onError(tab, "TAB_AS_INDENT", "Tabs are not allowed as indentation");
      return {
        comma,
        found,
        spaceBefore,
        comment,
        hasNewline,
        anchor,
        tag,
        newlineAfterProp,
        end,
        start: start ?? end
      };
    }
    exports.resolveProps = resolveProps;
  }
});

// ../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/compose/util-contains-newline.js
var require_util_contains_newline = __commonJS({
  "../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/compose/util-contains-newline.js"(exports) {
    "use strict";
    function containsNewline(key) {
      if (!key) return null;
      switch (key.type) {
        case "alias":
        case "scalar":
        case "double-quoted-scalar":
        case "single-quoted-scalar":
          if (key.source.includes("\n")) return true;
          if (key.end) {
            for (const st of key.end) if (st.type === "newline") return true;
          }
          return false;
        case "flow-collection":
          for (const it of key.items) {
            for (const st of it.start) if (st.type === "newline") return true;
            if (it.sep) {
              for (const st of it.sep) if (st.type === "newline") return true;
            }
            if (containsNewline(it.key) || containsNewline(it.value)) return true;
          }
          return false;
        default:
          return true;
      }
    }
    exports.containsNewline = containsNewline;
  }
});

// ../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/compose/util-flow-indent-check.js
var require_util_flow_indent_check = __commonJS({
  "../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/compose/util-flow-indent-check.js"(exports) {
    "use strict";
    var utilContainsNewline = require_util_contains_newline();
    function flowIndentCheck(indent, fc, onError) {
      if (fc?.type === "flow-collection") {
        const end = fc.end[0];
        if (end.indent === indent && (end.source === "]" || end.source === "}") && utilContainsNewline.containsNewline(fc)) {
          const msg = "Flow end indicator should be more indented than parent";
          onError(end, "BAD_INDENT", msg, true);
        }
      }
    }
    exports.flowIndentCheck = flowIndentCheck;
  }
});

// ../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/compose/util-map-includes.js
var require_util_map_includes = __commonJS({
  "../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/compose/util-map-includes.js"(exports) {
    "use strict";
    var identity = require_identity();
    function mapIncludes(ctx, items, search) {
      const { uniqueKeys } = ctx.options;
      if (uniqueKeys === false) return false;
      const isEqual = typeof uniqueKeys === "function" ? uniqueKeys : (a, b) => a === b || identity.isScalar(a) && identity.isScalar(b) && a.value === b.value;
      return items.some((pair) => isEqual(pair.key, search));
    }
    exports.mapIncludes = mapIncludes;
  }
});

// ../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/compose/resolve-block-map.js
var require_resolve_block_map = __commonJS({
  "../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/compose/resolve-block-map.js"(exports) {
    "use strict";
    var Pair = require_Pair();
    var YAMLMap = require_YAMLMap();
    var resolveProps = require_resolve_props();
    var utilContainsNewline = require_util_contains_newline();
    var utilFlowIndentCheck = require_util_flow_indent_check();
    var utilMapIncludes = require_util_map_includes();
    var startColMsg = "All mapping items must start at the same column";
    function resolveBlockMap({ composeNode, composeEmptyNode }, ctx, bm, onError, tag) {
      const NodeClass = tag?.nodeClass ?? YAMLMap.YAMLMap;
      const map = new NodeClass(ctx.schema);
      if (ctx.atRoot) ctx.atRoot = false;
      let offset = bm.offset;
      let commentEnd = null;
      for (const collItem of bm.items) {
        const { start, key, sep, value } = collItem;
        const keyProps = resolveProps.resolveProps(start, {
          indicator: "explicit-key-ind",
          next: key ?? sep?.[0],
          offset,
          onError,
          parentIndent: bm.indent,
          startOnNewline: true
        });
        const implicitKey = !keyProps.found;
        if (implicitKey) {
          if (key) {
            if (key.type === "block-seq") onError(offset, "BLOCK_AS_IMPLICIT_KEY", "A block sequence may not be used as an implicit map key");
            else if ("indent" in key && key.indent !== bm.indent) onError(offset, "BAD_INDENT", startColMsg);
          }
          if (!keyProps.anchor && !keyProps.tag && !sep) {
            commentEnd = keyProps.end;
            if (keyProps.comment) {
              if (map.comment) map.comment += "\n" + keyProps.comment;
              else map.comment = keyProps.comment;
            }
            continue;
          }
          if (keyProps.newlineAfterProp || utilContainsNewline.containsNewline(key)) {
            onError(key ?? start[start.length - 1], "MULTILINE_IMPLICIT_KEY", "Implicit keys need to be on a single line");
          }
        } else if (keyProps.found?.indent !== bm.indent) {
          onError(offset, "BAD_INDENT", startColMsg);
        }
        ctx.atKey = true;
        const keyStart = keyProps.end;
        const keyNode = key ? composeNode(ctx, key, keyProps, onError) : composeEmptyNode(ctx, keyStart, start, null, keyProps, onError);
        if (ctx.schema.compat) utilFlowIndentCheck.flowIndentCheck(bm.indent, key, onError);
        ctx.atKey = false;
        if (utilMapIncludes.mapIncludes(ctx, map.items, keyNode)) onError(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
        const valueProps = resolveProps.resolveProps(sep ?? [], {
          indicator: "map-value-ind",
          next: value,
          offset: keyNode.range[2],
          onError,
          parentIndent: bm.indent,
          startOnNewline: !key || key.type === "block-scalar"
        });
        offset = valueProps.end;
        if (valueProps.found) {
          if (implicitKey) {
            if (value?.type === "block-map" && !valueProps.hasNewline) onError(offset, "BLOCK_AS_IMPLICIT_KEY", "Nested mappings are not allowed in compact mappings");
            if (ctx.options.strict && keyProps.start < valueProps.found.offset - 1024) onError(keyNode.range, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit block mapping key");
          }
          const valueNode = value ? composeNode(ctx, value, valueProps, onError) : composeEmptyNode(ctx, offset, sep, null, valueProps, onError);
          if (ctx.schema.compat) utilFlowIndentCheck.flowIndentCheck(bm.indent, value, onError);
          offset = valueNode.range[2];
          const pair = new Pair.Pair(keyNode, valueNode);
          if (ctx.options.keepSourceTokens) pair.srcToken = collItem;
          map.items.push(pair);
        } else {
          if (implicitKey) onError(keyNode.range, "MISSING_CHAR", "Implicit map keys need to be followed by map values");
          if (valueProps.comment) {
            if (keyNode.comment) keyNode.comment += "\n" + valueProps.comment;
            else keyNode.comment = valueProps.comment;
          }
          const pair = new Pair.Pair(keyNode);
          if (ctx.options.keepSourceTokens) pair.srcToken = collItem;
          map.items.push(pair);
        }
      }
      if (commentEnd && commentEnd < offset) onError(commentEnd, "IMPOSSIBLE", "Map comment with trailing content");
      map.range = [
        bm.offset,
        offset,
        commentEnd ?? offset
      ];
      return map;
    }
    exports.resolveBlockMap = resolveBlockMap;
  }
});

// ../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/compose/resolve-block-seq.js
var require_resolve_block_seq = __commonJS({
  "../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/compose/resolve-block-seq.js"(exports) {
    "use strict";
    var YAMLSeq = require_YAMLSeq();
    var resolveProps = require_resolve_props();
    var utilFlowIndentCheck = require_util_flow_indent_check();
    function resolveBlockSeq({ composeNode, composeEmptyNode }, ctx, bs, onError, tag) {
      const NodeClass = tag?.nodeClass ?? YAMLSeq.YAMLSeq;
      const seq = new NodeClass(ctx.schema);
      if (ctx.atRoot) ctx.atRoot = false;
      if (ctx.atKey) ctx.atKey = false;
      let offset = bs.offset;
      let commentEnd = null;
      for (const { start, value } of bs.items) {
        const props = resolveProps.resolveProps(start, {
          indicator: "seq-item-ind",
          next: value,
          offset,
          onError,
          parentIndent: bs.indent,
          startOnNewline: true
        });
        if (!props.found) {
          if (props.anchor || props.tag || value) {
            if (value && value.type === "block-seq") onError(props.end, "BAD_INDENT", "All sequence items must start at the same column");
            else onError(offset, "MISSING_CHAR", "Sequence item without - indicator");
          } else {
            commentEnd = props.end;
            if (props.comment) seq.comment = props.comment;
            continue;
          }
        }
        const node = value ? composeNode(ctx, value, props, onError) : composeEmptyNode(ctx, props.end, start, null, props, onError);
        if (ctx.schema.compat) utilFlowIndentCheck.flowIndentCheck(bs.indent, value, onError);
        offset = node.range[2];
        seq.items.push(node);
      }
      seq.range = [
        bs.offset,
        offset,
        commentEnd ?? offset
      ];
      return seq;
    }
    exports.resolveBlockSeq = resolveBlockSeq;
  }
});

// ../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/compose/resolve-end.js
var require_resolve_end = __commonJS({
  "../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/compose/resolve-end.js"(exports) {
    "use strict";
    function resolveEnd(end, offset, reqSpace, onError) {
      let comment = "";
      if (end) {
        let hasSpace = false;
        let sep = "";
        for (const token of end) {
          const { source, type } = token;
          switch (type) {
            case "space":
              hasSpace = true;
              break;
            case "comment": {
              if (reqSpace && !hasSpace) onError(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
              const cb = source.substring(1) || " ";
              if (!comment) comment = cb;
              else comment += sep + cb;
              sep = "";
              break;
            }
            case "newline":
              if (comment) sep += source;
              hasSpace = true;
              break;
            default:
              onError(token, "UNEXPECTED_TOKEN", `Unexpected ${type} at node end`);
          }
          offset += source.length;
        }
      }
      return {
        comment,
        offset
      };
    }
    exports.resolveEnd = resolveEnd;
  }
});

// ../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/compose/resolve-flow-collection.js
var require_resolve_flow_collection = __commonJS({
  "../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/compose/resolve-flow-collection.js"(exports) {
    "use strict";
    var identity = require_identity();
    var Pair = require_Pair();
    var YAMLMap = require_YAMLMap();
    var YAMLSeq = require_YAMLSeq();
    var resolveEnd = require_resolve_end();
    var resolveProps = require_resolve_props();
    var utilContainsNewline = require_util_contains_newline();
    var utilMapIncludes = require_util_map_includes();
    var blockMsg = "Block collections are not allowed within flow collections";
    var isBlock = (token) => token && (token.type === "block-map" || token.type === "block-seq");
    function resolveFlowCollection({ composeNode, composeEmptyNode }, ctx, fc, onError, tag) {
      const isMap = fc.start.source === "{";
      const fcName = isMap ? "flow map" : "flow sequence";
      const NodeClass = tag?.nodeClass ?? (isMap ? YAMLMap.YAMLMap : YAMLSeq.YAMLSeq);
      const coll = new NodeClass(ctx.schema);
      coll.flow = true;
      const atRoot = ctx.atRoot;
      if (atRoot) ctx.atRoot = false;
      if (ctx.atKey) ctx.atKey = false;
      let offset = fc.offset + fc.start.source.length;
      for (let i2 = 0; i2 < fc.items.length; ++i2) {
        const collItem = fc.items[i2];
        const { start, key, sep, value } = collItem;
        const props = resolveProps.resolveProps(start, {
          flow: fcName,
          indicator: "explicit-key-ind",
          next: key ?? sep?.[0],
          offset,
          onError,
          parentIndent: fc.indent,
          startOnNewline: false
        });
        if (!props.found) {
          if (!props.anchor && !props.tag && !sep && !value) {
            if (i2 === 0 && props.comma) onError(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`);
            else if (i2 < fc.items.length - 1) onError(props.start, "UNEXPECTED_TOKEN", `Unexpected empty item in ${fcName}`);
            if (props.comment) {
              if (coll.comment) coll.comment += "\n" + props.comment;
              else coll.comment = props.comment;
            }
            offset = props.end;
            continue;
          }
          if (!isMap && ctx.options.strict && utilContainsNewline.containsNewline(key)) onError(key, "MULTILINE_IMPLICIT_KEY", "Implicit keys of flow sequence pairs need to be on a single line");
        }
        if (i2 === 0) {
          if (props.comma) onError(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`);
        } else {
          if (!props.comma) onError(props.start, "MISSING_CHAR", `Missing , between ${fcName} items`);
          if (props.comment) {
            let prevItemComment = "";
            loop: for (const st of start) {
              switch (st.type) {
                case "comma":
                case "space":
                  break;
                case "comment":
                  prevItemComment = st.source.substring(1);
                  break loop;
                default:
                  break loop;
              }
            }
            if (prevItemComment) {
              let prev = coll.items[coll.items.length - 1];
              if (identity.isPair(prev)) prev = prev.value ?? prev.key;
              if (prev.comment) prev.comment += "\n" + prevItemComment;
              else prev.comment = prevItemComment;
              props.comment = props.comment.substring(prevItemComment.length + 1);
            }
          }
        }
        if (!isMap && !sep && !props.found) {
          const valueNode = value ? composeNode(ctx, value, props, onError) : composeEmptyNode(ctx, props.end, sep, null, props, onError);
          coll.items.push(valueNode);
          offset = valueNode.range[2];
          if (isBlock(value)) onError(valueNode.range, "BLOCK_IN_FLOW", blockMsg);
        } else {
          ctx.atKey = true;
          const keyStart = props.end;
          const keyNode = key ? composeNode(ctx, key, props, onError) : composeEmptyNode(ctx, keyStart, start, null, props, onError);
          if (isBlock(key)) onError(keyNode.range, "BLOCK_IN_FLOW", blockMsg);
          ctx.atKey = false;
          const valueProps = resolveProps.resolveProps(sep ?? [], {
            flow: fcName,
            indicator: "map-value-ind",
            next: value,
            offset: keyNode.range[2],
            onError,
            parentIndent: fc.indent,
            startOnNewline: false
          });
          if (valueProps.found) {
            if (!isMap && !props.found && ctx.options.strict) {
              if (sep) for (const st of sep) {
                if (st === valueProps.found) break;
                if (st.type === "newline") {
                  onError(st, "MULTILINE_IMPLICIT_KEY", "Implicit keys of flow sequence pairs need to be on a single line");
                  break;
                }
              }
              if (props.start < valueProps.found.offset - 1024) onError(valueProps.found, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit flow sequence key");
            }
          } else if (value) {
            if ("source" in value && value.source && value.source[0] === ":") onError(value, "MISSING_CHAR", `Missing space after : in ${fcName}`);
            else onError(valueProps.start, "MISSING_CHAR", `Missing , or : between ${fcName} items`);
          }
          const valueNode = value ? composeNode(ctx, value, valueProps, onError) : valueProps.found ? composeEmptyNode(ctx, valueProps.end, sep, null, valueProps, onError) : null;
          if (valueNode) {
            if (isBlock(value)) onError(valueNode.range, "BLOCK_IN_FLOW", blockMsg);
          } else if (valueProps.comment) {
            if (keyNode.comment) keyNode.comment += "\n" + valueProps.comment;
            else keyNode.comment = valueProps.comment;
          }
          const pair = new Pair.Pair(keyNode, valueNode);
          if (ctx.options.keepSourceTokens) pair.srcToken = collItem;
          if (isMap) {
            const map = coll;
            if (utilMapIncludes.mapIncludes(ctx, map.items, keyNode)) onError(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
            map.items.push(pair);
          } else {
            const map = new YAMLMap.YAMLMap(ctx.schema);
            map.flow = true;
            map.items.push(pair);
            const endRange = (valueNode ?? keyNode).range;
            map.range = [
              keyNode.range[0],
              endRange[1],
              endRange[2]
            ];
            coll.items.push(map);
          }
          offset = valueNode ? valueNode.range[2] : valueProps.end;
        }
      }
      const expectedEnd = isMap ? "}" : "]";
      const [ce, ...ee] = fc.end;
      let cePos = offset;
      if (ce && ce.source === expectedEnd) cePos = ce.offset + ce.source.length;
      else {
        const name = fcName[0].toUpperCase() + fcName.substring(1);
        const msg = atRoot ? `${name} must end with a ${expectedEnd}` : `${name} in block collection must be sufficiently indented and end with a ${expectedEnd}`;
        onError(offset, atRoot ? "MISSING_CHAR" : "BAD_INDENT", msg);
        if (ce && ce.source.length !== 1) ee.unshift(ce);
      }
      if (ee.length > 0) {
        const end = resolveEnd.resolveEnd(ee, cePos, ctx.options.strict, onError);
        if (end.comment) {
          if (coll.comment) coll.comment += "\n" + end.comment;
          else coll.comment = end.comment;
        }
        coll.range = [
          fc.offset,
          cePos,
          end.offset
        ];
      } else {
        coll.range = [
          fc.offset,
          cePos,
          cePos
        ];
      }
      return coll;
    }
    exports.resolveFlowCollection = resolveFlowCollection;
  }
});

// ../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/compose/compose-collection.js
var require_compose_collection = __commonJS({
  "../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/compose/compose-collection.js"(exports) {
    "use strict";
    var identity = require_identity();
    var Scalar = require_Scalar();
    var YAMLMap = require_YAMLMap();
    var YAMLSeq = require_YAMLSeq();
    var resolveBlockMap = require_resolve_block_map();
    var resolveBlockSeq = require_resolve_block_seq();
    var resolveFlowCollection = require_resolve_flow_collection();
    function resolveCollection(CN, ctx, token, onError, tagName, tag) {
      const coll = token.type === "block-map" ? resolveBlockMap.resolveBlockMap(CN, ctx, token, onError, tag) : token.type === "block-seq" ? resolveBlockSeq.resolveBlockSeq(CN, ctx, token, onError, tag) : resolveFlowCollection.resolveFlowCollection(CN, ctx, token, onError, tag);
      const Coll = coll.constructor;
      if (tagName === "!" || tagName === Coll.tagName) {
        coll.tag = Coll.tagName;
        return coll;
      }
      if (tagName) coll.tag = tagName;
      return coll;
    }
    function composeCollection(CN, ctx, token, props, onError) {
      const tagToken = props.tag;
      const tagName = !tagToken ? null : ctx.directives.tagName(tagToken.source, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg));
      if (token.type === "block-seq") {
        const { anchor, newlineAfterProp: nl } = props;
        const lastProp = anchor && tagToken ? anchor.offset > tagToken.offset ? anchor : tagToken : anchor ?? tagToken;
        if (lastProp && (!nl || nl.offset < lastProp.offset)) {
          const message = "Missing newline after block sequence props";
          onError(lastProp, "MISSING_CHAR", message);
        }
      }
      const expType = token.type === "block-map" ? "map" : token.type === "block-seq" ? "seq" : token.start.source === "{" ? "map" : "seq";
      if (!tagToken || !tagName || tagName === "!" || tagName === YAMLMap.YAMLMap.tagName && expType === "map" || tagName === YAMLSeq.YAMLSeq.tagName && expType === "seq") {
        return resolveCollection(CN, ctx, token, onError, tagName);
      }
      let tag = ctx.schema.tags.find((t) => t.tag === tagName && t.collection === expType);
      if (!tag) {
        const kt = ctx.schema.knownTags[tagName];
        if (kt && kt.collection === expType) {
          ctx.schema.tags.push(Object.assign({}, kt, {
            default: false
          }));
          tag = kt;
        } else {
          if (kt) {
            onError(tagToken, "BAD_COLLECTION_TYPE", `${kt.tag} used for ${expType} collection, but expects ${kt.collection ?? "scalar"}`, true);
          } else {
            onError(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, true);
          }
          return resolveCollection(CN, ctx, token, onError, tagName);
        }
      }
      const coll = resolveCollection(CN, ctx, token, onError, tagName, tag);
      const res = tag.resolve?.(coll, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg), ctx.options) ?? coll;
      const node = identity.isNode(res) ? res : new Scalar.Scalar(res);
      node.range = coll.range;
      node.tag = tagName;
      if (tag?.format) node.format = tag.format;
      return node;
    }
    exports.composeCollection = composeCollection;
  }
});

// ../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/compose/resolve-block-scalar.js
var require_resolve_block_scalar = __commonJS({
  "../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/compose/resolve-block-scalar.js"(exports) {
    "use strict";
    var Scalar = require_Scalar();
    function resolveBlockScalar(ctx, scalar, onError) {
      const start = scalar.offset;
      const header = parseBlockScalarHeader(scalar, ctx.options.strict, onError);
      if (!header) return {
        value: "",
        type: null,
        comment: "",
        range: [
          start,
          start,
          start
        ]
      };
      const type = header.mode === ">" ? Scalar.Scalar.BLOCK_FOLDED : Scalar.Scalar.BLOCK_LITERAL;
      const lines = scalar.source ? splitLines(scalar.source) : [];
      let chompStart = lines.length;
      for (let i2 = lines.length - 1; i2 >= 0; --i2) {
        const content = lines[i2][1];
        if (content === "" || content === "\r") chompStart = i2;
        else break;
      }
      if (chompStart === 0) {
        const value2 = header.chomp === "+" && lines.length > 0 ? "\n".repeat(Math.max(1, lines.length - 1)) : "";
        let end2 = start + header.length;
        if (scalar.source) end2 += scalar.source.length;
        return {
          value: value2,
          type,
          comment: header.comment,
          range: [
            start,
            end2,
            end2
          ]
        };
      }
      let trimIndent = scalar.indent + header.indent;
      let offset = scalar.offset + header.length;
      let contentStart = 0;
      for (let i2 = 0; i2 < chompStart; ++i2) {
        const [indent, content] = lines[i2];
        if (content === "" || content === "\r") {
          if (header.indent === 0 && indent.length > trimIndent) trimIndent = indent.length;
        } else {
          if (indent.length < trimIndent) {
            const message = "Block scalars with more-indented leading empty lines must use an explicit indentation indicator";
            onError(offset + indent.length, "MISSING_CHAR", message);
          }
          if (header.indent === 0) trimIndent = indent.length;
          contentStart = i2;
          if (trimIndent === 0 && !ctx.atRoot) {
            const message = "Block scalar values in collections must be indented";
            onError(offset, "BAD_INDENT", message);
          }
          break;
        }
        offset += indent.length + content.length + 1;
      }
      for (let i2 = lines.length - 1; i2 >= chompStart; --i2) {
        if (lines[i2][0].length > trimIndent) chompStart = i2 + 1;
      }
      let value = "";
      let sep = "";
      let prevMoreIndented = false;
      for (let i2 = 0; i2 < contentStart; ++i2) value += lines[i2][0].slice(trimIndent) + "\n";
      for (let i2 = contentStart; i2 < chompStart; ++i2) {
        let [indent, content] = lines[i2];
        offset += indent.length + content.length + 1;
        const crlf = content[content.length - 1] === "\r";
        if (crlf) content = content.slice(0, -1);
        if (content && indent.length < trimIndent) {
          const src = header.indent ? "explicit indentation indicator" : "first line";
          const message = `Block scalar lines must not be less indented than their ${src}`;
          onError(offset - content.length - (crlf ? 2 : 1), "BAD_INDENT", message);
          indent = "";
        }
        if (type === Scalar.Scalar.BLOCK_LITERAL) {
          value += sep + indent.slice(trimIndent) + content;
          sep = "\n";
        } else if (indent.length > trimIndent || content[0] === "	") {
          if (sep === " ") sep = "\n";
          else if (!prevMoreIndented && sep === "\n") sep = "\n\n";
          value += sep + indent.slice(trimIndent) + content;
          sep = "\n";
          prevMoreIndented = true;
        } else if (content === "") {
          if (sep === "\n") value += "\n";
          else sep = "\n";
        } else {
          value += sep + content;
          sep = " ";
          prevMoreIndented = false;
        }
      }
      switch (header.chomp) {
        case "-":
          break;
        case "+":
          for (let i2 = chompStart; i2 < lines.length; ++i2) value += "\n" + lines[i2][0].slice(trimIndent);
          if (value[value.length - 1] !== "\n") value += "\n";
          break;
        default:
          value += "\n";
      }
      const end = start + header.length + scalar.source.length;
      return {
        value,
        type,
        comment: header.comment,
        range: [
          start,
          end,
          end
        ]
      };
    }
    function parseBlockScalarHeader({ offset, props }, strict, onError) {
      if (props[0].type !== "block-scalar-header") {
        onError(props[0], "IMPOSSIBLE", "Block scalar header not found");
        return null;
      }
      const { source } = props[0];
      const mode = source[0];
      let indent = 0;
      let chomp = "";
      let error = -1;
      for (let i2 = 1; i2 < source.length; ++i2) {
        const ch = source[i2];
        if (!chomp && (ch === "-" || ch === "+")) chomp = ch;
        else {
          const n = Number(ch);
          if (!indent && n) indent = n;
          else if (error === -1) error = offset + i2;
        }
      }
      if (error !== -1) onError(error, "UNEXPECTED_TOKEN", `Block scalar header includes extra characters: ${source}`);
      let hasSpace = false;
      let comment = "";
      let length = source.length;
      for (let i2 = 1; i2 < props.length; ++i2) {
        const token = props[i2];
        switch (token.type) {
          case "space":
            hasSpace = true;
          // fallthrough
          case "newline":
            length += token.source.length;
            break;
          case "comment":
            if (strict && !hasSpace) {
              const message = "Comments must be separated from other tokens by white space characters";
              onError(token, "MISSING_CHAR", message);
            }
            length += token.source.length;
            comment = token.source.substring(1);
            break;
          case "error":
            onError(token, "UNEXPECTED_TOKEN", token.message);
            length += token.source.length;
            break;
          /* istanbul ignore next should not happen */
          default: {
            const message = `Unexpected token in block scalar header: ${token.type}`;
            onError(token, "UNEXPECTED_TOKEN", message);
            const ts = token.source;
            if (ts && typeof ts === "string") length += ts.length;
          }
        }
      }
      return {
        mode,
        indent,
        chomp,
        comment,
        length
      };
    }
    function splitLines(source) {
      const split = source.split(/\n( *)/);
      const first = split[0];
      const m = first.match(/^( *)/);
      const line0 = m?.[1] ? [
        m[1],
        first.slice(m[1].length)
      ] : [
        "",
        first
      ];
      const lines = [
        line0
      ];
      for (let i2 = 1; i2 < split.length; i2 += 2) lines.push([
        split[i2],
        split[i2 + 1]
      ]);
      return lines;
    }
    exports.resolveBlockScalar = resolveBlockScalar;
  }
});

// ../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/compose/resolve-flow-scalar.js
var require_resolve_flow_scalar = __commonJS({
  "../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/compose/resolve-flow-scalar.js"(exports) {
    "use strict";
    var Scalar = require_Scalar();
    var resolveEnd = require_resolve_end();
    function resolveFlowScalar(scalar, strict, onError) {
      const { offset, type, source, end } = scalar;
      let _type;
      let value;
      const _onError = (rel, code, msg) => onError(offset + rel, code, msg);
      switch (type) {
        case "scalar":
          _type = Scalar.Scalar.PLAIN;
          value = plainValue(source, _onError);
          break;
        case "single-quoted-scalar":
          _type = Scalar.Scalar.QUOTE_SINGLE;
          value = singleQuotedValue(source, _onError);
          break;
        case "double-quoted-scalar":
          _type = Scalar.Scalar.QUOTE_DOUBLE;
          value = doubleQuotedValue(source, _onError);
          break;
        /* istanbul ignore next should not happen */
        default:
          onError(scalar, "UNEXPECTED_TOKEN", `Expected a flow scalar value, but found: ${type}`);
          return {
            value: "",
            type: null,
            comment: "",
            range: [
              offset,
              offset + source.length,
              offset + source.length
            ]
          };
      }
      const valueEnd = offset + source.length;
      const re = resolveEnd.resolveEnd(end, valueEnd, strict, onError);
      return {
        value,
        type: _type,
        comment: re.comment,
        range: [
          offset,
          valueEnd,
          re.offset
        ]
      };
    }
    function plainValue(source, onError) {
      let badChar = "";
      switch (source[0]) {
        /* istanbul ignore next should not happen */
        case "	":
          badChar = "a tab character";
          break;
        case ",":
          badChar = "flow indicator character ,";
          break;
        case "%":
          badChar = "directive indicator character %";
          break;
        case "|":
        case ">": {
          badChar = `block scalar indicator ${source[0]}`;
          break;
        }
        case "@":
        case "`": {
          badChar = `reserved character ${source[0]}`;
          break;
        }
      }
      if (badChar) onError(0, "BAD_SCALAR_START", `Plain value cannot start with ${badChar}`);
      return foldLines(source);
    }
    function singleQuotedValue(source, onError) {
      if (source[source.length - 1] !== "'" || source.length === 1) onError(source.length, "MISSING_CHAR", "Missing closing 'quote");
      return foldLines(source.slice(1, -1)).replace(/''/g, "'");
    }
    function foldLines(source) {
      let first, line;
      try {
        first = new RegExp("(.*?)(?<![ 	])[ 	]*\r?\n", "sy");
        line = new RegExp("[ 	]*(.*?)(?:(?<![ 	])[ 	]*)?\r?\n", "sy");
      } catch {
        first = /(.*?)[ \t]*\r?\n/sy;
        line = /[ \t]*(.*?)[ \t]*\r?\n/sy;
      }
      let match2 = first.exec(source);
      if (!match2) return source;
      let res = match2[1];
      let sep = " ";
      let pos = first.lastIndex;
      line.lastIndex = pos;
      while (match2 = line.exec(source)) {
        if (match2[1] === "") {
          if (sep === "\n") res += sep;
          else sep = "\n";
        } else {
          res += sep + match2[1];
          sep = " ";
        }
        pos = line.lastIndex;
      }
      const last = /[ \t]*(.*)/sy;
      last.lastIndex = pos;
      match2 = last.exec(source);
      return res + sep + (match2?.[1] ?? "");
    }
    function doubleQuotedValue(source, onError) {
      let res = "";
      for (let i2 = 1; i2 < source.length - 1; ++i2) {
        const ch = source[i2];
        if (ch === "\r" && source[i2 + 1] === "\n") continue;
        if (ch === "\n") {
          const { fold, offset } = foldNewline(source, i2);
          res += fold;
          i2 = offset;
        } else if (ch === "\\") {
          let next = source[++i2];
          const cc = escapeCodes[next];
          if (cc) res += cc;
          else if (next === "\n") {
            next = source[i2 + 1];
            while (next === " " || next === "	") next = source[++i2 + 1];
          } else if (next === "\r" && source[i2 + 1] === "\n") {
            next = source[++i2 + 1];
            while (next === " " || next === "	") next = source[++i2 + 1];
          } else if (next === "x" || next === "u" || next === "U") {
            const length = {
              x: 2,
              u: 4,
              U: 8
            }[next];
            res += parseCharCode(source, i2 + 1, length, onError);
            i2 += length;
          } else {
            const raw = source.substr(i2 - 1, 2);
            onError(i2 - 1, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`);
            res += raw;
          }
        } else if (ch === " " || ch === "	") {
          const wsStart = i2;
          let next = source[i2 + 1];
          while (next === " " || next === "	") next = source[++i2 + 1];
          if (next !== "\n" && !(next === "\r" && source[i2 + 2] === "\n")) res += i2 > wsStart ? source.slice(wsStart, i2 + 1) : ch;
        } else {
          res += ch;
        }
      }
      if (source[source.length - 1] !== '"' || source.length === 1) onError(source.length, "MISSING_CHAR", 'Missing closing "quote');
      return res;
    }
    function foldNewline(source, offset) {
      let fold = "";
      let ch = source[offset + 1];
      while (ch === " " || ch === "	" || ch === "\n" || ch === "\r") {
        if (ch === "\r" && source[offset + 2] !== "\n") break;
        if (ch === "\n") fold += "\n";
        offset += 1;
        ch = source[offset + 1];
      }
      if (!fold) fold = " ";
      return {
        fold,
        offset
      };
    }
    var escapeCodes = {
      "0": "\0",
      a: "\x07",
      b: "\b",
      e: "\x1B",
      f: "\f",
      n: "\n",
      r: "\r",
      t: "	",
      v: "\v",
      N: "\x85",
      _: "\xA0",
      L: "\u2028",
      P: "\u2029",
      " ": " ",
      '"': '"',
      "/": "/",
      "\\": "\\",
      "	": "	"
    };
    function parseCharCode(source, offset, length, onError) {
      const cc = source.substr(offset, length);
      const ok = cc.length === length && /^[0-9a-fA-F]+$/.test(cc);
      const code = ok ? parseInt(cc, 16) : NaN;
      if (isNaN(code)) {
        const raw = source.substr(offset - 2, length + 2);
        onError(offset - 2, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`);
        return raw;
      }
      return String.fromCodePoint(code);
    }
    exports.resolveFlowScalar = resolveFlowScalar;
  }
});

// ../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/compose/compose-scalar.js
var require_compose_scalar = __commonJS({
  "../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/compose/compose-scalar.js"(exports) {
    "use strict";
    var identity = require_identity();
    var Scalar = require_Scalar();
    var resolveBlockScalar = require_resolve_block_scalar();
    var resolveFlowScalar = require_resolve_flow_scalar();
    function composeScalar(ctx, token, tagToken, onError) {
      const { value, type, comment, range } = token.type === "block-scalar" ? resolveBlockScalar.resolveBlockScalar(ctx, token, onError) : resolveFlowScalar.resolveFlowScalar(token, ctx.options.strict, onError);
      const tagName = tagToken ? ctx.directives.tagName(tagToken.source, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg)) : null;
      let tag;
      if (ctx.options.stringKeys && ctx.atKey) {
        tag = ctx.schema[identity.SCALAR];
      } else if (tagName) tag = findScalarTagByName(ctx.schema, value, tagName, tagToken, onError);
      else if (token.type === "scalar") tag = findScalarTagByTest(ctx, value, token, onError);
      else tag = ctx.schema[identity.SCALAR];
      let scalar;
      try {
        const res = tag.resolve(value, (msg) => onError(tagToken ?? token, "TAG_RESOLVE_FAILED", msg), ctx.options);
        scalar = identity.isScalar(res) ? res : new Scalar.Scalar(res);
      } catch (error) {
        const msg = error instanceof Error ? error.message : String(error);
        onError(tagToken ?? token, "TAG_RESOLVE_FAILED", msg);
        scalar = new Scalar.Scalar(value);
      }
      scalar.range = range;
      scalar.source = value;
      if (type) scalar.type = type;
      if (tagName) scalar.tag = tagName;
      if (tag.format) scalar.format = tag.format;
      if (comment) scalar.comment = comment;
      return scalar;
    }
    function findScalarTagByName(schema, value, tagName, tagToken, onError) {
      if (tagName === "!") return schema[identity.SCALAR];
      const matchWithTest = [];
      for (const tag of schema.tags) {
        if (!tag.collection && tag.tag === tagName) {
          if (tag.default && tag.test) matchWithTest.push(tag);
          else return tag;
        }
      }
      for (const tag of matchWithTest) if (tag.test?.test(value)) return tag;
      const kt = schema.knownTags[tagName];
      if (kt && !kt.collection) {
        schema.tags.push(Object.assign({}, kt, {
          default: false,
          test: void 0
        }));
        return kt;
      }
      onError(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, tagName !== "tag:yaml.org,2002:str");
      return schema[identity.SCALAR];
    }
    function findScalarTagByTest({ atKey, directives, schema }, value, token, onError) {
      const tag = schema.tags.find((tag2) => (tag2.default === true || atKey && tag2.default === "key") && tag2.test?.test(value)) || schema[identity.SCALAR];
      if (schema.compat) {
        const compat = schema.compat.find((tag2) => tag2.default && tag2.test?.test(value)) ?? schema[identity.SCALAR];
        if (tag.tag !== compat.tag) {
          const ts = directives.tagString(tag.tag);
          const cs = directives.tagString(compat.tag);
          const msg = `Value may be parsed as either ${ts} or ${cs}`;
          onError(token, "TAG_RESOLVE_FAILED", msg, true);
        }
      }
      return tag;
    }
    exports.composeScalar = composeScalar;
  }
});

// ../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/compose/util-empty-scalar-position.js
var require_util_empty_scalar_position = __commonJS({
  "../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/compose/util-empty-scalar-position.js"(exports) {
    "use strict";
    function emptyScalarPosition(offset, before, pos) {
      if (before) {
        pos ?? (pos = before.length);
        for (let i2 = pos - 1; i2 >= 0; --i2) {
          let st = before[i2];
          switch (st.type) {
            case "space":
            case "comment":
            case "newline":
              offset -= st.source.length;
              continue;
          }
          st = before[++i2];
          while (st?.type === "space") {
            offset += st.source.length;
            st = before[++i2];
          }
          break;
        }
      }
      return offset;
    }
    exports.emptyScalarPosition = emptyScalarPosition;
  }
});

// ../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/compose/compose-node.js
var require_compose_node = __commonJS({
  "../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/compose/compose-node.js"(exports) {
    "use strict";
    var Alias = require_Alias();
    var identity = require_identity();
    var composeCollection = require_compose_collection();
    var composeScalar = require_compose_scalar();
    var resolveEnd = require_resolve_end();
    var utilEmptyScalarPosition = require_util_empty_scalar_position();
    var CN = {
      composeNode,
      composeEmptyNode
    };
    function composeNode(ctx, token, props, onError) {
      const atKey = ctx.atKey;
      const { spaceBefore, comment, anchor, tag } = props;
      let node;
      let isSrcToken = true;
      switch (token.type) {
        case "alias":
          node = composeAlias(ctx, token, onError);
          if (anchor || tag) onError(token, "ALIAS_PROPS", "An alias node must not specify any properties");
          break;
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar":
        case "block-scalar":
          node = composeScalar.composeScalar(ctx, token, tag, onError);
          if (anchor) node.anchor = anchor.source.substring(1);
          break;
        case "block-map":
        case "block-seq":
        case "flow-collection":
          node = composeCollection.composeCollection(CN, ctx, token, props, onError);
          if (anchor) node.anchor = anchor.source.substring(1);
          break;
        default: {
          const message = token.type === "error" ? token.message : `Unsupported token (type: ${token.type})`;
          onError(token, "UNEXPECTED_TOKEN", message);
          node = composeEmptyNode(ctx, token.offset, void 0, null, props, onError);
          isSrcToken = false;
        }
      }
      if (anchor && node.anchor === "") onError(anchor, "BAD_ALIAS", "Anchor cannot be an empty string");
      if (atKey && ctx.options.stringKeys && (!identity.isScalar(node) || typeof node.value !== "string" || node.tag && node.tag !== "tag:yaml.org,2002:str")) {
        const msg = "With stringKeys, all keys must be strings";
        onError(tag ?? token, "NON_STRING_KEY", msg);
      }
      if (spaceBefore) node.spaceBefore = true;
      if (comment) {
        if (token.type === "scalar" && token.source === "") node.comment = comment;
        else node.commentBefore = comment;
      }
      if (ctx.options.keepSourceTokens && isSrcToken) node.srcToken = token;
      return node;
    }
    function composeEmptyNode(ctx, offset, before, pos, { spaceBefore, comment, anchor, tag, end }, onError) {
      const token = {
        type: "scalar",
        offset: utilEmptyScalarPosition.emptyScalarPosition(offset, before, pos),
        indent: -1,
        source: ""
      };
      const node = composeScalar.composeScalar(ctx, token, tag, onError);
      if (anchor) {
        node.anchor = anchor.source.substring(1);
        if (node.anchor === "") onError(anchor, "BAD_ALIAS", "Anchor cannot be an empty string");
      }
      if (spaceBefore) node.spaceBefore = true;
      if (comment) {
        node.comment = comment;
        node.range[2] = end;
      }
      return node;
    }
    function composeAlias({ options }, { offset, source, end }, onError) {
      const alias = new Alias.Alias(source.substring(1));
      if (alias.source === "") onError(offset, "BAD_ALIAS", "Alias cannot be an empty string");
      if (alias.source.endsWith(":")) onError(offset + source.length - 1, "BAD_ALIAS", "Alias ending in : is ambiguous", true);
      const valueEnd = offset + source.length;
      const re = resolveEnd.resolveEnd(end, valueEnd, options.strict, onError);
      alias.range = [
        offset,
        valueEnd,
        re.offset
      ];
      if (re.comment) alias.comment = re.comment;
      return alias;
    }
    exports.composeEmptyNode = composeEmptyNode;
    exports.composeNode = composeNode;
  }
});

// ../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/compose/compose-doc.js
var require_compose_doc = __commonJS({
  "../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/compose/compose-doc.js"(exports) {
    "use strict";
    var Document = require_Document();
    var composeNode = require_compose_node();
    var resolveEnd = require_resolve_end();
    var resolveProps = require_resolve_props();
    function composeDoc(options, directives, { offset, start, value, end }, onError) {
      const opts = Object.assign({
        _directives: directives
      }, options);
      const doc = new Document.Document(void 0, opts);
      const ctx = {
        atKey: false,
        atRoot: true,
        directives: doc.directives,
        options: doc.options,
        schema: doc.schema
      };
      const props = resolveProps.resolveProps(start, {
        indicator: "doc-start",
        next: value ?? end?.[0],
        offset,
        onError,
        parentIndent: 0,
        startOnNewline: true
      });
      if (props.found) {
        doc.directives.docStart = true;
        if (value && (value.type === "block-map" || value.type === "block-seq") && !props.hasNewline) onError(props.end, "MISSING_CHAR", "Block collection cannot start on same line with directives-end marker");
      }
      doc.contents = value ? composeNode.composeNode(ctx, value, props, onError) : composeNode.composeEmptyNode(ctx, props.end, start, null, props, onError);
      const contentEnd = doc.contents.range[2];
      const re = resolveEnd.resolveEnd(end, contentEnd, false, onError);
      if (re.comment) doc.comment = re.comment;
      doc.range = [
        offset,
        contentEnd,
        re.offset
      ];
      return doc;
    }
    exports.composeDoc = composeDoc;
  }
});

// ../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/compose/composer.js
var require_composer = __commonJS({
  "../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/compose/composer.js"(exports) {
    "use strict";
    var node_process = __require("node:process");
    var directives = require_directives();
    var Document = require_Document();
    var errors = require_errors();
    var identity = require_identity();
    var composeDoc = require_compose_doc();
    var resolveEnd = require_resolve_end();
    function getErrorPos(src) {
      if (typeof src === "number") return [
        src,
        src + 1
      ];
      if (Array.isArray(src)) return src.length === 2 ? src : [
        src[0],
        src[1]
      ];
      const { offset, source } = src;
      return [
        offset,
        offset + (typeof source === "string" ? source.length : 1)
      ];
    }
    function parsePrelude(prelude) {
      let comment = "";
      let atComment = false;
      let afterEmptyLine = false;
      for (let i2 = 0; i2 < prelude.length; ++i2) {
        const source = prelude[i2];
        switch (source[0]) {
          case "#":
            comment += (comment === "" ? "" : afterEmptyLine ? "\n\n" : "\n") + (source.substring(1) || " ");
            atComment = true;
            afterEmptyLine = false;
            break;
          case "%":
            if (prelude[i2 + 1]?.[0] !== "#") i2 += 1;
            atComment = false;
            break;
          default:
            if (!atComment) afterEmptyLine = true;
            atComment = false;
        }
      }
      return {
        comment,
        afterEmptyLine
      };
    }
    var Composer = class {
      constructor(options = {}) {
        this.doc = null;
        this.atDirectives = false;
        this.prelude = [];
        this.errors = [];
        this.warnings = [];
        this.onError = (source, code, message, warning) => {
          const pos = getErrorPos(source);
          if (warning) this.warnings.push(new errors.YAMLWarning(pos, code, message));
          else this.errors.push(new errors.YAMLParseError(pos, code, message));
        };
        this.directives = new directives.Directives({
          version: options.version || "1.2"
        });
        this.options = options;
      }
      decorate(doc, afterDoc) {
        const { comment, afterEmptyLine } = parsePrelude(this.prelude);
        if (comment) {
          const dc = doc.contents;
          if (afterDoc) {
            doc.comment = doc.comment ? `${doc.comment}
${comment}` : comment;
          } else if (afterEmptyLine || doc.directives.docStart || !dc) {
            doc.commentBefore = comment;
          } else if (identity.isCollection(dc) && !dc.flow && dc.items.length > 0) {
            let it = dc.items[0];
            if (identity.isPair(it)) it = it.key;
            const cb = it.commentBefore;
            it.commentBefore = cb ? `${comment}
${cb}` : comment;
          } else {
            const cb = dc.commentBefore;
            dc.commentBefore = cb ? `${comment}
${cb}` : comment;
          }
        }
        if (afterDoc) {
          Array.prototype.push.apply(doc.errors, this.errors);
          Array.prototype.push.apply(doc.warnings, this.warnings);
        } else {
          doc.errors = this.errors;
          doc.warnings = this.warnings;
        }
        this.prelude = [];
        this.errors = [];
        this.warnings = [];
      }
      /**
         * Current stream status information.
         *
         * Mostly useful at the end of input for an empty stream.
         */
      streamInfo() {
        return {
          comment: parsePrelude(this.prelude).comment,
          directives: this.directives,
          errors: this.errors,
          warnings: this.warnings
        };
      }
      /**
         * Compose tokens into documents.
         *
         * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
         * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
         */
      *compose(tokens, forceDoc = false, endOffset = -1) {
        for (const token of tokens) yield* this.next(token);
        yield* this.end(forceDoc, endOffset);
      }
      /** Advance the composer by one CST token. */
      *next(token) {
        if (node_process.env.LOG_STREAM) console.dir(token, {
          depth: null
        });
        switch (token.type) {
          case "directive":
            this.directives.add(token.source, (offset, message, warning) => {
              const pos = getErrorPos(token);
              pos[0] += offset;
              this.onError(pos, "BAD_DIRECTIVE", message, warning);
            });
            this.prelude.push(token.source);
            this.atDirectives = true;
            break;
          case "document": {
            const doc = composeDoc.composeDoc(this.options, this.directives, token, this.onError);
            if (this.atDirectives && !doc.directives.docStart) this.onError(token, "MISSING_CHAR", "Missing directives-end/doc-start indicator line");
            this.decorate(doc, false);
            if (this.doc) yield this.doc;
            this.doc = doc;
            this.atDirectives = false;
            break;
          }
          case "byte-order-mark":
          case "space":
            break;
          case "comment":
          case "newline":
            this.prelude.push(token.source);
            break;
          case "error": {
            const msg = token.source ? `${token.message}: ${JSON.stringify(token.source)}` : token.message;
            const error = new errors.YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", msg);
            if (this.atDirectives || !this.doc) this.errors.push(error);
            else this.doc.errors.push(error);
            break;
          }
          case "doc-end": {
            if (!this.doc) {
              const msg = "Unexpected doc-end without preceding document";
              this.errors.push(new errors.YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", msg));
              break;
            }
            this.doc.directives.docEnd = true;
            const end = resolveEnd.resolveEnd(token.end, token.offset + token.source.length, this.doc.options.strict, this.onError);
            this.decorate(this.doc, true);
            if (end.comment) {
              const dc = this.doc.comment;
              this.doc.comment = dc ? `${dc}
${end.comment}` : end.comment;
            }
            this.doc.range[2] = end.offset;
            break;
          }
          default:
            this.errors.push(new errors.YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", `Unsupported token ${token.type}`));
        }
      }
      /**
         * Call at end of input to yield any remaining document.
         *
         * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
         * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
         */
      *end(forceDoc = false, endOffset = -1) {
        if (this.doc) {
          this.decorate(this.doc, true);
          yield this.doc;
          this.doc = null;
        } else if (forceDoc) {
          const opts = Object.assign({
            _directives: this.directives
          }, this.options);
          const doc = new Document.Document(void 0, opts);
          if (this.atDirectives) this.onError(endOffset, "MISSING_CHAR", "Missing directives-end indicator line");
          doc.range = [
            0,
            endOffset,
            endOffset
          ];
          this.decorate(doc, false);
          yield doc;
        }
      }
    };
    exports.Composer = Composer;
  }
});

// ../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/parse/cst-scalar.js
var require_cst_scalar = __commonJS({
  "../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/parse/cst-scalar.js"(exports) {
    "use strict";
    var resolveBlockScalar = require_resolve_block_scalar();
    var resolveFlowScalar = require_resolve_flow_scalar();
    var errors = require_errors();
    var stringifyString = require_stringifyString();
    function resolveAsScalar(token, strict = true, onError) {
      if (token) {
        const _onError = (pos, code, message) => {
          const offset = typeof pos === "number" ? pos : Array.isArray(pos) ? pos[0] : pos.offset;
          if (onError) onError(offset, code, message);
          else throw new errors.YAMLParseError([
            offset,
            offset + 1
          ], code, message);
        };
        switch (token.type) {
          case "scalar":
          case "single-quoted-scalar":
          case "double-quoted-scalar":
            return resolveFlowScalar.resolveFlowScalar(token, strict, _onError);
          case "block-scalar":
            return resolveBlockScalar.resolveBlockScalar({
              options: {
                strict
              }
            }, token, _onError);
        }
      }
      return null;
    }
    function createScalarToken(value, context) {
      const { implicitKey = false, indent, inFlow = false, offset = -1, type = "PLAIN" } = context;
      const source = stringifyString.stringifyString({
        type,
        value
      }, {
        implicitKey,
        indent: indent > 0 ? " ".repeat(indent) : "",
        inFlow,
        options: {
          blockQuote: true,
          lineWidth: -1
        }
      });
      const end = context.end ?? [
        {
          type: "newline",
          offset: -1,
          indent,
          source: "\n"
        }
      ];
      switch (source[0]) {
        case "|":
        case ">": {
          const he = source.indexOf("\n");
          const head = source.substring(0, he);
          const body = source.substring(he + 1) + "\n";
          const props = [
            {
              type: "block-scalar-header",
              offset,
              indent,
              source: head
            }
          ];
          if (!addEndtoBlockProps(props, end)) props.push({
            type: "newline",
            offset: -1,
            indent,
            source: "\n"
          });
          return {
            type: "block-scalar",
            offset,
            indent,
            props,
            source: body
          };
        }
        case '"':
          return {
            type: "double-quoted-scalar",
            offset,
            indent,
            source,
            end
          };
        case "'":
          return {
            type: "single-quoted-scalar",
            offset,
            indent,
            source,
            end
          };
        default:
          return {
            type: "scalar",
            offset,
            indent,
            source,
            end
          };
      }
    }
    function setScalarValue(token, value, context = {}) {
      let { afterKey = false, implicitKey = false, inFlow = false, type } = context;
      let indent = "indent" in token ? token.indent : null;
      if (afterKey && typeof indent === "number") indent += 2;
      if (!type) switch (token.type) {
        case "single-quoted-scalar":
          type = "QUOTE_SINGLE";
          break;
        case "double-quoted-scalar":
          type = "QUOTE_DOUBLE";
          break;
        case "block-scalar": {
          const header = token.props[0];
          if (header.type !== "block-scalar-header") throw new Error("Invalid block scalar header");
          type = header.source[0] === ">" ? "BLOCK_FOLDED" : "BLOCK_LITERAL";
          break;
        }
        default:
          type = "PLAIN";
      }
      const source = stringifyString.stringifyString({
        type,
        value
      }, {
        implicitKey: implicitKey || indent === null,
        indent: indent !== null && indent > 0 ? " ".repeat(indent) : "",
        inFlow,
        options: {
          blockQuote: true,
          lineWidth: -1
        }
      });
      switch (source[0]) {
        case "|":
        case ">":
          setBlockScalarValue(token, source);
          break;
        case '"':
          setFlowScalarValue(token, source, "double-quoted-scalar");
          break;
        case "'":
          setFlowScalarValue(token, source, "single-quoted-scalar");
          break;
        default:
          setFlowScalarValue(token, source, "scalar");
      }
    }
    function setBlockScalarValue(token, source) {
      const he = source.indexOf("\n");
      const head = source.substring(0, he);
      const body = source.substring(he + 1) + "\n";
      if (token.type === "block-scalar") {
        const header = token.props[0];
        if (header.type !== "block-scalar-header") throw new Error("Invalid block scalar header");
        header.source = head;
        token.source = body;
      } else {
        const { offset } = token;
        const indent = "indent" in token ? token.indent : -1;
        const props = [
          {
            type: "block-scalar-header",
            offset,
            indent,
            source: head
          }
        ];
        if (!addEndtoBlockProps(props, "end" in token ? token.end : void 0)) props.push({
          type: "newline",
          offset: -1,
          indent,
          source: "\n"
        });
        for (const key of Object.keys(token)) if (key !== "type" && key !== "offset") delete token[key];
        Object.assign(token, {
          type: "block-scalar",
          indent,
          props,
          source: body
        });
      }
    }
    function addEndtoBlockProps(props, end) {
      if (end) for (const st of end) switch (st.type) {
        case "space":
        case "comment":
          props.push(st);
          break;
        case "newline":
          props.push(st);
          return true;
      }
      return false;
    }
    function setFlowScalarValue(token, source, type) {
      switch (token.type) {
        case "scalar":
        case "double-quoted-scalar":
        case "single-quoted-scalar":
          token.type = type;
          token.source = source;
          break;
        case "block-scalar": {
          const end = token.props.slice(1);
          let oa = source.length;
          if (token.props[0].type === "block-scalar-header") oa -= token.props[0].source.length;
          for (const tok of end) tok.offset += oa;
          delete token.props;
          Object.assign(token, {
            type,
            source,
            end
          });
          break;
        }
        case "block-map":
        case "block-seq": {
          const offset = token.offset + source.length;
          const nl = {
            type: "newline",
            offset,
            indent: token.indent,
            source: "\n"
          };
          delete token.items;
          Object.assign(token, {
            type,
            source,
            end: [
              nl
            ]
          });
          break;
        }
        default: {
          const indent = "indent" in token ? token.indent : -1;
          const end = "end" in token && Array.isArray(token.end) ? token.end.filter((st) => st.type === "space" || st.type === "comment" || st.type === "newline") : [];
          for (const key of Object.keys(token)) if (key !== "type" && key !== "offset") delete token[key];
          Object.assign(token, {
            type,
            indent,
            source,
            end
          });
        }
      }
    }
    exports.createScalarToken = createScalarToken;
    exports.resolveAsScalar = resolveAsScalar;
    exports.setScalarValue = setScalarValue;
  }
});

// ../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/parse/cst-stringify.js
var require_cst_stringify = __commonJS({
  "../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/parse/cst-stringify.js"(exports) {
    "use strict";
    var stringify = (cst) => "type" in cst ? stringifyToken(cst) : stringifyItem(cst);
    function stringifyToken(token) {
      switch (token.type) {
        case "block-scalar": {
          let res = "";
          for (const tok of token.props) res += stringifyToken(tok);
          return res + token.source;
        }
        case "block-map":
        case "block-seq": {
          let res = "";
          for (const item of token.items) res += stringifyItem(item);
          return res;
        }
        case "flow-collection": {
          let res = token.start.source;
          for (const item of token.items) res += stringifyItem(item);
          for (const st of token.end) res += st.source;
          return res;
        }
        case "document": {
          let res = stringifyItem(token);
          if (token.end) for (const st of token.end) res += st.source;
          return res;
        }
        default: {
          let res = token.source;
          if ("end" in token && token.end) for (const st of token.end) res += st.source;
          return res;
        }
      }
    }
    function stringifyItem({ start, key, sep, value }) {
      let res = "";
      for (const st of start) res += st.source;
      if (key) res += stringifyToken(key);
      if (sep) for (const st of sep) res += st.source;
      if (value) res += stringifyToken(value);
      return res;
    }
    exports.stringify = stringify;
  }
});

// ../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/parse/cst-visit.js
var require_cst_visit = __commonJS({
  "../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/parse/cst-visit.js"(exports) {
    "use strict";
    var BREAK = Symbol("break visit");
    var SKIP = Symbol("skip children");
    var REMOVE = Symbol("remove item");
    function visit(cst, visitor) {
      if ("type" in cst && cst.type === "document") cst = {
        start: cst.start,
        value: cst.value
      };
      _visit(Object.freeze([]), cst, visitor);
    }
    visit.BREAK = BREAK;
    visit.SKIP = SKIP;
    visit.REMOVE = REMOVE;
    visit.itemAtPath = (cst, path2) => {
      let item = cst;
      for (const [field, index] of path2) {
        const tok = item?.[field];
        if (tok && "items" in tok) {
          item = tok.items[index];
        } else return void 0;
      }
      return item;
    };
    visit.parentCollection = (cst, path2) => {
      const parent = visit.itemAtPath(cst, path2.slice(0, -1));
      const field = path2[path2.length - 1][0];
      const coll = parent?.[field];
      if (coll && "items" in coll) return coll;
      throw new Error("Parent collection not found");
    };
    function _visit(path2, item, visitor) {
      let ctrl = visitor(item, path2);
      if (typeof ctrl === "symbol") return ctrl;
      for (const field of [
        "key",
        "value"
      ]) {
        const token = item[field];
        if (token && "items" in token) {
          for (let i2 = 0; i2 < token.items.length; ++i2) {
            const ci = _visit(Object.freeze(path2.concat([
              [
                field,
                i2
              ]
            ])), token.items[i2], visitor);
            if (typeof ci === "number") i2 = ci - 1;
            else if (ci === BREAK) return BREAK;
            else if (ci === REMOVE) {
              token.items.splice(i2, 1);
              i2 -= 1;
            }
          }
          if (typeof ctrl === "function" && field === "key") ctrl = ctrl(item, path2);
        }
      }
      return typeof ctrl === "function" ? ctrl(item, path2) : ctrl;
    }
    exports.visit = visit;
  }
});

// ../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/parse/cst.js
var require_cst = __commonJS({
  "../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/parse/cst.js"(exports) {
    "use strict";
    var cstScalar = require_cst_scalar();
    var cstStringify = require_cst_stringify();
    var cstVisit = require_cst_visit();
    var BOM = "\uFEFF";
    var DOCUMENT = "";
    var FLOW_END = "";
    var SCALAR = "";
    var isCollection = (token) => !!token && "items" in token;
    var isScalar = (token) => !!token && (token.type === "scalar" || token.type === "single-quoted-scalar" || token.type === "double-quoted-scalar" || token.type === "block-scalar");
    function prettyToken(token) {
      switch (token) {
        case BOM:
          return "<BOM>";
        case DOCUMENT:
          return "<DOC>";
        case FLOW_END:
          return "<FLOW_END>";
        case SCALAR:
          return "<SCALAR>";
        default:
          return JSON.stringify(token);
      }
    }
    function tokenType(source) {
      switch (source) {
        case BOM:
          return "byte-order-mark";
        case DOCUMENT:
          return "doc-mode";
        case FLOW_END:
          return "flow-error-end";
        case SCALAR:
          return "scalar";
        case "---":
          return "doc-start";
        case "...":
          return "doc-end";
        case "":
        case "\n":
        case "\r\n":
          return "newline";
        case "-":
          return "seq-item-ind";
        case "?":
          return "explicit-key-ind";
        case ":":
          return "map-value-ind";
        case "{":
          return "flow-map-start";
        case "}":
          return "flow-map-end";
        case "[":
          return "flow-seq-start";
        case "]":
          return "flow-seq-end";
        case ",":
          return "comma";
      }
      switch (source[0]) {
        case " ":
        case "	":
          return "space";
        case "#":
          return "comment";
        case "%":
          return "directive-line";
        case "*":
          return "alias";
        case "&":
          return "anchor";
        case "!":
          return "tag";
        case "'":
          return "single-quoted-scalar";
        case '"':
          return "double-quoted-scalar";
        case "|":
        case ">":
          return "block-scalar-header";
      }
      return null;
    }
    exports.createScalarToken = cstScalar.createScalarToken;
    exports.resolveAsScalar = cstScalar.resolveAsScalar;
    exports.setScalarValue = cstScalar.setScalarValue;
    exports.stringify = cstStringify.stringify;
    exports.visit = cstVisit.visit;
    exports.BOM = BOM;
    exports.DOCUMENT = DOCUMENT;
    exports.FLOW_END = FLOW_END;
    exports.SCALAR = SCALAR;
    exports.isCollection = isCollection;
    exports.isScalar = isScalar;
    exports.prettyToken = prettyToken;
    exports.tokenType = tokenType;
  }
});

// ../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/parse/lexer.js
var require_lexer = __commonJS({
  "../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/parse/lexer.js"(exports) {
    "use strict";
    var cst = require_cst();
    function isEmpty(ch) {
      switch (ch) {
        case void 0:
        case " ":
        case "\n":
        case "\r":
        case "	":
          return true;
        default:
          return false;
      }
    }
    var hexDigits = new Set("0123456789ABCDEFabcdef");
    var tagChars = new Set("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-#;/?:@&=+$_.!~*'()");
    var flowIndicatorChars = new Set(",[]{}");
    var invalidAnchorChars = new Set(" ,[]{}\n\r	");
    var isNotAnchorChar = (ch) => !ch || invalidAnchorChars.has(ch);
    var Lexer = class {
      constructor() {
        this.atEnd = false;
        this.blockScalarIndent = -1;
        this.blockScalarKeep = false;
        this.buffer = "";
        this.flowKey = false;
        this.flowLevel = 0;
        this.indentNext = 0;
        this.indentValue = 0;
        this.lineEndPos = null;
        this.next = null;
        this.pos = 0;
      }
      /**
         * Generate YAML tokens from the `source` string. If `incomplete`,
         * a part of the last line may be left as a buffer for the next call.
         *
         * @returns A generator of lexical tokens
         */
      *lex(source, incomplete = false) {
        if (source) {
          if (typeof source !== "string") throw TypeError("source is not a string");
          this.buffer = this.buffer ? this.buffer + source : source;
          this.lineEndPos = null;
        }
        this.atEnd = !incomplete;
        let next = this.next ?? "stream";
        while (next && (incomplete || this.hasChars(1))) next = yield* this.parseNext(next);
      }
      atLineEnd() {
        let i2 = this.pos;
        let ch = this.buffer[i2];
        while (ch === " " || ch === "	") ch = this.buffer[++i2];
        if (!ch || ch === "#" || ch === "\n") return true;
        if (ch === "\r") return this.buffer[i2 + 1] === "\n";
        return false;
      }
      charAt(n) {
        return this.buffer[this.pos + n];
      }
      continueScalar(offset) {
        let ch = this.buffer[offset];
        if (this.indentNext > 0) {
          let indent = 0;
          while (ch === " ") ch = this.buffer[++indent + offset];
          if (ch === "\r") {
            const next = this.buffer[indent + offset + 1];
            if (next === "\n" || !next && !this.atEnd) return offset + indent + 1;
          }
          return ch === "\n" || indent >= this.indentNext || !ch && !this.atEnd ? offset + indent : -1;
        }
        if (ch === "-" || ch === ".") {
          const dt = this.buffer.substr(offset, 3);
          if ((dt === "---" || dt === "...") && isEmpty(this.buffer[offset + 3])) return -1;
        }
        return offset;
      }
      getLine() {
        let end = this.lineEndPos;
        if (typeof end !== "number" || end !== -1 && end < this.pos) {
          end = this.buffer.indexOf("\n", this.pos);
          this.lineEndPos = end;
        }
        if (end === -1) return this.atEnd ? this.buffer.substring(this.pos) : null;
        if (this.buffer[end - 1] === "\r") end -= 1;
        return this.buffer.substring(this.pos, end);
      }
      hasChars(n) {
        return this.pos + n <= this.buffer.length;
      }
      setNext(state) {
        this.buffer = this.buffer.substring(this.pos);
        this.pos = 0;
        this.lineEndPos = null;
        this.next = state;
        return null;
      }
      peek(n) {
        return this.buffer.substr(this.pos, n);
      }
      *parseNext(next) {
        switch (next) {
          case "stream":
            return yield* this.parseStream();
          case "line-start":
            return yield* this.parseLineStart();
          case "block-start":
            return yield* this.parseBlockStart();
          case "doc":
            return yield* this.parseDocument();
          case "flow":
            return yield* this.parseFlowCollection();
          case "quoted-scalar":
            return yield* this.parseQuotedScalar();
          case "block-scalar":
            return yield* this.parseBlockScalar();
          case "plain-scalar":
            return yield* this.parsePlainScalar();
        }
      }
      *parseStream() {
        let line = this.getLine();
        if (line === null) return this.setNext("stream");
        if (line[0] === cst.BOM) {
          yield* this.pushCount(1);
          line = line.substring(1);
        }
        if (line[0] === "%") {
          let dirEnd = line.length;
          let cs = line.indexOf("#");
          while (cs !== -1) {
            const ch = line[cs - 1];
            if (ch === " " || ch === "	") {
              dirEnd = cs - 1;
              break;
            } else {
              cs = line.indexOf("#", cs + 1);
            }
          }
          while (true) {
            const ch = line[dirEnd - 1];
            if (ch === " " || ch === "	") dirEnd -= 1;
            else break;
          }
          const n = (yield* this.pushCount(dirEnd)) + (yield* this.pushSpaces(true));
          yield* this.pushCount(line.length - n);
          this.pushNewline();
          return "stream";
        }
        if (this.atLineEnd()) {
          const sp = yield* this.pushSpaces(true);
          yield* this.pushCount(line.length - sp);
          yield* this.pushNewline();
          return "stream";
        }
        yield cst.DOCUMENT;
        return yield* this.parseLineStart();
      }
      *parseLineStart() {
        const ch = this.charAt(0);
        if (!ch && !this.atEnd) return this.setNext("line-start");
        if (ch === "-" || ch === ".") {
          if (!this.atEnd && !this.hasChars(4)) return this.setNext("line-start");
          const s = this.peek(3);
          if ((s === "---" || s === "...") && isEmpty(this.charAt(3))) {
            yield* this.pushCount(3);
            this.indentValue = 0;
            this.indentNext = 0;
            return s === "---" ? "doc" : "stream";
          }
        }
        this.indentValue = yield* this.pushSpaces(false);
        if (this.indentNext > this.indentValue && !isEmpty(this.charAt(1))) this.indentNext = this.indentValue;
        return yield* this.parseBlockStart();
      }
      *parseBlockStart() {
        const [ch0, ch1] = this.peek(2);
        if (!ch1 && !this.atEnd) return this.setNext("block-start");
        if ((ch0 === "-" || ch0 === "?" || ch0 === ":") && isEmpty(ch1)) {
          const n = (yield* this.pushCount(1)) + (yield* this.pushSpaces(true));
          this.indentNext = this.indentValue + 1;
          this.indentValue += n;
          return yield* this.parseBlockStart();
        }
        return "doc";
      }
      *parseDocument() {
        yield* this.pushSpaces(true);
        const line = this.getLine();
        if (line === null) return this.setNext("doc");
        let n = yield* this.pushIndicators();
        switch (line[n]) {
          case "#":
            yield* this.pushCount(line.length - n);
          // fallthrough
          case void 0:
            yield* this.pushNewline();
            return yield* this.parseLineStart();
          case "{":
          case "[":
            yield* this.pushCount(1);
            this.flowKey = false;
            this.flowLevel = 1;
            return "flow";
          case "}":
          case "]":
            yield* this.pushCount(1);
            return "doc";
          case "*":
            yield* this.pushUntil(isNotAnchorChar);
            return "doc";
          case '"':
          case "'":
            return yield* this.parseQuotedScalar();
          case "|":
          case ">":
            n += yield* this.parseBlockScalarHeader();
            n += yield* this.pushSpaces(true);
            yield* this.pushCount(line.length - n);
            yield* this.pushNewline();
            return yield* this.parseBlockScalar();
          default:
            return yield* this.parsePlainScalar();
        }
      }
      *parseFlowCollection() {
        let nl, sp;
        let indent = -1;
        do {
          nl = yield* this.pushNewline();
          if (nl > 0) {
            sp = yield* this.pushSpaces(false);
            this.indentValue = indent = sp;
          } else {
            sp = 0;
          }
          sp += yield* this.pushSpaces(true);
        } while (nl + sp > 0);
        const line = this.getLine();
        if (line === null) return this.setNext("flow");
        if (indent !== -1 && indent < this.indentNext && line[0] !== "#" || indent === 0 && (line.startsWith("---") || line.startsWith("...")) && isEmpty(line[3])) {
          const atFlowEndMarker = indent === this.indentNext - 1 && this.flowLevel === 1 && (line[0] === "]" || line[0] === "}");
          if (!atFlowEndMarker) {
            this.flowLevel = 0;
            yield cst.FLOW_END;
            return yield* this.parseLineStart();
          }
        }
        let n = 0;
        while (line[n] === ",") {
          n += yield* this.pushCount(1);
          n += yield* this.pushSpaces(true);
          this.flowKey = false;
        }
        n += yield* this.pushIndicators();
        switch (line[n]) {
          case void 0:
            return "flow";
          case "#":
            yield* this.pushCount(line.length - n);
            return "flow";
          case "{":
          case "[":
            yield* this.pushCount(1);
            this.flowKey = false;
            this.flowLevel += 1;
            return "flow";
          case "}":
          case "]":
            yield* this.pushCount(1);
            this.flowKey = true;
            this.flowLevel -= 1;
            return this.flowLevel ? "flow" : "doc";
          case "*":
            yield* this.pushUntil(isNotAnchorChar);
            return "flow";
          case '"':
          case "'":
            this.flowKey = true;
            return yield* this.parseQuotedScalar();
          case ":": {
            const next = this.charAt(1);
            if (this.flowKey || isEmpty(next) || next === ",") {
              this.flowKey = false;
              yield* this.pushCount(1);
              yield* this.pushSpaces(true);
              return "flow";
            }
          }
          // fallthrough
          default:
            this.flowKey = false;
            return yield* this.parsePlainScalar();
        }
      }
      *parseQuotedScalar() {
        const quote = this.charAt(0);
        let end = this.buffer.indexOf(quote, this.pos + 1);
        if (quote === "'") {
          while (end !== -1 && this.buffer[end + 1] === "'") end = this.buffer.indexOf("'", end + 2);
        } else {
          while (end !== -1) {
            let n = 0;
            while (this.buffer[end - 1 - n] === "\\") n += 1;
            if (n % 2 === 0) break;
            end = this.buffer.indexOf('"', end + 1);
          }
        }
        const qb = this.buffer.substring(0, end);
        let nl = qb.indexOf("\n", this.pos);
        if (nl !== -1) {
          while (nl !== -1) {
            const cs = this.continueScalar(nl + 1);
            if (cs === -1) break;
            nl = qb.indexOf("\n", cs);
          }
          if (nl !== -1) {
            end = nl - (qb[nl - 1] === "\r" ? 2 : 1);
          }
        }
        if (end === -1) {
          if (!this.atEnd) return this.setNext("quoted-scalar");
          end = this.buffer.length;
        }
        yield* this.pushToIndex(end + 1, false);
        return this.flowLevel ? "flow" : "doc";
      }
      *parseBlockScalarHeader() {
        this.blockScalarIndent = -1;
        this.blockScalarKeep = false;
        let i2 = this.pos;
        while (true) {
          const ch = this.buffer[++i2];
          if (ch === "+") this.blockScalarKeep = true;
          else if (ch > "0" && ch <= "9") this.blockScalarIndent = Number(ch) - 1;
          else if (ch !== "-") break;
        }
        return yield* this.pushUntil((ch) => isEmpty(ch) || ch === "#");
      }
      *parseBlockScalar() {
        let nl = this.pos - 1;
        let indent = 0;
        let ch;
        loop: for (let i3 = this.pos; ch = this.buffer[i3]; ++i3) {
          switch (ch) {
            case " ":
              indent += 1;
              break;
            case "\n":
              nl = i3;
              indent = 0;
              break;
            case "\r": {
              const next = this.buffer[i3 + 1];
              if (!next && !this.atEnd) return this.setNext("block-scalar");
              if (next === "\n") break;
            }
            default:
              break loop;
          }
        }
        if (!ch && !this.atEnd) return this.setNext("block-scalar");
        if (indent >= this.indentNext) {
          if (this.blockScalarIndent === -1) this.indentNext = indent;
          else {
            this.indentNext = this.blockScalarIndent + (this.indentNext === 0 ? 1 : this.indentNext);
          }
          do {
            const cs = this.continueScalar(nl + 1);
            if (cs === -1) break;
            nl = this.buffer.indexOf("\n", cs);
          } while (nl !== -1);
          if (nl === -1) {
            if (!this.atEnd) return this.setNext("block-scalar");
            nl = this.buffer.length;
          }
        }
        let i2 = nl + 1;
        ch = this.buffer[i2];
        while (ch === " ") ch = this.buffer[++i2];
        if (ch === "	") {
          while (ch === "	" || ch === " " || ch === "\r" || ch === "\n") ch = this.buffer[++i2];
          nl = i2 - 1;
        } else if (!this.blockScalarKeep) {
          do {
            let i3 = nl - 1;
            let ch2 = this.buffer[i3];
            if (ch2 === "\r") ch2 = this.buffer[--i3];
            const lastChar = i3;
            while (ch2 === " ") ch2 = this.buffer[--i3];
            if (ch2 === "\n" && i3 >= this.pos && i3 + 1 + indent > lastChar) nl = i3;
            else break;
          } while (true);
        }
        yield cst.SCALAR;
        yield* this.pushToIndex(nl + 1, true);
        return yield* this.parseLineStart();
      }
      *parsePlainScalar() {
        const inFlow = this.flowLevel > 0;
        let end = this.pos - 1;
        let i2 = this.pos - 1;
        let ch;
        while (ch = this.buffer[++i2]) {
          if (ch === ":") {
            const next = this.buffer[i2 + 1];
            if (isEmpty(next) || inFlow && flowIndicatorChars.has(next)) break;
            end = i2;
          } else if (isEmpty(ch)) {
            let next = this.buffer[i2 + 1];
            if (ch === "\r") {
              if (next === "\n") {
                i2 += 1;
                ch = "\n";
                next = this.buffer[i2 + 1];
              } else end = i2;
            }
            if (next === "#" || inFlow && flowIndicatorChars.has(next)) break;
            if (ch === "\n") {
              const cs = this.continueScalar(i2 + 1);
              if (cs === -1) break;
              i2 = Math.max(i2, cs - 2);
            }
          } else {
            if (inFlow && flowIndicatorChars.has(ch)) break;
            end = i2;
          }
        }
        if (!ch && !this.atEnd) return this.setNext("plain-scalar");
        yield cst.SCALAR;
        yield* this.pushToIndex(end + 1, true);
        return inFlow ? "flow" : "doc";
      }
      *pushCount(n) {
        if (n > 0) {
          yield this.buffer.substr(this.pos, n);
          this.pos += n;
          return n;
        }
        return 0;
      }
      *pushToIndex(i2, allowEmpty) {
        const s = this.buffer.slice(this.pos, i2);
        if (s) {
          yield s;
          this.pos += s.length;
          return s.length;
        } else if (allowEmpty) yield "";
        return 0;
      }
      *pushIndicators() {
        switch (this.charAt(0)) {
          case "!":
            return (yield* this.pushTag()) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
          case "&":
            return (yield* this.pushUntil(isNotAnchorChar)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
          case "-":
          case "?":
          case ":": {
            const inFlow = this.flowLevel > 0;
            const ch1 = this.charAt(1);
            if (isEmpty(ch1) || inFlow && flowIndicatorChars.has(ch1)) {
              if (!inFlow) this.indentNext = this.indentValue + 1;
              else if (this.flowKey) this.flowKey = false;
              return (yield* this.pushCount(1)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
            }
          }
        }
        return 0;
      }
      *pushTag() {
        if (this.charAt(1) === "<") {
          let i2 = this.pos + 2;
          let ch = this.buffer[i2];
          while (!isEmpty(ch) && ch !== ">") ch = this.buffer[++i2];
          return yield* this.pushToIndex(ch === ">" ? i2 + 1 : i2, false);
        } else {
          let i2 = this.pos + 1;
          let ch = this.buffer[i2];
          while (ch) {
            if (tagChars.has(ch)) ch = this.buffer[++i2];
            else if (ch === "%" && hexDigits.has(this.buffer[i2 + 1]) && hexDigits.has(this.buffer[i2 + 2])) {
              ch = this.buffer[i2 += 3];
            } else break;
          }
          return yield* this.pushToIndex(i2, false);
        }
      }
      *pushNewline() {
        const ch = this.buffer[this.pos];
        if (ch === "\n") return yield* this.pushCount(1);
        else if (ch === "\r" && this.charAt(1) === "\n") return yield* this.pushCount(2);
        else return 0;
      }
      *pushSpaces(allowTabs) {
        let i2 = this.pos - 1;
        let ch;
        do {
          ch = this.buffer[++i2];
        } while (ch === " " || allowTabs && ch === "	");
        const n = i2 - this.pos;
        if (n > 0) {
          yield this.buffer.substr(this.pos, n);
          this.pos = i2;
        }
        return n;
      }
      *pushUntil(test) {
        let i2 = this.pos;
        let ch = this.buffer[i2];
        while (!test(ch)) ch = this.buffer[++i2];
        return yield* this.pushToIndex(i2, false);
      }
    };
    exports.Lexer = Lexer;
  }
});

// ../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/parse/line-counter.js
var require_line_counter = __commonJS({
  "../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/parse/line-counter.js"(exports) {
    "use strict";
    var LineCounter = class {
      constructor() {
        this.lineStarts = [];
        this.addNewLine = (offset) => this.lineStarts.push(offset);
        this.linePos = (offset) => {
          let low = 0;
          let high = this.lineStarts.length;
          while (low < high) {
            const mid = low + high >> 1;
            if (this.lineStarts[mid] < offset) low = mid + 1;
            else high = mid;
          }
          if (this.lineStarts[low] === offset) return {
            line: low + 1,
            col: 1
          };
          if (low === 0) return {
            line: 0,
            col: offset
          };
          const start = this.lineStarts[low - 1];
          return {
            line: low,
            col: offset - start + 1
          };
        };
      }
    };
    exports.LineCounter = LineCounter;
  }
});

// ../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/parse/parser.js
var require_parser = __commonJS({
  "../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/parse/parser.js"(exports) {
    "use strict";
    var node_process = __require("node:process");
    var cst = require_cst();
    var lexer = require_lexer();
    function includesToken(list, type) {
      for (let i2 = 0; i2 < list.length; ++i2) if (list[i2].type === type) return true;
      return false;
    }
    function findNonEmptyIndex(list) {
      for (let i2 = 0; i2 < list.length; ++i2) {
        switch (list[i2].type) {
          case "space":
          case "comment":
          case "newline":
            break;
          default:
            return i2;
        }
      }
      return -1;
    }
    function isFlowToken(token) {
      switch (token?.type) {
        case "alias":
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar":
        case "flow-collection":
          return true;
        default:
          return false;
      }
    }
    function getPrevProps(parent) {
      switch (parent.type) {
        case "document":
          return parent.start;
        case "block-map": {
          const it = parent.items[parent.items.length - 1];
          return it.sep ?? it.start;
        }
        case "block-seq":
          return parent.items[parent.items.length - 1].start;
        /* istanbul ignore next should not happen */
        default:
          return [];
      }
    }
    function getFirstKeyStartProps(prev) {
      if (prev.length === 0) return [];
      let i2 = prev.length;
      loop: while (--i2 >= 0) {
        switch (prev[i2].type) {
          case "doc-start":
          case "explicit-key-ind":
          case "map-value-ind":
          case "seq-item-ind":
          case "newline":
            break loop;
        }
      }
      while (prev[++i2]?.type === "space") {
      }
      return prev.splice(i2, prev.length);
    }
    function fixFlowSeqItems(fc) {
      if (fc.start.type === "flow-seq-start") {
        for (const it of fc.items) {
          if (it.sep && !it.value && !includesToken(it.start, "explicit-key-ind") && !includesToken(it.sep, "map-value-ind")) {
            if (it.key) it.value = it.key;
            delete it.key;
            if (isFlowToken(it.value)) {
              if (it.value.end) Array.prototype.push.apply(it.value.end, it.sep);
              else it.value.end = it.sep;
            } else Array.prototype.push.apply(it.start, it.sep);
            delete it.sep;
          }
        }
      }
    }
    var Parser = class {
      /**
         * @param onNewLine - If defined, called separately with the start position of
         *   each new line (in `parse()`, including the start of input).
         */
      constructor(onNewLine) {
        this.atNewLine = true;
        this.atScalar = false;
        this.indent = 0;
        this.offset = 0;
        this.onKeyLine = false;
        this.stack = [];
        this.source = "";
        this.type = "";
        this.lexer = new lexer.Lexer();
        this.onNewLine = onNewLine;
      }
      /**
         * Parse `source` as a YAML stream.
         * If `incomplete`, a part of the last line may be left as a buffer for the next call.
         *
         * Errors are not thrown, but yielded as `{ type: 'error', message }` tokens.
         *
         * @returns A generator of tokens representing each directive, document, and other structure.
         */
      *parse(source, incomplete = false) {
        if (this.onNewLine && this.offset === 0) this.onNewLine(0);
        for (const lexeme of this.lexer.lex(source, incomplete)) yield* this.next(lexeme);
        if (!incomplete) yield* this.end();
      }
      /**
         * Advance the parser by the `source` of one lexical token.
         */
      *next(source) {
        this.source = source;
        if (node_process.env.LOG_TOKENS) console.log("|", cst.prettyToken(source));
        if (this.atScalar) {
          this.atScalar = false;
          yield* this.step();
          this.offset += source.length;
          return;
        }
        const type = cst.tokenType(source);
        if (!type) {
          const message = `Not a YAML token: ${source}`;
          yield* this.pop({
            type: "error",
            offset: this.offset,
            message,
            source
          });
          this.offset += source.length;
        } else if (type === "scalar") {
          this.atNewLine = false;
          this.atScalar = true;
          this.type = "scalar";
        } else {
          this.type = type;
          yield* this.step();
          switch (type) {
            case "newline":
              this.atNewLine = true;
              this.indent = 0;
              if (this.onNewLine) this.onNewLine(this.offset + source.length);
              break;
            case "space":
              if (this.atNewLine && source[0] === " ") this.indent += source.length;
              break;
            case "explicit-key-ind":
            case "map-value-ind":
            case "seq-item-ind":
              if (this.atNewLine) this.indent += source.length;
              break;
            case "doc-mode":
            case "flow-error-end":
              return;
            default:
              this.atNewLine = false;
          }
          this.offset += source.length;
        }
      }
      /** Call at end of input to push out any remaining constructions */
      *end() {
        while (this.stack.length > 0) yield* this.pop();
      }
      get sourceToken() {
        const st = {
          type: this.type,
          offset: this.offset,
          indent: this.indent,
          source: this.source
        };
        return st;
      }
      *step() {
        const top = this.peek(1);
        if (this.type === "doc-end" && (!top || top.type !== "doc-end")) {
          while (this.stack.length > 0) yield* this.pop();
          this.stack.push({
            type: "doc-end",
            offset: this.offset,
            source: this.source
          });
          return;
        }
        if (!top) return yield* this.stream();
        switch (top.type) {
          case "document":
            return yield* this.document(top);
          case "alias":
          case "scalar":
          case "single-quoted-scalar":
          case "double-quoted-scalar":
            return yield* this.scalar(top);
          case "block-scalar":
            return yield* this.blockScalar(top);
          case "block-map":
            return yield* this.blockMap(top);
          case "block-seq":
            return yield* this.blockSequence(top);
          case "flow-collection":
            return yield* this.flowCollection(top);
          case "doc-end":
            return yield* this.documentEnd(top);
        }
        yield* this.pop();
      }
      peek(n) {
        return this.stack[this.stack.length - n];
      }
      *pop(error) {
        const token = error ?? this.stack.pop();
        if (!token) {
          const message = "Tried to pop an empty stack";
          yield {
            type: "error",
            offset: this.offset,
            source: "",
            message
          };
        } else if (this.stack.length === 0) {
          yield token;
        } else {
          const top = this.peek(1);
          if (token.type === "block-scalar") {
            token.indent = "indent" in top ? top.indent : 0;
          } else if (token.type === "flow-collection" && top.type === "document") {
            token.indent = 0;
          }
          if (token.type === "flow-collection") fixFlowSeqItems(token);
          switch (top.type) {
            case "document":
              top.value = token;
              break;
            case "block-scalar":
              top.props.push(token);
              break;
            case "block-map": {
              const it = top.items[top.items.length - 1];
              if (it.value) {
                top.items.push({
                  start: [],
                  key: token,
                  sep: []
                });
                this.onKeyLine = true;
                return;
              } else if (it.sep) {
                it.value = token;
              } else {
                Object.assign(it, {
                  key: token,
                  sep: []
                });
                this.onKeyLine = !it.explicitKey;
                return;
              }
              break;
            }
            case "block-seq": {
              const it = top.items[top.items.length - 1];
              if (it.value) top.items.push({
                start: [],
                value: token
              });
              else it.value = token;
              break;
            }
            case "flow-collection": {
              const it = top.items[top.items.length - 1];
              if (!it || it.value) top.items.push({
                start: [],
                key: token,
                sep: []
              });
              else if (it.sep) it.value = token;
              else Object.assign(it, {
                key: token,
                sep: []
              });
              return;
            }
            /* istanbul ignore next should not happen */
            default:
              yield* this.pop();
              yield* this.pop(token);
          }
          if ((top.type === "document" || top.type === "block-map" || top.type === "block-seq") && (token.type === "block-map" || token.type === "block-seq")) {
            const last = token.items[token.items.length - 1];
            if (last && !last.sep && !last.value && last.start.length > 0 && findNonEmptyIndex(last.start) === -1 && (token.indent === 0 || last.start.every((st) => st.type !== "comment" || st.indent < token.indent))) {
              if (top.type === "document") top.end = last.start;
              else top.items.push({
                start: last.start
              });
              token.items.splice(-1, 1);
            }
          }
        }
      }
      *stream() {
        switch (this.type) {
          case "directive-line":
            yield {
              type: "directive",
              offset: this.offset,
              source: this.source
            };
            return;
          case "byte-order-mark":
          case "space":
          case "comment":
          case "newline":
            yield this.sourceToken;
            return;
          case "doc-mode":
          case "doc-start": {
            const doc = {
              type: "document",
              offset: this.offset,
              start: []
            };
            if (this.type === "doc-start") doc.start.push(this.sourceToken);
            this.stack.push(doc);
            return;
          }
        }
        yield {
          type: "error",
          offset: this.offset,
          message: `Unexpected ${this.type} token in YAML stream`,
          source: this.source
        };
      }
      *document(doc) {
        if (doc.value) return yield* this.lineEnd(doc);
        switch (this.type) {
          case "doc-start": {
            if (findNonEmptyIndex(doc.start) !== -1) {
              yield* this.pop();
              yield* this.step();
            } else doc.start.push(this.sourceToken);
            return;
          }
          case "anchor":
          case "tag":
          case "space":
          case "comment":
          case "newline":
            doc.start.push(this.sourceToken);
            return;
        }
        const bv = this.startBlockValue(doc);
        if (bv) this.stack.push(bv);
        else {
          yield {
            type: "error",
            offset: this.offset,
            message: `Unexpected ${this.type} token in YAML document`,
            source: this.source
          };
        }
      }
      *scalar(scalar) {
        if (this.type === "map-value-ind") {
          const prev = getPrevProps(this.peek(2));
          const start = getFirstKeyStartProps(prev);
          let sep;
          if (scalar.end) {
            sep = scalar.end;
            sep.push(this.sourceToken);
            delete scalar.end;
          } else sep = [
            this.sourceToken
          ];
          const map = {
            type: "block-map",
            offset: scalar.offset,
            indent: scalar.indent,
            items: [
              {
                start,
                key: scalar,
                sep
              }
            ]
          };
          this.onKeyLine = true;
          this.stack[this.stack.length - 1] = map;
        } else yield* this.lineEnd(scalar);
      }
      *blockScalar(scalar) {
        switch (this.type) {
          case "space":
          case "comment":
          case "newline":
            scalar.props.push(this.sourceToken);
            return;
          case "scalar":
            scalar.source = this.source;
            this.atNewLine = true;
            this.indent = 0;
            if (this.onNewLine) {
              let nl = this.source.indexOf("\n") + 1;
              while (nl !== 0) {
                this.onNewLine(this.offset + nl);
                nl = this.source.indexOf("\n", nl) + 1;
              }
            }
            yield* this.pop();
            break;
          /* istanbul ignore next should not happen */
          default:
            yield* this.pop();
            yield* this.step();
        }
      }
      *blockMap(map) {
        const it = map.items[map.items.length - 1];
        switch (this.type) {
          case "newline":
            this.onKeyLine = false;
            if (it.value) {
              const end = "end" in it.value ? it.value.end : void 0;
              const last = Array.isArray(end) ? end[end.length - 1] : void 0;
              if (last?.type === "comment") end?.push(this.sourceToken);
              else map.items.push({
                start: [
                  this.sourceToken
                ]
              });
            } else if (it.sep) {
              it.sep.push(this.sourceToken);
            } else {
              it.start.push(this.sourceToken);
            }
            return;
          case "space":
          case "comment":
            if (it.value) {
              map.items.push({
                start: [
                  this.sourceToken
                ]
              });
            } else if (it.sep) {
              it.sep.push(this.sourceToken);
            } else {
              if (this.atIndentedComment(it.start, map.indent)) {
                const prev = map.items[map.items.length - 2];
                const end = prev?.value?.end;
                if (Array.isArray(end)) {
                  Array.prototype.push.apply(end, it.start);
                  end.push(this.sourceToken);
                  map.items.pop();
                  return;
                }
              }
              it.start.push(this.sourceToken);
            }
            return;
        }
        if (this.indent >= map.indent) {
          const atMapIndent = !this.onKeyLine && this.indent === map.indent;
          const atNextItem = atMapIndent && (it.sep || it.explicitKey) && this.type !== "seq-item-ind";
          let start = [];
          if (atNextItem && it.sep && !it.value) {
            const nl = [];
            for (let i2 = 0; i2 < it.sep.length; ++i2) {
              const st = it.sep[i2];
              switch (st.type) {
                case "newline":
                  nl.push(i2);
                  break;
                case "space":
                  break;
                case "comment":
                  if (st.indent > map.indent) nl.length = 0;
                  break;
                default:
                  nl.length = 0;
              }
            }
            if (nl.length >= 2) start = it.sep.splice(nl[1]);
          }
          switch (this.type) {
            case "anchor":
            case "tag":
              if (atNextItem || it.value) {
                start.push(this.sourceToken);
                map.items.push({
                  start
                });
                this.onKeyLine = true;
              } else if (it.sep) {
                it.sep.push(this.sourceToken);
              } else {
                it.start.push(this.sourceToken);
              }
              return;
            case "explicit-key-ind":
              if (!it.sep && !it.explicitKey) {
                it.start.push(this.sourceToken);
                it.explicitKey = true;
              } else if (atNextItem || it.value) {
                start.push(this.sourceToken);
                map.items.push({
                  start,
                  explicitKey: true
                });
              } else {
                this.stack.push({
                  type: "block-map",
                  offset: this.offset,
                  indent: this.indent,
                  items: [
                    {
                      start: [
                        this.sourceToken
                      ],
                      explicitKey: true
                    }
                  ]
                });
              }
              this.onKeyLine = true;
              return;
            case "map-value-ind":
              if (it.explicitKey) {
                if (!it.sep) {
                  if (includesToken(it.start, "newline")) {
                    Object.assign(it, {
                      key: null,
                      sep: [
                        this.sourceToken
                      ]
                    });
                  } else {
                    const start2 = getFirstKeyStartProps(it.start);
                    this.stack.push({
                      type: "block-map",
                      offset: this.offset,
                      indent: this.indent,
                      items: [
                        {
                          start: start2,
                          key: null,
                          sep: [
                            this.sourceToken
                          ]
                        }
                      ]
                    });
                  }
                } else if (it.value) {
                  map.items.push({
                    start: [],
                    key: null,
                    sep: [
                      this.sourceToken
                    ]
                  });
                } else if (includesToken(it.sep, "map-value-ind")) {
                  this.stack.push({
                    type: "block-map",
                    offset: this.offset,
                    indent: this.indent,
                    items: [
                      {
                        start,
                        key: null,
                        sep: [
                          this.sourceToken
                        ]
                      }
                    ]
                  });
                } else if (isFlowToken(it.key) && !includesToken(it.sep, "newline")) {
                  const start2 = getFirstKeyStartProps(it.start);
                  const key = it.key;
                  const sep = it.sep;
                  sep.push(this.sourceToken);
                  delete it.key;
                  delete it.sep;
                  this.stack.push({
                    type: "block-map",
                    offset: this.offset,
                    indent: this.indent,
                    items: [
                      {
                        start: start2,
                        key,
                        sep
                      }
                    ]
                  });
                } else if (start.length > 0) {
                  it.sep = it.sep.concat(start, this.sourceToken);
                } else {
                  it.sep.push(this.sourceToken);
                }
              } else {
                if (!it.sep) {
                  Object.assign(it, {
                    key: null,
                    sep: [
                      this.sourceToken
                    ]
                  });
                } else if (it.value || atNextItem) {
                  map.items.push({
                    start,
                    key: null,
                    sep: [
                      this.sourceToken
                    ]
                  });
                } else if (includesToken(it.sep, "map-value-ind")) {
                  this.stack.push({
                    type: "block-map",
                    offset: this.offset,
                    indent: this.indent,
                    items: [
                      {
                        start: [],
                        key: null,
                        sep: [
                          this.sourceToken
                        ]
                      }
                    ]
                  });
                } else {
                  it.sep.push(this.sourceToken);
                }
              }
              this.onKeyLine = true;
              return;
            case "alias":
            case "scalar":
            case "single-quoted-scalar":
            case "double-quoted-scalar": {
              const fs = this.flowScalar(this.type);
              if (atNextItem || it.value) {
                map.items.push({
                  start,
                  key: fs,
                  sep: []
                });
                this.onKeyLine = true;
              } else if (it.sep) {
                this.stack.push(fs);
              } else {
                Object.assign(it, {
                  key: fs,
                  sep: []
                });
                this.onKeyLine = true;
              }
              return;
            }
            default: {
              const bv = this.startBlockValue(map);
              if (bv) {
                if (bv.type === "block-seq") {
                  if (!it.explicitKey && it.sep && !includesToken(it.sep, "newline")) {
                    yield* this.pop({
                      type: "error",
                      offset: this.offset,
                      message: "Unexpected block-seq-ind on same line with key",
                      source: this.source
                    });
                    return;
                  }
                } else if (atMapIndent) {
                  map.items.push({
                    start
                  });
                }
                this.stack.push(bv);
                return;
              }
            }
          }
        }
        yield* this.pop();
        yield* this.step();
      }
      *blockSequence(seq) {
        const it = seq.items[seq.items.length - 1];
        switch (this.type) {
          case "newline":
            if (it.value) {
              const end = "end" in it.value ? it.value.end : void 0;
              const last = Array.isArray(end) ? end[end.length - 1] : void 0;
              if (last?.type === "comment") end?.push(this.sourceToken);
              else seq.items.push({
                start: [
                  this.sourceToken
                ]
              });
            } else it.start.push(this.sourceToken);
            return;
          case "space":
          case "comment":
            if (it.value) seq.items.push({
              start: [
                this.sourceToken
              ]
            });
            else {
              if (this.atIndentedComment(it.start, seq.indent)) {
                const prev = seq.items[seq.items.length - 2];
                const end = prev?.value?.end;
                if (Array.isArray(end)) {
                  Array.prototype.push.apply(end, it.start);
                  end.push(this.sourceToken);
                  seq.items.pop();
                  return;
                }
              }
              it.start.push(this.sourceToken);
            }
            return;
          case "anchor":
          case "tag":
            if (it.value || this.indent <= seq.indent) break;
            it.start.push(this.sourceToken);
            return;
          case "seq-item-ind":
            if (this.indent !== seq.indent) break;
            if (it.value || includesToken(it.start, "seq-item-ind")) seq.items.push({
              start: [
                this.sourceToken
              ]
            });
            else it.start.push(this.sourceToken);
            return;
        }
        if (this.indent > seq.indent) {
          const bv = this.startBlockValue(seq);
          if (bv) {
            this.stack.push(bv);
            return;
          }
        }
        yield* this.pop();
        yield* this.step();
      }
      *flowCollection(fc) {
        const it = fc.items[fc.items.length - 1];
        if (this.type === "flow-error-end") {
          let top;
          do {
            yield* this.pop();
            top = this.peek(1);
          } while (top && top.type === "flow-collection");
        } else if (fc.end.length === 0) {
          switch (this.type) {
            case "comma":
            case "explicit-key-ind":
              if (!it || it.sep) fc.items.push({
                start: [
                  this.sourceToken
                ]
              });
              else it.start.push(this.sourceToken);
              return;
            case "map-value-ind":
              if (!it || it.value) fc.items.push({
                start: [],
                key: null,
                sep: [
                  this.sourceToken
                ]
              });
              else if (it.sep) it.sep.push(this.sourceToken);
              else Object.assign(it, {
                key: null,
                sep: [
                  this.sourceToken
                ]
              });
              return;
            case "space":
            case "comment":
            case "newline":
            case "anchor":
            case "tag":
              if (!it || it.value) fc.items.push({
                start: [
                  this.sourceToken
                ]
              });
              else if (it.sep) it.sep.push(this.sourceToken);
              else it.start.push(this.sourceToken);
              return;
            case "alias":
            case "scalar":
            case "single-quoted-scalar":
            case "double-quoted-scalar": {
              const fs = this.flowScalar(this.type);
              if (!it || it.value) fc.items.push({
                start: [],
                key: fs,
                sep: []
              });
              else if (it.sep) this.stack.push(fs);
              else Object.assign(it, {
                key: fs,
                sep: []
              });
              return;
            }
            case "flow-map-end":
            case "flow-seq-end":
              fc.end.push(this.sourceToken);
              return;
          }
          const bv = this.startBlockValue(fc);
          if (bv) this.stack.push(bv);
          else {
            yield* this.pop();
            yield* this.step();
          }
        } else {
          const parent = this.peek(2);
          if (parent.type === "block-map" && (this.type === "map-value-ind" && parent.indent === fc.indent || this.type === "newline" && !parent.items[parent.items.length - 1].sep)) {
            yield* this.pop();
            yield* this.step();
          } else if (this.type === "map-value-ind" && parent.type !== "flow-collection") {
            const prev = getPrevProps(parent);
            const start = getFirstKeyStartProps(prev);
            fixFlowSeqItems(fc);
            const sep = fc.end.splice(1, fc.end.length);
            sep.push(this.sourceToken);
            const map = {
              type: "block-map",
              offset: fc.offset,
              indent: fc.indent,
              items: [
                {
                  start,
                  key: fc,
                  sep
                }
              ]
            };
            this.onKeyLine = true;
            this.stack[this.stack.length - 1] = map;
          } else {
            yield* this.lineEnd(fc);
          }
        }
      }
      flowScalar(type) {
        if (this.onNewLine) {
          let nl = this.source.indexOf("\n") + 1;
          while (nl !== 0) {
            this.onNewLine(this.offset + nl);
            nl = this.source.indexOf("\n", nl) + 1;
          }
        }
        return {
          type,
          offset: this.offset,
          indent: this.indent,
          source: this.source
        };
      }
      startBlockValue(parent) {
        switch (this.type) {
          case "alias":
          case "scalar":
          case "single-quoted-scalar":
          case "double-quoted-scalar":
            return this.flowScalar(this.type);
          case "block-scalar-header":
            return {
              type: "block-scalar",
              offset: this.offset,
              indent: this.indent,
              props: [
                this.sourceToken
              ],
              source: ""
            };
          case "flow-map-start":
          case "flow-seq-start":
            return {
              type: "flow-collection",
              offset: this.offset,
              indent: this.indent,
              start: this.sourceToken,
              items: [],
              end: []
            };
          case "seq-item-ind":
            return {
              type: "block-seq",
              offset: this.offset,
              indent: this.indent,
              items: [
                {
                  start: [
                    this.sourceToken
                  ]
                }
              ]
            };
          case "explicit-key-ind": {
            this.onKeyLine = true;
            const prev = getPrevProps(parent);
            const start = getFirstKeyStartProps(prev);
            start.push(this.sourceToken);
            return {
              type: "block-map",
              offset: this.offset,
              indent: this.indent,
              items: [
                {
                  start,
                  explicitKey: true
                }
              ]
            };
          }
          case "map-value-ind": {
            this.onKeyLine = true;
            const prev = getPrevProps(parent);
            const start = getFirstKeyStartProps(prev);
            return {
              type: "block-map",
              offset: this.offset,
              indent: this.indent,
              items: [
                {
                  start,
                  key: null,
                  sep: [
                    this.sourceToken
                  ]
                }
              ]
            };
          }
        }
        return null;
      }
      atIndentedComment(start, indent) {
        if (this.type !== "comment") return false;
        if (this.indent <= indent) return false;
        return start.every((st) => st.type === "newline" || st.type === "space");
      }
      *documentEnd(docEnd) {
        if (this.type !== "doc-mode") {
          if (docEnd.end) docEnd.end.push(this.sourceToken);
          else docEnd.end = [
            this.sourceToken
          ];
          if (this.type === "newline") yield* this.pop();
        }
      }
      *lineEnd(token) {
        switch (this.type) {
          case "comma":
          case "doc-start":
          case "doc-end":
          case "flow-seq-end":
          case "flow-map-end":
          case "map-value-ind":
            yield* this.pop();
            yield* this.step();
            break;
          case "newline":
            this.onKeyLine = false;
          // fallthrough
          case "space":
          case "comment":
          default:
            if (token.end) token.end.push(this.sourceToken);
            else token.end = [
              this.sourceToken
            ];
            if (this.type === "newline") yield* this.pop();
        }
      }
    };
    exports.Parser = Parser;
  }
});

// ../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/public-api.js
var require_public_api = __commonJS({
  "../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/public-api.js"(exports) {
    "use strict";
    var composer = require_composer();
    var Document = require_Document();
    var errors = require_errors();
    var log = require_log();
    var identity = require_identity();
    var lineCounter = require_line_counter();
    var parser = require_parser();
    function parseOptions(options) {
      const prettyErrors = options.prettyErrors !== false;
      const lineCounter$1 = options.lineCounter || prettyErrors && new lineCounter.LineCounter() || null;
      return {
        lineCounter: lineCounter$1,
        prettyErrors
      };
    }
    function parseAllDocuments(source, options = {}) {
      const { lineCounter: lineCounter2, prettyErrors } = parseOptions(options);
      const parser$1 = new parser.Parser(lineCounter2?.addNewLine);
      const composer$1 = new composer.Composer(options);
      const docs = Array.from(composer$1.compose(parser$1.parse(source)));
      if (prettyErrors && lineCounter2) for (const doc of docs) {
        doc.errors.forEach(errors.prettifyError(source, lineCounter2));
        doc.warnings.forEach(errors.prettifyError(source, lineCounter2));
      }
      if (docs.length > 0) return docs;
      return Object.assign([], {
        empty: true
      }, composer$1.streamInfo());
    }
    function parseDocument(source, options = {}) {
      const { lineCounter: lineCounter2, prettyErrors } = parseOptions(options);
      const parser$1 = new parser.Parser(lineCounter2?.addNewLine);
      const composer$1 = new composer.Composer(options);
      let doc = null;
      for (const _doc of composer$1.compose(parser$1.parse(source), true, source.length)) {
        if (!doc) doc = _doc;
        else if (doc.options.logLevel !== "silent") {
          doc.errors.push(new errors.YAMLParseError(_doc.range.slice(0, 2), "MULTIPLE_DOCS", "Source contains multiple documents; please use YAML.parseAllDocuments()"));
          break;
        }
      }
      if (prettyErrors && lineCounter2) {
        doc.errors.forEach(errors.prettifyError(source, lineCounter2));
        doc.warnings.forEach(errors.prettifyError(source, lineCounter2));
      }
      return doc;
    }
    function parse(src, reviver, options) {
      let _reviver = void 0;
      if (typeof reviver === "function") {
        _reviver = reviver;
      } else if (options === void 0 && reviver && typeof reviver === "object") {
        options = reviver;
      }
      const doc = parseDocument(src, options);
      if (!doc) return null;
      doc.warnings.forEach((warning) => log.warn(doc.options.logLevel, warning));
      if (doc.errors.length > 0) {
        if (doc.options.logLevel !== "silent") throw doc.errors[0];
        else doc.errors = [];
      }
      return doc.toJS(Object.assign({
        reviver: _reviver
      }, options));
    }
    function stringify(value, replacer, options) {
      let _replacer = null;
      if (typeof replacer === "function" || Array.isArray(replacer)) {
        _replacer = replacer;
      } else if (options === void 0 && replacer) {
        options = replacer;
      }
      if (typeof options === "string") options = options.length;
      if (typeof options === "number") {
        const indent = Math.round(options);
        options = indent < 1 ? void 0 : indent > 8 ? {
          indent: 8
        } : {
          indent
        };
      }
      if (value === void 0) {
        const { keepUndefined } = options ?? replacer ?? {};
        if (!keepUndefined) return void 0;
      }
      if (identity.isDocument(value) && !_replacer) return value.toString(options);
      return new Document.Document(value, _replacer, options).toString(options);
    }
    exports.parse = parse;
    exports.parseAllDocuments = parseAllDocuments;
    exports.parseDocument = parseDocument;
    exports.stringify = stringify;
  }
});

// ../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/index.js
var require_dist2 = __commonJS({
  "../../../../../node_modules/.deno/yaml@2.8.0/node_modules/yaml/dist/index.js"(exports) {
    "use strict";
    var composer = require_composer();
    var Document = require_Document();
    var Schema = require_Schema();
    var errors = require_errors();
    var Alias = require_Alias();
    var identity = require_identity();
    var Pair = require_Pair();
    var Scalar = require_Scalar();
    var YAMLMap = require_YAMLMap();
    var YAMLSeq = require_YAMLSeq();
    var cst = require_cst();
    var lexer = require_lexer();
    var lineCounter = require_line_counter();
    var parser = require_parser();
    var publicApi = require_public_api();
    var visit = require_visit();
    exports.Composer = composer.Composer;
    exports.Document = Document.Document;
    exports.Schema = Schema.Schema;
    exports.YAMLError = errors.YAMLError;
    exports.YAMLParseError = errors.YAMLParseError;
    exports.YAMLWarning = errors.YAMLWarning;
    exports.Alias = Alias.Alias;
    exports.isAlias = identity.isAlias;
    exports.isCollection = identity.isCollection;
    exports.isDocument = identity.isDocument;
    exports.isMap = identity.isMap;
    exports.isNode = identity.isNode;
    exports.isPair = identity.isPair;
    exports.isScalar = identity.isScalar;
    exports.isSeq = identity.isSeq;
    exports.Pair = Pair.Pair;
    exports.Scalar = Scalar.Scalar;
    exports.YAMLMap = YAMLMap.YAMLMap;
    exports.YAMLSeq = YAMLSeq.YAMLSeq;
    exports.CST = cst;
    exports.Lexer = lexer.Lexer;
    exports.LineCounter = lineCounter.LineCounter;
    exports.Parser = parser.Parser;
    exports.parse = publicApi.parse;
    exports.parseAllDocuments = publicApi.parseAllDocuments;
    exports.parseDocument = publicApi.parseDocument;
    exports.stringify = publicApi.stringify;
    exports.visit = visit.visit;
    exports.visitAsync = visit.visitAsync;
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/support/Support.js
var require_Support = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/support/Support.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
          enumerable: true,
          get: function() {
            return m[k];
          }
        };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
      });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || /* @__PURE__ */ function() {
      var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      };
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i2 = 0; i2 < k.length; i2++) if (k[i2] !== "default") __createBinding(result, mod, k[i2]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.isStringMap = isStringMap;
    exports.checkString = checkString;
    exports.checkStringMap = checkStringMap;
    exports.checkArray = checkArray;
    exports.defined = defined;
    exports.nonNull = nonNull;
    exports.assertNever = assertNever;
    exports.assert = assert;
    exports.panic = panic;
    exports.mustNotHappen = mustNotHappen;
    exports.repeated = repeated;
    exports.repeatedCall = repeatedCall;
    exports.errorMessage = errorMessage;
    exports.inflateBase64 = inflateBase64;
    exports.parseJSON = parseJSON;
    exports.indentationString = indentationString;
    exports.numberEnumValues = numberEnumValues;
    var js_base64_1 = require_base64();
    var pako = __importStar(require_pako());
    var YAML = __importStar(require_dist2());
    var Messages_1 = require_Messages();
    function isStringMap(x, checkValue) {
      if (typeof x !== "object" || Array.isArray(x) || x === null) {
        return false;
      }
      if (checkValue !== void 0) {
        for (const k of Object.getOwnPropertyNames(x)) {
          const v = x[k];
          if (!checkValue(v)) {
            return false;
          }
        }
      }
      return true;
    }
    function checkString(x) {
      return typeof x === "string";
    }
    function checkStringMap(x, checkValue) {
      if (checkValue && isStringMap(x, checkValue)) {
        return x;
      }
      if (isStringMap(x)) {
        return x;
      }
      return panic(`Value must be an object, but is ${x}`);
    }
    function checkArray(x, checkItem) {
      if (!Array.isArray(x)) {
        return panic(`Value must be an array, but is ${x}`);
      }
      if (checkItem !== void 0) {
        for (const v of x) {
          if (!checkItem(v)) {
            return panic(`Array item does not satisfy constraint: ${v}`);
          }
        }
      }
      return x;
    }
    function defined(x) {
      if (x !== void 0) return x;
      return panic("Defined value expected, but got undefined");
    }
    function nonNull(x) {
      if (x !== null) return x;
      return panic("Non-null value expected, but got null");
    }
    function assertNever(x) {
      return (0, Messages_1.messageError)("InternalError", {
        message: `Unexpected object ${x}`
      });
    }
    function assert(condition, message = "Assertion failed") {
      if (!condition) {
        return (0, Messages_1.messageError)("InternalError", {
          message
        });
      }
    }
    function panic(message) {
      return (0, Messages_1.messageError)("InternalError", {
        message
      });
    }
    function mustNotHappen() {
      return panic("This must not happen");
    }
    function repeated(n, value) {
      const arr = [];
      for (let i2 = 0; i2 < n; i2++) {
        arr.push(value);
      }
      return arr;
    }
    function repeatedCall(n, producer) {
      const arr = [];
      for (let i2 = 0; i2 < n; i2++) {
        arr.push(producer());
      }
      return arr;
    }
    function errorMessage(e) {
      if (e instanceof Error) {
        return e.message;
      }
      return e.toString();
    }
    function inflateBase64(encoded) {
      const bytes = js_base64_1.Base64.atob(encoded);
      return pako.inflate(bytes, {
        to: "string"
      });
    }
    function parseJSON(text, description, address = "<unknown>") {
      try {
        if (text.charCodeAt(0) === 65279) {
          text = text.slice(1);
        }
        return YAML.parse(text);
      } catch (e) {
        let message;
        if (e instanceof SyntaxError) {
          message = e.message;
        } else {
          message = `Unknown exception ${e}`;
        }
        return (0, Messages_1.messageError)("MiscJSONParseError", {
          description,
          address,
          message
        });
      }
    }
    function indentationString(level) {
      return "  ".repeat(level);
    }
    function numberEnumValues(e) {
      const result = [];
      for (const k of Object.keys(e)) {
        const v = e[k];
        if (typeof v === "number") {
          result.push(v);
        }
      }
      return result;
    }
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/support/Strings.js
var require_Strings = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/support/Strings.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : {
        "default": mod
      };
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.fastIsUpperCase = exports.stringEscape = exports.utf16StringEscape = void 0;
    exports.utf16ConcatMap = utf16ConcatMap;
    exports.utf32ConcatMap = utf32ConcatMap;
    exports.utf16LegalizeCharacters = utf16LegalizeCharacters;
    exports.legalizeCharacters = legalizeCharacters;
    exports.repeatString = repeatString;
    exports.intToHex = intToHex;
    exports.standardUnicodeHexEscape = standardUnicodeHexEscape;
    exports.escapeNonPrintableMapper = escapeNonPrintableMapper;
    exports.isPrintable = isPrintable;
    exports.isAscii = isAscii;
    exports.isLetter = isLetter;
    exports.isDigit = isDigit;
    exports.isNumeric = isNumeric;
    exports.isLetterOrDigit = isLetterOrDigit;
    exports.isLetterOrUnderscore = isLetterOrUnderscore;
    exports.isLetterOrUnderscoreOrDigit = isLetterOrUnderscoreOrDigit;
    exports.isWordCharacter = isWordCharacter;
    exports.trimEnd = trimEnd;
    exports.capitalize = capitalize;
    exports.decapitalize = decapitalize;
    exports.pascalCase = pascalCase;
    exports.camelCase = camelCase;
    exports.snakeCase = snakeCase;
    exports.startWithLetter = startWithLetter;
    exports.splitIntoWords = splitIntoWords;
    exports.firstUpperWordStyle = firstUpperWordStyle;
    exports.allUpperWordStyle = allUpperWordStyle;
    exports.originalWord = originalWord;
    exports.allLowerWordStyle = allLowerWordStyle;
    exports.combineWords = combineWords;
    exports.addPrefixIfNecessary = addPrefixIfNecessary;
    exports.makeNameStyle = makeNameStyle;
    var unicode_properties_1 = __importDefault(require_main());
    var Messages_1 = require_Messages();
    var Acronyms_const_1 = require_Acronyms_const();
    var Support_1 = require_Support();
    function computeAsciiMap(mapper) {
      const charStringMap = [];
      const charNoEscapeMap = [];
      for (let i2 = 0; i2 < 128; i2++) {
        let noEscape = 0;
        const result = mapper(i2);
        if (result === String.fromCharCode(i2)) {
          noEscape = 1;
        }
        charStringMap.push(result);
        charNoEscapeMap.push(noEscape);
      }
      return {
        charStringMap,
        charNoEscapeMap
      };
    }
    function precomputedCodePointPredicate(p) {
      const asciiResults = [];
      for (let cp = 0; cp < 128; cp++) {
        asciiResults.push(p(cp));
      }
      return (cp) => cp < 128 ? asciiResults[cp] : p(cp);
    }
    function utf16ConcatMap(mapper) {
      const { charStringMap, charNoEscapeMap } = computeAsciiMap(mapper);
      return function stringConcatMap_inner(s) {
        let cs = null;
        let start = 0;
        let i2 = 0;
        while (i2 < s.length) {
          const cc = s.charCodeAt(i2);
          if (charNoEscapeMap[cc] !== 1) {
            if (cs === null) cs = [];
            cs.push(s.substring(start, i2));
            const str = charStringMap[cc];
            if (str === void 0) {
              cs.push(mapper(s.charCodeAt(i2)));
            } else {
              cs.push(str);
            }
            start = i2 + 1;
          }
          i2++;
        }
        if (cs === null) return s;
        cs.push(s.substring(start, i2));
        return cs.join("");
      };
    }
    function isHighSurrogate(cc) {
      return cc >= 55296 && cc <= 56319;
    }
    function isLowSurrogate(cc) {
      return cc >= 56320 && cc <= 57343;
    }
    function utf32ConcatMap(mapper) {
      const { charStringMap, charNoEscapeMap } = computeAsciiMap(mapper);
      return function stringConcatMap_inner(s) {
        let cs = null;
        let start = 0;
        let i2 = 0;
        while (i2 < s.length) {
          let cc = s.charCodeAt(i2);
          if (charNoEscapeMap[cc] !== 1) {
            if (cs === null) cs = [];
            cs.push(s.substring(start, i2));
            if (isHighSurrogate(cc)) {
              const highSurrogate = cc;
              i2++;
              const lowSurrogate = s.charCodeAt(i2);
              (0, Messages_1.messageAssert)(isLowSurrogate(lowSurrogate), "MiscUnicodeHighSurrogateWithoutLowSurrogate", {});
              const highBits = highSurrogate - 55296;
              const lowBits = lowSurrogate - 56320;
              cc = 65536 + lowBits + (highBits << 10);
            }
            const str = charStringMap[cc];
            if (str === void 0) {
              cs.push(mapper(cc));
            } else {
              cs.push(str);
            }
            start = i2 + 1;
          }
          i2++;
        }
        if (cs === null) return s;
        cs.push(s.substring(start, i2));
        return cs.join("");
      };
    }
    function utf16LegalizeCharacters(isLegal) {
      return utf16ConcatMap((u) => isLegal(u) ? String.fromCharCode(u) : "");
    }
    function legalizeCharacters(isLegal) {
      return utf32ConcatMap((u) => u <= 65535 && isLegal(u) ? String.fromCharCode(u) : "");
    }
    function repeatString(s, n) {
      (0, Support_1.assert)(n >= 0, "Cannot repeat a string a negative number of times");
      if (n === 0) return "";
      let result = "";
      do {
        if (n % 2 !== 0) {
          result += s;
        }
        n = Math.floor(n / 2);
        if (n > 0) {
          s += s;
        }
      } while (n > 0);
      return result;
    }
    function intToHex(i2, width) {
      const str = i2.toString(16);
      if (str.length >= width) return str;
      return repeatString("0", width - str.length) + str;
    }
    function standardUnicodeHexEscape(codePoint) {
      if (codePoint <= 65535) {
        return "\\u" + intToHex(codePoint, 4);
      } else {
        return "\\U" + intToHex(codePoint, 8);
      }
    }
    function escapeNonPrintableMapper(printablePredicate, escaper) {
      function mapper(u) {
        switch (u) {
          case 92:
            return "\\\\";
          case 34:
            return '\\"';
          case 10:
            return "\\n";
          case 9:
            return "\\t";
          default:
            if (printablePredicate(u)) {
              return String.fromCharCode(u);
            }
            return escaper(u);
        }
      }
      return mapper;
    }
    exports.utf16StringEscape = utf16ConcatMap(escapeNonPrintableMapper(isPrintable, standardUnicodeHexEscape));
    exports.stringEscape = utf32ConcatMap(escapeNonPrintableMapper(isPrintable, standardUnicodeHexEscape));
    function isPrintable(codePoint) {
      if (codePoint > 65535) return false;
      const category = unicode_properties_1.default.getCategory(codePoint);
      return [
        "Mc",
        "No",
        "Sk",
        "Me",
        "Nd",
        "Po",
        "Lt",
        "Pc",
        "Sm",
        "Zs",
        "Lu",
        "Pd",
        "So",
        "Pe",
        "Pf",
        "Ps",
        "Sc",
        "Ll",
        "Lm",
        "Pi",
        "Nl",
        "Mn",
        "Lo"
      ].includes(category);
    }
    function isAscii(codePoint) {
      return codePoint < 128;
    }
    function isLetter(codePoint) {
      const category = unicode_properties_1.default.getCategory(codePoint);
      return [
        "Lu",
        "Ll",
        "Lt",
        "Lo"
      ].includes(category);
    }
    function isDigit(codePoint) {
      const category = unicode_properties_1.default.getCategory(codePoint);
      return [
        "Nd"
      ].includes(category);
    }
    function isNumeric(codePoint) {
      const category = unicode_properties_1.default.getCategory(codePoint);
      return [
        "No",
        "Nd",
        "Nl"
      ].includes(category);
    }
    function isLetterOrDigit(codePoint) {
      return isLetter(codePoint) || isDigit(codePoint);
    }
    function isLetterOrUnderscore(codePoint) {
      return isLetter(codePoint) || codePoint === 95;
    }
    function isLetterOrUnderscoreOrDigit(codePoint) {
      return isLetterOrUnderscore(codePoint) || isDigit(codePoint);
    }
    function isWordCharacter(codePoint) {
      return isLetter(codePoint) || isDigit(codePoint);
    }
    function trimEnd(str) {
      const l = str.length;
      let firstWS = l;
      for (let i2 = l - 1; i2 >= 0; i2--) {
        if (!unicode_properties_1.default.isWhiteSpace(str.charCodeAt(i2))) break;
        firstWS = i2;
      }
      if (firstWS === l) return str;
      return str.slice(0, firstWS);
    }
    function modifyFirstChar(f, s) {
      if (s === "") return s;
      return f(s[0]) + s.slice(1);
    }
    function capitalize(str) {
      return modifyFirstChar((c) => c.toUpperCase(), str);
    }
    function decapitalize(str) {
      return modifyFirstChar((c) => c.toLowerCase(), str);
    }
    var wordSeparatorRegex = /[-_. ]+/;
    function pascalCase(str) {
      const words = str.split(wordSeparatorRegex).map(capitalize);
      return words.join("");
    }
    function camelCase(str) {
      return decapitalize(pascalCase(str));
    }
    function snakeCase(str) {
      const words = splitIntoWords(str).map(({ word }) => word.toLowerCase());
      return words.join("_");
    }
    function startWithLetter(isAllowedStart, upper, str) {
      const modify = upper ? capitalize : decapitalize;
      if (str === "") return modify("empty");
      if (isAllowedStart(str.charCodeAt(0))) return modify(str);
      return modify("the" + str);
    }
    var knownAcronyms = new Set(Acronyms_const_1.acronyms);
    var fastIsWordCharacter = precomputedCodePointPredicate(isWordCharacter);
    var fastIsNonWordCharacter = precomputedCodePointPredicate((cp) => !isWordCharacter(cp));
    var fastIsLowerCase = precomputedCodePointPredicate((cp) => unicode_properties_1.default.isLowerCase(cp));
    exports.fastIsUpperCase = precomputedCodePointPredicate((cp) => unicode_properties_1.default.isUpperCase(cp));
    var fastNonLetter = precomputedCodePointPredicate((cp) => !unicode_properties_1.default.isLowerCase(cp) && !unicode_properties_1.default.isUpperCase(cp));
    var fastIsDigit = precomputedCodePointPredicate(isDigit);
    function splitIntoWords(s) {
      const intervals = [];
      let intervalStart = void 0;
      const len = s.length;
      let i2 = 0;
      let lastLowerCaseIndex = void 0;
      function atEnd() {
        return i2 >= len;
      }
      function currentCodePoint() {
        return (0, Support_1.defined)(s.codePointAt(i2));
      }
      function skipWhile(p) {
        while (!atEnd()) {
          const cp = currentCodePoint();
          if (!p(cp)) break;
          if (fastIsLowerCase(cp)) lastLowerCaseIndex = i2;
          i2++;
        }
      }
      function skipNonWord() {
        skipWhile(fastIsNonWordCharacter);
      }
      function skipLowerCase() {
        skipWhile(fastIsLowerCase);
      }
      function skipUpperCase() {
        skipWhile(exports.fastIsUpperCase);
      }
      function skipNonLetter() {
        skipWhile(fastNonLetter);
      }
      function skipDigits() {
        skipWhile(fastIsDigit);
      }
      function startInterval() {
        (0, Support_1.assert)(intervalStart === void 0, "Interval started before last one was committed");
        intervalStart = i2;
      }
      function commitInterval() {
        if (intervalStart === void 0) {
          return (0, Support_1.panic)("Tried to commit interval without starting one");
        }
        (0, Support_1.assert)(i2 > intervalStart, "Interval must be non-empty");
        if (!atEnd() && isLowSurrogate(currentCodePoint())) {
          i2 += 1;
        }
        const allUpper = lastLowerCaseIndex === void 0 || lastLowerCaseIndex < intervalStart;
        intervals.push([
          intervalStart,
          i2,
          allUpper
        ]);
        intervalStart = void 0;
      }
      function intervalLength() {
        if (intervalStart === void 0) {
          return (0, Support_1.panic)("Tried to get interval length without starting one");
        }
        return i2 - intervalStart;
      }
      for (; ; ) {
        skipNonWord();
        if (atEnd()) break;
        startInterval();
        if (fastIsLowerCase(currentCodePoint())) {
          skipLowerCase();
          skipDigits();
          commitInterval();
        } else if ((0, exports.fastIsUpperCase)(currentCodePoint())) {
          skipUpperCase();
          if (atEnd()) {
            commitInterval();
          } else if (intervalLength() === 1) {
            skipLowerCase();
            skipDigits();
            commitInterval();
          } else if (isDigit(currentCodePoint())) {
            skipDigits();
            commitInterval();
          } else {
            if (fastIsWordCharacter(currentCodePoint())) {
              i2 -= 1;
            }
            commitInterval();
          }
        } else {
          skipNonLetter();
          commitInterval();
        }
      }
      const words = [];
      for (const [start, end, allUpper] of intervals) {
        const word = s.slice(start, end);
        const isAcronym = lastLowerCaseIndex !== void 0 && allUpper || knownAcronyms.has(word.toLowerCase());
        words.push({
          word,
          isAcronym
        });
      }
      return words;
    }
    function firstUpperWordStyle(s) {
      (0, Support_1.assert)(s.length > 0, "Cannot style an empty string");
      return s[0].toUpperCase() + s.slice(1).toLowerCase();
    }
    function allUpperWordStyle(s) {
      return s.toUpperCase();
    }
    function originalWord(s) {
      return s;
    }
    function allLowerWordStyle(s) {
      return s.toLowerCase();
    }
    function styleWord(style, word) {
      (0, Support_1.assert)(word.length > 0, "Tried to style an empty word");
      const result = style(word);
      (0, Support_1.assert)(result.length > 0, "Word style must not make word empty");
      return result;
    }
    function combineWords(words, removeInvalidCharacters, firstWordStyle, restWordStyle, firstWordAcronymStyle, restAcronymStyle, separator, isStartCharacter) {
      const legalizedWords = [];
      for (const w of words) {
        const word = removeInvalidCharacters(w.word);
        if (word.length === 0) continue;
        legalizedWords.push({
          word,
          isAcronym: w.isAcronym
        });
      }
      if (legalizedWords.length === 0) {
        const validEmpty = removeInvalidCharacters("empty");
        (0, Support_1.assert)(validEmpty.length > 0, 'Word "empty" is invalid in target language');
        legalizedWords.push({
          word: validEmpty,
          isAcronym: false
        });
      }
      const styledWords = [];
      const first = legalizedWords[0];
      const firstStyle = first.isAcronym ? firstWordAcronymStyle : firstWordStyle;
      const styledFirstWord = styleWord(firstStyle, first.word);
      let restWords;
      if (!isStartCharacter((0, Support_1.defined)(styledFirstWord.codePointAt(0)))) {
        const validThe = removeInvalidCharacters("the");
        (0, Support_1.assert)(validThe.length > 0, 'Word "the" is invalid in the target language');
        const styledThe = styleWord(firstWordStyle, validThe);
        (0, Support_1.assert)(isStartCharacter((0, Support_1.defined)(styledThe.codePointAt(0))), 'The first character of styling "the" is not a start character');
        styledWords.push(styledThe);
        restWords = legalizedWords;
      } else {
        styledWords.push(styledFirstWord);
        restWords = legalizedWords.slice(1);
      }
      for (const w of restWords) {
        const style = w.isAcronym ? restAcronymStyle : restWordStyle;
        styledWords.push(styleWord(style, w.word));
      }
      return styledWords.join(separator);
    }
    function addPrefixIfNecessary(prefix, name) {
      return name.startsWith(prefix) ? name : prefix + name;
    }
    function makeNameStyle(namingStyle, legalizeName, prefix) {
      let separator;
      let firstWordStyle;
      let restWordStyle;
      let firstWordAcronymStyle;
      let restAcronymStyle;
      if (namingStyle === "pascal" || namingStyle === "camel" || namingStyle === "pascal-upper-acronyms" || namingStyle === "camel-upper-acronyms") {
        separator = "";
        if (namingStyle === "pascal-upper-acronyms" || namingStyle === "camel-upper-acronyms") {
          restWordStyle = firstUpperWordStyle;
          restAcronymStyle = allUpperWordStyle;
        } else {
          restWordStyle = restAcronymStyle = firstUpperWordStyle;
        }
      } else {
        separator = "_";
      }
      switch (namingStyle) {
        case "pascal":
        case "pascal-upper-acronyms":
          firstWordStyle = firstWordAcronymStyle = firstUpperWordStyle;
          break;
        case "camel":
        case "camel-upper-acronyms":
          firstWordStyle = firstWordAcronymStyle = allLowerWordStyle;
          break;
        case "underscore":
          firstWordStyle = restWordStyle = firstWordAcronymStyle = restAcronymStyle = allLowerWordStyle;
          break;
        case "upper-underscore":
          firstWordStyle = restWordStyle = firstWordAcronymStyle = restAcronymStyle = allUpperWordStyle;
          break;
        default:
          return (0, Support_1.assertNever)(namingStyle);
      }
      return (original) => {
        const words = splitIntoWords(original);
        const styledName = combineWords(words, legalizeName, firstWordStyle, restWordStyle, firstWordAcronymStyle, restAcronymStyle, separator, isLetterOrUnderscore);
        if (prefix !== void 0) {
          return addPrefixIfNecessary(prefix, styledName);
        } else {
          return styledName;
        }
      };
    }
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/attributes/TypeAttributes.js
var require_TypeAttributes = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/attributes/TypeAttributes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.emptyTypeAttributes = exports.TypeAttributeKind = void 0;
    exports.combineTypeAttributes = combineTypeAttributes;
    exports.makeTypeAttributesInferred = makeTypeAttributesInferred;
    exports.increaseTypeAttributesDistance = increaseTypeAttributesDistance;
    var collection_utils_1 = require_dist();
    var Support_1 = require_Support();
    var TypeAttributeKind = class _TypeAttributeKind {
      constructor(name) {
        this.name = name;
      }
      appliesToTypeKind(kind) {
        return kind !== "any";
      }
      combine(_attrs) {
        return (0, Support_1.panic)(`Cannot combine type attribute ${this.name}`);
      }
      intersect(attrs) {
        return this.combine(attrs);
      }
      makeInferred(_) {
        return (0, Support_1.panic)(`Cannot make type attribute ${this.name} inferred`);
      }
      increaseDistance(attrs) {
        return attrs;
      }
      addToSchema(_schema, _t, _attrs) {
        return;
      }
      children(_) {
        return /* @__PURE__ */ new Set();
      }
      stringify(_) {
        return void 0;
      }
      get inIdentity() {
        return false;
      }
      requiresUniqueIdentity(_) {
        return false;
      }
      reconstitute(_builder, a) {
        return a;
      }
      makeAttributes(value) {
        const kvps = [
          [
            this,
            value
          ]
        ];
        return new Map(kvps);
      }
      tryGetInAttributes(a) {
        return a.get(this);
      }
      setInAttributes(a, value) {
        return new Map(a).set(this, value);
      }
      modifyInAttributes(a, modify) {
        const modified = modify(this.tryGetInAttributes(a));
        if (modified === void 0) {
          const result = new Map(a);
          result.delete(this);
          return result;
        }
        return this.setInAttributes(a, modified);
      }
      setDefaultInAttributes(a, makeDefault) {
        if (this.tryGetInAttributes(a) !== void 0) return a;
        return this.modifyInAttributes(a, makeDefault);
      }
      removeInAttributes(a) {
        return (0, collection_utils_1.mapFilter)(a, (_, k) => k !== this);
      }
      equals(other) {
        if (!(other instanceof _TypeAttributeKind)) {
          return false;
        }
        return this.name === other.name;
      }
      hashCode() {
        return (0, collection_utils_1.hashString)(this.name);
      }
    };
    exports.TypeAttributeKind = TypeAttributeKind;
    exports.emptyTypeAttributes = /* @__PURE__ */ new Map();
    function combineTypeAttributes(combinationKind, firstOrArray, second) {
      const union = combinationKind === "union";
      let attributeArray;
      if (Array.isArray(firstOrArray)) {
        attributeArray = firstOrArray;
      } else {
        if (second === void 0) {
          return (0, Support_1.panic)("Must have on array or two attributes");
        }
        attributeArray = [
          firstOrArray,
          second
        ];
      }
      const attributesByKind = (0, collection_utils_1.mapTranspose)(attributeArray);
      function combine(attrs, kind) {
        (0, Support_1.assert)(attrs.length > 0, "Cannot combine zero type attributes");
        if (attrs.length === 1) return attrs[0];
        if (union) {
          return kind.combine(attrs);
        } else {
          return kind.intersect(attrs);
        }
      }
      return (0, collection_utils_1.mapFilterMap)(attributesByKind, combine);
    }
    function makeTypeAttributesInferred(attr) {
      return (0, collection_utils_1.mapFilterMap)(attr, (value, kind) => kind.makeInferred(value));
    }
    function increaseTypeAttributesDistance(attr) {
      return (0, collection_utils_1.mapFilterMap)(attr, (value, kind) => kind.increaseDistance(value));
    }
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/attributes/TypeNames.js
var require_TypeNames = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/attributes/TypeNames.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
          enumerable: true,
          get: function() {
            return m[k];
          }
        };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
      });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || /* @__PURE__ */ function() {
      var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      };
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i2 = 0; i2 < k.length; i2++) if (k[i2] !== "default") __createBinding(result, mod, k[i2]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.namesTypeAttributeKind = exports.TooManyTypeNames = exports.RegularTypeNames = exports.TypeNames = exports.tooManyNamesThreshold = void 0;
    exports.initTypeNames = initTypeNames;
    exports.modifyTypeNames = modifyTypeNames;
    exports.singularizeTypeNames = singularizeTypeNames;
    exports.makeNamesTypeAttributes = makeNamesTypeAttributes;
    var collection_utils_1 = require_dist();
    var pluralize = __importStar(require_pluralize());
    var Chance_1 = require_Chance();
    var Strings_1 = require_Strings();
    var Support_1 = require_Support();
    var TypeAttributes_1 = require_TypeAttributes();
    var chance;
    var usedRandomNames;
    function initTypeNames() {
      chance = new Chance_1.Chance(31415);
      usedRandomNames = /* @__PURE__ */ new Set();
    }
    initTypeNames();
    function makeRandomName() {
      for (; ; ) {
        const name = `${chance.city()} ${chance.animal()}`;
        if (usedRandomNames.has(name)) continue;
        usedRandomNames.add(name);
        return name;
      }
    }
    function combineNames(names) {
      const originalFirst = (0, collection_utils_1.iterableFirst)(names);
      if (originalFirst === void 0) {
        return (0, Support_1.panic)("Named type has no names");
      }
      if (names.size === 1) {
        return originalFirst;
      }
      const namesSet = (0, collection_utils_1.setMap)(names, (s) => (0, Strings_1.splitIntoWords)(s).map((w) => w.word.toLowerCase()).join("_"));
      const first = (0, Support_1.defined)((0, collection_utils_1.iterableFirst)(namesSet));
      if (namesSet.size === 1) {
        return first;
      }
      let prefixLength = first.length;
      let suffixLength = first.length;
      for (const n of (0, collection_utils_1.iterableSkip)(namesSet, 1)) {
        prefixLength = Math.min(prefixLength, n.length);
        for (let i2 = 0; i2 < prefixLength; i2++) {
          if (first[i2] !== n[i2]) {
            prefixLength = i2;
            break;
          }
        }
        suffixLength = Math.min(suffixLength, n.length);
        for (let i2 = 0; i2 < suffixLength; i2++) {
          if (first[first.length - i2 - 1] !== n[n.length - i2 - 1]) {
            suffixLength = i2;
            break;
          }
        }
      }
      const prefix = prefixLength > 2 ? first.slice(0, prefixLength) : "";
      const suffix = suffixLength > 2 ? first.slice(first.length - suffixLength) : "";
      const combined = prefix + suffix;
      if (combined.length > 2) {
        return combined;
      }
      return first;
    }
    exports.tooManyNamesThreshold = 1e3;
    var TypeNames = class _TypeNames {
      static makeWithDistance(names, alternativeNames, distance) {
        if (names.size >= exports.tooManyNamesThreshold) {
          return new TooManyTypeNames(distance);
        }
        if (alternativeNames === void 0 || alternativeNames.size > exports.tooManyNamesThreshold) {
          alternativeNames = void 0;
        }
        return new RegularTypeNames(names, alternativeNames, distance);
      }
      static make(names, alternativeNames, areInferred) {
        return _TypeNames.makeWithDistance(names, alternativeNames, areInferred ? 1 : 0);
      }
      constructor(distance) {
        this.distance = distance;
      }
      get areInferred() {
        return this.distance > 0;
      }
    };
    exports.TypeNames = TypeNames;
    var RegularTypeNames = class _RegularTypeNames extends TypeNames {
      constructor(names, _alternativeNames, distance) {
        super(distance);
        this.names = names;
        this._alternativeNames = _alternativeNames;
      }
      add(namesArray, startIndex = 0) {
        let newNames = new Set(this.names);
        let newDistance = this.distance;
        let newAlternativeNames = (0, collection_utils_1.definedMap)(this._alternativeNames, (s) => new Set(s));
        for (let i2 = startIndex; i2 < namesArray.length; i2++) {
          const other = namesArray[i2];
          if (other instanceof _RegularTypeNames && other._alternativeNames !== void 0) {
            if (newAlternativeNames === void 0) {
              newAlternativeNames = /* @__PURE__ */ new Set();
            }
            (0, collection_utils_1.setUnionInto)(newAlternativeNames, other._alternativeNames);
          }
          if (other.distance > newDistance) continue;
          if (!(other instanceof _RegularTypeNames)) {
            (0, Support_1.assert)(other instanceof TooManyTypeNames, "Unknown TypeNames instance");
            return other.add(namesArray, i2 + 1);
          }
          if (other.distance < newDistance) {
            newNames = new Set(other.names);
            newDistance = other.distance;
            newAlternativeNames = (0, collection_utils_1.definedMap)(other._alternativeNames, (s) => new Set(s));
          } else {
            (0, Support_1.assert)(other.distance === newDistance, "This should be the only case left");
            (0, collection_utils_1.setUnionInto)(newNames, other.names);
          }
        }
        return TypeNames.makeWithDistance(newNames, newAlternativeNames, newDistance);
      }
      clearInferred() {
        const newNames = this.areInferred ? /* @__PURE__ */ new Set() : this.names;
        return TypeNames.makeWithDistance(newNames, /* @__PURE__ */ new Set(), this.distance);
      }
      get combinedName() {
        return combineNames(this.names);
      }
      get proposedNames() {
        const set = /* @__PURE__ */ new Set([
          this.combinedName
        ]);
        if (this._alternativeNames === void 0) {
          return set;
        }
        (0, collection_utils_1.setUnionInto)(set, this._alternativeNames);
        return set;
      }
      makeInferred() {
        return TypeNames.makeWithDistance(this.names, this._alternativeNames, this.distance + 1);
      }
      singularize() {
        return TypeNames.makeWithDistance((0, collection_utils_1.setMap)(this.names, pluralize.singular), (0, collection_utils_1.definedMap)(this._alternativeNames, (an) => (0, collection_utils_1.setMap)(an, pluralize.singular)), this.distance + 1);
      }
      toString() {
        const inferred = this.areInferred ? `distance ${this.distance}` : "given";
        const names = `${inferred} ${Array.from(this.names).join(",")}`;
        if (this._alternativeNames === void 0) {
          return names;
        }
        return `${names} (${Array.from(this._alternativeNames).join(",")})`;
      }
    };
    exports.RegularTypeNames = RegularTypeNames;
    var TooManyTypeNames = class _TooManyTypeNames extends TypeNames {
      constructor(distance, name) {
        super(distance);
        if (name === void 0) {
          name = makeRandomName();
        }
        this.names = /* @__PURE__ */ new Set([
          name
        ]);
      }
      get combinedName() {
        return (0, Support_1.defined)((0, collection_utils_1.iterableFirst)(this.names));
      }
      get proposedNames() {
        return this.names;
      }
      add(namesArray, startIndex = 0) {
        if (!this.areInferred) return this;
        for (let i2 = startIndex; i2 < namesArray.length; i2++) {
          const other = namesArray[i2];
          if (other.distance < this.distance) {
            return other.add(namesArray, i2 + 1);
          }
        }
        return this;
      }
      clearInferred() {
        if (!this.areInferred) {
          return this;
        }
        return TypeNames.makeWithDistance(/* @__PURE__ */ new Set(), /* @__PURE__ */ new Set(), this.distance);
      }
      makeInferred() {
        return new _TooManyTypeNames(this.distance + 1, (0, collection_utils_1.iterableFirst)(this.names));
      }
      singularize() {
        return this;
      }
      toString() {
        return `too many ${this.combinedName}`;
      }
    };
    exports.TooManyTypeNames = TooManyTypeNames;
    var TypeNamesTypeAttributeKind = class extends TypeAttributes_1.TypeAttributeKind {
      constructor() {
        super("names");
      }
      combine(namesArray) {
        (0, Support_1.assert)(namesArray.length > 0, "Can't combine zero type names");
        return namesArray[0].add(namesArray, 1);
      }
      makeInferred(tn) {
        return tn.makeInferred();
      }
      increaseDistance(tn) {
        return tn.makeInferred();
      }
      stringify(tn) {
        return tn.toString();
      }
    };
    exports.namesTypeAttributeKind = new TypeNamesTypeAttributeKind();
    function modifyTypeNames(attributes, modifier) {
      return exports.namesTypeAttributeKind.modifyInAttributes(attributes, modifier);
    }
    function singularizeTypeNames(attributes) {
      return modifyTypeNames(attributes, (maybeNames) => {
        if (maybeNames === void 0) return void 0;
        return maybeNames.singularize();
      });
    }
    function makeNamesTypeAttributes(nameOrNames, areNamesInferred) {
      let typeNames;
      if (typeof nameOrNames === "string") {
        typeNames = TypeNames.make(/* @__PURE__ */ new Set([
          nameOrNames
        ]), /* @__PURE__ */ new Set(), (0, Support_1.defined)(areNamesInferred));
      } else {
        typeNames = nameOrNames;
      }
      return exports.namesTypeAttributeKind.makeAttributes(typeNames);
    }
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/input/PathElement.js
var require_PathElement = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/input/PathElement.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.PathElementKind = void 0;
    var PathElementKind;
    (function(PathElementKind2) {
      PathElementKind2[PathElementKind2["Root"] = 1] = "Root";
      PathElementKind2[PathElementKind2["KeyOrIndex"] = 2] = "KeyOrIndex";
      PathElementKind2[PathElementKind2["Type"] = 3] = "Type";
      PathElementKind2[PathElementKind2["Object"] = 4] = "Object";
    })(PathElementKind || (exports.PathElementKind = PathElementKind = {}));
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/attributes/Description.js
var require_Description = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/attributes/Description.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.propertyDescriptionsTypeAttributeKind = exports.descriptionTypeAttributeKind = void 0;
    exports.addDescriptionToSchema = addDescriptionToSchema;
    exports.descriptionAttributeProducer = descriptionAttributeProducer;
    var collection_utils_1 = require_dist();
    var PathElement_1 = require_PathElement();
    var TypeAttributes_1 = require_TypeAttributes();
    function addDescriptionToSchema(schema, description) {
      if (description === void 0) return;
      schema.description = Array.from(description).join("\n");
    }
    var DescriptionTypeAttributeKind = class extends TypeAttributes_1.TypeAttributeKind {
      constructor() {
        super("description");
      }
      combine(attrs) {
        return (0, collection_utils_1.setUnionManyInto)(/* @__PURE__ */ new Set(), attrs);
      }
      makeInferred(_) {
        return void 0;
      }
      addToSchema(schema, _t, attrs) {
        addDescriptionToSchema(schema, attrs);
      }
      stringify(descriptions) {
        let result = (0, collection_utils_1.iterableFirst)(descriptions);
        if (result === void 0) return void 0;
        if (result.length > 5 + 3) {
          result = `${result.slice(0, 5)}...`;
        }
        if (descriptions.size > 1) {
          result = `${result}, ...`;
        }
        return result;
      }
    };
    exports.descriptionTypeAttributeKind = new DescriptionTypeAttributeKind();
    var PropertyDescriptionsTypeAttributeKind = class extends TypeAttributes_1.TypeAttributeKind {
      constructor() {
        super("propertyDescriptions");
      }
      combine(attrs) {
        const result = /* @__PURE__ */ new Map();
        for (const attr of attrs) {
          (0, collection_utils_1.mapMergeWithInto)(result, (sa, sb) => (0, collection_utils_1.setUnion)(sa, sb), attr);
        }
        return result;
      }
      makeInferred(_) {
        return void 0;
      }
      stringify(propertyDescriptions) {
        if (propertyDescriptions.size === 0) return void 0;
        return `prop descs: ${propertyDescriptions.size}`;
      }
    };
    exports.propertyDescriptionsTypeAttributeKind = new PropertyDescriptionsTypeAttributeKind();
    function isPropertiesKey(el) {
      return el.kind === PathElement_1.PathElementKind.KeyOrIndex && el.key === "properties";
    }
    function descriptionAttributeProducer(schema, ref, types) {
      if (!(typeof schema === "object")) return void 0;
      let description = TypeAttributes_1.emptyTypeAttributes;
      let propertyDescription = TypeAttributes_1.emptyTypeAttributes;
      const pathLength = ref.path.length;
      if (types.has("object") || (0, collection_utils_1.setSubtract)(types, [
        "null"
      ]).size > 1 || schema.enum !== void 0 || pathLength < 2 || !isPropertiesKey(ref.path[pathLength - 2])) {
        const maybeDescription = schema.description;
        if (typeof maybeDescription === "string") {
          description = exports.descriptionTypeAttributeKind.makeAttributes(/* @__PURE__ */ new Set([
            maybeDescription
          ]));
        }
      }
      if (types.has("object") && typeof schema.properties === "object") {
        const propertyDescriptions = (0, collection_utils_1.mapFilterMap)((0, collection_utils_1.mapFromObject)(schema.properties), (propSchema) => {
          if (propSchema && typeof propSchema === "object" && "description" in propSchema) {
            const desc = propSchema.description;
            if (typeof desc === "string") {
              return /* @__PURE__ */ new Set([
                desc
              ]);
            }
          }
          return void 0;
        });
        if (propertyDescriptions.size > 0) {
          propertyDescription = exports.propertyDescriptionsTypeAttributeKind.makeAttributes(propertyDescriptions);
        }
      }
      return {
        forType: description,
        forObject: propertyDescription
      };
    }
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/RendererOptions/types.js
var require_types = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/RendererOptions/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/RendererOptions/index.js
var require_RendererOptions = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/RendererOptions/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
          enumerable: true,
          get: function() {
            return m[k];
          }
        };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.EnumOption = exports.StringOption = exports.BooleanOption = exports.Option = void 0;
    exports.getOptionValues = getOptionValues;
    var Messages_1 = require_Messages();
    var Support_1 = require_Support();
    __exportStar(require_types(), exports);
    var Option = class {
      constructor(definition) {
        this.definition = definition;
        (0, Support_1.assert)(definition.kind !== void 0, "Renderer option kind must be defined");
      }
      get name() {
        return this.definition.name;
      }
      getValue(values) {
        var _a;
        return (_a = values[this.name]) !== null && _a !== void 0 ? _a : this.definition.defaultValue;
      }
      get cliDefinitions() {
        return {
          actual: [
            this.definition
          ],
          display: [
            this.definition
          ]
        };
      }
    };
    exports.Option = Option;
    function getOptionValues(options, untypedOptionValues) {
      const optionValues = {};
      for (const [key, option] of Object.entries(options)) {
        const value = option.getValue(untypedOptionValues);
        if (option instanceof EnumOption) {
          optionValues[key] = option.getEnumValue(value);
        } else {
          optionValues[key] = value;
        }
      }
      return optionValues;
    }
    var BooleanOption = class extends Option {
      /**
         * @param name The shorthand name.
         * @param description Short-ish description of the option.
         * @param defaultValue The default value.
         * @param kind Whether it's a primary or secondary option.
         */
      constructor(name, description, defaultValue, kind = "primary") {
        super({
          name,
          kind,
          optionType: "boolean",
          description,
          defaultValue
        });
      }
      get cliDefinitions() {
        const negated = Object.assign({}, this.definition, {
          name: `no-${this.name}`,
          defaultValue: !this.definition.defaultValue
        });
        const display = Object.assign({}, this.definition, {
          name: `[no-]${this.name}`,
          description: `${this.definition.description} (${this.definition.defaultValue ? "on" : "off"} by default)`
        });
        return {
          display: [
            display
          ],
          actual: [
            this.definition,
            negated
          ]
        };
      }
      getValue(values) {
        let value = values[this.name];
        if (value === void 0) {
          value = this.definition.defaultValue;
        }
        let negated = values[`no-${this.name}`];
        if (negated === void 0) {
          negated = !this.definition.defaultValue;
        }
        if (value === "true") {
          value = true;
        } else if (value === "false") {
          value = false;
        }
        if (this.definition.defaultValue) {
          return value && !negated;
        }
        return value || !negated;
      }
    };
    exports.BooleanOption = BooleanOption;
    var StringOption = class extends Option {
      constructor(name, description, typeLabel, defaultValue, kind = "primary") {
        super({
          name,
          kind,
          optionType: "string",
          description,
          typeLabel,
          defaultValue
        });
      }
    };
    exports.StringOption = StringOption;
    var EnumOption = class extends Option {
      constructor(name, description, values, defaultValue, kind = "primary") {
        super({
          name,
          kind,
          optionType: "enum",
          description,
          typeLabel: Object.keys(values).join("|"),
          defaultValue,
          values
        });
        this._values = values;
      }
      getEnumValue(name) {
        if (!name) {
          const defaultKey = this.definition.defaultValue;
          return this._values[defaultKey];
        }
        if (!(name in this._values)) {
          return (0, Messages_1.messageError)("RendererUnknownOptionValue", {
            value: name,
            name: this.name
          });
        }
        return this._values[name];
      }
    };
    exports.EnumOption = EnumOption;
  }
});

// ../../../../../node_modules/.deno/wordwrap@1.0.0/node_modules/wordwrap/index.js
var require_wordwrap = __commonJS({
  "../../../../../node_modules/.deno/wordwrap@1.0.0/node_modules/wordwrap/index.js"(exports, module) {
    var wordwrap = module.exports = function(start, stop, params) {
      if (typeof start === "object") {
        params = start;
        start = params.start;
        stop = params.stop;
      }
      if (typeof stop === "object") {
        params = stop;
        start = start || params.start;
        stop = void 0;
      }
      if (!stop) {
        stop = start;
        start = 0;
      }
      if (!params) params = {};
      var mode = params.mode || "soft";
      var re = mode === "hard" ? /\b/ : /(\S+\s+)/;
      return function(text) {
        var chunks = text.toString().split(re).reduce(function(acc, x) {
          if (mode === "hard") {
            for (var i2 = 0; i2 < x.length; i2 += stop - start) {
              acc.push(x.slice(i2, i2 + stop - start));
            }
          } else acc.push(x);
          return acc;
        }, []);
        return chunks.reduce(function(lines, rawChunk) {
          if (rawChunk === "") return lines;
          var chunk = rawChunk.replace(/\t/g, "    ");
          var i2 = lines.length - 1;
          if (lines[i2].length + chunk.length > stop) {
            lines[i2] = lines[i2].replace(/\s+$/, "");
            chunk.split(/\n/).forEach(function(c) {
              lines.push(new Array(start + 1).join(" ") + c.replace(/^\s+/, ""));
            });
          } else if (chunk.match(/\n/)) {
            var xs = chunk.split(/\n/);
            lines[i2] += xs.shift();
            xs.forEach(function(c) {
              lines.push(new Array(start + 1).join(" ") + c.replace(/^\s+/, ""));
            });
          } else {
            lines[i2] += chunk;
          }
          return lines;
        }, [
          new Array(start + 1).join(" ")
        ]).join("\n");
      };
    };
    wordwrap.soft = wordwrap;
    wordwrap.hard = function(start, stop) {
      return wordwrap(start, stop, {
        mode: "hard"
      });
    };
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/attributes/AccessorNames.js
var require_AccessorNames = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/attributes/AccessorNames.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.unionMemberNamesTypeAttributeKind = exports.unionIdentifierTypeAttributeKind = exports.accessorNamesTypeAttributeKind = void 0;
    exports.lookupKey = lookupKey;
    exports.objectPropertyNames = objectPropertyNames;
    exports.enumCaseNames = enumCaseNames;
    exports.getAccessorName = getAccessorName;
    exports.makeUnionIdentifierAttribute = makeUnionIdentifierAttribute;
    exports.makeUnionMemberNamesAttribute = makeUnionMemberNamesAttribute;
    exports.unionMemberName = unionMemberName;
    exports.makeAccessorNames = makeAccessorNames;
    exports.accessorNamesAttributeProducer = accessorNamesAttributeProducer;
    var collection_utils_1 = require_dist();
    var Messages_1 = require_Messages();
    var Support_1 = require_Support();
    var TypeAttributes_1 = require_TypeAttributes();
    var AccessorNamesTypeAttributeKind = class extends TypeAttributes_1.TypeAttributeKind {
      constructor() {
        super("accessorNames");
      }
      makeInferred(_) {
        return void 0;
      }
    };
    exports.accessorNamesTypeAttributeKind = new AccessorNamesTypeAttributeKind();
    function getFromEntry(entry, language) {
      if (typeof entry === "string") return [
        entry,
        false
      ];
      const maybeForLanguage = entry.get(language);
      if (maybeForLanguage !== void 0) return [
        maybeForLanguage,
        true
      ];
      const maybeWildcard = entry.get("*");
      if (maybeWildcard !== void 0) return [
        maybeWildcard,
        false
      ];
      return void 0;
    }
    function lookupKey(accessors, key, language) {
      const entry = accessors.get(key);
      if (entry === void 0) return void 0;
      return getFromEntry(entry, language);
    }
    function objectPropertyNames(o, language) {
      const accessors = exports.accessorNamesTypeAttributeKind.tryGetInAttributes(o.getAttributes());
      const map = o.getProperties();
      if (accessors === void 0) return (0, collection_utils_1.mapMap)(map, (_) => void 0);
      return (0, collection_utils_1.mapMap)(map, (_cp, n) => lookupKey(accessors, n, language));
    }
    function enumCaseNames(e, language) {
      const accessors = exports.accessorNamesTypeAttributeKind.tryGetInAttributes(e.getAttributes());
      if (accessors === void 0) return (0, collection_utils_1.mapMap)(e.cases.entries(), (_) => void 0);
      return (0, collection_utils_1.mapMap)(e.cases.entries(), (c) => lookupKey(accessors, c, language));
    }
    function getAccessorName(names, original) {
      const maybeName = names.get(original);
      if (maybeName === void 0) return [
        void 0,
        false
      ];
      return maybeName;
    }
    var UnionIdentifierTypeAttributeKind = class extends TypeAttributes_1.TypeAttributeKind {
      constructor() {
        super("unionIdentifier");
      }
      combine(arr) {
        return (0, collection_utils_1.setUnionManyInto)(/* @__PURE__ */ new Set(), arr);
      }
      makeInferred(_) {
        return /* @__PURE__ */ new Set();
      }
    };
    exports.unionIdentifierTypeAttributeKind = new UnionIdentifierTypeAttributeKind();
    var nextUnionIdentifier = 0;
    function makeUnionIdentifierAttribute() {
      const attributes = exports.unionIdentifierTypeAttributeKind.makeAttributes(/* @__PURE__ */ new Set([
        nextUnionIdentifier
      ]));
      nextUnionIdentifier += 1;
      return attributes;
    }
    var UnionMemberNamesTypeAttributeKind = class extends TypeAttributes_1.TypeAttributeKind {
      constructor() {
        super("unionMemberNames");
      }
      combine(arr) {
        const result = /* @__PURE__ */ new Map();
        for (const m of arr) {
          (0, collection_utils_1.mapMergeInto)(result, m);
        }
        return result;
      }
    };
    exports.unionMemberNamesTypeAttributeKind = new UnionMemberNamesTypeAttributeKind();
    function makeUnionMemberNamesAttribute(unionAttributes, entry) {
      const identifiers = (0, Support_1.defined)(exports.unionIdentifierTypeAttributeKind.tryGetInAttributes(unionAttributes));
      const map = (0, collection_utils_1.mapFromIterable)(identifiers, (_) => entry);
      return exports.unionMemberNamesTypeAttributeKind.makeAttributes(map);
    }
    function unionMemberName(u, member, language) {
      const identifiers = exports.unionIdentifierTypeAttributeKind.tryGetInAttributes(u.getAttributes());
      if (identifiers === void 0) return [
        void 0,
        false
      ];
      const memberNames = exports.unionMemberNamesTypeAttributeKind.tryGetInAttributes(member.getAttributes());
      if (memberNames === void 0) return [
        void 0,
        false
      ];
      const names = /* @__PURE__ */ new Set();
      const fixedNames = /* @__PURE__ */ new Set();
      for (const i2 of identifiers) {
        const maybeEntry = memberNames.get(i2);
        if (maybeEntry === void 0) continue;
        const maybeName = getFromEntry(maybeEntry, language);
        if (maybeName === void 0) continue;
        const [name, isNameFixed] = maybeName;
        if (isNameFixed) {
          fixedNames.add(name);
        } else {
          names.add(name);
        }
      }
      let size;
      let isFixed;
      let first = (0, collection_utils_1.iterableFirst)(fixedNames);
      if (first !== void 0) {
        size = fixedNames.size;
        isFixed = true;
      } else {
        first = (0, collection_utils_1.iterableFirst)(names);
        if (first === void 0) return [
          void 0,
          false
        ];
        size = names.size;
        isFixed = false;
      }
      (0, Messages_1.messageAssert)(size === 1, "SchemaMoreThanOneUnionMemberName", {
        names: Array.from(names)
      });
      return [
        first,
        isFixed
      ];
    }
    function isAccessorEntry(x) {
      if (typeof x === "string") {
        return true;
      }
      return (0, Support_1.isStringMap)(x, (v) => typeof v === "string");
    }
    function makeAccessorEntry(ae) {
      if (typeof ae === "string") return ae;
      return (0, collection_utils_1.mapFromObject)(ae);
    }
    function makeAccessorNames(x) {
      const stringMap = (0, Support_1.checkStringMap)(x, isAccessorEntry);
      return (0, collection_utils_1.mapMap)((0, collection_utils_1.mapFromObject)(stringMap), makeAccessorEntry);
    }
    function accessorNamesAttributeProducer(schema, canonicalRef, _types, cases) {
      if (typeof schema !== "object") return void 0;
      const maybeAccessors = schema["qt-accessors"];
      if (maybeAccessors === void 0) return void 0;
      if (cases === void 0) {
        return {
          forType: exports.accessorNamesTypeAttributeKind.makeAttributes(makeAccessorNames(maybeAccessors))
        };
      } else {
        const identifierAttribute = makeUnionIdentifierAttribute();
        const accessors = (0, Support_1.checkArray)(maybeAccessors, isAccessorEntry);
        (0, Messages_1.messageAssert)(cases.length === accessors.length, "SchemaWrongAccessorEntryArrayLength", {
          operation: "oneOf",
          ref: canonicalRef.push("oneOf")
        });
        const caseAttributes = accessors.map((accessor) => makeUnionMemberNamesAttribute(identifierAttribute, makeAccessorEntry(accessor)));
        return {
          forUnion: identifierAttribute,
          forCases: caseAttributes
        };
      }
    }
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/Graph.js
var require_Graph = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/Graph.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Graph = void 0;
    var collection_utils_1 = require_dist();
    var Support_1 = require_Support();
    function countComponentGraphNodes(components) {
      if (components.length === 0) return 0;
      let largest = -1;
      let count = 0;
      for (const c of components) {
        (0, Support_1.assert)(c.length > 0, "Empty component not allowed");
        for (const v of c) {
          (0, Support_1.assert)(v >= 0, "Negative vertex index is invalid");
          largest = Math.max(largest, v);
          count += 1;
        }
      }
      (0, Support_1.assert)(largest + 1 === count, "Vertex indexes and count don't match up");
      return count;
    }
    function stronglyConnectedComponents(successors) {
      let index = 0;
      const stack = [];
      const numNodes = successors.length;
      const indexes = (0, Support_1.repeated)(numNodes, -1);
      const lowLinks = (0, Support_1.repeated)(numNodes, -1);
      const onStack = (0, Support_1.repeated)(numNodes, false);
      const sccs = [];
      function strongconnect(v) {
        indexes[v] = index;
        lowLinks[v] = index;
        index += 1;
        stack.push(v);
        onStack[v] = true;
        for (const w of successors[v]) {
          if (indexes[w] < 0) {
            strongconnect(w);
            lowLinks[v] = Math.min(lowLinks[v], lowLinks[w]);
          } else if (onStack[w]) {
            lowLinks[v] = Math.min(lowLinks[v], indexes[w]);
          }
        }
        if (lowLinks[v] === indexes[v]) {
          const scc = [];
          let w;
          do {
            w = (0, Support_1.defined)(stack.pop());
            onStack[w] = false;
            scc.push(w);
          } while (w !== v);
          sccs.push(scc);
        }
      }
      for (let v = 0; v < numNodes; v++) {
        if (indexes[v] < 0) {
          strongconnect(v);
        }
      }
      (0, Support_1.assert)(countComponentGraphNodes(sccs) === numNodes, "We didn't put all the nodes into SCCs");
      return sccs;
    }
    function buildComponentOfNodeMap(successors, components) {
      const numComponents = components.length;
      const numNodes = successors.length;
      (0, Support_1.assert)(numNodes === countComponentGraphNodes(components), "Components don't match up with graph");
      const componentOfNode = (0, Support_1.repeated)(numNodes, -1);
      for (let c = 0; c < numComponents; c++) {
        for (const n of components[c]) {
          (0, Support_1.assert)(componentOfNode[n] < 0, "We have a node that's in two components");
          componentOfNode[n] = c;
        }
      }
      return componentOfNode;
    }
    function buildMetaSuccessors(successors, components) {
      const numComponents = components.length;
      const componentOfNode = buildComponentOfNodeMap(successors, components);
      const componentAdded = (0, Support_1.repeated)(numComponents, false);
      const metaSuccessors = [];
      for (let c = 0; c < numComponents; c++) {
        const succ = [];
        for (const n of components[c]) {
          for (const s of successors[n]) {
            const ms = componentOfNode[s];
            if (ms === c || componentAdded[ms]) continue;
            succ.push(ms);
            componentAdded[ms] = true;
          }
        }
        for (const ms of succ) {
          (0, Support_1.assert)(componentAdded[ms]);
          componentAdded[ms] = false;
        }
        metaSuccessors.push(succ);
      }
      return metaSuccessors;
    }
    function invertEdges(successors) {
      const numNodes = successors.length;
      const predecessors = (0, Support_1.repeatedCall)(numNodes, () => []);
      for (let s = 0; s < numNodes; s++) {
        for (const v of successors[s]) {
          predecessors[v].push(s);
        }
      }
      return predecessors;
    }
    function calculateInDegrees(successors) {
      const numNodes = successors.length;
      const inDegrees = (0, Support_1.repeated)(numNodes, 0);
      for (const s of successors) {
        for (const v of s) {
          inDegrees[v] += 1;
        }
      }
      return inDegrees;
    }
    function findRoots(successors) {
      const numNodes = successors.length;
      const inDegrees = calculateInDegrees(successors);
      const roots = [];
      for (let v = 0; v < numNodes; v++) {
        if (inDegrees[v] === 0) {
          roots.push(v);
        }
      }
      return roots;
    }
    var Graph = class _Graph {
      constructor(nodes, invertDirection, edges) {
        this._nodes = Array.from(nodes);
        this._indexByNode = new Map(this._nodes.map((n, i2) => [
          n,
          i2
        ]));
        let edgesArray;
        if (Array.isArray(edges)) {
          edgesArray = edges;
        } else {
          edgesArray = this._nodes.map((n) => Array.from(edges(n)).map((s) => (0, Support_1.defined)(this._indexByNode.get(s))));
        }
        if (invertDirection) {
          edgesArray = invertEdges(edgesArray);
        }
        this._successors = edgesArray;
      }
      get size() {
        return this._nodes.length;
      }
      get nodes() {
        return this._nodes;
      }
      findRoots() {
        const roots = findRoots(this._successors);
        return new Set(roots.map((n) => this._nodes[n]));
      }
      // The subgraph starting at `root` must be acyclic.
      dfsTraversal(root, preOrder, process2) {
        const visited = (0, Support_1.repeated)(this.size, false);
        const visit = (v) => {
          if (visited[v]) return;
          visited[v] = true;
          if (preOrder) {
            process2(this._nodes[v]);
          }
          for (const w of this._successors[v]) {
            visit(w);
          }
          if (!preOrder) {
            process2(this._nodes[v]);
          }
        };
        visit((0, Support_1.defined)(this._indexByNode.get(root)));
      }
      stronglyConnectedComponents() {
        const components = stronglyConnectedComponents(this._successors);
        const componentSuccessors = buildMetaSuccessors(this._successors, components);
        return new _Graph(components.map((ns) => (0, collection_utils_1.setMap)(ns, (n) => this._nodes[n])), false, componentSuccessors);
      }
      makeDot(includeNode, nodeLabel) {
        const lines = [];
        lines.push("digraph G {");
        lines.push("    ordering = out;");
        lines.push("");
        for (let i2 = 0; i2 < this.size; i2++) {
          const n = this._nodes[i2];
          if (!includeNode(n)) continue;
          lines.push(`    node${i2} [label="${nodeLabel(n)}"];`);
        }
        for (let i2 = 0; i2 < this.size; i2++) {
          if (!includeNode(this._nodes[i2])) continue;
          for (const j of this._successors[i2]) {
            if (!includeNode(this._nodes[j])) continue;
            lines.push(`    node${i2} -> node${j};`);
          }
        }
        lines.push("}");
        lines.push("");
        return lines.join("\n");
      }
    };
    exports.Graph = Graph;
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/DeclarationIR.js
var require_DeclarationIR = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/DeclarationIR.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.DeclarationIR = void 0;
    exports.cycleBreakerTypesForGraph = cycleBreakerTypesForGraph;
    exports.declarationsForGraph = declarationsForGraph;
    var collection_utils_1 = require_dist();
    var Graph_1 = require_Graph();
    var Messages_1 = require_Messages();
    var Support_1 = require_Support();
    var DeclarationIR = class {
      constructor(declarations, forwardedTypes) {
        this.forwardedTypes = forwardedTypes;
        this.declarations = Array.from(declarations);
      }
    };
    exports.DeclarationIR = DeclarationIR;
    function findBreaker(t, path2, canBreak) {
      const index = path2.indexOf(t);
      if (index < 0) return void 0;
      if (canBreak === void 0) {
        return path2[index];
      }
      const potentialBreakers = path2.slice(0, index + 1).reverse();
      const maybeBreaker = potentialBreakers.find(canBreak);
      if (maybeBreaker === void 0) {
        return (0, Support_1.panic)("Found a cycle that cannot be broken");
      }
      return maybeBreaker;
    }
    function cycleBreakerTypesForGraph(graph, isImplicitCycleBreaker, canBreakCycles) {
      const visitedTypes = /* @__PURE__ */ new Set();
      const cycleBreakerTypes = /* @__PURE__ */ new Set();
      const queue = Array.from(graph.topLevels.values());
      function visit(t, path2) {
        if (visitedTypes.has(t)) return;
        if (isImplicitCycleBreaker(t)) {
          for (const c of t.getChildren()) {
            queue.push(c);
          }
        } else {
          const maybeBreaker = findBreaker(t, path2, canBreakCycles);
          if (maybeBreaker !== void 0) {
            cycleBreakerTypes.add(maybeBreaker);
            return;
          }
          for (const c of t.getChildren()) {
            path2.unshift(t);
            visit(c, path2);
            path2.shift();
          }
        }
        visitedTypes.add(t);
      }
      for (; ; ) {
        const maybeType = queue.pop();
        if (maybeType === void 0) break;
        const path2 = [];
        visit(maybeType, path2);
        (0, Support_1.assert)(path2.length === 0);
      }
      return cycleBreakerTypes;
    }
    function declarationsForGraph(typeGraph, canBeForwardDeclared, childrenOfType, needsDeclaration) {
      const topDown = canBeForwardDeclared === void 0;
      const declarations = [];
      const forwardedTypes = /* @__PURE__ */ new Set();
      const visitedComponents = /* @__PURE__ */ new Set();
      function processGraph(graph, _writeComponents) {
        const componentsGraph = graph.stronglyConnectedComponents();
        function visitComponent(component) {
          if (visitedComponents.has(component)) return;
          visitedComponents.add(component);
          const declarationNeeded = (0, collection_utils_1.setFilter)(component, needsDeclaration);
          if (declarationNeeded.size === 1) {
            declarations.push({
              kind: "define",
              type: (0, Support_1.defined)((0, collection_utils_1.iterableFirst)(declarationNeeded))
            });
            return;
          }
          if (declarationNeeded.size === 0 && component.size === 1) {
            return;
          }
          if (declarationNeeded.size === 0) {
            declarations.push({
              kind: "define",
              type: (0, Support_1.defined)((0, collection_utils_1.iterableFirst)(component))
            });
            return;
          }
          if (canBeForwardDeclared === void 0) {
            for (const t of declarationNeeded) {
              declarations.push({
                kind: "define",
                type: t
              });
            }
            return;
          }
          const forwardDeclarable = (0, collection_utils_1.setFilter)(component, canBeForwardDeclared);
          if (forwardDeclarable.size === 0) {
            (0, Messages_1.messageError)("IRNoForwardDeclarableTypeInCycle", {});
          }
          for (const t of forwardDeclarable) {
            declarations.push({
              kind: "forward",
              type: t
            });
          }
          (0, collection_utils_1.setUnionInto)(forwardedTypes, forwardDeclarable);
          const rest = (0, collection_utils_1.setSubtract)(component, forwardDeclarable);
          const restGraph = new Graph_1.Graph(rest, true, (t) => (0, collection_utils_1.setIntersect)(childrenOfType(t), rest));
          processGraph(restGraph, false);
          for (const t of forwardDeclarable) {
            declarations.push({
              kind: "define",
              type: t
            });
          }
          return;
        }
        const rootsUnordered = componentsGraph.findRoots();
        const roots = rootsUnordered;
        for (const component of roots) {
          componentsGraph.dfsTraversal(component, topDown, visitComponent);
        }
      }
      const fullGraph = typeGraph.makeGraph(false, childrenOfType);
      processGraph(fullGraph, true);
      return new DeclarationIR(declarations, forwardedTypes);
    }
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/Naming.js
var require_Naming = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/Naming.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.DependencyName = exports.AssociatedName = exports.SimpleName = exports.FixedName = exports.Name = exports.Namer = exports.Namespace = void 0;
    exports.funPrefixNamer = funPrefixNamer;
    exports.keywordNamespace = keywordNamespace;
    exports.assignNames = assignNames;
    var collection_utils_1 = require_dist();
    var Support_1 = require_Support();
    var Namespace = class {
      constructor(_name, parent, forbiddenNamespaces, additionalForbidden) {
        this._children = /* @__PURE__ */ new Set();
        this._members = /* @__PURE__ */ new Set();
        this.forbiddenNamespaces = new Set(forbiddenNamespaces);
        this.additionalForbidden = new Set(additionalForbidden);
        if (parent !== void 0) {
          parent.addChild(this);
        }
      }
      addChild(child) {
        this._children.add(child);
      }
      get children() {
        return this._children;
      }
      get members() {
        return this._members;
      }
      get forbiddenNameds() {
        return (0, collection_utils_1.setUnion)(this.additionalForbidden, ...Array.from(this.forbiddenNamespaces).map((ns) => ns.members));
      }
      add(named) {
        this._members.add(named);
        return named;
      }
    };
    exports.Namespace = Namespace;
    var Namer = class {
      constructor(name, nameStyle, prefixes) {
        this.name = name;
        this.nameStyle = nameStyle;
        this.prefixes = prefixes;
        this._prefixes = new Set(prefixes);
      }
      // The namesIterable comes directly out of the context and will
      // be modified if we assign
      assignNames(names, forbiddenNamesIterable, namesToAssignIterable) {
        const forbiddenNames = new Set(forbiddenNamesIterable);
        const namesToAssign = Array.from(namesToAssignIterable);
        (0, Support_1.assert)(namesToAssign.length > 0, "Number of names can't be less than 1");
        const allAssignedNames = /* @__PURE__ */ new Map();
        const namesToPrefix = [];
        for (const name of namesToAssign) {
          const proposedNames = name.proposeUnstyledNames(names);
          const namingFunction = name.namingFunction;
          const maybeUniqueName = (0, collection_utils_1.iterableFind)(proposedNames, (proposed) => !forbiddenNames.has(namingFunction.nameStyle(proposed)) && namesToAssign.every((n) => n === name || !n.proposeUnstyledNames(names).has(proposed)));
          if (maybeUniqueName !== void 0) {
            const styledName = namingFunction.nameStyle(maybeUniqueName);
            const assigned = name.nameAssignments(forbiddenNames, styledName);
            if (assigned !== null) {
              (0, collection_utils_1.mapMergeInto)(allAssignedNames, assigned);
              (0, collection_utils_1.setUnionInto)(forbiddenNames, assigned.values());
              continue;
            }
          }
          namesToPrefix.push(name);
        }
        const prefixes = this._prefixes.values();
        let suffixNumber = 1;
        for (const name of namesToPrefix) {
          const originalName = (0, Support_1.defined)((0, collection_utils_1.iterableFirst)(name.proposeUnstyledNames(names)));
          for (; ; ) {
            let nameToTry;
            const { done, value: prefix } = prefixes.next();
            if (!done) {
              nameToTry = `${prefix}_${originalName}`;
            } else {
              nameToTry = `${originalName}_${suffixNumber.toString()}`;
              suffixNumber++;
            }
            const styledName = name.namingFunction.nameStyle(nameToTry);
            const assigned = name.nameAssignments(forbiddenNames, styledName);
            if (assigned === null) continue;
            (0, collection_utils_1.mapMergeInto)(allAssignedNames, assigned);
            (0, collection_utils_1.setUnionInto)(forbiddenNames, assigned.values());
            break;
          }
        }
        return allAssignedNames;
      }
    };
    exports.Namer = Namer;
    var funPrefixes = [
      "Purple",
      "Fluffy",
      "Tentacled",
      "Sticky",
      "Indigo",
      "Indecent",
      "Hilarious",
      "Ambitious",
      "Cunning",
      "Magenta",
      "Frisky",
      "Mischievous",
      "Braggadocious"
    ];
    function funPrefixNamer(name, nameStyle) {
      return new Namer(name, nameStyle, funPrefixes);
    }
    var Name = class {
      // If a Named is fixed, the namingFunction is undefined.
      constructor(_namingFunction, order) {
        this._namingFunction = _namingFunction;
        this.order = order;
        this._associates = /* @__PURE__ */ new Set();
      }
      addAssociate(associate) {
        this._associates.add(associate);
      }
      isFixed() {
        return this instanceof FixedName;
      }
      get namingFunction() {
        return (0, Support_1.defined)(this._namingFunction);
      }
      firstProposedName(names) {
        return (0, Support_1.defined)((0, collection_utils_1.iterableFirst)(this.proposeUnstyledNames(names)));
      }
      nameAssignments(forbiddenNames, assignedName) {
        if (forbiddenNames.has(assignedName)) return null;
        const assignments = /* @__PURE__ */ new Map([
          [
            this,
            assignedName
          ]
        ]);
        for (const an of this._associates) {
          const associatedAssignedName = an.getName(assignedName);
          if (forbiddenNames.has(associatedAssignedName)) {
            return null;
          }
          assignments.set(an, associatedAssignedName);
        }
        return assignments;
      }
    };
    exports.Name = Name;
    var FixedName = class extends Name {
      constructor(_fixedName) {
        super(void 0, 0);
        this._fixedName = _fixedName;
      }
      get dependencies() {
        return [];
      }
      addAssociate(_) {
        return (0, Support_1.panic)("Cannot add associates to fixed names");
      }
      get fixedName() {
        return this._fixedName;
      }
      proposeUnstyledNames(_) {
        return (0, Support_1.panic)("Only fixedName should be called on FixedName.");
      }
    };
    exports.FixedName = FixedName;
    var SimpleName = class extends Name {
      constructor(unstyledNames, namingFunction, order) {
        super(namingFunction, order);
        this._unstyledNames = new Set(unstyledNames);
      }
      get dependencies() {
        return [];
      }
      proposeUnstyledNames(_) {
        return this._unstyledNames;
      }
    };
    exports.SimpleName = SimpleName;
    var AssociatedName = class extends Name {
      constructor(_sponsor, order, getName) {
        super(void 0, order);
        this._sponsor = _sponsor;
        this.getName = getName;
      }
      get dependencies() {
        return [
          this._sponsor
        ];
      }
      proposeUnstyledNames(_) {
        return (0, Support_1.panic)("AssociatedName must be assigned via its sponsor");
      }
    };
    exports.AssociatedName = AssociatedName;
    var DependencyName = class extends Name {
      constructor(namingFunction, order, _proposeUnstyledName) {
        super(namingFunction, order);
        this._proposeUnstyledName = _proposeUnstyledName;
        const dependencies = [];
        _proposeUnstyledName((n) => {
          dependencies.push(n);
          return "0xDEADBEEF";
        });
        this._dependencies = new Set(dependencies);
      }
      get dependencies() {
        return Array.from(this._dependencies);
      }
      proposeUnstyledNames(names) {
        return /* @__PURE__ */ new Set([
          this._proposeUnstyledName((n) => {
            (0, Support_1.assert)(this._dependencies.has(n), "DependencyName proposer is not pure");
            return (0, Support_1.defined)(names.get(n));
          })
        ]);
      }
    };
    exports.DependencyName = DependencyName;
    function keywordNamespace(name, keywords) {
      const ns = new Namespace(name, void 0, [], []);
      for (const kw of keywords) {
        ns.add(new FixedName(kw));
      }
      return ns;
    }
    function allNamespacesRecursively(namespaces) {
      return (0, collection_utils_1.setUnion)(namespaces, ...Array.from((0, collection_utils_1.setMap)(namespaces, (ns) => allNamespacesRecursively(ns.children))));
    }
    var NamingContext = class {
      constructor(rootNamespaces) {
        this._names = /* @__PURE__ */ new Map();
        this._namedsForName = /* @__PURE__ */ new Map();
        this.namespaces = allNamespacesRecursively(rootNamespaces);
      }
      get names() {
        return this._names;
      }
      isReadyToBeNamed(named) {
        if (this._names.has(named)) return false;
        return named.dependencies.every((n) => this._names.has(n));
      }
      areForbiddensFullyNamed(namespace) {
        return (0, collection_utils_1.iterableEvery)(namespace.forbiddenNameds, (n) => this._names.has(n));
      }
      isConflicting(namedNamespace, proposed) {
        const namedsForProposed = this._namedsForName.get(proposed);
        if (namedsForProposed === void 0) return false;
        for (const n of namedsForProposed) {
          if (namedNamespace.members.has(n) || namedNamespace.forbiddenNameds.has(n)) {
            return true;
          }
        }
        return false;
      }
      assign(named, namedNamespace, name) {
        (0, Support_1.assert)(!this.names.has(named), `Name "${name}" assigned twice`);
        (0, Support_1.assert)(!this.isConflicting(namedNamespace, name), `Assigned name "${name}" conflicts`);
        this._names.set(named, name);
        let namedsForName = this._namedsForName.get(name);
        if (namedsForName === void 0) {
          namedsForName = /* @__PURE__ */ new Set();
          this._namedsForName.set(name, namedsForName);
        }
        namedsForName.add(named);
      }
    };
    function assignNames(rootNamespaces) {
      const ctx = new NamingContext(rootNamespaces);
      for (const ns of ctx.namespaces) {
        for (const n of ns.members) {
          if (!n.isFixed()) continue;
          ctx.assign(n, ns, n.fixedName);
        }
      }
      for (; ; ) {
        const unfinishedNamespaces = (0, collection_utils_1.setFilter)(ctx.namespaces, (ns) => ctx.areForbiddensFullyNamed(ns));
        const readyNamespace = (0, collection_utils_1.iterableFind)(unfinishedNamespaces, (ns) => (0, collection_utils_1.iterableSome)(ns.members, (member) => ctx.isReadyToBeNamed(member)));
        if (readyNamespace === void 0) {
          return ctx.names;
        }
        const allForbiddenNames = (0, collection_utils_1.setUnion)(readyNamespace.members, readyNamespace.forbiddenNameds);
        const forbiddenNames = (0, collection_utils_1.setFilterMap)(allForbiddenNames, (n) => ctx.names.get(n));
        for (; ; ) {
          const allReadyNames = (0, collection_utils_1.setFilter)(readyNamespace.members, (member) => ctx.isReadyToBeNamed(member));
          const minOrderName = (0, collection_utils_1.iterableMinBy)(allReadyNames, (n) => n.order);
          if (minOrderName === void 0) break;
          const minOrder = minOrderName.order;
          const readyNames = (0, collection_utils_1.setFilter)(allReadyNames, (n) => n.order === minOrder);
          const byNamingFunction = (0, collection_utils_1.setGroupBy)(readyNames, (n) => n.namingFunction);
          for (const [namer, namedsForNamingFunction] of byNamingFunction) {
            const byProposed = (0, collection_utils_1.setGroupBy)(namedsForNamingFunction, (n) => n.namingFunction.nameStyle(n.firstProposedName(ctx.names)));
            for (const [, nameds] of byProposed) {
              const names = namer.assignNames(ctx.names, forbiddenNames, nameds);
              for (const [name, assigned] of names) {
                ctx.assign(name, readyNamespace, assigned);
              }
              (0, collection_utils_1.setUnionInto)(forbiddenNames, names.values());
            }
          }
        }
      }
    }
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/Annotation.js
var require_Annotation = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/Annotation.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.nullTypeIssueAnnotation = exports.anyTypeIssueAnnotation = exports.IssueAnnotationData = exports.AnnotationData = void 0;
    var AnnotationData = class {
    };
    exports.AnnotationData = AnnotationData;
    var IssueAnnotationData = class extends AnnotationData {
      constructor(message) {
        super();
        this.message = message;
      }
    };
    exports.IssueAnnotationData = IssueAnnotationData;
    exports.anyTypeIssueAnnotation = new IssueAnnotationData("quicktype cannot infer this type because there is no data about it in the input.");
    exports.nullTypeIssueAnnotation = new IssueAnnotationData("The only value for this in the input is null, which means you probably need a more complete input sample.");
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/Source.js
var require_Source = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/Source.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.newline = newline;
    exports.sourcelikeToSource = sourcelikeToSource;
    exports.annotated = annotated;
    exports.maybeAnnotated = maybeAnnotated;
    exports.modifySource = modifySource;
    exports.serializeRenderResult = serializeRenderResult;
    exports.singleWord = singleWord;
    exports.multiWord = multiWord;
    exports.parenIfNeeded = parenIfNeeded;
    var collection_utils_1 = require_dist();
    var Naming_1 = require_Naming();
    var Strings_1 = require_Strings();
    var Support_1 = require_Support();
    function newline() {
      return {
        kind: "newline",
        indentationChange: 0
      };
    }
    function sourcelikeToSource(sl) {
      if (sl instanceof Array) {
        return {
          kind: "sequence",
          sequence: sl.map(sourcelikeToSource)
        };
      }
      if (typeof sl === "string") {
        const lines = sl.split("\n");
        if (lines.length === 1) {
          return {
            kind: "text",
            text: sl
          };
        }
        return {
          kind: "sequence",
          sequence: (0, collection_utils_1.arrayIntercalate)(newline(), lines.map((l) => ({
            kind: "text",
            text: l
          })))
        };
      }
      if (sl instanceof Naming_1.Name) {
        return {
          kind: "name",
          named: sl
        };
      }
      return sl;
    }
    function annotated(annotation, sl) {
      return {
        kind: "annotated",
        annotation,
        source: sourcelikeToSource(sl)
      };
    }
    function maybeAnnotated(doAnnotate, annotation, sl) {
      if (!doAnnotate) {
        return sl;
      }
      return annotated(annotation, sl);
    }
    function modifySource(modifier, sl) {
      return {
        kind: "modified",
        modifier,
        source: sourcelikeToSource(sl)
      };
    }
    function sourceLineLength(source, names) {
      switch (source.kind) {
        case "text":
          return source.text.length;
        case "newline":
          return (0, Support_1.panic)("Newline must not occur within a line.");
        case "sequence":
          return source.sequence.map((s) => sourceLineLength(s, names)).reduce((a, b) => a + b, 0);
        case "table":
          return (0, Support_1.panic)("Table must not occur within a  line.");
        case "annotated":
          return sourceLineLength(source.source, names);
        case "name":
          return (0, Support_1.defined)(names.get(source.named)).length;
        case "modified":
          return serializeRenderResult(source, names, "").lines.join("\n").length;
        default:
          return (0, Support_1.assertNever)(source);
      }
    }
    function serializeRenderResult(rootSource, names, indentation) {
      let indent = 0;
      let indentNeeded = 0;
      const lines = [];
      let currentLine = [];
      const annotations = [];
      function indentIfNeeded() {
        if (indentNeeded === 0) return;
        currentLine.push((0, Strings_1.repeatString)(indentation, indentNeeded));
        indentNeeded = 0;
      }
      function flattenCurrentLine() {
        const str = currentLine.join("");
        currentLine = [
          str
        ];
        return str;
      }
      function currentLocation() {
        return {
          line: lines.length,
          column: flattenCurrentLine().length
        };
      }
      function finishLine() {
        lines.push(flattenCurrentLine());
        currentLine = [];
      }
      function serializeToStringArray(source) {
        switch (source.kind) {
          case "text":
            indentIfNeeded();
            currentLine.push(source.text);
            break;
          case "newline":
            finishLine();
            indent += source.indentationChange;
            indentNeeded = indent;
            break;
          case "sequence":
            for (const s of source.sequence) {
              serializeToStringArray(s);
            }
            break;
          case "table":
            const t = source.table;
            const numRows = t.length;
            if (numRows === 0) break;
            const widths = t.map((l) => l.map((s) => sourceLineLength(s, names)));
            const numColumns = (0, Support_1.defined)((0, collection_utils_1.iterableMax)(t.map((l) => l.length)));
            if (numColumns === 0) break;
            const columnWidths = [];
            for (let i2 = 0; i2 < numColumns; i2++) {
              columnWidths.push((0, Support_1.defined)((0, collection_utils_1.iterableMax)(widths.map((l) => (0, collection_utils_1.withDefault)(l[i2], 0)))));
            }
            for (let y = 0; y < numRows; y++) {
              indentIfNeeded();
              const row = (0, Support_1.defined)(t[y]);
              const rowWidths = (0, Support_1.defined)(widths[y]);
              for (let x = 0; x < numColumns; x++) {
                const colWidth = columnWidths[x];
                const src = (0, collection_utils_1.withDefault)(row[x], {
                  kind: "text",
                  text: ""
                });
                const srcWidth = (0, collection_utils_1.withDefault)(rowWidths[x], 0);
                serializeToStringArray(src);
                if (x < numColumns - 1 && srcWidth < colWidth) {
                  currentLine.push((0, Strings_1.repeatString)(" ", colWidth - srcWidth));
                }
              }
              if (y < numRows - 1) {
                finishLine();
                indentNeeded = indent;
              }
            }
            break;
          case "annotated":
            const start = currentLocation();
            serializeToStringArray(source.source);
            const end = currentLocation();
            annotations.push({
              annotation: source.annotation,
              span: {
                start,
                end
              }
            });
            break;
          case "name":
            (0, Support_1.assert)(names.has(source.named), "No name for Named");
            indentIfNeeded();
            currentLine.push((0, Support_1.defined)(names.get(source.named)));
            break;
          case "modified":
            indentIfNeeded();
            const serialized = serializeRenderResult(source.source, names, indentation).lines;
            (0, Support_1.assert)(serialized.length === 1, "Cannot modify more than one line.");
            currentLine.push(source.modifier(serialized[0]));
            break;
          default:
            return (0, Support_1.assertNever)(source);
        }
      }
      serializeToStringArray(rootSource);
      finishLine();
      return {
        lines,
        annotations
      };
    }
    function singleWord(...source) {
      return {
        source,
        needsParens: false
      };
    }
    function multiWord(separator, ...words) {
      (0, Support_1.assert)(words.length > 0, "Zero words is not multiple");
      if (words.length === 1) {
        return singleWord(words[0]);
      }
      const items = [];
      for (let i2 = 0; i2 < words.length; i2++) {
        if (i2 > 0) items.push(separator);
        items.push(words[i2]);
      }
      return {
        source: items,
        needsParens: true
      };
    }
    function parenIfNeeded({ source, needsParens }) {
      if (needsParens) {
        return [
          "(",
          source,
          ")"
        ];
      }
      return source;
    }
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/Renderer.js
var require_Renderer = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/Renderer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Renderer = void 0;
    var collection_utils_1 = require_dist();
    var Annotation_1 = require_Annotation();
    var Naming_1 = require_Naming();
    var Source_1 = require_Source();
    var Support_1 = require_Support();
    function getBlankLineConfig(cfg) {
      if (Array.isArray(cfg)) {
        return {
          position: cfg[0],
          count: cfg[1]
        };
      }
      return {
        position: cfg,
        count: 1
      };
    }
    function lineIndentation(line) {
      const len = line.length;
      let indent = 0;
      for (let i2 = 0; i2 < len; i2++) {
        const c = line.charAt(i2);
        if (c === " ") {
          indent += 1;
        } else if (c === "	") {
          indent = (indent / 4 + 1) * 4;
        } else {
          return {
            indent,
            text: line.substring(i2)
          };
        }
      }
      return {
        indent: 0,
        text: null
      };
    }
    var EmitContext = class {
      constructor() {
        this._currentEmitTarget = this._emitted = [];
        this._numBlankLinesNeeded = 0;
        this._preventBlankLine = true;
      }
      get isEmpty() {
        return this._emitted.length === 0;
      }
      get isNested() {
        return this._emitted !== this._currentEmitTarget;
      }
      get source() {
        return this._emitted;
      }
      pushItem(item) {
        this._currentEmitTarget.push(item);
        this._preventBlankLine = false;
      }
      emitNewline() {
        const nl = (0, Source_1.newline)();
        this.pushItem(nl);
        this._lastNewline = nl;
      }
      emitItem(item) {
        if (!this.isEmpty) {
          for (let i2 = 0; i2 < this._numBlankLinesNeeded; i2++) {
            this.emitNewline();
          }
        }
        this._numBlankLinesNeeded = 0;
        this.pushItem(item);
      }
      containsItem(item) {
        const existingItem = this._currentEmitTarget.find((value) => item === value);
        return existingItem !== void 0;
      }
      ensureBlankLine(numBlankLines) {
        if (this._preventBlankLine) return;
        this._numBlankLinesNeeded = Math.max(this._numBlankLinesNeeded, numBlankLines);
      }
      preventBlankLine() {
        this._numBlankLinesNeeded = 0;
        this._preventBlankLine = true;
      }
      changeIndent(offset) {
        if (this._lastNewline === void 0) {
          (0, Support_1.panic)("Cannot change indent for the first line");
        }
        this._lastNewline.indentationChange += offset;
      }
    };
    var Renderer = class {
      constructor(targetLanguage, renderContext) {
        this.targetLanguage = targetLanguage;
        this.emitTable = (tableArray) => {
          if (tableArray.length === 0) return;
          const table = tableArray.map((r) => r.map((sl) => (0, Source_1.sourcelikeToSource)(sl)));
          this._emitContext.emitItem({
            kind: "table",
            table
          });
          this._emitContext.emitNewline();
        };
        this.typeGraph = renderContext.typeGraph;
        this.leadingComments = renderContext.leadingComments;
        this._finishedFiles = /* @__PURE__ */ new Map();
        this._finishedEmitContexts = /* @__PURE__ */ new Map();
        this._emitContext = new EmitContext();
      }
      // FIXME: make protected once JavaDateTimeRenderer is refactored
      ensureBlankLine(numBlankLines = 1) {
        this._emitContext.ensureBlankLine(numBlankLines);
      }
      preventBlankLine() {
        this._emitContext.preventBlankLine();
      }
      emitItem(item) {
        this._emitContext.emitItem(item);
      }
      emitItemOnce(item) {
        if (this._emitContext.containsItem(item)) {
          return false;
        }
        this.emitItem(item);
        return true;
      }
      emitLineOnce(...lineParts) {
        let lineEmitted = true;
        if (lineParts.length === 1) {
          lineEmitted = this.emitItemOnce(lineParts[0]);
        } else if (lineParts.length > 1) {
          lineEmitted = this.emitItemOnce(lineParts);
        }
        if (lineEmitted) {
          this._emitContext.emitNewline();
        }
      }
      // FIXME: make protected once JavaDateTimeRenderer is refactored
      emitLine(...lineParts) {
        if (lineParts.length === 1) {
          this._emitContext.emitItem(lineParts[0]);
        } else if (lineParts.length > 1) {
          this._emitContext.emitItem(lineParts);
        }
        this._emitContext.emitNewline();
      }
      emitMultiline(linesString) {
        const lines = linesString.split("\n");
        const numLines = lines.length;
        if (numLines === 0) return;
        this.emitLine(lines[0]);
        let currentIndent = 0;
        for (let i2 = 1; i2 < numLines; i2++) {
          const line = lines[i2];
          const { indent, text } = lineIndentation(line);
          (0, Support_1.assert)(indent % 4 === 0, "Indentation is not a multiple of 4.");
          if (text !== null) {
            const newIndent = indent / 4;
            this.changeIndent(newIndent - currentIndent);
            currentIndent = newIndent;
            this.emitLine(text);
          } else {
            this._emitContext.emitNewline();
          }
        }
        if (currentIndent !== 0) {
          this.changeIndent(-currentIndent);
        }
      }
      gatherSource(emitter) {
        const oldEmitContext = this._emitContext;
        this._emitContext = new EmitContext();
        emitter();
        (0, Support_1.assert)(!this._emitContext.isNested, "emit context not restored correctly");
        const source = this._emitContext.source;
        this._emitContext = oldEmitContext;
        return source;
      }
      emitGatheredSource(items) {
        for (const item of items) {
          this._emitContext.emitItem(item);
        }
      }
      emitAnnotated(annotation, emitter) {
        const lines = this.gatherSource(emitter);
        const source = (0, Source_1.sourcelikeToSource)(lines);
        this._emitContext.emitItem((0, Source_1.annotated)(annotation, source));
      }
      emitIssue(message, emitter) {
        this.emitAnnotated(new Annotation_1.IssueAnnotationData(message), emitter);
      }
      changeIndent(offset) {
        this._emitContext.changeIndent(offset);
      }
      iterableForEach(iterable, emitter) {
        const items = Array.from(iterable);
        let onFirst = true;
        for (const [i2, v] of (0, collection_utils_1.iterableEnumerate)(items)) {
          const position = items.length === 1 ? "only" : onFirst ? "first" : i2 === items.length - 1 ? "last" : "middle";
          emitter(v, position);
          onFirst = false;
        }
      }
      forEach(iterable, interposedBlankLines, leadingBlankLines, emitter) {
        let didEmit = false;
        this.iterableForEach(iterable, ([k, v], position) => {
          if (position === "only" || position === "first") {
            this.ensureBlankLine(leadingBlankLines);
          } else {
            this.ensureBlankLine(interposedBlankLines);
          }
          emitter(v, k, position);
          didEmit = true;
        });
        return didEmit;
      }
      forEachWithBlankLines(iterable, blankLineConfig, emitter) {
        const { position, count } = getBlankLineConfig(blankLineConfig);
        const interposing = [
          "interposing",
          "leading-and-interposing"
        ].includes(position);
        const leading = [
          "leading",
          "leading-and-interposing"
        ].includes(position);
        return this.forEach(iterable, interposing ? count : 0, leading ? count : 0, emitter);
      }
      // FIXME: make protected once JavaDateTimeRenderer is refactored
      indent(fn) {
        this.changeIndent(1);
        fn();
        this.changeIndent(-1);
      }
      assignNames() {
        return (0, Naming_1.assignNames)(this.setUpNaming());
      }
      initializeEmitContextForFilename(filename) {
        if (this._finishedEmitContexts.has(filename.toLowerCase())) {
          const existingEmitContext = this._finishedEmitContexts.get(filename.toLowerCase());
          if (existingEmitContext !== void 0) {
            this._emitContext = existingEmitContext;
          }
        }
      }
      finishFile(filename) {
        if (this._finishedFiles.has(filename)) {
          console.log(`[WARNING] Tried to emit file ${filename} more than once. If performing multi-file output this warning can be safely ignored.`);
        }
        const source = (0, Source_1.sourcelikeToSource)(this._emitContext.source);
        this._finishedFiles.set(filename, source);
        this._finishedEmitContexts.set(filename.toLowerCase(), this._emitContext);
        this._emitContext = new EmitContext();
      }
      render(givenOutputFilename) {
        this._names = this.assignNames();
        this.emitSource(givenOutputFilename);
        if (!this._emitContext.isEmpty) {
          this.finishFile(givenOutputFilename);
        }
        return {
          sources: this._finishedFiles,
          names: this._names
        };
      }
      get names() {
        if (this._names === void 0) {
          return (0, Support_1.panic)("Names accessed before they were assigned");
        }
        return this._names;
      }
    };
    exports.Renderer = Renderer;
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/support/Comments.js
var require_Comments = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/support/Comments.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.isStringComment = void 0;
    var isStringComment = (comment) => {
      return typeof comment === "string";
    };
    exports.isStringComment = isStringComment;
  }
});

// ../../../../../node_modules/.deno/urijs@1.19.11/node_modules/urijs/src/punycode.js
var require_punycode = __commonJS({
  "../../../../../node_modules/.deno/urijs@1.19.11/node_modules/urijs/src/punycode.js"(exports, module) {
    (function(root) {
      var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
      var freeModule = typeof module == "object" && module && !module.nodeType && module;
      var freeGlobal = typeof global == "object" && global;
      if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal) {
        root = freeGlobal;
      }
      var punycode, maxInt = 2147483647, base = 36, tMin = 1, tMax = 26, skew = 38, damp = 700, initialBias = 72, initialN = 128, delimiter = "-", regexPunycode = /^xn--/, regexNonASCII = /[^\x20-\x7E]/, regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, errors = {
        "overflow": "Overflow: input needs wider integers to process",
        "not-basic": "Illegal input >= 0x80 (not a basic code point)",
        "invalid-input": "Invalid input"
      }, baseMinusTMin = base - tMin, floor = Math.floor, stringFromCharCode = String.fromCharCode, key;
      function error(type) {
        throw new RangeError(errors[type]);
      }
      function map(array, fn) {
        var length = array.length;
        var result = [];
        while (length--) {
          result[length] = fn(array[length]);
        }
        return result;
      }
      function mapDomain(string, fn) {
        var parts = string.split("@");
        var result = "";
        if (parts.length > 1) {
          result = parts[0] + "@";
          string = parts[1];
        }
        string = string.replace(regexSeparators, ".");
        var labels = string.split(".");
        var encoded = map(labels, fn).join(".");
        return result + encoded;
      }
      function ucs2decode(string) {
        var output = [], counter = 0, length = string.length, value, extra;
        while (counter < length) {
          value = string.charCodeAt(counter++);
          if (value >= 55296 && value <= 56319 && counter < length) {
            extra = string.charCodeAt(counter++);
            if ((extra & 64512) == 56320) {
              output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
            } else {
              output.push(value);
              counter--;
            }
          } else {
            output.push(value);
          }
        }
        return output;
      }
      function ucs2encode(array) {
        return map(array, function(value) {
          var output = "";
          if (value > 65535) {
            value -= 65536;
            output += stringFromCharCode(value >>> 10 & 1023 | 55296);
            value = 56320 | value & 1023;
          }
          output += stringFromCharCode(value);
          return output;
        }).join("");
      }
      function basicToDigit(codePoint) {
        if (codePoint - 48 < 10) {
          return codePoint - 22;
        }
        if (codePoint - 65 < 26) {
          return codePoint - 65;
        }
        if (codePoint - 97 < 26) {
          return codePoint - 97;
        }
        return base;
      }
      function digitToBasic(digit, flag) {
        return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
      }
      function adapt(delta, numPoints, firstTime) {
        var k = 0;
        delta = firstTime ? floor(delta / damp) : delta >> 1;
        delta += floor(delta / numPoints);
        for (; delta > baseMinusTMin * tMax >> 1; k += base) {
          delta = floor(delta / baseMinusTMin);
        }
        return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
      }
      function decode(input) {
        var output = [], inputLength = input.length, out, i2 = 0, n = initialN, bias = initialBias, basic, j, index, oldi, w, k, digit, t, baseMinusT;
        basic = input.lastIndexOf(delimiter);
        if (basic < 0) {
          basic = 0;
        }
        for (j = 0; j < basic; ++j) {
          if (input.charCodeAt(j) >= 128) {
            error("not-basic");
          }
          output.push(input.charCodeAt(j));
        }
        for (index = basic > 0 ? basic + 1 : 0; index < inputLength; ) {
          for (oldi = i2, w = 1, k = base; ; k += base) {
            if (index >= inputLength) {
              error("invalid-input");
            }
            digit = basicToDigit(input.charCodeAt(index++));
            if (digit >= base || digit > floor((maxInt - i2) / w)) {
              error("overflow");
            }
            i2 += digit * w;
            t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
            if (digit < t) {
              break;
            }
            baseMinusT = base - t;
            if (w > floor(maxInt / baseMinusT)) {
              error("overflow");
            }
            w *= baseMinusT;
          }
          out = output.length + 1;
          bias = adapt(i2 - oldi, out, oldi == 0);
          if (floor(i2 / out) > maxInt - n) {
            error("overflow");
          }
          n += floor(i2 / out);
          i2 %= out;
          output.splice(i2++, 0, n);
        }
        return ucs2encode(output);
      }
      function encode(input) {
        var n, delta, handledCPCount, basicLength, bias, j, m, q, k, t, currentValue, output = [], inputLength, handledCPCountPlusOne, baseMinusT, qMinusT;
        input = ucs2decode(input);
        inputLength = input.length;
        n = initialN;
        delta = 0;
        bias = initialBias;
        for (j = 0; j < inputLength; ++j) {
          currentValue = input[j];
          if (currentValue < 128) {
            output.push(stringFromCharCode(currentValue));
          }
        }
        handledCPCount = basicLength = output.length;
        if (basicLength) {
          output.push(delimiter);
        }
        while (handledCPCount < inputLength) {
          for (m = maxInt, j = 0; j < inputLength; ++j) {
            currentValue = input[j];
            if (currentValue >= n && currentValue < m) {
              m = currentValue;
            }
          }
          handledCPCountPlusOne = handledCPCount + 1;
          if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
            error("overflow");
          }
          delta += (m - n) * handledCPCountPlusOne;
          n = m;
          for (j = 0; j < inputLength; ++j) {
            currentValue = input[j];
            if (currentValue < n && ++delta > maxInt) {
              error("overflow");
            }
            if (currentValue == n) {
              for (q = delta, k = base; ; k += base) {
                t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                if (q < t) {
                  break;
                }
                qMinusT = q - t;
                baseMinusT = base - t;
                output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
                q = floor(qMinusT / baseMinusT);
              }
              output.push(stringFromCharCode(digitToBasic(q, 0)));
              bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
              delta = 0;
              ++handledCPCount;
            }
          }
          ++delta;
          ++n;
        }
        return output.join("");
      }
      function toUnicode(input) {
        return mapDomain(input, function(string) {
          return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
        });
      }
      function toASCII(input) {
        return mapDomain(input, function(string) {
          return regexNonASCII.test(string) ? "xn--" + encode(string) : string;
        });
      }
      punycode = {
        /**
        * A string representing the current Punycode.js version number.
        * @memberOf punycode
        * @type String
        */
        "version": "1.3.2",
        /**
        * An object of methods to convert from JavaScript's internal character
        * representation (UCS-2) to Unicode code points, and back.
        * @see <https://mathiasbynens.be/notes/javascript-encoding>
        * @memberOf punycode
        * @type Object
        */
        "ucs2": {
          "decode": ucs2decode,
          "encode": ucs2encode
        },
        "decode": decode,
        "encode": encode,
        "toASCII": toASCII,
        "toUnicode": toUnicode
      };
      if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
        define("punycode", function() {
          return punycode;
        });
      } else if (freeExports && freeModule) {
        if (module.exports == freeExports) {
          freeModule.exports = punycode;
        } else {
          for (key in punycode) {
            punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
          }
        }
      } else {
        root.punycode = punycode;
      }
    })(exports);
  }
});

// ../../../../../node_modules/.deno/urijs@1.19.11/node_modules/urijs/src/IPv6.js
var require_IPv6 = __commonJS({
  "../../../../../node_modules/.deno/urijs@1.19.11/node_modules/urijs/src/IPv6.js"(exports, module) {
    (function(root, factory) {
      "use strict";
      if (typeof module === "object" && module.exports) {
        module.exports = factory();
      } else if (typeof define === "function" && define.amd) {
        define(factory);
      } else {
        root.IPv6 = factory(root);
      }
    })(exports, function(root) {
      "use strict";
      var _IPv6 = root && root.IPv6;
      function bestPresentation(address) {
        var _address = address.toLowerCase();
        var segments = _address.split(":");
        var length = segments.length;
        var total = 8;
        if (segments[0] === "" && segments[1] === "" && segments[2] === "") {
          segments.shift();
          segments.shift();
        } else if (segments[0] === "" && segments[1] === "") {
          segments.shift();
        } else if (segments[length - 1] === "" && segments[length - 2] === "") {
          segments.pop();
        }
        length = segments.length;
        if (segments[length - 1].indexOf(".") !== -1) {
          total = 7;
        }
        var pos;
        for (pos = 0; pos < length; pos++) {
          if (segments[pos] === "") {
            break;
          }
        }
        if (pos < total) {
          segments.splice(pos, 1, "0000");
          while (segments.length < total) {
            segments.splice(pos, 0, "0000");
          }
        }
        var _segments;
        for (var i2 = 0; i2 < total; i2++) {
          _segments = segments[i2].split("");
          for (var j = 0; j < 3; j++) {
            if (_segments[0] === "0" && _segments.length > 1) {
              _segments.splice(0, 1);
            } else {
              break;
            }
          }
          segments[i2] = _segments.join("");
        }
        var best = -1;
        var _best = 0;
        var _current = 0;
        var current = -1;
        var inzeroes = false;
        for (i2 = 0; i2 < total; i2++) {
          if (inzeroes) {
            if (segments[i2] === "0") {
              _current += 1;
            } else {
              inzeroes = false;
              if (_current > _best) {
                best = current;
                _best = _current;
              }
            }
          } else {
            if (segments[i2] === "0") {
              inzeroes = true;
              current = i2;
              _current = 1;
            }
          }
        }
        if (_current > _best) {
          best = current;
          _best = _current;
        }
        if (_best > 1) {
          segments.splice(best, _best, "");
        }
        length = segments.length;
        var result = "";
        if (segments[0] === "") {
          result = ":";
        }
        for (i2 = 0; i2 < length; i2++) {
          result += segments[i2];
          if (i2 === length - 1) {
            break;
          }
          result += ":";
        }
        if (segments[length - 1] === "") {
          result += ":";
        }
        return result;
      }
      function noConflict() {
        if (root.IPv6 === this) {
          root.IPv6 = _IPv6;
        }
        return this;
      }
      return {
        best: bestPresentation,
        noConflict
      };
    });
  }
});

// ../../../../../node_modules/.deno/urijs@1.19.11/node_modules/urijs/src/SecondLevelDomains.js
var require_SecondLevelDomains = __commonJS({
  "../../../../../node_modules/.deno/urijs@1.19.11/node_modules/urijs/src/SecondLevelDomains.js"(exports, module) {
    (function(root, factory) {
      "use strict";
      if (typeof module === "object" && module.exports) {
        module.exports = factory();
      } else if (typeof define === "function" && define.amd) {
        define(factory);
      } else {
        root.SecondLevelDomains = factory(root);
      }
    })(exports, function(root) {
      "use strict";
      var _SecondLevelDomains = root && root.SecondLevelDomains;
      var SLD = {
        // list of known Second Level Domains
        // converted list of SLDs from https://github.com/gavingmiller/second-level-domains
        // ----
        // publicsuffix.org is more current and actually used by a couple of browsers internally.
        // downside is it also contains domains like "dyndns.org" - which is fine for the security
        // issues browser have to deal with (SOP for cookies, etc) - but is way overboard for URI.js
        // ----
        list: {
          "ac": " com gov mil net org ",
          "ae": " ac co gov mil name net org pro sch ",
          "af": " com edu gov net org ",
          "al": " com edu gov mil net org ",
          "ao": " co ed gv it og pb ",
          "ar": " com edu gob gov int mil net org tur ",
          "at": " ac co gv or ",
          "au": " asn com csiro edu gov id net org ",
          "ba": " co com edu gov mil net org rs unbi unmo unsa untz unze ",
          "bb": " biz co com edu gov info net org store tv ",
          "bh": " biz cc com edu gov info net org ",
          "bn": " com edu gov net org ",
          "bo": " com edu gob gov int mil net org tv ",
          "br": " adm adv agr am arq art ato b bio blog bmd cim cng cnt com coop ecn edu eng esp etc eti far flog fm fnd fot fst g12 ggf gov imb ind inf jor jus lel mat med mil mus net nom not ntr odo org ppg pro psc psi qsl rec slg srv tmp trd tur tv vet vlog wiki zlg ",
          "bs": " com edu gov net org ",
          "bz": " du et om ov rg ",
          "ca": " ab bc mb nb nf nl ns nt nu on pe qc sk yk ",
          "ck": " biz co edu gen gov info net org ",
          "cn": " ac ah bj com cq edu fj gd gov gs gx gz ha hb he hi hl hn jl js jx ln mil net nm nx org qh sc sd sh sn sx tj tw xj xz yn zj ",
          "co": " com edu gov mil net nom org ",
          "cr": " ac c co ed fi go or sa ",
          "cy": " ac biz com ekloges gov ltd name net org parliament press pro tm ",
          "do": " art com edu gob gov mil net org sld web ",
          "dz": " art asso com edu gov net org pol ",
          "ec": " com edu fin gov info med mil net org pro ",
          "eg": " com edu eun gov mil name net org sci ",
          "er": " com edu gov ind mil net org rochest w ",
          "es": " com edu gob nom org ",
          "et": " biz com edu gov info name net org ",
          "fj": " ac biz com info mil name net org pro ",
          "fk": " ac co gov net nom org ",
          "fr": " asso com f gouv nom prd presse tm ",
          "gg": " co net org ",
          "gh": " com edu gov mil org ",
          "gn": " ac com gov net org ",
          "gr": " com edu gov mil net org ",
          "gt": " com edu gob ind mil net org ",
          "gu": " com edu gov net org ",
          "hk": " com edu gov idv net org ",
          "hu": " 2000 agrar bolt casino city co erotica erotika film forum games hotel info ingatlan jogasz konyvelo lakas media news org priv reklam sex shop sport suli szex tm tozsde utazas video ",
          "id": " ac co go mil net or sch web ",
          "il": " ac co gov idf k12 muni net org ",
          "in": " ac co edu ernet firm gen gov i ind mil net nic org res ",
          "iq": " com edu gov i mil net org ",
          "ir": " ac co dnssec gov i id net org sch ",
          "it": " edu gov ",
          "je": " co net org ",
          "jo": " com edu gov mil name net org sch ",
          "jp": " ac ad co ed go gr lg ne or ",
          "ke": " ac co go info me mobi ne or sc ",
          "kh": " com edu gov mil net org per ",
          "ki": " biz com de edu gov info mob net org tel ",
          "km": " asso com coop edu gouv k medecin mil nom notaires pharmaciens presse tm veterinaire ",
          "kn": " edu gov net org ",
          "kr": " ac busan chungbuk chungnam co daegu daejeon es gangwon go gwangju gyeongbuk gyeonggi gyeongnam hs incheon jeju jeonbuk jeonnam k kg mil ms ne or pe re sc seoul ulsan ",
          "kw": " com edu gov net org ",
          "ky": " com edu gov net org ",
          "kz": " com edu gov mil net org ",
          "lb": " com edu gov net org ",
          "lk": " assn com edu gov grp hotel int ltd net ngo org sch soc web ",
          "lr": " com edu gov net org ",
          "lv": " asn com conf edu gov id mil net org ",
          "ly": " com edu gov id med net org plc sch ",
          "ma": " ac co gov m net org press ",
          "mc": " asso tm ",
          "me": " ac co edu gov its net org priv ",
          "mg": " com edu gov mil nom org prd tm ",
          "mk": " com edu gov inf name net org pro ",
          "ml": " com edu gov net org presse ",
          "mn": " edu gov org ",
          "mo": " com edu gov net org ",
          "mt": " com edu gov net org ",
          "mv": " aero biz com coop edu gov info int mil museum name net org pro ",
          "mw": " ac co com coop edu gov int museum net org ",
          "mx": " com edu gob net org ",
          "my": " com edu gov mil name net org sch ",
          "nf": " arts com firm info net other per rec store web ",
          "ng": " biz com edu gov mil mobi name net org sch ",
          "ni": " ac co com edu gob mil net nom org ",
          "np": " com edu gov mil net org ",
          "nr": " biz com edu gov info net org ",
          "om": " ac biz co com edu gov med mil museum net org pro sch ",
          "pe": " com edu gob mil net nom org sld ",
          "ph": " com edu gov i mil net ngo org ",
          "pk": " biz com edu fam gob gok gon gop gos gov net org web ",
          "pl": " art bialystok biz com edu gda gdansk gorzow gov info katowice krakow lodz lublin mil net ngo olsztyn org poznan pwr radom slupsk szczecin torun warszawa waw wroc wroclaw zgora ",
          "pr": " ac biz com edu est gov info isla name net org pro prof ",
          "ps": " com edu gov net org plo sec ",
          "pw": " belau co ed go ne or ",
          "ro": " arts com firm info nom nt org rec store tm www ",
          "rs": " ac co edu gov in org ",
          "sb": " com edu gov net org ",
          "sc": " com edu gov net org ",
          "sh": " co com edu gov net nom org ",
          "sl": " com edu gov net org ",
          "st": " co com consulado edu embaixada gov mil net org principe saotome store ",
          "sv": " com edu gob org red ",
          "sz": " ac co org ",
          "tr": " av bbs bel biz com dr edu gen gov info k12 name net org pol tel tsk tv web ",
          "tt": " aero biz cat co com coop edu gov info int jobs mil mobi museum name net org pro tel travel ",
          "tw": " club com ebiz edu game gov idv mil net org ",
          "mu": " ac co com gov net or org ",
          "mz": " ac co edu gov org ",
          "na": " co com ",
          "nz": " ac co cri geek gen govt health iwi maori mil net org parliament school ",
          "pa": " abo ac com edu gob ing med net nom org sld ",
          "pt": " com edu gov int net nome org publ ",
          "py": " com edu gov mil net org ",
          "qa": " com edu gov mil net org ",
          "re": " asso com nom ",
          "ru": " ac adygeya altai amur arkhangelsk astrakhan bashkiria belgorod bir bryansk buryatia cbg chel chelyabinsk chita chukotka chuvashia com dagestan e-burg edu gov grozny int irkutsk ivanovo izhevsk jar joshkar-ola kalmykia kaluga kamchatka karelia kazan kchr kemerovo khabarovsk khakassia khv kirov koenig komi kostroma kranoyarsk kuban kurgan kursk lipetsk magadan mari mari-el marine mil mordovia mosreg msk murmansk nalchik net nnov nov novosibirsk nsk omsk orenburg org oryol penza perm pp pskov ptz rnd ryazan sakhalin samara saratov simbirsk smolensk spb stavropol stv surgut tambov tatarstan tom tomsk tsaritsyn tsk tula tuva tver tyumen udm udmurtia ulan-ude vladikavkaz vladimir vladivostok volgograd vologda voronezh vrn vyatka yakutia yamal yekaterinburg yuzhno-sakhalinsk ",
          "rw": " ac co com edu gouv gov int mil net ",
          "sa": " com edu gov med net org pub sch ",
          "sd": " com edu gov info med net org tv ",
          "se": " a ac b bd c d e f g h i k l m n o org p parti pp press r s t tm u w x y z ",
          "sg": " com edu gov idn net org per ",
          "sn": " art com edu gouv org perso univ ",
          "sy": " com edu gov mil net news org ",
          "th": " ac co go in mi net or ",
          "tj": " ac biz co com edu go gov info int mil name net nic org test web ",
          "tn": " agrinet com defense edunet ens fin gov ind info intl mincom nat net org perso rnrt rns rnu tourism ",
          "tz": " ac co go ne or ",
          "ua": " biz cherkassy chernigov chernovtsy ck cn co com crimea cv dn dnepropetrovsk donetsk dp edu gov if in ivano-frankivsk kh kharkov kherson khmelnitskiy kiev kirovograd km kr ks kv lg lugansk lutsk lviv me mk net nikolaev od odessa org pl poltava pp rovno rv sebastopol sumy te ternopil uzhgorod vinnica vn zaporizhzhe zhitomir zp zt ",
          "ug": " ac co go ne or org sc ",
          "uk": " ac bl british-library co cym gov govt icnet jet lea ltd me mil mod national-library-scotland nel net nhs nic nls org orgn parliament plc police sch scot soc ",
          "us": " dni fed isa kids nsn ",
          "uy": " com edu gub mil net org ",
          "ve": " co com edu gob info mil net org web ",
          "vi": " co com k12 net org ",
          "vn": " ac biz com edu gov health info int name net org pro ",
          "ye": " co com gov ltd me net org plc ",
          "yu": " ac co edu gov org ",
          "za": " ac agric alt bourse city co cybernet db edu gov grondar iaccess imt inca landesign law mil net ngo nis nom olivetti org pix school tm web ",
          "zm": " ac co com edu gov net org sch ",
          // https://en.wikipedia.org/wiki/CentralNic#Second-level_domains
          "com": "ar br cn de eu gb gr hu jpn kr no qc ru sa se uk us uy za ",
          "net": "gb jp se uk ",
          "org": "ae",
          "de": "com "
        },
        // gorhill 2013-10-25: Using indexOf() instead Regexp(). Significant boost
        // in both performance and memory footprint. No initialization required.
        // http://jsperf.com/uri-js-sld-regex-vs-binary-search/4
        // Following methods use lastIndexOf() rather than array.split() in order
        // to avoid any memory allocations.
        has: function(domain) {
          var tldOffset = domain.lastIndexOf(".");
          if (tldOffset <= 0 || tldOffset >= domain.length - 1) {
            return false;
          }
          var sldOffset = domain.lastIndexOf(".", tldOffset - 1);
          if (sldOffset <= 0 || sldOffset >= tldOffset - 1) {
            return false;
          }
          var sldList = SLD.list[domain.slice(tldOffset + 1)];
          if (!sldList) {
            return false;
          }
          return sldList.indexOf(" " + domain.slice(sldOffset + 1, tldOffset) + " ") >= 0;
        },
        is: function(domain) {
          var tldOffset = domain.lastIndexOf(".");
          if (tldOffset <= 0 || tldOffset >= domain.length - 1) {
            return false;
          }
          var sldOffset = domain.lastIndexOf(".", tldOffset - 1);
          if (sldOffset >= 0) {
            return false;
          }
          var sldList = SLD.list[domain.slice(tldOffset + 1)];
          if (!sldList) {
            return false;
          }
          return sldList.indexOf(" " + domain.slice(0, tldOffset) + " ") >= 0;
        },
        get: function(domain) {
          var tldOffset = domain.lastIndexOf(".");
          if (tldOffset <= 0 || tldOffset >= domain.length - 1) {
            return null;
          }
          var sldOffset = domain.lastIndexOf(".", tldOffset - 1);
          if (sldOffset <= 0 || sldOffset >= tldOffset - 1) {
            return null;
          }
          var sldList = SLD.list[domain.slice(tldOffset + 1)];
          if (!sldList) {
            return null;
          }
          if (sldList.indexOf(" " + domain.slice(sldOffset + 1, tldOffset) + " ") < 0) {
            return null;
          }
          return domain.slice(sldOffset + 1);
        },
        noConflict: function() {
          if (root.SecondLevelDomains === this) {
            root.SecondLevelDomains = _SecondLevelDomains;
          }
          return this;
        }
      };
      return SLD;
    });
  }
});

// ../../../../../node_modules/.deno/urijs@1.19.11/node_modules/urijs/src/URI.js
var require_URI = __commonJS({
  "../../../../../node_modules/.deno/urijs@1.19.11/node_modules/urijs/src/URI.js"(exports, module) {
    (function(root, factory) {
      "use strict";
      if (typeof module === "object" && module.exports) {
        module.exports = factory(require_punycode(), require_IPv6(), require_SecondLevelDomains());
      } else if (typeof define === "function" && define.amd) {
        define([
          "./punycode",
          "./IPv6",
          "./SecondLevelDomains"
        ], factory);
      } else {
        root.URI = factory(root.punycode, root.IPv6, root.SecondLevelDomains, root);
      }
    })(exports, function(punycode, IPv6, SLD, root) {
      "use strict";
      var _URI = root && root.URI;
      function URI(url, base) {
        var _urlSupplied = arguments.length >= 1;
        var _baseSupplied = arguments.length >= 2;
        if (!(this instanceof URI)) {
          if (_urlSupplied) {
            if (_baseSupplied) {
              return new URI(url, base);
            }
            return new URI(url);
          }
          return new URI();
        }
        if (url === void 0) {
          if (_urlSupplied) {
            throw new TypeError("undefined is not a valid argument for URI");
          }
          if (typeof location !== "undefined") {
            url = location.href + "";
          } else {
            url = "";
          }
        }
        if (url === null) {
          if (_urlSupplied) {
            throw new TypeError("null is not a valid argument for URI");
          }
        }
        this.href(url);
        if (base !== void 0) {
          return this.absoluteTo(base);
        }
        return this;
      }
      function isInteger(value) {
        return /^[0-9]+$/.test(value);
      }
      URI.version = "1.19.11";
      var p = URI.prototype;
      var hasOwn = Object.prototype.hasOwnProperty;
      function escapeRegEx(string) {
        return string.replace(/([.*+?^=!:${}()|[\]\/\\])/g, "\\$1");
      }
      function getType(value) {
        if (value === void 0) {
          return "Undefined";
        }
        return String(Object.prototype.toString.call(value)).slice(8, -1);
      }
      function isArray(obj2) {
        return getType(obj2) === "Array";
      }
      function filterArrayValues(data, value) {
        var lookup = {};
        var i2, length;
        if (getType(value) === "RegExp") {
          lookup = null;
        } else if (isArray(value)) {
          for (i2 = 0, length = value.length; i2 < length; i2++) {
            lookup[value[i2]] = true;
          }
        } else {
          lookup[value] = true;
        }
        for (i2 = 0, length = data.length; i2 < length; i2++) {
          var _match = lookup && lookup[data[i2]] !== void 0 || !lookup && value.test(data[i2]);
          if (_match) {
            data.splice(i2, 1);
            length--;
            i2--;
          }
        }
        return data;
      }
      function arrayContains(list, value) {
        var i2, length;
        if (isArray(value)) {
          for (i2 = 0, length = value.length; i2 < length; i2++) {
            if (!arrayContains(list, value[i2])) {
              return false;
            }
          }
          return true;
        }
        var _type = getType(value);
        for (i2 = 0, length = list.length; i2 < length; i2++) {
          if (_type === "RegExp") {
            if (typeof list[i2] === "string" && list[i2].match(value)) {
              return true;
            }
          } else if (list[i2] === value) {
            return true;
          }
        }
        return false;
      }
      function arraysEqual(one, two) {
        if (!isArray(one) || !isArray(two)) {
          return false;
        }
        if (one.length !== two.length) {
          return false;
        }
        one.sort();
        two.sort();
        for (var i2 = 0, l = one.length; i2 < l; i2++) {
          if (one[i2] !== two[i2]) {
            return false;
          }
        }
        return true;
      }
      function trimSlashes(text) {
        var trim_expression = /^\/+|\/+$/g;
        return text.replace(trim_expression, "");
      }
      URI._parts = function() {
        return {
          protocol: null,
          username: null,
          password: null,
          hostname: null,
          urn: null,
          port: null,
          path: null,
          query: null,
          fragment: null,
          // state
          preventInvalidHostname: URI.preventInvalidHostname,
          duplicateQueryParameters: URI.duplicateQueryParameters,
          escapeQuerySpace: URI.escapeQuerySpace
        };
      };
      URI.preventInvalidHostname = false;
      URI.duplicateQueryParameters = false;
      URI.escapeQuerySpace = true;
      URI.protocol_expression = /^[a-z][a-z0-9.+-]*$/i;
      URI.idn_expression = /[^a-z0-9\._-]/i;
      URI.punycode_expression = /(xn--)/i;
      URI.ip4_expression = /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/;
      URI.ip6_expression = /^\s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(%.+)?\s*$/;
      URI.find_uri_expression = /\b((?:[a-z][\w-]+:(?:\/{1,3}|[a-z0-9%])|www\d{0,3}[.]|[a-z0-9.\-]+[.][a-z]{2,4}\/)(?:[^\s()<>]+|\(([^\s()<>]+|(\([^\s()<>]+\)))*\))+(?:\(([^\s()<>]+|(\([^\s()<>]+\)))*\)|[^\s`!()\[\]{};:'".,<>?Â«Â»ââââ]))/ig;
      URI.findUri = {
        // valid "scheme://" or "www."
        start: /\b(?:([a-z][a-z0-9.+-]*:\/\/)|www\.)/gi,
        // everything up to the next whitespace
        end: /[\s\r\n]|$/,
        // trim trailing punctuation captured by end RegExp
        trim: /[`!()\[\]{};:'".,<>?Â«Â»âââââ]+$/,
        // balanced parens inclusion (), [], {}, <>
        parens: /(\([^\)]*\)|\[[^\]]*\]|\{[^}]*\}|<[^>]*>)/g
      };
      URI.leading_whitespace_expression = /^[\x00-\x20\u00a0\u1680\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]+/;
      URI.ascii_tab_whitespace = /[\u0009\u000A\u000D]+/g;
      URI.defaultPorts = {
        http: "80",
        https: "443",
        ftp: "21",
        gopher: "70",
        ws: "80",
        wss: "443"
      };
      URI.hostProtocols = [
        "http",
        "https"
      ];
      URI.invalid_hostname_characters = /[^a-zA-Z0-9\.\-:_]/;
      URI.domAttributes = {
        "a": "href",
        "blockquote": "cite",
        "link": "href",
        "base": "href",
        "script": "src",
        "form": "action",
        "img": "src",
        "area": "href",
        "iframe": "src",
        "embed": "src",
        "source": "src",
        "track": "src",
        "input": "src",
        "audio": "src",
        "video": "src"
      };
      URI.getDomAttribute = function(node) {
        if (!node || !node.nodeName) {
          return void 0;
        }
        var nodeName = node.nodeName.toLowerCase();
        if (nodeName === "input" && node.type !== "image") {
          return void 0;
        }
        return URI.domAttributes[nodeName];
      };
      function escapeForDumbFirefox36(value) {
        return escape(value);
      }
      function strictEncodeURIComponent(string) {
        return encodeURIComponent(string).replace(/[!'()*]/g, escapeForDumbFirefox36).replace(/\*/g, "%2A");
      }
      URI.encode = strictEncodeURIComponent;
      URI.decode = decodeURIComponent;
      URI.iso8859 = function() {
        URI.encode = escape;
        URI.decode = unescape;
      };
      URI.unicode = function() {
        URI.encode = strictEncodeURIComponent;
        URI.decode = decodeURIComponent;
      };
      URI.characters = {
        pathname: {
          encode: {
            // RFC3986 2.1: For consistency, URI producers and normalizers should
            // use uppercase hexadecimal digits for all percent-encodings.
            expression: /%(24|26|2B|2C|3B|3D|3A|40)/ig,
            map: {
              // -._~!'()*
              "%24": "$",
              "%26": "&",
              "%2B": "+",
              "%2C": ",",
              "%3B": ";",
              "%3D": "=",
              "%3A": ":",
              "%40": "@"
            }
          },
          decode: {
            expression: /[\/\?#]/g,
            map: {
              "/": "%2F",
              "?": "%3F",
              "#": "%23"
            }
          }
        },
        reserved: {
          encode: {
            // RFC3986 2.1: For consistency, URI producers and normalizers should
            // use uppercase hexadecimal digits for all percent-encodings.
            expression: /%(21|23|24|26|27|28|29|2A|2B|2C|2F|3A|3B|3D|3F|40|5B|5D)/ig,
            map: {
              // gen-delims
              "%3A": ":",
              "%2F": "/",
              "%3F": "?",
              "%23": "#",
              "%5B": "[",
              "%5D": "]",
              "%40": "@",
              // sub-delims
              "%21": "!",
              "%24": "$",
              "%26": "&",
              "%27": "'",
              "%28": "(",
              "%29": ")",
              "%2A": "*",
              "%2B": "+",
              "%2C": ",",
              "%3B": ";",
              "%3D": "="
            }
          }
        },
        urnpath: {
          // The characters under `encode` are the characters called out by RFC 2141 as being acceptable
          // for usage in a URN. RFC2141 also calls out "-", ".", and "_" as acceptable characters, but
          // these aren't encoded by encodeURIComponent, so we don't have to call them out here. Also
          // note that the colon character is not featured in the encoding map; this is because URI.js
          // gives the colons in URNs semantic meaning as the delimiters of path segements, and so it
          // should not appear unencoded in a segment itself.
          // See also the note above about RFC3986 and capitalalized hex digits.
          encode: {
            expression: /%(21|24|27|28|29|2A|2B|2C|3B|3D|40)/ig,
            map: {
              "%21": "!",
              "%24": "$",
              "%27": "'",
              "%28": "(",
              "%29": ")",
              "%2A": "*",
              "%2B": "+",
              "%2C": ",",
              "%3B": ";",
              "%3D": "=",
              "%40": "@"
            }
          },
          // These characters are the characters called out by RFC2141 as "reserved" characters that
          // should never appear in a URN, plus the colon character (see note above).
          decode: {
            expression: /[\/\?#:]/g,
            map: {
              "/": "%2F",
              "?": "%3F",
              "#": "%23",
              ":": "%3A"
            }
          }
        }
      };
      URI.encodeQuery = function(string, escapeQuerySpace) {
        var escaped = URI.encode(string + "");
        if (escapeQuerySpace === void 0) {
          escapeQuerySpace = URI.escapeQuerySpace;
        }
        return escapeQuerySpace ? escaped.replace(/%20/g, "+") : escaped;
      };
      URI.decodeQuery = function(string, escapeQuerySpace) {
        string += "";
        if (escapeQuerySpace === void 0) {
          escapeQuerySpace = URI.escapeQuerySpace;
        }
        try {
          return URI.decode(escapeQuerySpace ? string.replace(/\+/g, "%20") : string);
        } catch (e) {
          return string;
        }
      };
      var _parts = {
        "encode": "encode",
        "decode": "decode"
      };
      var _part;
      var generateAccessor = function(_group, _part2) {
        return function(string) {
          try {
            return URI[_part2](string + "").replace(URI.characters[_group][_part2].expression, function(c) {
              return URI.characters[_group][_part2].map[c];
            });
          } catch (e) {
            return string;
          }
        };
      };
      for (_part in _parts) {
        URI[_part + "PathSegment"] = generateAccessor("pathname", _parts[_part]);
        URI[_part + "UrnPathSegment"] = generateAccessor("urnpath", _parts[_part]);
      }
      var generateSegmentedPathFunction = function(_sep, _codingFuncName, _innerCodingFuncName) {
        return function(string) {
          var actualCodingFunc;
          if (!_innerCodingFuncName) {
            actualCodingFunc = URI[_codingFuncName];
          } else {
            actualCodingFunc = function(string2) {
              return URI[_codingFuncName](URI[_innerCodingFuncName](string2));
            };
          }
          var segments = (string + "").split(_sep);
          for (var i2 = 0, length = segments.length; i2 < length; i2++) {
            segments[i2] = actualCodingFunc(segments[i2]);
          }
          return segments.join(_sep);
        };
      };
      URI.decodePath = generateSegmentedPathFunction("/", "decodePathSegment");
      URI.decodeUrnPath = generateSegmentedPathFunction(":", "decodeUrnPathSegment");
      URI.recodePath = generateSegmentedPathFunction("/", "encodePathSegment", "decode");
      URI.recodeUrnPath = generateSegmentedPathFunction(":", "encodeUrnPathSegment", "decode");
      URI.encodeReserved = generateAccessor("reserved", "encode");
      URI.parse = function(string, parts) {
        var pos;
        if (!parts) {
          parts = {
            preventInvalidHostname: URI.preventInvalidHostname
          };
        }
        string = string.replace(URI.leading_whitespace_expression, "");
        string = string.replace(URI.ascii_tab_whitespace, "");
        pos = string.indexOf("#");
        if (pos > -1) {
          parts.fragment = string.substring(pos + 1) || null;
          string = string.substring(0, pos);
        }
        pos = string.indexOf("?");
        if (pos > -1) {
          parts.query = string.substring(pos + 1) || null;
          string = string.substring(0, pos);
        }
        string = string.replace(/^(https?|ftp|wss?)?:+[/\\]*/i, "$1://");
        string = string.replace(/^[/\\]{2,}/i, "//");
        if (string.substring(0, 2) === "//") {
          parts.protocol = null;
          string = string.substring(2);
          string = URI.parseAuthority(string, parts);
        } else {
          pos = string.indexOf(":");
          if (pos > -1) {
            parts.protocol = string.substring(0, pos) || null;
            if (parts.protocol && !parts.protocol.match(URI.protocol_expression)) {
              parts.protocol = void 0;
            } else if (string.substring(pos + 1, pos + 3).replace(/\\/g, "/") === "//") {
              string = string.substring(pos + 3);
              string = URI.parseAuthority(string, parts);
            } else {
              string = string.substring(pos + 1);
              parts.urn = true;
            }
          }
        }
        parts.path = string;
        return parts;
      };
      URI.parseHost = function(string, parts) {
        if (!string) {
          string = "";
        }
        string = string.replace(/\\/g, "/");
        var pos = string.indexOf("/");
        var bracketPos;
        var t;
        if (pos === -1) {
          pos = string.length;
        }
        if (string.charAt(0) === "[") {
          bracketPos = string.indexOf("]");
          parts.hostname = string.substring(1, bracketPos) || null;
          parts.port = string.substring(bracketPos + 2, pos) || null;
          if (parts.port === "/") {
            parts.port = null;
          }
        } else {
          var firstColon = string.indexOf(":");
          var firstSlash = string.indexOf("/");
          var nextColon = string.indexOf(":", firstColon + 1);
          if (nextColon !== -1 && (firstSlash === -1 || nextColon < firstSlash)) {
            parts.hostname = string.substring(0, pos) || null;
            parts.port = null;
          } else {
            t = string.substring(0, pos).split(":");
            parts.hostname = t[0] || null;
            parts.port = t[1] || null;
          }
        }
        if (parts.hostname && string.substring(pos).charAt(0) !== "/") {
          pos++;
          string = "/" + string;
        }
        if (parts.preventInvalidHostname) {
          URI.ensureValidHostname(parts.hostname, parts.protocol);
        }
        if (parts.port) {
          URI.ensureValidPort(parts.port);
        }
        return string.substring(pos) || "/";
      };
      URI.parseAuthority = function(string, parts) {
        string = URI.parseUserinfo(string, parts);
        return URI.parseHost(string, parts);
      };
      URI.parseUserinfo = function(string, parts) {
        var _string = string;
        var firstBackSlash = string.indexOf("\\");
        if (firstBackSlash !== -1) {
          string = string.replace(/\\/g, "/");
        }
        var firstSlash = string.indexOf("/");
        var pos = string.lastIndexOf("@", firstSlash > -1 ? firstSlash : string.length - 1);
        var t;
        if (pos > -1 && (firstSlash === -1 || pos < firstSlash)) {
          t = string.substring(0, pos).split(":");
          parts.username = t[0] ? URI.decode(t[0]) : null;
          t.shift();
          parts.password = t[0] ? URI.decode(t.join(":")) : null;
          string = _string.substring(pos + 1);
        } else {
          parts.username = null;
          parts.password = null;
        }
        return string;
      };
      URI.parseQuery = function(string, escapeQuerySpace) {
        if (!string) {
          return {};
        }
        string = string.replace(/&+/g, "&").replace(/^\?*&*|&+$/g, "");
        if (!string) {
          return {};
        }
        var items = {};
        var splits = string.split("&");
        var length = splits.length;
        var v, name, value;
        for (var i2 = 0; i2 < length; i2++) {
          v = splits[i2].split("=");
          name = URI.decodeQuery(v.shift(), escapeQuerySpace);
          value = v.length ? URI.decodeQuery(v.join("="), escapeQuerySpace) : null;
          if (name === "__proto__") {
            continue;
          } else if (hasOwn.call(items, name)) {
            if (typeof items[name] === "string" || items[name] === null) {
              items[name] = [
                items[name]
              ];
            }
            items[name].push(value);
          } else {
            items[name] = value;
          }
        }
        return items;
      };
      URI.build = function(parts) {
        var t = "";
        var requireAbsolutePath = false;
        if (parts.protocol) {
          t += parts.protocol + ":";
        }
        if (!parts.urn && (t || parts.hostname)) {
          t += "//";
          requireAbsolutePath = true;
        }
        t += URI.buildAuthority(parts) || "";
        if (typeof parts.path === "string") {
          if (parts.path.charAt(0) !== "/" && requireAbsolutePath) {
            t += "/";
          }
          t += parts.path;
        }
        if (typeof parts.query === "string" && parts.query) {
          t += "?" + parts.query;
        }
        if (typeof parts.fragment === "string" && parts.fragment) {
          t += "#" + parts.fragment;
        }
        return t;
      };
      URI.buildHost = function(parts) {
        var t = "";
        if (!parts.hostname) {
          return "";
        } else if (URI.ip6_expression.test(parts.hostname)) {
          t += "[" + parts.hostname + "]";
        } else {
          t += parts.hostname;
        }
        if (parts.port) {
          t += ":" + parts.port;
        }
        return t;
      };
      URI.buildAuthority = function(parts) {
        return URI.buildUserinfo(parts) + URI.buildHost(parts);
      };
      URI.buildUserinfo = function(parts) {
        var t = "";
        if (parts.username) {
          t += URI.encode(parts.username);
        }
        if (parts.password) {
          t += ":" + URI.encode(parts.password);
        }
        if (t) {
          t += "@";
        }
        return t;
      };
      URI.buildQuery = function(data, duplicateQueryParameters, escapeQuerySpace) {
        var t = "";
        var unique, key, i2, length;
        for (key in data) {
          if (key === "__proto__") {
            continue;
          } else if (hasOwn.call(data, key)) {
            if (isArray(data[key])) {
              unique = {};
              for (i2 = 0, length = data[key].length; i2 < length; i2++) {
                if (data[key][i2] !== void 0 && unique[data[key][i2] + ""] === void 0) {
                  t += "&" + URI.buildQueryParameter(key, data[key][i2], escapeQuerySpace);
                  if (duplicateQueryParameters !== true) {
                    unique[data[key][i2] + ""] = true;
                  }
                }
              }
            } else if (data[key] !== void 0) {
              t += "&" + URI.buildQueryParameter(key, data[key], escapeQuerySpace);
            }
          }
        }
        return t.substring(1);
      };
      URI.buildQueryParameter = function(name, value, escapeQuerySpace) {
        return URI.encodeQuery(name, escapeQuerySpace) + (value !== null ? "=" + URI.encodeQuery(value, escapeQuerySpace) : "");
      };
      URI.addQuery = function(data, name, value) {
        if (typeof name === "object") {
          for (var key in name) {
            if (hasOwn.call(name, key)) {
              URI.addQuery(data, key, name[key]);
            }
          }
        } else if (typeof name === "string") {
          if (data[name] === void 0) {
            data[name] = value;
            return;
          } else if (typeof data[name] === "string") {
            data[name] = [
              data[name]
            ];
          }
          if (!isArray(value)) {
            value = [
              value
            ];
          }
          data[name] = (data[name] || []).concat(value);
        } else {
          throw new TypeError("URI.addQuery() accepts an object, string as the name parameter");
        }
      };
      URI.setQuery = function(data, name, value) {
        if (typeof name === "object") {
          for (var key in name) {
            if (hasOwn.call(name, key)) {
              URI.setQuery(data, key, name[key]);
            }
          }
        } else if (typeof name === "string") {
          data[name] = value === void 0 ? null : value;
        } else {
          throw new TypeError("URI.setQuery() accepts an object, string as the name parameter");
        }
      };
      URI.removeQuery = function(data, name, value) {
        var i2, length, key;
        if (isArray(name)) {
          for (i2 = 0, length = name.length; i2 < length; i2++) {
            data[name[i2]] = void 0;
          }
        } else if (getType(name) === "RegExp") {
          for (key in data) {
            if (name.test(key)) {
              data[key] = void 0;
            }
          }
        } else if (typeof name === "object") {
          for (key in name) {
            if (hasOwn.call(name, key)) {
              URI.removeQuery(data, key, name[key]);
            }
          }
        } else if (typeof name === "string") {
          if (value !== void 0) {
            if (getType(value) === "RegExp") {
              if (!isArray(data[name]) && value.test(data[name])) {
                data[name] = void 0;
              } else {
                data[name] = filterArrayValues(data[name], value);
              }
            } else if (data[name] === String(value) && (!isArray(value) || value.length === 1)) {
              data[name] = void 0;
            } else if (isArray(data[name])) {
              data[name] = filterArrayValues(data[name], value);
            }
          } else {
            data[name] = void 0;
          }
        } else {
          throw new TypeError("URI.removeQuery() accepts an object, string, RegExp as the first parameter");
        }
      };
      URI.hasQuery = function(data, name, value, withinArray) {
        switch (getType(name)) {
          case "String":
            break;
          case "RegExp":
            for (var key in data) {
              if (hasOwn.call(data, key)) {
                if (name.test(key) && (value === void 0 || URI.hasQuery(data, key, value))) {
                  return true;
                }
              }
            }
            return false;
          case "Object":
            for (var _key in name) {
              if (hasOwn.call(name, _key)) {
                if (!URI.hasQuery(data, _key, name[_key])) {
                  return false;
                }
              }
            }
            return true;
          default:
            throw new TypeError("URI.hasQuery() accepts a string, regular expression or object as the name parameter");
        }
        switch (getType(value)) {
          case "Undefined":
            return name in data;
          // data[name] !== undefined;
          case "Boolean":
            var _booly = Boolean(isArray(data[name]) ? data[name].length : data[name]);
            return value === _booly;
          case "Function":
            return !!value(data[name], name, data);
          case "Array":
            if (!isArray(data[name])) {
              return false;
            }
            var op = withinArray ? arrayContains : arraysEqual;
            return op(data[name], value);
          case "RegExp":
            if (!isArray(data[name])) {
              return Boolean(data[name] && data[name].match(value));
            }
            if (!withinArray) {
              return false;
            }
            return arrayContains(data[name], value);
          case "Number":
            value = String(value);
          /* falls through */
          case "String":
            if (!isArray(data[name])) {
              return data[name] === value;
            }
            if (!withinArray) {
              return false;
            }
            return arrayContains(data[name], value);
          default:
            throw new TypeError("URI.hasQuery() accepts undefined, boolean, string, number, RegExp, Function as the value parameter");
        }
      };
      URI.joinPaths = function() {
        var input = [];
        var segments = [];
        var nonEmptySegments = 0;
        for (var i2 = 0; i2 < arguments.length; i2++) {
          var url = new URI(arguments[i2]);
          input.push(url);
          var _segments = url.segment();
          for (var s = 0; s < _segments.length; s++) {
            if (typeof _segments[s] === "string") {
              segments.push(_segments[s]);
            }
            if (_segments[s]) {
              nonEmptySegments++;
            }
          }
        }
        if (!segments.length || !nonEmptySegments) {
          return new URI("");
        }
        var uri = new URI("").segment(segments);
        if (input[0].path() === "" || input[0].path().slice(0, 1) === "/") {
          uri.path("/" + uri.path());
        }
        return uri.normalize();
      };
      URI.commonPath = function(one, two) {
        var length = Math.min(one.length, two.length);
        var pos;
        for (pos = 0; pos < length; pos++) {
          if (one.charAt(pos) !== two.charAt(pos)) {
            pos--;
            break;
          }
        }
        if (pos < 1) {
          return one.charAt(0) === two.charAt(0) && one.charAt(0) === "/" ? "/" : "";
        }
        if (one.charAt(pos) !== "/" || two.charAt(pos) !== "/") {
          pos = one.substring(0, pos).lastIndexOf("/");
        }
        return one.substring(0, pos + 1);
      };
      URI.withinString = function(string, callback, options) {
        options || (options = {});
        var _start = options.start || URI.findUri.start;
        var _end = options.end || URI.findUri.end;
        var _trim = options.trim || URI.findUri.trim;
        var _parens = options.parens || URI.findUri.parens;
        var _attributeOpen = /[a-z0-9-]=["']?$/i;
        _start.lastIndex = 0;
        while (true) {
          var match2 = _start.exec(string);
          if (!match2) {
            break;
          }
          var start = match2.index;
          if (options.ignoreHtml) {
            var attributeOpen = string.slice(Math.max(start - 3, 0), start);
            if (attributeOpen && _attributeOpen.test(attributeOpen)) {
              continue;
            }
          }
          var end = start + string.slice(start).search(_end);
          var slice = string.slice(start, end);
          var parensEnd = -1;
          while (true) {
            var parensMatch = _parens.exec(slice);
            if (!parensMatch) {
              break;
            }
            var parensMatchEnd = parensMatch.index + parensMatch[0].length;
            parensEnd = Math.max(parensEnd, parensMatchEnd);
          }
          if (parensEnd > -1) {
            slice = slice.slice(0, parensEnd) + slice.slice(parensEnd).replace(_trim, "");
          } else {
            slice = slice.replace(_trim, "");
          }
          if (slice.length <= match2[0].length) {
            continue;
          }
          if (options.ignore && options.ignore.test(slice)) {
            continue;
          }
          end = start + slice.length;
          var result = callback(slice, start, end, string);
          if (result === void 0) {
            _start.lastIndex = end;
            continue;
          }
          result = String(result);
          string = string.slice(0, start) + result + string.slice(end);
          _start.lastIndex = start + result.length;
        }
        _start.lastIndex = 0;
        return string;
      };
      URI.ensureValidHostname = function(v, protocol) {
        var hasHostname = !!v;
        var hasProtocol = !!protocol;
        var rejectEmptyHostname = false;
        if (hasProtocol) {
          rejectEmptyHostname = arrayContains(URI.hostProtocols, protocol);
        }
        if (rejectEmptyHostname && !hasHostname) {
          throw new TypeError("Hostname cannot be empty, if protocol is " + protocol);
        } else if (v && v.match(URI.invalid_hostname_characters)) {
          if (!punycode) {
            throw new TypeError('Hostname "' + v + '" contains characters other than [A-Z0-9.-:_] and Punycode.js is not available');
          }
          if (punycode.toASCII(v).match(URI.invalid_hostname_characters)) {
            throw new TypeError('Hostname "' + v + '" contains characters other than [A-Z0-9.-:_]');
          }
        }
      };
      URI.ensureValidPort = function(v) {
        if (!v) {
          return;
        }
        var port = Number(v);
        if (isInteger(port) && port > 0 && port < 65536) {
          return;
        }
        throw new TypeError('Port "' + v + '" is not a valid port');
      };
      URI.noConflict = function(removeAll) {
        if (removeAll) {
          var unconflicted = {
            URI: this.noConflict()
          };
          if (root.URITemplate && typeof root.URITemplate.noConflict === "function") {
            unconflicted.URITemplate = root.URITemplate.noConflict();
          }
          if (root.IPv6 && typeof root.IPv6.noConflict === "function") {
            unconflicted.IPv6 = root.IPv6.noConflict();
          }
          if (root.SecondLevelDomains && typeof root.SecondLevelDomains.noConflict === "function") {
            unconflicted.SecondLevelDomains = root.SecondLevelDomains.noConflict();
          }
          return unconflicted;
        } else if (root.URI === this) {
          root.URI = _URI;
        }
        return this;
      };
      p.build = function(deferBuild) {
        if (deferBuild === true) {
          this._deferred_build = true;
        } else if (deferBuild === void 0 || this._deferred_build) {
          this._string = URI.build(this._parts);
          this._deferred_build = false;
        }
        return this;
      };
      p.clone = function() {
        return new URI(this);
      };
      p.valueOf = p.toString = function() {
        return this.build(false)._string;
      };
      function generateSimpleAccessor(_part2) {
        return function(v, build) {
          if (v === void 0) {
            return this._parts[_part2] || "";
          } else {
            this._parts[_part2] = v || null;
            this.build(!build);
            return this;
          }
        };
      }
      function generatePrefixAccessor(_part2, _key) {
        return function(v, build) {
          if (v === void 0) {
            return this._parts[_part2] || "";
          } else {
            if (v !== null) {
              v = v + "";
              if (v.charAt(0) === _key) {
                v = v.substring(1);
              }
            }
            this._parts[_part2] = v;
            this.build(!build);
            return this;
          }
        };
      }
      p.protocol = generateSimpleAccessor("protocol");
      p.username = generateSimpleAccessor("username");
      p.password = generateSimpleAccessor("password");
      p.hostname = generateSimpleAccessor("hostname");
      p.port = generateSimpleAccessor("port");
      p.query = generatePrefixAccessor("query", "?");
      p.fragment = generatePrefixAccessor("fragment", "#");
      p.search = function(v, build) {
        var t = this.query(v, build);
        return typeof t === "string" && t.length ? "?" + t : t;
      };
      p.hash = function(v, build) {
        var t = this.fragment(v, build);
        return typeof t === "string" && t.length ? "#" + t : t;
      };
      p.pathname = function(v, build) {
        if (v === void 0 || v === true) {
          var res = this._parts.path || (this._parts.hostname ? "/" : "");
          return v ? (this._parts.urn ? URI.decodeUrnPath : URI.decodePath)(res) : res;
        } else {
          if (this._parts.urn) {
            this._parts.path = v ? URI.recodeUrnPath(v) : "";
          } else {
            this._parts.path = v ? URI.recodePath(v) : "/";
          }
          this.build(!build);
          return this;
        }
      };
      p.path = p.pathname;
      p.href = function(href, build) {
        var key;
        if (href === void 0) {
          return this.toString();
        }
        this._string = "";
        this._parts = URI._parts();
        var _URI2 = href instanceof URI;
        var _object = typeof href === "object" && (href.hostname || href.path || href.pathname);
        if (href.nodeName) {
          var attribute = URI.getDomAttribute(href);
          href = href[attribute] || "";
          _object = false;
        }
        if (!_URI2 && _object && href.pathname !== void 0) {
          href = href.toString();
        }
        if (typeof href === "string" || href instanceof String) {
          this._parts = URI.parse(String(href), this._parts);
        } else if (_URI2 || _object) {
          var src = _URI2 ? href._parts : href;
          for (key in src) {
            if (key === "query") {
              continue;
            }
            if (hasOwn.call(this._parts, key)) {
              this._parts[key] = src[key];
            }
          }
          if (src.query) {
            this.query(src.query, false);
          }
        } else {
          throw new TypeError("invalid input");
        }
        this.build(!build);
        return this;
      };
      p.is = function(what) {
        var ip = false;
        var ip4 = false;
        var ip6 = false;
        var name = false;
        var sld = false;
        var idn = false;
        var punycode2 = false;
        var relative2 = !this._parts.urn;
        if (this._parts.hostname) {
          relative2 = false;
          ip4 = URI.ip4_expression.test(this._parts.hostname);
          ip6 = URI.ip6_expression.test(this._parts.hostname);
          ip = ip4 || ip6;
          name = !ip;
          sld = name && SLD && SLD.has(this._parts.hostname);
          idn = name && URI.idn_expression.test(this._parts.hostname);
          punycode2 = name && URI.punycode_expression.test(this._parts.hostname);
        }
        switch (what.toLowerCase()) {
          case "relative":
            return relative2;
          case "absolute":
            return !relative2;
          // hostname identification
          case "domain":
          case "name":
            return name;
          case "sld":
            return sld;
          case "ip":
            return ip;
          case "ip4":
          case "ipv4":
          case "inet4":
            return ip4;
          case "ip6":
          case "ipv6":
          case "inet6":
            return ip6;
          case "idn":
            return idn;
          case "url":
            return !this._parts.urn;
          case "urn":
            return !!this._parts.urn;
          case "punycode":
            return punycode2;
        }
        return null;
      };
      var _protocol = p.protocol;
      var _port = p.port;
      var _hostname = p.hostname;
      p.protocol = function(v, build) {
        if (v) {
          v = v.replace(/:(\/\/)?$/, "");
          if (!v.match(URI.protocol_expression)) {
            throw new TypeError('Protocol "' + v + `" contains characters other than [A-Z0-9.+-] or doesn't start with [A-Z]`);
          }
        }
        return _protocol.call(this, v, build);
      };
      p.scheme = p.protocol;
      p.port = function(v, build) {
        if (this._parts.urn) {
          return v === void 0 ? "" : this;
        }
        if (v !== void 0) {
          if (v === 0) {
            v = null;
          }
          if (v) {
            v += "";
            if (v.charAt(0) === ":") {
              v = v.substring(1);
            }
            URI.ensureValidPort(v);
          }
        }
        return _port.call(this, v, build);
      };
      p.hostname = function(v, build) {
        if (this._parts.urn) {
          return v === void 0 ? "" : this;
        }
        if (v !== void 0) {
          var x = {
            preventInvalidHostname: this._parts.preventInvalidHostname
          };
          var res = URI.parseHost(v, x);
          if (res !== "/") {
            throw new TypeError('Hostname "' + v + '" contains characters other than [A-Z0-9.-]');
          }
          v = x.hostname;
          if (this._parts.preventInvalidHostname) {
            URI.ensureValidHostname(v, this._parts.protocol);
          }
        }
        return _hostname.call(this, v, build);
      };
      p.origin = function(v, build) {
        if (this._parts.urn) {
          return v === void 0 ? "" : this;
        }
        if (v === void 0) {
          var protocol = this.protocol();
          var authority = this.authority();
          if (!authority) {
            return "";
          }
          return (protocol ? protocol + "://" : "") + this.authority();
        } else {
          var origin = URI(v);
          this.protocol(origin.protocol()).authority(origin.authority()).build(!build);
          return this;
        }
      };
      p.host = function(v, build) {
        if (this._parts.urn) {
          return v === void 0 ? "" : this;
        }
        if (v === void 0) {
          return this._parts.hostname ? URI.buildHost(this._parts) : "";
        } else {
          var res = URI.parseHost(v, this._parts);
          if (res !== "/") {
            throw new TypeError('Hostname "' + v + '" contains characters other than [A-Z0-9.-]');
          }
          this.build(!build);
          return this;
        }
      };
      p.authority = function(v, build) {
        if (this._parts.urn) {
          return v === void 0 ? "" : this;
        }
        if (v === void 0) {
          return this._parts.hostname ? URI.buildAuthority(this._parts) : "";
        } else {
          var res = URI.parseAuthority(v, this._parts);
          if (res !== "/") {
            throw new TypeError('Hostname "' + v + '" contains characters other than [A-Z0-9.-]');
          }
          this.build(!build);
          return this;
        }
      };
      p.userinfo = function(v, build) {
        if (this._parts.urn) {
          return v === void 0 ? "" : this;
        }
        if (v === void 0) {
          var t = URI.buildUserinfo(this._parts);
          return t ? t.substring(0, t.length - 1) : t;
        } else {
          if (v[v.length - 1] !== "@") {
            v += "@";
          }
          URI.parseUserinfo(v, this._parts);
          this.build(!build);
          return this;
        }
      };
      p.resource = function(v, build) {
        var parts;
        if (v === void 0) {
          return this.path() + this.search() + this.hash();
        }
        parts = URI.parse(v);
        this._parts.path = parts.path;
        this._parts.query = parts.query;
        this._parts.fragment = parts.fragment;
        this.build(!build);
        return this;
      };
      p.subdomain = function(v, build) {
        if (this._parts.urn) {
          return v === void 0 ? "" : this;
        }
        if (v === void 0) {
          if (!this._parts.hostname || this.is("IP")) {
            return "";
          }
          var end = this._parts.hostname.length - this.domain().length - 1;
          return this._parts.hostname.substring(0, end) || "";
        } else {
          var e = this._parts.hostname.length - this.domain().length;
          var sub = this._parts.hostname.substring(0, e);
          var replace = new RegExp("^" + escapeRegEx(sub));
          if (v && v.charAt(v.length - 1) !== ".") {
            v += ".";
          }
          if (v.indexOf(":") !== -1) {
            throw new TypeError("Domains cannot contain colons");
          }
          if (v) {
            URI.ensureValidHostname(v, this._parts.protocol);
          }
          this._parts.hostname = this._parts.hostname.replace(replace, v);
          this.build(!build);
          return this;
        }
      };
      p.domain = function(v, build) {
        if (this._parts.urn) {
          return v === void 0 ? "" : this;
        }
        if (typeof v === "boolean") {
          build = v;
          v = void 0;
        }
        if (v === void 0) {
          if (!this._parts.hostname || this.is("IP")) {
            return "";
          }
          var t = this._parts.hostname.match(/\./g);
          if (t && t.length < 2) {
            return this._parts.hostname;
          }
          var end = this._parts.hostname.length - this.tld(build).length - 1;
          end = this._parts.hostname.lastIndexOf(".", end - 1) + 1;
          return this._parts.hostname.substring(end) || "";
        } else {
          if (!v) {
            throw new TypeError("cannot set domain empty");
          }
          if (v.indexOf(":") !== -1) {
            throw new TypeError("Domains cannot contain colons");
          }
          URI.ensureValidHostname(v, this._parts.protocol);
          if (!this._parts.hostname || this.is("IP")) {
            this._parts.hostname = v;
          } else {
            var replace = new RegExp(escapeRegEx(this.domain()) + "$");
            this._parts.hostname = this._parts.hostname.replace(replace, v);
          }
          this.build(!build);
          return this;
        }
      };
      p.tld = function(v, build) {
        if (this._parts.urn) {
          return v === void 0 ? "" : this;
        }
        if (typeof v === "boolean") {
          build = v;
          v = void 0;
        }
        if (v === void 0) {
          if (!this._parts.hostname || this.is("IP")) {
            return "";
          }
          var pos = this._parts.hostname.lastIndexOf(".");
          var tld = this._parts.hostname.substring(pos + 1);
          if (build !== true && SLD && SLD.list[tld.toLowerCase()]) {
            return SLD.get(this._parts.hostname) || tld;
          }
          return tld;
        } else {
          var replace;
          if (!v) {
            throw new TypeError("cannot set TLD empty");
          } else if (v.match(/[^a-zA-Z0-9-]/)) {
            if (SLD && SLD.is(v)) {
              replace = new RegExp(escapeRegEx(this.tld()) + "$");
              this._parts.hostname = this._parts.hostname.replace(replace, v);
            } else {
              throw new TypeError('TLD "' + v + '" contains characters other than [A-Z0-9]');
            }
          } else if (!this._parts.hostname || this.is("IP")) {
            throw new ReferenceError("cannot set TLD on non-domain host");
          } else {
            replace = new RegExp(escapeRegEx(this.tld()) + "$");
            this._parts.hostname = this._parts.hostname.replace(replace, v);
          }
          this.build(!build);
          return this;
        }
      };
      p.directory = function(v, build) {
        if (this._parts.urn) {
          return v === void 0 ? "" : this;
        }
        if (v === void 0 || v === true) {
          if (!this._parts.path && !this._parts.hostname) {
            return "";
          }
          if (this._parts.path === "/") {
            return "/";
          }
          var end = this._parts.path.length - this.filename().length - 1;
          var res = this._parts.path.substring(0, end) || (this._parts.hostname ? "/" : "");
          return v ? URI.decodePath(res) : res;
        } else {
          var e = this._parts.path.length - this.filename().length;
          var directory = this._parts.path.substring(0, e);
          var replace = new RegExp("^" + escapeRegEx(directory));
          if (!this.is("relative")) {
            if (!v) {
              v = "/";
            }
            if (v.charAt(0) !== "/") {
              v = "/" + v;
            }
          }
          if (v && v.charAt(v.length - 1) !== "/") {
            v += "/";
          }
          v = URI.recodePath(v);
          this._parts.path = this._parts.path.replace(replace, v);
          this.build(!build);
          return this;
        }
      };
      p.filename = function(v, build) {
        if (this._parts.urn) {
          return v === void 0 ? "" : this;
        }
        if (typeof v !== "string") {
          if (!this._parts.path || this._parts.path === "/") {
            return "";
          }
          var pos = this._parts.path.lastIndexOf("/");
          var res = this._parts.path.substring(pos + 1);
          return v ? URI.decodePathSegment(res) : res;
        } else {
          var mutatedDirectory = false;
          if (v.charAt(0) === "/") {
            v = v.substring(1);
          }
          if (v.match(/\.?\//)) {
            mutatedDirectory = true;
          }
          var replace = new RegExp(escapeRegEx(this.filename()) + "$");
          v = URI.recodePath(v);
          this._parts.path = this._parts.path.replace(replace, v);
          if (mutatedDirectory) {
            this.normalizePath(build);
          } else {
            this.build(!build);
          }
          return this;
        }
      };
      p.suffix = function(v, build) {
        if (this._parts.urn) {
          return v === void 0 ? "" : this;
        }
        if (v === void 0 || v === true) {
          if (!this._parts.path || this._parts.path === "/") {
            return "";
          }
          var filename = this.filename();
          var pos = filename.lastIndexOf(".");
          var s, res;
          if (pos === -1) {
            return "";
          }
          s = filename.substring(pos + 1);
          res = /^[a-z0-9%]+$/i.test(s) ? s : "";
          return v ? URI.decodePathSegment(res) : res;
        } else {
          if (v.charAt(0) === ".") {
            v = v.substring(1);
          }
          var suffix = this.suffix();
          var replace;
          if (!suffix) {
            if (!v) {
              return this;
            }
            this._parts.path += "." + URI.recodePath(v);
          } else if (!v) {
            replace = new RegExp(escapeRegEx("." + suffix) + "$");
          } else {
            replace = new RegExp(escapeRegEx(suffix) + "$");
          }
          if (replace) {
            v = URI.recodePath(v);
            this._parts.path = this._parts.path.replace(replace, v);
          }
          this.build(!build);
          return this;
        }
      };
      p.segment = function(segment, v, build) {
        var separator = this._parts.urn ? ":" : "/";
        var path2 = this.path();
        var absolute = path2.substring(0, 1) === "/";
        var segments = path2.split(separator);
        if (segment !== void 0 && typeof segment !== "number") {
          build = v;
          v = segment;
          segment = void 0;
        }
        if (segment !== void 0 && typeof segment !== "number") {
          throw new Error('Bad segment "' + segment + '", must be 0-based integer');
        }
        if (absolute) {
          segments.shift();
        }
        if (segment < 0) {
          segment = Math.max(segments.length + segment, 0);
        }
        if (v === void 0) {
          return segment === void 0 ? segments : segments[segment];
        } else if (segment === null || segments[segment] === void 0) {
          if (isArray(v)) {
            segments = [];
            for (var i2 = 0, l = v.length; i2 < l; i2++) {
              if (!v[i2].length && (!segments.length || !segments[segments.length - 1].length)) {
                continue;
              }
              if (segments.length && !segments[segments.length - 1].length) {
                segments.pop();
              }
              segments.push(trimSlashes(v[i2]));
            }
          } else if (v || typeof v === "string") {
            v = trimSlashes(v);
            if (segments[segments.length - 1] === "") {
              segments[segments.length - 1] = v;
            } else {
              segments.push(v);
            }
          }
        } else {
          if (v) {
            segments[segment] = trimSlashes(v);
          } else {
            segments.splice(segment, 1);
          }
        }
        if (absolute) {
          segments.unshift("");
        }
        return this.path(segments.join(separator), build);
      };
      p.segmentCoded = function(segment, v, build) {
        var segments, i2, l;
        if (typeof segment !== "number") {
          build = v;
          v = segment;
          segment = void 0;
        }
        if (v === void 0) {
          segments = this.segment(segment, v, build);
          if (!isArray(segments)) {
            segments = segments !== void 0 ? URI.decode(segments) : void 0;
          } else {
            for (i2 = 0, l = segments.length; i2 < l; i2++) {
              segments[i2] = URI.decode(segments[i2]);
            }
          }
          return segments;
        }
        if (!isArray(v)) {
          v = typeof v === "string" || v instanceof String ? URI.encode(v) : v;
        } else {
          for (i2 = 0, l = v.length; i2 < l; i2++) {
            v[i2] = URI.encode(v[i2]);
          }
        }
        return this.segment(segment, v, build);
      };
      var q = p.query;
      p.query = function(v, build) {
        if (v === true) {
          return URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
        } else if (typeof v === "function") {
          var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
          var result = v.call(this, data);
          this._parts.query = URI.buildQuery(result || data, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);
          this.build(!build);
          return this;
        } else if (v !== void 0 && typeof v !== "string") {
          this._parts.query = URI.buildQuery(v, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);
          this.build(!build);
          return this;
        } else {
          return q.call(this, v, build);
        }
      };
      p.setQuery = function(name, value, build) {
        var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
        if (typeof name === "string" || name instanceof String) {
          data[name] = value !== void 0 ? value : null;
        } else if (typeof name === "object") {
          for (var key in name) {
            if (hasOwn.call(name, key)) {
              data[key] = name[key];
            }
          }
        } else {
          throw new TypeError("URI.addQuery() accepts an object, string as the name parameter");
        }
        this._parts.query = URI.buildQuery(data, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);
        if (typeof name !== "string") {
          build = value;
        }
        this.build(!build);
        return this;
      };
      p.addQuery = function(name, value, build) {
        var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
        URI.addQuery(data, name, value === void 0 ? null : value);
        this._parts.query = URI.buildQuery(data, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);
        if (typeof name !== "string") {
          build = value;
        }
        this.build(!build);
        return this;
      };
      p.removeQuery = function(name, value, build) {
        var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
        URI.removeQuery(data, name, value);
        this._parts.query = URI.buildQuery(data, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);
        if (typeof name !== "string") {
          build = value;
        }
        this.build(!build);
        return this;
      };
      p.hasQuery = function(name, value, withinArray) {
        var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
        return URI.hasQuery(data, name, value, withinArray);
      };
      p.setSearch = p.setQuery;
      p.addSearch = p.addQuery;
      p.removeSearch = p.removeQuery;
      p.hasSearch = p.hasQuery;
      p.normalize = function() {
        if (this._parts.urn) {
          return this.normalizeProtocol(false).normalizePath(false).normalizeQuery(false).normalizeFragment(false).build();
        }
        return this.normalizeProtocol(false).normalizeHostname(false).normalizePort(false).normalizePath(false).normalizeQuery(false).normalizeFragment(false).build();
      };
      p.normalizeProtocol = function(build) {
        if (typeof this._parts.protocol === "string") {
          this._parts.protocol = this._parts.protocol.toLowerCase();
          this.build(!build);
        }
        return this;
      };
      p.normalizeHostname = function(build) {
        if (this._parts.hostname) {
          if (this.is("IDN") && punycode) {
            this._parts.hostname = punycode.toASCII(this._parts.hostname);
          } else if (this.is("IPv6") && IPv6) {
            this._parts.hostname = IPv6.best(this._parts.hostname);
          }
          this._parts.hostname = this._parts.hostname.toLowerCase();
          this.build(!build);
        }
        return this;
      };
      p.normalizePort = function(build) {
        if (typeof this._parts.protocol === "string" && this._parts.port === URI.defaultPorts[this._parts.protocol]) {
          this._parts.port = null;
          this.build(!build);
        }
        return this;
      };
      p.normalizePath = function(build) {
        var _path = this._parts.path;
        if (!_path) {
          return this;
        }
        if (this._parts.urn) {
          this._parts.path = URI.recodeUrnPath(this._parts.path);
          this.build(!build);
          return this;
        }
        if (this._parts.path === "/") {
          return this;
        }
        _path = URI.recodePath(_path);
        var _was_relative;
        var _leadingParents = "";
        var _parent, _pos;
        if (_path.charAt(0) !== "/") {
          _was_relative = true;
          _path = "/" + _path;
        }
        if (_path.slice(-3) === "/.." || _path.slice(-2) === "/.") {
          _path += "/";
        }
        _path = _path.replace(/(\/(\.\/)+)|(\/\.$)/g, "/").replace(/\/{2,}/g, "/");
        if (_was_relative) {
          _leadingParents = _path.substring(1).match(/^(\.\.\/)+/) || "";
          if (_leadingParents) {
            _leadingParents = _leadingParents[0];
          }
        }
        while (true) {
          _parent = _path.search(/\/\.\.(\/|$)/);
          if (_parent === -1) {
            break;
          } else if (_parent === 0) {
            _path = _path.substring(3);
            continue;
          }
          _pos = _path.substring(0, _parent).lastIndexOf("/");
          if (_pos === -1) {
            _pos = _parent;
          }
          _path = _path.substring(0, _pos) + _path.substring(_parent + 3);
        }
        if (_was_relative && this.is("relative")) {
          _path = _leadingParents + _path.substring(1);
        }
        this._parts.path = _path;
        this.build(!build);
        return this;
      };
      p.normalizePathname = p.normalizePath;
      p.normalizeQuery = function(build) {
        if (typeof this._parts.query === "string") {
          if (!this._parts.query.length) {
            this._parts.query = null;
          } else {
            this.query(URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace));
          }
          this.build(!build);
        }
        return this;
      };
      p.normalizeFragment = function(build) {
        if (!this._parts.fragment) {
          this._parts.fragment = null;
          this.build(!build);
        }
        return this;
      };
      p.normalizeSearch = p.normalizeQuery;
      p.normalizeHash = p.normalizeFragment;
      p.iso8859 = function() {
        var e = URI.encode;
        var d = URI.decode;
        URI.encode = escape;
        URI.decode = decodeURIComponent;
        try {
          this.normalize();
        } finally {
          URI.encode = e;
          URI.decode = d;
        }
        return this;
      };
      p.unicode = function() {
        var e = URI.encode;
        var d = URI.decode;
        URI.encode = strictEncodeURIComponent;
        URI.decode = unescape;
        try {
          this.normalize();
        } finally {
          URI.encode = e;
          URI.decode = d;
        }
        return this;
      };
      p.readable = function() {
        var uri = this.clone();
        uri.username("").password("").normalize();
        var t = "";
        if (uri._parts.protocol) {
          t += uri._parts.protocol + "://";
        }
        if (uri._parts.hostname) {
          if (uri.is("punycode") && punycode) {
            t += punycode.toUnicode(uri._parts.hostname);
            if (uri._parts.port) {
              t += ":" + uri._parts.port;
            }
          } else {
            t += uri.host();
          }
        }
        if (uri._parts.hostname && uri._parts.path && uri._parts.path.charAt(0) !== "/") {
          t += "/";
        }
        t += uri.path(true);
        if (uri._parts.query) {
          var q2 = "";
          for (var i2 = 0, qp = uri._parts.query.split("&"), l = qp.length; i2 < l; i2++) {
            var kv = (qp[i2] || "").split("=");
            q2 += "&" + URI.decodeQuery(kv[0], this._parts.escapeQuerySpace).replace(/&/g, "%26");
            if (kv[1] !== void 0) {
              q2 += "=" + URI.decodeQuery(kv[1], this._parts.escapeQuerySpace).replace(/&/g, "%26");
            }
          }
          t += "?" + q2.substring(1);
        }
        t += URI.decodeQuery(uri.hash(), true);
        return t;
      };
      p.absoluteTo = function(base) {
        var resolved = this.clone();
        var properties = [
          "protocol",
          "username",
          "password",
          "hostname",
          "port"
        ];
        var basedir, i2, p2;
        if (this._parts.urn) {
          throw new Error("URNs do not have any generally defined hierarchical components");
        }
        if (!(base instanceof URI)) {
          base = new URI(base);
        }
        if (resolved._parts.protocol) {
          return resolved;
        } else {
          resolved._parts.protocol = base._parts.protocol;
        }
        if (this._parts.hostname) {
          return resolved;
        }
        for (i2 = 0; p2 = properties[i2]; i2++) {
          resolved._parts[p2] = base._parts[p2];
        }
        if (!resolved._parts.path) {
          resolved._parts.path = base._parts.path;
          if (!resolved._parts.query) {
            resolved._parts.query = base._parts.query;
          }
        } else {
          if (resolved._parts.path.substring(-2) === "..") {
            resolved._parts.path += "/";
          }
          if (resolved.path().charAt(0) !== "/") {
            basedir = base.directory();
            basedir = basedir ? basedir : base.path().indexOf("/") === 0 ? "/" : "";
            resolved._parts.path = (basedir ? basedir + "/" : "") + resolved._parts.path;
            resolved.normalizePath();
          }
        }
        resolved.build();
        return resolved;
      };
      p.relativeTo = function(base) {
        var relative2 = this.clone().normalize();
        var relativeParts, baseParts, common, relativePath, basePath;
        if (relative2._parts.urn) {
          throw new Error("URNs do not have any generally defined hierarchical components");
        }
        base = new URI(base).normalize();
        relativeParts = relative2._parts;
        baseParts = base._parts;
        relativePath = relative2.path();
        basePath = base.path();
        if (relativePath.charAt(0) !== "/") {
          throw new Error("URI is already relative");
        }
        if (basePath.charAt(0) !== "/") {
          throw new Error("Cannot calculate a URI relative to another relative URI");
        }
        if (relativeParts.protocol === baseParts.protocol) {
          relativeParts.protocol = null;
        }
        if (relativeParts.username !== baseParts.username || relativeParts.password !== baseParts.password) {
          return relative2.build();
        }
        if (relativeParts.protocol !== null || relativeParts.username !== null || relativeParts.password !== null) {
          return relative2.build();
        }
        if (relativeParts.hostname === baseParts.hostname && relativeParts.port === baseParts.port) {
          relativeParts.hostname = null;
          relativeParts.port = null;
        } else {
          return relative2.build();
        }
        if (relativePath === basePath) {
          relativeParts.path = "";
          return relative2.build();
        }
        common = URI.commonPath(relativePath, basePath);
        if (!common) {
          return relative2.build();
        }
        var parents = baseParts.path.substring(common.length).replace(/[^\/]*$/, "").replace(/.*?\//g, "../");
        relativeParts.path = parents + relativeParts.path.substring(common.length) || "./";
        return relative2.build();
      };
      p.equals = function(uri) {
        var one = this.clone();
        var two = new URI(uri);
        var one_map = {};
        var two_map = {};
        var checked = {};
        var one_query, two_query, key;
        one.normalize();
        two.normalize();
        if (one.toString() === two.toString()) {
          return true;
        }
        one_query = one.query();
        two_query = two.query();
        one.query("");
        two.query("");
        if (one.toString() !== two.toString()) {
          return false;
        }
        if (one_query.length !== two_query.length) {
          return false;
        }
        one_map = URI.parseQuery(one_query, this._parts.escapeQuerySpace);
        two_map = URI.parseQuery(two_query, this._parts.escapeQuerySpace);
        for (key in one_map) {
          if (hasOwn.call(one_map, key)) {
            if (!isArray(one_map[key])) {
              if (one_map[key] !== two_map[key]) {
                return false;
              }
            } else if (!arraysEqual(one_map[key], two_map[key])) {
              return false;
            }
            checked[key] = true;
          }
        }
        for (key in two_map) {
          if (hasOwn.call(two_map, key)) {
            if (!checked[key]) {
              return false;
            }
          }
        }
        return true;
      };
      p.preventInvalidHostname = function(v) {
        this._parts.preventInvalidHostname = !!v;
        return this;
      };
      p.duplicateQueryParameters = function(v) {
        this._parts.duplicateQueryParameters = !!v;
        return this;
      };
      p.escapeQuerySpace = function(v) {
        this._parts.escapeQuerySpace = !!v;
        return this;
      };
      return URI;
    });
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/attributes/URIAttributes.js
var require_URIAttributes = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/attributes/URIAttributes.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : {
        "default": mod
      };
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.uriTypeAttributeKind = void 0;
    exports.uriInferenceAttributesProducer = uriInferenceAttributesProducer;
    exports.uriSchemaAttributesProducer = uriSchemaAttributesProducer;
    var collection_utils_1 = require_dist();
    var urijs_1 = __importDefault(require_URI());
    var Support_1 = require_Support();
    var TypeAttributes_1 = require_TypeAttributes();
    var protocolsSchemaProperty = "qt-uri-protocols";
    var extensionsSchemaProperty = "qt-uri-extensions";
    var URITypeAttributeKind = class extends TypeAttributes_1.TypeAttributeKind {
      constructor() {
        super("uriAttributes");
      }
      get inIdentity() {
        return true;
      }
      combine(attrs) {
        const protocolSets = attrs.map((a) => a[0]);
        const extensionSets = attrs.map((a) => a[1]);
        return [
          (0, collection_utils_1.setUnionManyInto)(/* @__PURE__ */ new Set(), protocolSets),
          (0, collection_utils_1.setUnionManyInto)(/* @__PURE__ */ new Set(), extensionSets)
        ];
      }
      makeInferred(_) {
        return void 0;
      }
      addToSchema(schema, t, attrs) {
        if (t.kind !== "string" && t.kind !== "uri") return;
        const [protocols, extensions] = attrs;
        if (protocols.size > 0) {
          schema[protocolsSchemaProperty] = Array.from(protocols).sort();
        }
        if (extensions.size > 0) {
          schema[extensionsSchemaProperty] = Array.from(extensions).sort();
        }
      }
    };
    exports.uriTypeAttributeKind = new URITypeAttributeKind();
    var extensionRegex = /^.+(\.[^./\\]+)$/;
    function pathExtension(path2) {
      const matches = extensionRegex.exec(path2);
      if (matches === null) return void 0;
      return matches[1];
    }
    function uriInferenceAttributesProducer(s) {
      try {
        const uri = (0, urijs_1.default)(s);
        const extension = pathExtension(uri.path());
        const extensions = extension === void 0 ? [] : [
          extension.toLowerCase()
        ];
        return exports.uriTypeAttributeKind.makeAttributes([
          /* @__PURE__ */ new Set([
            uri.protocol().toLowerCase()
          ]),
          new Set(extensions)
        ]);
      } catch (_a) {
        return TypeAttributes_1.emptyTypeAttributes;
      }
    }
    function uriSchemaAttributesProducer(schema, _ref, types) {
      if (!(typeof schema === "object")) return void 0;
      if (!types.has("string")) return void 0;
      let protocols;
      const maybeProtocols = schema[protocolsSchemaProperty];
      if (maybeProtocols !== void 0) {
        protocols = new Set((0, Support_1.checkArray)(maybeProtocols, Support_1.checkString));
      } else {
        protocols = /* @__PURE__ */ new Set();
      }
      let extensions;
      const maybeExtensions = schema[extensionsSchemaProperty];
      if (maybeExtensions !== void 0) {
        extensions = new Set((0, Support_1.checkArray)(maybeExtensions, Support_1.checkString));
      } else {
        extensions = /* @__PURE__ */ new Set();
      }
      if (protocols.size === 0 && extensions.size === 0) return void 0;
      return {
        forString: exports.uriTypeAttributeKind.makeAttributes([
          protocols,
          extensions
        ])
      };
    }
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/Type/TransformedStringType.js
var require_TransformedStringType = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/Type/TransformedStringType.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.transformedStringTypeKinds = exports.transformedStringTypeTargetTypeKindsMap = void 0;
    exports.isPrimitiveStringTypeKind = isPrimitiveStringTypeKind;
    exports.targetTypeKindForTransformedStringTypeKind = targetTypeKindForTransformedStringTypeKind;
    exports.isNumberTypeKind = isNumberTypeKind;
    exports.isPrimitiveTypeKind = isPrimitiveTypeKind;
    exports.triviallyStructurallyCompatible = triviallyStructurallyCompatible;
    var collection_utils_1 = require_dist();
    var URIAttributes_1 = require_URIAttributes();
    var transformedStringTypeTargetTypeKinds = {
      date: {
        jsonSchema: "date",
        primitive: void 0
      },
      time: {
        jsonSchema: "time",
        primitive: void 0
      },
      "date-time": {
        jsonSchema: "date-time",
        primitive: void 0
      },
      uuid: {
        jsonSchema: "uuid",
        primitive: void 0
      },
      uri: {
        jsonSchema: "uri",
        primitive: void 0,
        attributesProducer: URIAttributes_1.uriInferenceAttributesProducer
      },
      "integer-string": {
        jsonSchema: "integer",
        primitive: "integer"
      },
      "bool-string": {
        jsonSchema: "boolean",
        primitive: "bool"
      }
    };
    exports.transformedStringTypeTargetTypeKindsMap = (0, collection_utils_1.mapFromObject)(transformedStringTypeTargetTypeKinds);
    exports.transformedStringTypeKinds = new Set(Object.getOwnPropertyNames(transformedStringTypeTargetTypeKinds));
    function isPrimitiveStringTypeKind(kind) {
      return kind === "string" || (0, collection_utils_1.hasOwnProperty)(transformedStringTypeTargetTypeKinds, kind);
    }
    function targetTypeKindForTransformedStringTypeKind(kind) {
      const target = exports.transformedStringTypeTargetTypeKindsMap.get(kind);
      if (target === void 0) return void 0;
      return target.primitive;
    }
    function isNumberTypeKind(kind) {
      return kind === "integer" || kind === "double";
    }
    function isPrimitiveTypeKind(kind) {
      if (isPrimitiveStringTypeKind(kind)) return true;
      if (isNumberTypeKind(kind)) return true;
      return kind === "none" || kind === "any" || kind === "null" || kind === "bool";
    }
    function triviallyStructurallyCompatible(x, y) {
      if (x.index === y.index) return true;
      if (x.kind === "none" || y.kind === "none") return true;
      return false;
    }
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/Type/TypeRef.js
var require_TypeRef = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/Type/TypeRef.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.isTypeRef = isTypeRef;
    exports.makeTypeRef = makeTypeRef;
    exports.typeRefIndex = typeRefIndex;
    exports.assertTypeRefGraph = assertTypeRefGraph;
    exports.derefTypeRef = derefTypeRef;
    exports.attributesForTypeRef = attributesForTypeRef;
    exports.typeAndAttributesForTypeRef = typeAndAttributesForTypeRef;
    var Support_1 = require_Support();
    var indexBits = 26;
    var indexMask = (1 << indexBits) - 1;
    var serialBits = 31 - indexBits;
    var serialMask = (1 << serialBits) - 1;
    function isTypeRef(x) {
      return typeof x === "number";
    }
    function makeTypeRef(graph, index) {
      (0, Support_1.assert)(index <= indexMask, "Too many types in graph");
      return (graph.serial & serialMask) << indexBits | index;
    }
    function typeRefIndex(tref) {
      return tref & indexMask;
    }
    function assertTypeRefGraph(tref, graph) {
      (0, Support_1.assert)((tref >> indexBits & serialMask) === (graph.serial & serialMask), "Mixing the wrong type reference and graph");
    }
    function getGraph(graphOrBuilder) {
      if ("originalGraph" in graphOrBuilder) {
        return graphOrBuilder.originalGraph;
      }
      return graphOrBuilder;
    }
    function derefTypeRef(tref, graphOrBuilder) {
      const graph = getGraph(graphOrBuilder);
      assertTypeRefGraph(tref, graph);
      return graph.typeAtIndex(typeRefIndex(tref));
    }
    function attributesForTypeRef(tref, graphOrBuilder) {
      const graph = getGraph(graphOrBuilder);
      assertTypeRefGraph(tref, graph);
      return graph.atIndex(typeRefIndex(tref))[1];
    }
    function typeAndAttributesForTypeRef(tref, graphOrBuilder) {
      const graph = getGraph(graphOrBuilder);
      assertTypeRefGraph(tref, graph);
      return graph.atIndex(typeRefIndex(tref));
    }
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/Type/Type.js
var require_Type = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/Type/Type.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.UnionType = exports.IntersectionType = exports.SetOperationType = exports.EnumType = exports.MapType = exports.ClassType = exports.ObjectType = exports.ClassProperty = exports.GenericClassProperty = exports.ArrayType = exports.PrimitiveType = exports.Type = exports.TypeIdentity = void 0;
    exports.primitiveTypeIdentity = primitiveTypeIdentity;
    exports.arrayTypeIdentity = arrayTypeIdentity;
    exports.classTypeIdentity = classTypeIdentity;
    exports.mapTypeIdentify = mapTypeIdentify;
    exports.enumTypeIdentity = enumTypeIdentity;
    exports.setOperationCasesEqual = setOperationCasesEqual;
    exports.setOperationTypeIdentity = setOperationTypeIdentity;
    exports.unionTypeIdentity = unionTypeIdentity;
    exports.intersectionTypeIdentity = intersectionTypeIdentity;
    var collection_utils_1 = require_dist();
    var TypeNames_1 = require_TypeNames();
    var Messages_1 = require_Messages();
    var Support_1 = require_Support();
    var TransformedStringType_1 = require_TransformedStringType();
    var TypeRef_1 = require_TypeRef();
    var TypeIdentity = class _TypeIdentity {
      constructor(_kind, _components) {
        this._kind = _kind;
        this._components = _components;
        let h = collection_utils_1.hashCodeInit;
        h = (0, collection_utils_1.addHashCode)(h, (0, collection_utils_1.hashCodeOf)(this._kind));
        for (const c of _components) {
          h = (0, collection_utils_1.addHashCode)(h, (0, collection_utils_1.hashCodeOf)(c));
        }
        this._hashCode = h;
      }
      equals(other) {
        if (!(other instanceof _TypeIdentity)) return false;
        if (this._kind !== other._kind) return false;
        const n = this._components.length;
        (0, Support_1.assert)(n === other._components.length, "Components of a type kind's identity must have the same length");
        for (let i2 = 0; i2 < n; i2++) {
          if (!(0, collection_utils_1.areEqual)(this._components[i2], other._components[i2])) return false;
        }
        return true;
      }
      hashCode() {
        return this._hashCode;
      }
    };
    exports.TypeIdentity = TypeIdentity;
    var Type = class _Type {
      constructor(typeRef, graph) {
        this.typeRef = typeRef;
        this.graph = graph;
      }
      get index() {
        return (0, TypeRef_1.typeRefIndex)(this.typeRef);
      }
      getChildren() {
        const result = this.getNonAttributeChildren();
        for (const [k, v] of this.getAttributes()) {
          if (k.children === void 0) continue;
          (0, collection_utils_1.setUnionInto)(result, k.children(v));
        }
        return result;
      }
      getAttributes() {
        return (0, TypeRef_1.attributesForTypeRef)(this.typeRef, this.graph);
      }
      get hasNames() {
        return TypeNames_1.namesTypeAttributeKind.tryGetInAttributes(this.getAttributes()) !== void 0;
      }
      getNames() {
        return (0, Support_1.defined)(TypeNames_1.namesTypeAttributeKind.tryGetInAttributes(this.getAttributes()));
      }
      getCombinedName() {
        return this.getNames().combinedName;
      }
      get debugPrintKind() {
        return this.kind;
      }
      equals(other) {
        if (!(other instanceof _Type)) return false;
        return this.typeRef === other.typeRef;
      }
      hashCode() {
        return (0, collection_utils_1.hashCodeOf)(this.typeRef);
      }
      structurallyCompatible(other, conflateNumbers = false) {
        function kindsCompatible(kind1, kind2) {
          if (kind1 === kind2) return true;
          if (!conflateNumbers) return false;
          if (kind1 === "integer") return kind2 === "double";
          if (kind1 === "double") return kind2 === "integer";
          return false;
        }
        if ((0, TransformedStringType_1.triviallyStructurallyCompatible)(this, other)) return true;
        if (!kindsCompatible(this.kind, other.kind)) return false;
        const workList = [
          [
            this,
            other
          ]
        ];
        const done = [];
        let failed;
        const queue = (x, y) => {
          if ((0, TransformedStringType_1.triviallyStructurallyCompatible)(x, y)) return true;
          if (!kindsCompatible(x.kind, y.kind)) {
            failed = true;
            return false;
          }
          workList.push([
            x,
            y
          ]);
          return true;
        };
        while (workList.length > 0) {
          let [a, b] = (0, Support_1.defined)(workList.pop());
          if (a.index > b.index) {
            [a, b] = [
              b,
              a
            ];
          }
          if (!a.isPrimitive()) {
            const ai = a.index;
            const bi = b.index;
            let found = false;
            for (const [dai, dbi] of done) {
              if (dai === ai && dbi === bi) {
                found = true;
                break;
              }
            }
            if (found) continue;
            done.push([
              ai,
              bi
            ]);
          }
          failed = false;
          if (!a.structuralEqualityStep(b, conflateNumbers, queue)) return false;
          if (failed) return false;
        }
        return true;
      }
      getParentTypes() {
        return this.graph.getParentsOfType(this);
      }
      getAncestorsNotInSet(set) {
        const workList = [
          this
        ];
        const processed = /* @__PURE__ */ new Set();
        const ancestors = /* @__PURE__ */ new Set();
        for (; ; ) {
          const t = workList.pop();
          if (t === void 0) break;
          const parents = t.getParentTypes();
          console.log(`${parents.size} parents`);
          for (const p of parents) {
            if (processed.has(p)) continue;
            processed.add(p);
            if (set.has(p.typeRef)) {
              console.log(`adding ${p.kind}`);
              workList.push(p);
            } else {
              console.log(`found ${p.kind}`);
              ancestors.add(p);
            }
          }
        }
        return ancestors;
      }
    };
    exports.Type = Type;
    function hasUniqueIdentityAttributes(attributes) {
      return (0, collection_utils_1.mapSome)(attributes, (v, ta) => ta.requiresUniqueIdentity(v));
    }
    function identityAttributes(attributes) {
      return (0, collection_utils_1.mapFilter)(attributes, (_, kind) => kind.inIdentity);
    }
    function primitiveTypeIdentity(kind, attributes) {
      if (hasUniqueIdentityAttributes(attributes)) return void 0;
      return new TypeIdentity(kind, [
        identityAttributes(attributes)
      ]);
    }
    var PrimitiveType = class extends Type {
      constructor(typeRef, graph, kind) {
        super(typeRef, graph);
        this.kind = kind;
      }
      get isNullable() {
        return this.kind === "null" || this.kind === "any" || this.kind === "none";
      }
      isPrimitive() {
        return true;
      }
      getNonAttributeChildren() {
        return /* @__PURE__ */ new Set();
      }
      get identity() {
        return primitiveTypeIdentity(this.kind, this.getAttributes());
      }
      reconstitute(builder) {
        builder.getPrimitiveType(this.kind);
      }
      structuralEqualityStep(_other, _conflateNumbers, _queue) {
        return true;
      }
    };
    exports.PrimitiveType = PrimitiveType;
    function arrayTypeIdentity(attributes, itemsRef) {
      if (hasUniqueIdentityAttributes(attributes)) return void 0;
      return new TypeIdentity("array", [
        identityAttributes(attributes),
        itemsRef
      ]);
    }
    var ArrayType = class extends Type {
      constructor(typeRef, graph, _itemsRef) {
        super(typeRef, graph);
        this._itemsRef = _itemsRef;
        this.kind = "array";
      }
      setItems(itemsRef) {
        if (this._itemsRef !== void 0) {
          (0, Support_1.panic)("Can only set array items once");
        }
        this._itemsRef = itemsRef;
      }
      getItemsRef() {
        if (this._itemsRef === void 0) {
          return (0, Support_1.panic)("Array items accessed before they were set");
        }
        return this._itemsRef;
      }
      get items() {
        return (0, TypeRef_1.derefTypeRef)(this.getItemsRef(), this.graph);
      }
      getNonAttributeChildren() {
        return /* @__PURE__ */ new Set([
          this.items
        ]);
      }
      get isNullable() {
        return false;
      }
      isPrimitive() {
        return false;
      }
      get identity() {
        return arrayTypeIdentity(this.getAttributes(), this.getItemsRef());
      }
      reconstitute(builder) {
        const itemsRef = this.getItemsRef();
        const maybeItems = builder.lookup(itemsRef);
        if (maybeItems === void 0) {
          builder.getUniqueArrayType();
          builder.setArrayItems(builder.reconstitute(this.getItemsRef()));
        } else {
          builder.getArrayType(maybeItems);
        }
      }
      structuralEqualityStep(other, _conflateNumbers, queue) {
        return queue(this.items, other.items);
      }
    };
    exports.ArrayType = ArrayType;
    var GenericClassProperty = class _GenericClassProperty {
      constructor(typeData, isOptional) {
        this.typeData = typeData;
        this.isOptional = isOptional;
      }
      equals(other) {
        if (!(other instanceof _GenericClassProperty)) {
          return false;
        }
        return (0, collection_utils_1.areEqual)(this.typeData, other.typeData) && this.isOptional === other.isOptional;
      }
      hashCode() {
        return (0, collection_utils_1.hashCodeOf)(this.typeData) + (this.isOptional ? 17 : 23);
      }
    };
    exports.GenericClassProperty = GenericClassProperty;
    var ClassProperty = class extends GenericClassProperty {
      constructor(typeRef, graph, isOptional) {
        super(typeRef, isOptional);
        this.graph = graph;
      }
      get typeRef() {
        return this.typeData;
      }
      get type() {
        return (0, TypeRef_1.derefTypeRef)(this.typeRef, this.graph);
      }
    };
    exports.ClassProperty = ClassProperty;
    function objectTypeIdentify(kind, attributes, properties, additionalPropertiesRef) {
      if (hasUniqueIdentityAttributes(attributes)) return void 0;
      return new TypeIdentity(kind, [
        identityAttributes(attributes),
        properties,
        additionalPropertiesRef
      ]);
    }
    function classTypeIdentity(attributes, properties) {
      return objectTypeIdentify("class", attributes, properties, void 0);
    }
    function mapTypeIdentify(attributes, additionalPropertiesRef) {
      return objectTypeIdentify("map", attributes, /* @__PURE__ */ new Map(), additionalPropertiesRef);
    }
    var ObjectType = class extends Type {
      constructor(typeRef, graph, kind, isFixed, _properties, _additionalPropertiesRef) {
        super(typeRef, graph);
        this.kind = kind;
        this.isFixed = isFixed;
        this._properties = _properties;
        this._additionalPropertiesRef = _additionalPropertiesRef;
        if (kind === "map") {
          if (_properties !== void 0) {
            (0, Support_1.assert)(_properties.size === 0);
          }
          (0, Support_1.assert)(!isFixed);
        } else if (kind === "class") {
          (0, Support_1.assert)(_additionalPropertiesRef === void 0);
        } else {
          (0, Support_1.assert)(isFixed);
        }
      }
      setProperties(properties, additionalPropertiesRef) {
        (0, Support_1.assert)(this._properties === void 0, "Tried to set object properties twice");
        if (this instanceof MapType) {
          (0, Support_1.assert)(properties.size === 0, "Cannot set properties on map type");
        }
        if (this instanceof ClassType) {
          (0, Support_1.assert)(additionalPropertiesRef === void 0, "Cannot set additional properties of class type");
        }
        this._properties = properties;
        this._additionalPropertiesRef = additionalPropertiesRef;
      }
      getProperties() {
        return (0, Support_1.defined)(this._properties);
      }
      getSortedProperties() {
        return (0, collection_utils_1.mapSortByKey)(this.getProperties());
      }
      getAdditionalPropertiesRef() {
        (0, Support_1.assert)(this._properties !== void 0, "Properties are not set yet");
        return this._additionalPropertiesRef;
      }
      getAdditionalProperties() {
        const tref = this.getAdditionalPropertiesRef();
        if (tref === void 0) return void 0;
        return (0, TypeRef_1.derefTypeRef)(tref, this.graph);
      }
      getNonAttributeChildren() {
        const types = (0, collection_utils_1.mapSortToArray)(this.getProperties(), (_, k) => k).map(([_, p]) => p.type);
        const additionalProperties = this.getAdditionalProperties();
        if (additionalProperties !== void 0) {
          types.push(additionalProperties);
        }
        return new Set(types);
      }
      get isNullable() {
        return false;
      }
      isPrimitive() {
        return false;
      }
      get identity() {
        if (this.isFixed) return void 0;
        return objectTypeIdentify(this.kind, this.getAttributes(), this.getProperties(), this.getAdditionalPropertiesRef());
      }
      reconstitute(builder, canonicalOrder) {
        const sortedProperties = this.getSortedProperties();
        const propertiesInNewOrder = canonicalOrder ? sortedProperties : this.getProperties();
        const maybePropertyTypes = builder.lookupMap((0, collection_utils_1.mapMap)(sortedProperties, (cp) => cp.typeRef));
        const maybeAdditionalProperties = (0, collection_utils_1.definedMap)(this._additionalPropertiesRef, (r) => builder.lookup(r));
        if (maybePropertyTypes !== void 0 && (maybeAdditionalProperties !== void 0 || this._additionalPropertiesRef === void 0)) {
          const properties = (0, collection_utils_1.mapMap)(propertiesInNewOrder, (cp, n) => builder.makeClassProperty((0, Support_1.defined)(maybePropertyTypes.get(n)), cp.isOptional));
          switch (this.kind) {
            case "object":
              (0, Support_1.assert)(this.isFixed);
              builder.getObjectType(properties, maybeAdditionalProperties);
              break;
            case "map":
              builder.getMapType((0, Support_1.defined)(maybeAdditionalProperties));
              break;
            case "class":
              if (this.isFixed) {
                builder.getUniqueClassType(true, properties);
              } else {
                builder.getClassType(properties);
              }
              break;
            default:
              (0, Support_1.panic)(`Invalid object type kind ${this.kind}`);
          }
        } else {
          switch (this.kind) {
            case "object":
              (0, Support_1.assert)(this.isFixed);
              builder.getUniqueObjectType(void 0, void 0);
              break;
            case "map":
              builder.getUniqueMapType();
              break;
            case "class":
              builder.getUniqueClassType(this.isFixed, void 0);
              break;
            default:
              (0, Support_1.panic)(`Invalid object type kind ${this.kind}`);
          }
          const reconstitutedTypes = (0, collection_utils_1.mapMap)(sortedProperties, (cp) => builder.reconstitute(cp.typeRef));
          const properties = (0, collection_utils_1.mapMap)(propertiesInNewOrder, (cp, n) => builder.makeClassProperty((0, Support_1.defined)(reconstitutedTypes.get(n)), cp.isOptional));
          const additionalProperties = (0, collection_utils_1.definedMap)(this._additionalPropertiesRef, (r) => builder.reconstitute(r));
          builder.setObjectProperties(properties, additionalProperties);
        }
      }
      structuralEqualityStep(other, _conflateNumbers, queue) {
        const pa = this.getProperties();
        const pb = other.getProperties();
        if (pa.size !== pb.size) return false;
        let failed = false;
        for (const [name, cpa] of pa) {
          const cpb = pb.get(name);
          if (cpb === void 0 || cpa.isOptional !== cpb.isOptional || !queue(cpa.type, cpb.type)) {
            failed = true;
            return false;
          }
        }
        if (failed) return false;
        const thisAdditionalProperties = this.getAdditionalProperties();
        const otherAdditionalProperties = other.getAdditionalProperties();
        if (thisAdditionalProperties === void 0 !== (otherAdditionalProperties === void 0)) return false;
        if (thisAdditionalProperties === void 0 || otherAdditionalProperties === void 0) return true;
        return queue(thisAdditionalProperties, otherAdditionalProperties);
      }
    };
    exports.ObjectType = ObjectType;
    var ClassType = class extends ObjectType {
      constructor(typeRef, graph, isFixed, properties) {
        super(typeRef, graph, "class", isFixed, properties, void 0);
      }
    };
    exports.ClassType = ClassType;
    var MapType = class extends ObjectType {
      constructor(typeRef, graph, valuesRef) {
        super(typeRef, graph, "map", false, (0, collection_utils_1.definedMap)(valuesRef, () => /* @__PURE__ */ new Map()), valuesRef);
      }
      // FIXME: Remove and use `getAdditionalProperties()` instead.
      get values() {
        return (0, Support_1.defined)(this.getAdditionalProperties());
      }
    };
    exports.MapType = MapType;
    function enumTypeIdentity(attributes, cases) {
      if (hasUniqueIdentityAttributes(attributes)) return void 0;
      return new TypeIdentity("enum", [
        identityAttributes(attributes),
        cases
      ]);
    }
    var EnumType = class extends Type {
      constructor(typeRef, graph, cases) {
        super(typeRef, graph);
        this.cases = cases;
        this.kind = "enum";
      }
      get isNullable() {
        return false;
      }
      isPrimitive() {
        return false;
      }
      get identity() {
        return enumTypeIdentity(this.getAttributes(), this.cases);
      }
      getNonAttributeChildren() {
        return /* @__PURE__ */ new Set();
      }
      reconstitute(builder) {
        builder.getEnumType(this.cases);
      }
      structuralEqualityStep(other, _conflateNumbers, _queue) {
        return (0, collection_utils_1.areEqual)(this.cases, other.cases);
      }
    };
    exports.EnumType = EnumType;
    function setOperationCasesEqual(typesA, typesB, conflateNumbers, membersEqual) {
      const ma = (0, collection_utils_1.toReadonlySet)(typesA);
      const mb = (0, collection_utils_1.toReadonlySet)(typesB);
      if (ma.size !== mb.size) return false;
      return (0, collection_utils_1.iterableEvery)(ma, (ta) => {
        const tb = (0, collection_utils_1.iterableFind)(mb, (t) => t.kind === ta.kind);
        if (tb !== void 0) {
          if (membersEqual(ta, tb)) return true;
        }
        if (conflateNumbers) {
          if (ta.kind === "integer" && (0, collection_utils_1.iterableSome)(mb, (t) => t.kind === "double")) return true;
          if (ta.kind === "double" && (0, collection_utils_1.iterableSome)(mb, (t) => t.kind === "integer")) return true;
        }
        return false;
      });
    }
    function setOperationTypeIdentity(kind, attributes, memberRefs) {
      if (hasUniqueIdentityAttributes(attributes)) return void 0;
      return new TypeIdentity(kind, [
        identityAttributes(attributes),
        memberRefs
      ]);
    }
    function unionTypeIdentity(attributes, memberRefs) {
      return setOperationTypeIdentity("union", attributes, memberRefs);
    }
    function intersectionTypeIdentity(attributes, memberRefs) {
      return setOperationTypeIdentity("intersection", attributes, memberRefs);
    }
    var SetOperationType = class extends Type {
      constructor(typeRef, graph, kind, _memberRefs) {
        super(typeRef, graph);
        this.kind = kind;
        this._memberRefs = _memberRefs;
      }
      setMembers(memberRefs) {
        if (this._memberRefs !== void 0) {
          (0, Support_1.panic)("Can only set map members once");
        }
        this._memberRefs = memberRefs;
      }
      getMemberRefs() {
        if (this._memberRefs === void 0) {
          return (0, Support_1.panic)("Map members accessed before they were set");
        }
        return this._memberRefs;
      }
      get members() {
        return (0, collection_utils_1.setMap)(this.getMemberRefs(), (tref) => (0, TypeRef_1.derefTypeRef)(tref, this.graph));
      }
      get sortedMembers() {
        return this.getNonAttributeChildren();
      }
      getNonAttributeChildren() {
        return (0, collection_utils_1.setSortBy)(this.members, (t) => t.kind);
      }
      isPrimitive() {
        return false;
      }
      get identity() {
        return setOperationTypeIdentity(this.kind, this.getAttributes(), this.getMemberRefs());
      }
      reconstituteSetOperation(builder, canonicalOrder, getType) {
        const sortedMemberRefs = (0, collection_utils_1.mapMap)(this.sortedMembers.entries(), (t) => t.typeRef);
        const membersInOrder = canonicalOrder ? this.sortedMembers : this.members;
        const maybeMembers = builder.lookupMap(sortedMemberRefs);
        if (maybeMembers === void 0) {
          getType(void 0);
          const reconstituted = builder.reconstituteMap(sortedMemberRefs);
          builder.setSetOperationMembers((0, collection_utils_1.setMap)(membersInOrder, (t) => (0, Support_1.defined)(reconstituted.get(t))));
        } else {
          getType((0, collection_utils_1.setMap)(membersInOrder, (t) => (0, Support_1.defined)(maybeMembers.get(t))));
        }
      }
      structuralEqualityStep(other, conflateNumbers, queue) {
        return setOperationCasesEqual(this.members, other.members, conflateNumbers, queue);
      }
    };
    exports.SetOperationType = SetOperationType;
    var IntersectionType = class extends SetOperationType {
      constructor(typeRef, graph, memberRefs) {
        super(typeRef, graph, "intersection", memberRefs);
      }
      get isNullable() {
        return (0, Support_1.panic)("isNullable not implemented for IntersectionType");
      }
      reconstitute(builder, canonicalOrder) {
        this.reconstituteSetOperation(builder, canonicalOrder, (members) => {
          if (members === void 0) {
            builder.getUniqueIntersectionType();
          } else {
            builder.getIntersectionType(members);
          }
        });
      }
    };
    exports.IntersectionType = IntersectionType;
    var UnionType = class extends SetOperationType {
      constructor(typeRef, graph, memberRefs) {
        super(typeRef, graph, "union", memberRefs);
        if (memberRefs !== void 0) {
          (0, Messages_1.messageAssert)(memberRefs.size > 0, "IRNoEmptyUnions", {});
        }
      }
      setMembers(memberRefs) {
        (0, Messages_1.messageAssert)(memberRefs.size > 0, "IRNoEmptyUnions", {});
        super.setMembers(memberRefs);
      }
      get stringTypeMembers() {
        return (0, collection_utils_1.setFilter)(this.members, (t) => (0, TransformedStringType_1.isPrimitiveStringTypeKind)(t.kind) || t.kind === "enum");
      }
      findMember(kind) {
        return (0, collection_utils_1.iterableFind)(this.members, (t) => t.kind === kind);
      }
      get isNullable() {
        return this.findMember("null") !== void 0;
      }
      get isCanonical() {
        const members = this.members;
        if (members.size <= 1) return false;
        const kinds = (0, collection_utils_1.setMap)(members, (t) => t.kind);
        if (kinds.size < members.size) return false;
        if (kinds.has("union") || kinds.has("intersection")) return false;
        if (kinds.has("none") || kinds.has("any")) return false;
        if (kinds.has("string") && kinds.has("enum")) return false;
        let numObjectTypes = 0;
        if (kinds.has("class")) numObjectTypes += 1;
        if (kinds.has("map")) numObjectTypes += 1;
        if (kinds.has("object")) numObjectTypes += 1;
        if (numObjectTypes > 1) return false;
        return true;
      }
      reconstitute(builder, canonicalOrder) {
        this.reconstituteSetOperation(builder, canonicalOrder, (members) => {
          if (members === void 0) {
            builder.getUniqueUnionType();
          } else {
            builder.getUnionType(members);
          }
        });
      }
    };
    exports.UnionType = UnionType;
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/Type/TypeBuilderUtils.js
var require_TypeBuilderUtils = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/Type/TypeBuilderUtils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.stringTypeMappingGet = stringTypeMappingGet;
    exports.getNoStringTypeMapping = getNoStringTypeMapping;
    var TransformedStringType_1 = require_TransformedStringType();
    function stringTypeMappingGet(stm, kind) {
      const mapped = stm.get(kind);
      if (mapped === void 0) return "string";
      return mapped;
    }
    var noStringTypeMapping;
    function getNoStringTypeMapping() {
      if (noStringTypeMapping === void 0) {
        noStringTypeMapping = new Map(Array.from(TransformedStringType_1.transformedStringTypeKinds).map((k) => [
          k,
          k
        ]));
      }
      return noStringTypeMapping;
    }
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/attributes/StringTypes.js
var require_StringTypes = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/attributes/StringTypes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.stringTypesTypeAttributeKind = exports.StringTypes = void 0;
    exports.inferTransformedStringTypeKindForString = inferTransformedStringTypeKindForString;
    var collection_utils_1 = require_dist();
    var Support_1 = require_Support();
    var TypeBuilderUtils_1 = require_TypeBuilderUtils();
    var TypeAttributes_1 = require_TypeAttributes();
    var StringTypes = class _StringTypes {
      static fromCase(s, count) {
        const caseMap = {};
        caseMap[s] = count;
        return new _StringTypes(/* @__PURE__ */ new Map([
          [
            s,
            count
          ]
        ]), /* @__PURE__ */ new Set());
      }
      static fromCases(cases) {
        const caseMap = {};
        for (const s of cases) {
          caseMap[s] = 1;
        }
        return new _StringTypes(new Map(cases.map((s) => [
          s,
          1
        ])), /* @__PURE__ */ new Set());
      }
      // undefined means no restrictions
      constructor(cases, transformations) {
        this.cases = cases;
        this.transformations = transformations;
        if (cases === void 0) {
          (0, Support_1.assert)(transformations.size === 0, "We can't have an unrestricted string that also allows transformations");
        }
      }
      get isRestricted() {
        return this.cases !== void 0;
      }
      union(othersArray, startIndex) {
        if (this.cases === void 0) return this;
        const cases = new Map(this.cases);
        const transformations = new Set(this.transformations);
        for (let i2 = startIndex; i2 < othersArray.length; i2++) {
          const other = othersArray[i2];
          if (other.cases === void 0) return other;
          (0, collection_utils_1.mapMergeWithInto)(cases, (x, y) => x + y, other.cases);
          (0, collection_utils_1.setUnionInto)(transformations, other.transformations);
        }
        return new _StringTypes(cases, transformations);
      }
      intersect(othersArray, startIndex) {
        let cases = this.cases;
        let transformations = this.transformations;
        for (let i2 = startIndex; i2 < othersArray.length; i2++) {
          const other = othersArray[i2];
          if (cases === void 0) {
            cases = (0, collection_utils_1.definedMap)(other.cases, (m) => new Map(m));
          } else if (other.cases !== void 0) {
            const thisCases = cases;
            const otherCases = other.cases;
            const intersects = (0, collection_utils_1.setIntersect)(thisCases.keys(), new Set(otherCases.keys()));
            const entries = intersects.size > 0 ? intersects.entries() : new Set(thisCases.keys()).entries();
            cases = (0, collection_utils_1.mapMap)(entries, (k) => {
              var _a;
              const thisValue = (0, Support_1.defined)(thisCases.get(k));
              const otherValue = (_a = otherCases.get(k)) !== null && _a !== void 0 ? _a : Math.min();
              return Math.min(thisValue, otherValue);
            });
          }
          transformations = (0, collection_utils_1.setIntersect)(transformations, other.transformations);
        }
        return new _StringTypes(cases, transformations);
      }
      applyStringTypeMapping(mapping) {
        if (!this.isRestricted) return this;
        const kinds = /* @__PURE__ */ new Set();
        for (const kind of this.transformations) {
          const mapped = (0, TypeBuilderUtils_1.stringTypeMappingGet)(mapping, kind);
          if (mapped === "string") return _StringTypes.unrestricted;
          kinds.add(mapped);
        }
        return new _StringTypes(this.cases, new Set(kinds));
      }
      equals(other) {
        if (!(other instanceof _StringTypes)) return false;
        return (0, collection_utils_1.areEqual)(this.cases, other.cases) && (0, collection_utils_1.areEqual)(this.transformations, other.transformations);
      }
      hashCode() {
        let h = (0, collection_utils_1.hashCodeOf)(this.cases);
        h = (0, collection_utils_1.addHashCode)(h, (0, collection_utils_1.hashCodeOf)(this.transformations));
        return h;
      }
      toString() {
        const parts = [];
        const enumCases = this.cases;
        if (enumCases === void 0) {
          parts.push("unrestricted");
        } else {
          const firstKey = (0, collection_utils_1.iterableFirst)(enumCases.keys());
          if (firstKey === void 0) {
            parts.push("enum with no cases");
          } else {
            parts.push(`${enumCases.size.toString()} enums: ${firstKey} (${enumCases.get(firstKey)}), ...`);
          }
        }
        return parts.concat(Array.from(this.transformations)).join(",");
      }
    };
    exports.StringTypes = StringTypes;
    StringTypes.unrestricted = new StringTypes(void 0, /* @__PURE__ */ new Set());
    var StringTypesTypeAttributeKind = class extends TypeAttributes_1.TypeAttributeKind {
      constructor() {
        super("stringTypes");
      }
      get inIdentity() {
        return true;
      }
      requiresUniqueIdentity(st) {
        return st.cases !== void 0 && st.cases.size > 0;
      }
      combine(arr) {
        (0, Support_1.assert)(arr.length > 0);
        return arr[0].union(arr, 1);
      }
      intersect(arr) {
        (0, Support_1.assert)(arr.length > 0);
        return arr[0].intersect(arr, 1);
      }
      makeInferred(_) {
        return void 0;
      }
      stringify(st) {
        return st.toString();
      }
    };
    exports.stringTypesTypeAttributeKind = new StringTypesTypeAttributeKind();
    var INTEGER_STRING = /^(0|-?[1-9]\d*)$/;
    var MIN_INTEGER_STRING = 1 << 31;
    var MAX_INTEGER_STRING = -(MIN_INTEGER_STRING + 1);
    function isIntegerString(s) {
      if (INTEGER_STRING.exec(s) === null) {
        return false;
      }
      const i2 = Number.parseInt(s, 10);
      return i2 >= MIN_INTEGER_STRING && i2 <= MAX_INTEGER_STRING;
    }
    var UUID = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/;
    function isUUID(s) {
      return UUID.exec(s) !== null;
    }
    var URI = /^(https?|ftp):\/\/[^{}]+$/;
    function isURI(s) {
      return URI.exec(s) !== null;
    }
    function inferTransformedStringTypeKindForString(s, recognizer) {
      if (s.length === 0 || !"0123456789-abcdefth".includes(s[0])) return void 0;
      if (recognizer.isDate(s)) {
        return "date";
      }
      if (recognizer.isTime(s)) {
        return "time";
      }
      if (recognizer.isDateTime(s)) {
        return "date-time";
      }
      if (isIntegerString(s)) {
        return "integer-string";
      }
      if (s === "false" || s === "true") {
        return "bool-string";
      }
      if (isUUID(s)) {
        return "uuid";
      }
      if (isURI(s)) {
        return "uri";
      }
      return void 0;
    }
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/Type/ProvenanceTypeAttributeKind.js
var require_ProvenanceTypeAttributeKind = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/Type/ProvenanceTypeAttributeKind.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.provenanceTypeAttributeKind = void 0;
    var collection_utils_1 = require_dist();
    var TypeAttributes_1 = require_TypeAttributes();
    var ProvenanceTypeAttributeKind = class extends TypeAttributes_1.TypeAttributeKind {
      constructor() {
        super("provenance");
      }
      appliesToTypeKind(_kind) {
        return true;
      }
      combine(arr) {
        return (0, collection_utils_1.setUnionManyInto)(/* @__PURE__ */ new Set(), arr);
      }
      makeInferred(p) {
        return p;
      }
      stringify(p) {
        return Array.from(p).sort().map((i2) => i2.toString()).join(",");
      }
    };
    exports.provenanceTypeAttributeKind = new ProvenanceTypeAttributeKind();
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/Type/TypeBuilder.js
var require_TypeBuilder = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/Type/TypeBuilder.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.TypeBuilder = void 0;
    var collection_utils_1 = require_dist();
    var StringTypes_1 = require_StringTypes();
    var TypeAttributes_1 = require_TypeAttributes();
    var Support_1 = require_Support();
    var ProvenanceTypeAttributeKind_1 = require_ProvenanceTypeAttributeKind();
    var TransformedStringType_1 = require_TransformedStringType();
    var Type_1 = require_Type();
    var TypeBuilderUtils_1 = require_TypeBuilderUtils();
    var TypeRef_1 = require_TypeRef();
    var TypeBuilder = class {
      constructor(_stringTypeMapping, canonicalOrder, _allPropertiesOptional, _addProvenanceAttributes, inheritsProvenanceAttributes) {
        this._stringTypeMapping = _stringTypeMapping;
        this.canonicalOrder = canonicalOrder;
        this._allPropertiesOptional = _allPropertiesOptional;
        this._addProvenanceAttributes = _addProvenanceAttributes;
        this.topLevels = /* @__PURE__ */ new Map();
        this.types = [];
        this.typeAttributes = [];
        this._addedForwardingIntersection = false;
        this._typeForIdentity = new collection_utils_1.EqualityMap();
        (0, Support_1.assert)(!_addProvenanceAttributes || !inheritsProvenanceAttributes, "We can't both inherit as well as add provenance");
      }
      get typeGraph() {
        (0, Support_1.assert)(!!this._typeGraph, "TypeBuilder must have a TypeGraph");
        return this._typeGraph;
      }
      /** typeGraph must be set externally to prevent import cycle of TypeGraph constructor */
      set typeGraph(typeGraph) {
        this._typeGraph = typeGraph;
      }
      addTopLevel(name, tref) {
        (0, Support_1.assert)(!this.topLevels.has(name), "Trying to add top-level with existing name");
        (0, Support_1.assert)(this.types[(0, TypeRef_1.typeRefIndex)(tref)] !== void 0, "Trying to add a top-level type that doesn't exist (yet?)");
        this.topLevels.set(name, tref);
      }
      reserveTypeRef() {
        const index = this.types.length;
        this.types.push(void 0);
        const tref = (0, TypeRef_1.makeTypeRef)(this.typeGraph, index);
        const attributes = this._addProvenanceAttributes ? ProvenanceTypeAttributeKind_1.provenanceTypeAttributeKind.makeAttributes(/* @__PURE__ */ new Set([
          index
        ])) : TypeAttributes_1.emptyTypeAttributes;
        this.typeAttributes.push(attributes);
        return tref;
      }
      assertTypeRefGraph(tref) {
        if (tref === void 0) return;
        (0, TypeRef_1.assertTypeRefGraph)(tref, this.typeGraph);
      }
      assertTypeRefSetGraph(trefs) {
        if (trefs === void 0) return;
        trefs.forEach((tref) => this.assertTypeRefGraph(tref));
      }
      filterTypeAttributes(t, attributes) {
        const filtered = (0, collection_utils_1.mapFilter)(attributes, (_, k) => k.appliesToTypeKind(t.kind));
        if (attributes.size !== filtered.size) {
          this.setLostTypeAttributes();
        }
        return filtered;
      }
      commitType(tref, t) {
        this.assertTypeRefGraph(tref);
        const index = (0, TypeRef_1.typeRefIndex)(tref);
        (0, Support_1.assert)(this.types[index] === void 0, "A type index was committed twice");
        this.types[index] = t;
        this.typeAttributes[index] = this.filterTypeAttributes(t, this.typeAttributes[index]);
      }
      addType(forwardingRef, creator, attributes) {
        if (forwardingRef !== void 0) {
          this.assertTypeRefGraph(forwardingRef);
          (0, Support_1.assert)(this.types[(0, TypeRef_1.typeRefIndex)(forwardingRef)] === void 0);
        }
        const tref = forwardingRef !== null && forwardingRef !== void 0 ? forwardingRef : this.reserveTypeRef();
        if (attributes !== void 0) {
          const index = (0, TypeRef_1.typeRefIndex)(tref);
          this.typeAttributes[index] = (0, TypeAttributes_1.combineTypeAttributes)("union", this.typeAttributes[index], attributes);
        }
        const t = creator(tref);
        this.commitType(tref, t);
        return tref;
      }
      typeAtIndex(index) {
        const maybeType = this.types[index];
        if (maybeType === void 0) {
          return (0, Support_1.panic)("Trying to deref an undefined type in a type builder");
        }
        return maybeType;
      }
      atIndex(index) {
        const t = this.typeAtIndex(index);
        const attribtues = this.typeAttributes[index];
        return [
          t,
          attribtues
        ];
      }
      addAttributes(tref, attributes) {
        this.assertTypeRefGraph(tref);
        const index = (0, TypeRef_1.typeRefIndex)(tref);
        const existingAttributes = this.typeAttributes[index];
        (0, Support_1.assert)((0, collection_utils_1.iterableEvery)(attributes, ([k, v]) => {
          if (!k.inIdentity) return true;
          const existing = existingAttributes.get(k);
          if (existing === void 0) return false;
          return (0, collection_utils_1.areEqual)(existing, v);
        }), "Can't add different identity type attributes to an existing type");
        const maybeType = this.types[index];
        if (maybeType !== void 0) {
          attributes = this.filterTypeAttributes(maybeType, attributes);
        }
        const nonIdentityAttributes = (0, collection_utils_1.mapFilter)(attributes, (_, k) => !k.inIdentity);
        this.typeAttributes[index] = (0, TypeAttributes_1.combineTypeAttributes)("union", existingAttributes, nonIdentityAttributes);
      }
      finish() {
        this.typeGraph.freeze(this.topLevels, this.types.map(Support_1.defined), this.typeAttributes);
        return this.typeGraph;
      }
      addForwardingIntersection(forwardingRef, tref) {
        this.assertTypeRefGraph(tref);
        this._addedForwardingIntersection = true;
        return this.addType(forwardingRef, (tr) => new Type_1.IntersectionType(tr, this.typeGraph, /* @__PURE__ */ new Set([
          tref
        ])), void 0);
      }
      forwardIfNecessary(forwardingRef, tref) {
        if (tref === void 0) return void 0;
        if (forwardingRef === void 0) return tref;
        return this.addForwardingIntersection(forwardingRef, tref);
      }
      get didAddForwardingIntersection() {
        return this._addedForwardingIntersection;
      }
      registerTypeForIdentity(identity, tref) {
        if (identity === void 0) return;
        this._typeForIdentity.set(identity, tref);
      }
      makeIdentity(maker) {
        return maker();
      }
      getOrAddType(identityMaker, creator, attributes, forwardingRef) {
        const identity = this.makeIdentity(identityMaker);
        let maybeTypeRef;
        if (identity === void 0) {
          maybeTypeRef = void 0;
        } else {
          maybeTypeRef = this._typeForIdentity.get(identity);
        }
        if (maybeTypeRef !== void 0) {
          const result = this.forwardIfNecessary(forwardingRef, maybeTypeRef);
          if (attributes !== void 0) {
            this.addAttributes(result, (0, collection_utils_1.mapFilter)(attributes, (_, k) => !k.inIdentity));
          }
          return result;
        }
        const tref = this.addType(forwardingRef, creator, attributes);
        this.registerTypeForIdentity(identity, tref);
        return tref;
      }
      registerType(t) {
        this.registerTypeForIdentity(t.identity, t.typeRef);
      }
      getPrimitiveType(kind, maybeAttributes, forwardingRef) {
        const attributes = (0, collection_utils_1.withDefault)(maybeAttributes, TypeAttributes_1.emptyTypeAttributes);
        const stringTypes = kind === "string" ? void 0 : StringTypes_1.StringTypes.unrestricted;
        if ((0, TransformedStringType_1.isPrimitiveStringTypeKind)(kind) && kind !== "string") {
          kind = (0, TypeBuilderUtils_1.stringTypeMappingGet)(this._stringTypeMapping, kind);
        }
        if (kind === "string") {
          return this.getStringType(attributes, stringTypes, forwardingRef);
        }
        return this.getOrAddType(() => (0, Type_1.primitiveTypeIdentity)(kind, attributes), (tr) => new Type_1.PrimitiveType(tr, this.typeGraph, kind), attributes, forwardingRef);
      }
      getStringType(attributes, stringTypes, forwardingRef) {
        const existingStringTypes = (0, collection_utils_1.mapFind)(attributes, (_, k) => k === StringTypes_1.stringTypesTypeAttributeKind);
        (0, Support_1.assert)(stringTypes === void 0 !== (existingStringTypes === void 0), "Must instantiate string type with one enum case attribute");
        if (existingStringTypes === void 0) {
          attributes = (0, TypeAttributes_1.combineTypeAttributes)("union", attributes, StringTypes_1.stringTypesTypeAttributeKind.makeAttributes((0, Support_1.defined)(stringTypes)));
        }
        return this.getOrAddType(() => (0, Type_1.primitiveTypeIdentity)("string", attributes), (tr) => new Type_1.PrimitiveType(tr, this.typeGraph, "string"), attributes, forwardingRef);
      }
      getEnumType(attributes, cases, forwardingRef) {
        return this.getOrAddType(() => (0, Type_1.enumTypeIdentity)(attributes, cases), (tr) => new Type_1.EnumType(tr, this.typeGraph, cases), attributes, forwardingRef);
      }
      makeClassProperty(tref, isOptional) {
        return new Type_1.ClassProperty(tref, this.typeGraph, isOptional);
      }
      getUniqueObjectType(attributes, properties, additionalProperties, forwardingRef) {
        this.assertTypeRefGraph(additionalProperties);
        properties = (0, collection_utils_1.definedMap)(properties, (p) => this.modifyPropertiesIfNecessary(p));
        return this.addType(forwardingRef, (tref) => new Type_1.ObjectType(tref, this.typeGraph, "object", true, properties, additionalProperties), attributes);
      }
      getUniqueMapType(forwardingRef) {
        return this.addType(forwardingRef, (tr) => new Type_1.MapType(tr, this.typeGraph, void 0), void 0);
      }
      getMapType(attributes, values, forwardingRef) {
        this.assertTypeRefGraph(values);
        return this.getOrAddType(() => (0, Type_1.mapTypeIdentify)(attributes, values), (tr) => new Type_1.MapType(tr, this.typeGraph, values), attributes, forwardingRef);
      }
      setObjectProperties(ref, properties, additionalProperties) {
        this.assertTypeRefGraph(additionalProperties);
        const type = (0, TypeRef_1.derefTypeRef)(ref, this.typeGraph);
        if (!(type instanceof Type_1.ObjectType)) {
          return (0, Support_1.panic)("Tried to set properties of non-object type");
        }
        type.setProperties(this.modifyPropertiesIfNecessary(properties), additionalProperties);
        this.registerType(type);
      }
      getUniqueArrayType(forwardingRef) {
        return this.addType(forwardingRef, (tr) => new Type_1.ArrayType(tr, this.typeGraph, void 0), void 0);
      }
      getArrayType(attributes, items, forwardingRef) {
        this.assertTypeRefGraph(items);
        return this.getOrAddType(() => (0, Type_1.arrayTypeIdentity)(attributes, items), (tr) => new Type_1.ArrayType(tr, this.typeGraph, items), attributes, forwardingRef);
      }
      setArrayItems(ref, items) {
        this.assertTypeRefGraph(items);
        const type = (0, TypeRef_1.derefTypeRef)(ref, this.typeGraph);
        if (!(type instanceof Type_1.ArrayType)) {
          (0, Support_1.panic)("Tried to set items of non-array type");
        }
        type.setItems(items);
        this.registerType(type);
      }
      modifyPropertiesIfNecessary(properties) {
        properties.forEach((p) => this.assertTypeRefGraph(p.typeRef));
        if (this.canonicalOrder) {
          properties = (0, collection_utils_1.mapSortByKey)(properties);
        }
        if (this._allPropertiesOptional) {
          properties = (0, collection_utils_1.mapMap)(properties, (cp) => this.makeClassProperty(cp.typeRef, true));
        }
        return properties;
      }
      getClassType(attributes, properties, forwardingRef) {
        properties = this.modifyPropertiesIfNecessary(properties);
        return this.getOrAddType(() => (0, Type_1.classTypeIdentity)(attributes, properties), (tr) => new Type_1.ClassType(tr, this.typeGraph, false, properties), attributes, forwardingRef);
      }
      // FIXME: Maybe just distinguish between this and `getClassType`
      // via a flag?  That would make `ClassType.map` simpler.
      getUniqueClassType(attributes, isFixed, properties, forwardingRef) {
        properties = (0, collection_utils_1.definedMap)(properties, (p) => this.modifyPropertiesIfNecessary(p));
        return this.addType(forwardingRef, (tref) => new Type_1.ClassType(tref, this.typeGraph, isFixed, properties), attributes);
      }
      getUnionType(attributes, members, forwardingRef) {
        this.assertTypeRefSetGraph(members);
        return this.getOrAddType(() => (0, Type_1.unionTypeIdentity)(attributes, members), (tr) => new Type_1.UnionType(tr, this.typeGraph, members), attributes, forwardingRef);
      }
      // FIXME: why do we sometimes call this with defined members???
      getUniqueUnionType(attributes, members, forwardingRef) {
        this.assertTypeRefSetGraph(members);
        return this.addType(forwardingRef, (tref) => new Type_1.UnionType(tref, this.typeGraph, members), attributes);
      }
      getIntersectionType(attributes, members, forwardingRef) {
        this.assertTypeRefSetGraph(members);
        return this.getOrAddType(() => (0, Type_1.intersectionTypeIdentity)(attributes, members), (tr) => new Type_1.IntersectionType(tr, this.typeGraph, members), attributes, forwardingRef);
      }
      // FIXME: why do we sometimes call this with defined members???
      getUniqueIntersectionType(attributes, members, forwardingRef) {
        this.assertTypeRefSetGraph(members);
        return this.addType(forwardingRef, (tref) => new Type_1.IntersectionType(tref, this.typeGraph, members), attributes);
      }
      setSetOperationMembers(ref, members) {
        this.assertTypeRefSetGraph(members);
        const type = (0, TypeRef_1.derefTypeRef)(ref, this.typeGraph);
        if (!(type instanceof Type_1.UnionType || type instanceof Type_1.IntersectionType)) {
          (0, Support_1.panic)("Tried to set members of non-set-operation type");
        }
        type.setMembers(members);
        this.registerType(type);
      }
      setLostTypeAttributes() {
        return;
      }
    };
    exports.TypeBuilder = TypeBuilder;
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/Type/TypeUtils.js
var require_TypeUtils = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/Type/TypeUtils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.assertIsObject = assertIsObject;
    exports.assertIsClass = assertIsClass;
    exports.setOperationMembersRecursively = setOperationMembersRecursively;
    exports.makeGroupsToFlatten = makeGroupsToFlatten;
    exports.combineTypeAttributesOfTypes = combineTypeAttributesOfTypes;
    exports.isAnyOrNull = isAnyOrNull;
    exports.removeNullFromUnion = removeNullFromUnion;
    exports.removeNullFromType = removeNullFromType;
    exports.nullableFromUnion = nullableFromUnion;
    exports.nonNullTypeCases = nonNullTypeCases;
    exports.getNullAsOptional = getNullAsOptional;
    exports.isNamedType = isNamedType;
    exports.separateNamedTypes = separateNamedTypes;
    exports.directlyReachableTypes = directlyReachableTypes;
    exports.directlyReachableSingleNamedType = directlyReachableSingleNamedType;
    exports.stringTypesForType = stringTypesForType;
    exports.matchTypeExhaustive = matchTypeExhaustive;
    exports.matchType = matchType;
    exports.matchCompoundType = matchCompoundType;
    var collection_utils_1 = require_dist();
    var StringTypes_1 = require_StringTypes();
    var TypeAttributes_1 = require_TypeAttributes();
    var Support_1 = require_Support();
    var TransformedStringType_1 = require_TransformedStringType();
    var Type_1 = require_Type();
    function assertIsObject(t) {
      if (t instanceof Type_1.ObjectType) {
        return t;
      }
      return (0, Support_1.panic)("Supposed object type is not an object type");
    }
    function assertIsClass(t) {
      if (!(t instanceof Type_1.ClassType)) {
        return (0, Support_1.panic)("Supposed class type is not a class type");
      }
      return t;
    }
    function setOperationMembersRecursively(oneOrMany, combinationKind) {
      const setOperations = Array.isArray(oneOrMany) ? oneOrMany : [
        oneOrMany
      ];
      const kind = setOperations[0].kind;
      const includeAny = kind !== "intersection";
      const processedSetOperations = /* @__PURE__ */ new Set();
      const members = /* @__PURE__ */ new Set();
      let attributes = TypeAttributes_1.emptyTypeAttributes;
      function process2(t) {
        if (t.kind === kind) {
          const so = t;
          if (processedSetOperations.has(so)) return;
          processedSetOperations.add(so);
          if (combinationKind !== void 0) {
            attributes = (0, TypeAttributes_1.combineTypeAttributes)(combinationKind, attributes, t.getAttributes());
          }
          for (const m of so.members) {
            process2(m);
          }
        } else if (includeAny || t.kind !== "any") {
          members.add(t);
        } else {
          if (combinationKind !== void 0) {
            attributes = (0, TypeAttributes_1.combineTypeAttributes)(combinationKind, attributes, t.getAttributes());
          }
        }
      }
      for (const so of setOperations) {
        process2(so);
      }
      return [
        members,
        attributes
      ];
    }
    function makeGroupsToFlatten(setOperations, include) {
      const typeGroups = new collection_utils_1.EqualityMap();
      for (const u of setOperations) {
        const members = new Set(setOperationMembersRecursively(u, void 0)[0]);
        if (include !== void 0) {
          if (!include(members)) continue;
        }
        let maybeSet = typeGroups.get(members);
        if (maybeSet === void 0) {
          maybeSet = /* @__PURE__ */ new Set();
          if (members.size === 1) {
            maybeSet.add((0, Support_1.defined)((0, collection_utils_1.iterableFirst)(members)));
          }
        }
        maybeSet.add(u);
        typeGroups.set(members, maybeSet);
      }
      return Array.from(typeGroups.values()).map((ts) => Array.from(ts));
    }
    function combineTypeAttributesOfTypes(combinationKind, types) {
      return (0, TypeAttributes_1.combineTypeAttributes)(combinationKind, Array.from(types).map((t) => t.getAttributes()));
    }
    function isAnyOrNull(t) {
      return t.kind === "any" || t.kind === "null";
    }
    function removeNullFromUnion(t, sortBy = false) {
      function sort(s) {
        if (sortBy === false) return s;
        if (sortBy === true) return (0, collection_utils_1.setSortBy)(s, (m) => m.kind);
        return (0, collection_utils_1.setSortBy)(s, sortBy);
      }
      const nullType = t.findMember("null");
      if (nullType === void 0) {
        return [
          null,
          sort(t.members)
        ];
      }
      return [
        nullType,
        sort((0, collection_utils_1.setFilter)(t.members, (m) => m.kind !== "null"))
      ];
    }
    function removeNullFromType(t) {
      if (t.kind === "null") {
        return [
          t,
          /* @__PURE__ */ new Set()
        ];
      }
      if (!(t instanceof Type_1.UnionType)) {
        return [
          null,
          /* @__PURE__ */ new Set([
            t
          ])
        ];
      }
      return removeNullFromUnion(t);
    }
    function nullableFromUnion(t) {
      const [hasNull, nonNulls] = removeNullFromUnion(t);
      if (hasNull === null) return null;
      if (nonNulls.size !== 1) return null;
      return (0, Support_1.defined)((0, collection_utils_1.iterableFirst)(nonNulls));
    }
    function nonNullTypeCases(t) {
      return removeNullFromType(t)[1];
    }
    function getNullAsOptional(cp) {
      const [maybeNull, nonNulls] = removeNullFromType(cp.type);
      if (cp.isOptional) {
        return [
          true,
          nonNulls
        ];
      }
      return [
        maybeNull !== null,
        nonNulls
      ];
    }
    function isNamedType(t) {
      return [
        "class",
        "union",
        "enum",
        "object"
      ].includes(t.kind);
    }
    function separateNamedTypes(types) {
      const objects = (0, collection_utils_1.setFilter)(types, (t) => t.kind === "object" || t.kind === "class");
      const enums = (0, collection_utils_1.setFilter)(types, (t) => t instanceof Type_1.EnumType);
      const unions = (0, collection_utils_1.setFilter)(types, (t) => t instanceof Type_1.UnionType);
      return {
        objects,
        enums,
        unions
      };
    }
    function directlyReachableTypes(t, setForType) {
      const set = setForType(t);
      if (set !== null) return set;
      return (0, collection_utils_1.setUnion)(...Array.from(t.getNonAttributeChildren()).map((c) => directlyReachableTypes(c, setForType)));
    }
    function directlyReachableSingleNamedType(type) {
      const definedTypes = directlyReachableTypes(type, (t) => {
        if (!(t instanceof Type_1.UnionType) && isNamedType(t) || t instanceof Type_1.UnionType && nullableFromUnion(t) === null) {
          return /* @__PURE__ */ new Set([
            t
          ]);
        }
        return null;
      });
      (0, Support_1.assert)(definedTypes.size <= 1, "Cannot have more than one defined type per top-level");
      return (0, collection_utils_1.iterableFirst)(definedTypes);
    }
    function stringTypesForType(t) {
      (0, Support_1.assert)(t.kind === "string", "Only strings can have string types");
      const stringTypes = StringTypes_1.stringTypesTypeAttributeKind.tryGetInAttributes(t.getAttributes());
      if (stringTypes === void 0) {
        return (0, Support_1.panic)("All strings must have a string type attribute");
      }
      return stringTypes;
    }
    function matchTypeExhaustive(t, noneType, anyType, nullType, boolType, integerType, doubleType, stringType, arrayType, classType, mapType, objectType, enumType, unionType, transformedStringType) {
      if (t.isPrimitive()) {
        if ((0, TransformedStringType_1.isPrimitiveStringTypeKind)(t.kind)) {
          if (t.kind === "string") {
            return stringType(t);
          }
          return transformedStringType(t);
        }
        const kind = t.kind;
        const f = {
          none: noneType,
          any: anyType,
          null: nullType,
          bool: boolType,
          integer: integerType,
          double: doubleType
        }[kind];
        if (f !== void 0) return f(t);
        return (0, Support_1.assertNever)(f);
      }
      if (t instanceof Type_1.ArrayType) return arrayType(t);
      if (t instanceof Type_1.ClassType) return classType(t);
      if (t instanceof Type_1.MapType) return mapType(t);
      if (t instanceof Type_1.ObjectType) return objectType(t);
      if (t instanceof Type_1.EnumType) return enumType(t);
      if (t instanceof Type_1.UnionType) return unionType(t);
      return (0, Support_1.panic)(`Unknown type ${t.kind}`);
    }
    function matchType(type, anyType, nullType, boolType, integerType, doubleType, stringType, arrayType, classType, mapType, enumType, unionType, transformedStringType) {
      function typeNotSupported(t) {
        return (0, Support_1.panic)(`Unsupported type ${t.kind} in non-exhaustive match`);
      }
      return matchTypeExhaustive(type, typeNotSupported, anyType, nullType, boolType, integerType, doubleType, stringType, arrayType, classType, mapType, typeNotSupported, enumType, unionType, transformedStringType !== null && transformedStringType !== void 0 ? transformedStringType : typeNotSupported);
    }
    function matchCompoundType(t, arrayType, classType, mapType, objectType, unionType) {
      function ignore(_) {
        return;
      }
      matchTypeExhaustive(t, ignore, ignore, ignore, ignore, ignore, ignore, ignore, arrayType, classType, mapType, objectType, ignore, unionType, ignore);
    }
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/GraphRewriting.js
var require_GraphRewriting = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/GraphRewriting.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.GraphRewriteBuilder = exports.GraphRemapBuilder = exports.BaseGraphRewriteBuilder = exports.TypeReconstituter = void 0;
    var collection_utils_1 = require_dist();
    var TypeAttributes_1 = require_TypeAttributes();
    var Support_1 = require_Support();
    var TypeBuilder_1 = require_TypeBuilder();
    var TypeRef_1 = require_TypeRef();
    var TypeUtils_1 = require_TypeUtils();
    var TypeReconstituter = class {
      constructor(_typeBuilder, _makeClassUnique, _typeAttributes, _forwardingRef, _register) {
        this._typeBuilder = _typeBuilder;
        this._makeClassUnique = _makeClassUnique;
        this._typeAttributes = _typeAttributes;
        this._forwardingRef = _forwardingRef;
        this._register = _register;
        this._wasUsed = false;
        this._typeRef = void 0;
      }
      builderForNewType() {
        (0, Support_1.assert)(!this._wasUsed, "TypeReconstituter used more than once");
        this._wasUsed = true;
        return this._typeBuilder;
      }
      builderForSetting() {
        (0, Support_1.assert)(this._wasUsed && this._typeRef !== void 0, "Can't set type members before constructing a type");
        return this._typeBuilder;
      }
      getResult() {
        if (this._typeRef === void 0) {
          return (0, Support_1.panic)("Type was not reconstituted");
        }
        return this._typeRef;
      }
      // FIXME: Do registration automatically.
      register(tref) {
        (0, Support_1.assert)(this._typeRef === void 0, "Cannot register a type twice");
        this._typeRef = tref;
        this._register(tref);
      }
      registerAndAddAttributes(tref) {
        this._typeBuilder.addAttributes(tref, this._typeAttributes);
        this.register(tref);
      }
      lookup(trefs) {
        (0, Support_1.assert)(!this._wasUsed, "Cannot lookup constituents after building type");
        if ((0, TypeRef_1.isTypeRef)(trefs)) {
          return this._typeBuilder.lookupTypeRefs([
            trefs
          ], void 0, false);
        }
        const maybeRefs = Array.from(trefs).map((tref) => this._typeBuilder.lookupTypeRefs([
          tref
        ], void 0, false));
        if (maybeRefs.some((tref) => tref === void 0)) {
          return void 0;
        }
        return maybeRefs;
      }
      lookupMap(trefs) {
        const resultValues = this.lookup(trefs.values());
        if (resultValues === void 0) return void 0;
        (0, Support_1.assert)(resultValues.length === trefs.size, "Didn't get back the correct number of types");
        const result = /* @__PURE__ */ new Map();
        let i2 = 0;
        for (const k of trefs.keys()) {
          result.set(k, resultValues[i2]);
          i2 += 1;
        }
        return result;
      }
      reconstitute(trefs) {
        (0, Support_1.assert)(this._wasUsed, "Cannot reconstitute constituents before building type");
        if ((0, TypeRef_1.isTypeRef)(trefs)) {
          return this._typeBuilder.reconstituteTypeRef(trefs);
        }
        return Array.from(trefs).map((tref) => this._typeBuilder.reconstituteTypeRef(tref));
      }
      reconstituteMap(trefs) {
        return (0, collection_utils_1.mapMap)(trefs, (tref) => this._typeBuilder.reconstituteTypeRef(tref));
      }
      getPrimitiveType(kind) {
        this.register(this.builderForNewType().getPrimitiveType(kind, this._typeAttributes, this._forwardingRef));
      }
      getEnumType(cases) {
        this.register(this.builderForNewType().getEnumType(this._typeAttributes, cases, this._forwardingRef));
      }
      getUniqueMapType() {
        this.registerAndAddAttributes(this.builderForNewType().getUniqueMapType(this._forwardingRef));
      }
      getMapType(values) {
        this.register(this.builderForNewType().getMapType(this._typeAttributes, values, this._forwardingRef));
      }
      getUniqueArrayType() {
        this.registerAndAddAttributes(this.builderForNewType().getUniqueArrayType(this._forwardingRef));
      }
      getArrayType(items) {
        this.register(this.builderForNewType().getArrayType(this._typeAttributes, items, this._forwardingRef));
      }
      setArrayItems(items) {
        this.builderForSetting().setArrayItems(this.getResult(), items);
      }
      makeClassProperty(tref, isOptional) {
        return this._typeBuilder.makeClassProperty(tref, isOptional);
      }
      getObjectType(properties, additionalProperties) {
        this.register(this.builderForNewType().getUniqueObjectType(this._typeAttributes, properties, additionalProperties, this._forwardingRef));
      }
      getUniqueObjectType(properties, additionalProperties) {
        this.register(this.builderForNewType().getUniqueObjectType(this._typeAttributes, properties, additionalProperties, this._forwardingRef));
      }
      getClassType(properties) {
        if (this._makeClassUnique) {
          this.getUniqueClassType(false, properties);
          return;
        }
        this.register(this.builderForNewType().getClassType(this._typeAttributes, properties, this._forwardingRef));
      }
      getUniqueClassType(isFixed, properties) {
        this.register(this.builderForNewType().getUniqueClassType(this._typeAttributes, isFixed, properties, this._forwardingRef));
      }
      setObjectProperties(properties, additionalProperties) {
        this.builderForSetting().setObjectProperties(this.getResult(), properties, additionalProperties);
      }
      getUnionType(members) {
        this.register(this.builderForNewType().getUnionType(this._typeAttributes, members, this._forwardingRef));
      }
      getUniqueUnionType() {
        this.register(this.builderForNewType().getUniqueUnionType(this._typeAttributes, void 0, this._forwardingRef));
      }
      getIntersectionType(members) {
        this.register(this.builderForNewType().getIntersectionType(this._typeAttributes, members, this._forwardingRef));
      }
      getUniqueIntersectionType(members) {
        this.register(this.builderForNewType().getUniqueIntersectionType(this._typeAttributes, members, this._forwardingRef));
      }
      setSetOperationMembers(members) {
        this.builderForSetting().setSetOperationMembers(this.getResult(), members);
      }
    };
    exports.TypeReconstituter = TypeReconstituter;
    var BaseGraphRewriteBuilder = class extends TypeBuilder_1.TypeBuilder {
      constructor(originalGraph, stringTypeMapping, alphabetizeProperties, graphHasProvenanceAttributes, debugPrint) {
        super(stringTypeMapping, alphabetizeProperties, false, false, graphHasProvenanceAttributes);
        this.originalGraph = originalGraph;
        this.debugPrint = debugPrint;
        this.reconstitutedTypes = /* @__PURE__ */ new Map();
        this._lostTypeAttributes = false;
        this._printIndent = 0;
      }
      withForwardingRef(maybeForwardingRef, typeCreator) {
        if (maybeForwardingRef !== void 0) {
          return typeCreator(maybeForwardingRef);
        }
        const forwardingRef = this.reserveTypeRef();
        const actualRef = typeCreator(forwardingRef);
        (0, Support_1.assert)(actualRef === forwardingRef, "Type creator didn't return its forwarding ref");
        return actualRef;
      }
      reconstituteType(t, attributes, forwardingRef) {
        return this.reconstituteTypeRef(t.typeRef, attributes, forwardingRef);
      }
      reconstituteTypeRef(originalRef, attributes, maybeForwardingRef) {
        const maybeRef = this.lookupTypeRefs([
          originalRef
        ], maybeForwardingRef);
        if (maybeRef !== void 0) {
          if (attributes !== void 0) {
            this.addAttributes(maybeRef, attributes);
          }
          return maybeRef;
        }
        return this.forceReconstituteTypeRef(originalRef, attributes, maybeForwardingRef);
      }
      reconstituteTypeAttributes(attributes) {
        return (0, collection_utils_1.mapMap)(attributes, (v, a) => a.reconstitute(this, v));
      }
      assertTypeRefsToReconstitute(typeRefs, forwardingRef) {
        (0, Support_1.assert)(typeRefs.length > 0, "Must have at least one type to reconstitute");
        for (const originalRef of typeRefs) {
          (0, TypeRef_1.assertTypeRefGraph)(originalRef, this.originalGraph);
        }
        if (forwardingRef !== void 0) {
          (0, TypeRef_1.assertTypeRefGraph)(forwardingRef, this.typeGraph);
        }
      }
      changeDebugPrintIndent(delta) {
        this._printIndent += delta;
      }
      get debugPrintIndentation() {
        return (0, Support_1.indentationString)(this._printIndent);
      }
      finish() {
        for (const [name, t] of this.originalGraph.topLevels) {
          this.addTopLevel(name, this.reconstituteType(t));
        }
        return super.finish();
      }
      setLostTypeAttributes() {
        this._lostTypeAttributes = true;
      }
      get lostTypeAttributes() {
        return this._lostTypeAttributes;
      }
    };
    exports.BaseGraphRewriteBuilder = BaseGraphRewriteBuilder;
    var GraphRemapBuilder = class extends BaseGraphRewriteBuilder {
      constructor(originalGraph, stringTypeMapping, alphabetizeProperties, graphHasProvenanceAttributes, _map, debugPrintRemapping) {
        super(originalGraph, stringTypeMapping, alphabetizeProperties, graphHasProvenanceAttributes, debugPrintRemapping);
        this._map = _map;
        this._attributeSources = /* @__PURE__ */ new Map();
        for (const [source, target] of _map) {
          let maybeSources = this._attributeSources.get(target);
          if (maybeSources === void 0) {
            maybeSources = [
              target
            ];
            this._attributeSources.set(target, maybeSources);
          }
          maybeSources.push(source);
        }
      }
      makeIdentity(_maker) {
        return void 0;
      }
      getMapTarget(tref) {
        const maybeType = this._map.get((0, TypeRef_1.derefTypeRef)(tref, this.originalGraph));
        if (maybeType === void 0) return tref;
        (0, Support_1.assert)(this._map.get(maybeType) === void 0, "We have a type that's remapped to a remapped type");
        return maybeType.typeRef;
      }
      addForwardingIntersection(_forwardingRef, _tref) {
        return (0, Support_1.panic)("We can't add forwarding intersections when we're removing forwarding intersections");
      }
      lookupTypeRefs(typeRefs, forwardingRef) {
        (0, Support_1.assert)(forwardingRef === void 0, "We can't have a forwarding ref when we remap");
        this.assertTypeRefsToReconstitute(typeRefs, forwardingRef);
        const first = this.reconstitutedTypes.get((0, TypeRef_1.typeRefIndex)(this.getMapTarget(typeRefs[0])));
        if (first === void 0) return void 0;
        for (let i2 = 1; i2 < typeRefs.length; i2++) {
          const other = this.reconstitutedTypes.get((0, TypeRef_1.typeRefIndex)(this.getMapTarget(typeRefs[i2])));
          if (first !== other) return void 0;
        }
        return first;
      }
      forceReconstituteTypeRef(originalRef, attributes, maybeForwardingRef) {
        originalRef = this.getMapTarget(originalRef);
        const index = (0, TypeRef_1.typeRefIndex)(originalRef);
        (0, Support_1.assert)(this.reconstitutedTypes.get(index) === void 0, "Type has already been reconstituted");
        (0, Support_1.assert)(maybeForwardingRef === void 0, "We can't have a forwarding ref when we remap");
        return this.withForwardingRef(void 0, (forwardingRef) => {
          this.reconstitutedTypes.set(index, forwardingRef);
          if (this.debugPrint) {
            console.log(`${this.debugPrintIndentation}reconstituting ${index} as ${(0, TypeRef_1.typeRefIndex)(forwardingRef)}`);
            this.changeDebugPrintIndent(1);
          }
          const [originalType, originalAttributes] = (0, TypeRef_1.typeAndAttributesForTypeRef)(originalRef, this.originalGraph);
          const attributeSources = this._attributeSources.get(originalType);
          if (attributes === void 0) {
            attributes = TypeAttributes_1.emptyTypeAttributes;
          }
          if (attributeSources === void 0) {
            attributes = (0, TypeAttributes_1.combineTypeAttributes)("union", attributes, this.reconstituteTypeAttributes(originalAttributes));
          } else {
            attributes = (0, TypeAttributes_1.combineTypeAttributes)("union", attributes, this.reconstituteTypeAttributes((0, TypeUtils_1.combineTypeAttributesOfTypes)("union", attributeSources)));
          }
          const newAttributes = attributes;
          const reconstituter = new TypeReconstituter(this, this.canonicalOrder, newAttributes, forwardingRef, (tref) => {
            (0, Support_1.assert)(tref === forwardingRef, "Reconstituted type as a different ref");
            if (this.debugPrint) {
              this.changeDebugPrintIndent(-1);
              console.log(`${this.debugPrintIndentation}reconstituted ${index} as ${(0, TypeRef_1.typeRefIndex)(tref)}`);
            }
          });
          originalType.reconstitute(reconstituter, this.canonicalOrder);
          return reconstituter.getResult();
        });
      }
    };
    exports.GraphRemapBuilder = GraphRemapBuilder;
    var GraphRewriteBuilder = class extends BaseGraphRewriteBuilder {
      constructor(originalGraph, stringTypeMapping, alphabetizeProperties, graphHasProvenanceAttributes, setsToReplace, debugPrintReconstitution, _replacer) {
        super(originalGraph, stringTypeMapping, alphabetizeProperties, graphHasProvenanceAttributes, debugPrintReconstitution);
        this._replacer = _replacer;
        this._reconstitutedUnions = new collection_utils_1.EqualityMap();
        this._setsToReplaceByMember = /* @__PURE__ */ new Map();
        for (const types of setsToReplace) {
          const set = new Set(types);
          for (const t of set) {
            const index = t.index;
            (0, Support_1.assert)(!this._setsToReplaceByMember.has(index), "A type is member of more than one set to be replaced");
            this._setsToReplaceByMember.set(index, set);
          }
        }
      }
      registerUnion(typeRefs, reconstituted) {
        const set = new Set(typeRefs);
        (0, Support_1.assert)(!this._reconstitutedUnions.has(set), "Cannot register reconstituted set twice");
        this._reconstitutedUnions.set(set, reconstituted);
      }
      replaceSet(typesToReplace, maybeForwardingRef) {
        return this.withForwardingRef(maybeForwardingRef, (forwardingRef) => {
          if (this.debugPrint) {
            console.log(`${this.debugPrintIndentation}replacing set ${Array.from(typesToReplace).map((t) => t.index.toString()).join(",")} as ${(0, TypeRef_1.typeRefIndex)(forwardingRef)}`);
            this.changeDebugPrintIndent(1);
          }
          for (const t of typesToReplace) {
            const originalRef = t.typeRef;
            const index = (0, TypeRef_1.typeRefIndex)(originalRef);
            this.reconstitutedTypes.set(index, forwardingRef);
            this._setsToReplaceByMember.delete(index);
          }
          const result = this._replacer(typesToReplace, this, forwardingRef);
          (0, Support_1.assert)(result === forwardingRef, "The forwarding ref got lost when replacing");
          if (this.debugPrint) {
            this.changeDebugPrintIndent(-1);
            console.log(`${this.debugPrintIndentation}replaced set ${Array.from(typesToReplace).map((t) => t.index.toString()).join(",")} as ${(0, TypeRef_1.typeRefIndex)(forwardingRef)}`);
          }
          return result;
        });
      }
      forceReconstituteTypeRef(originalRef, attributes, maybeForwardingRef) {
        const [originalType, originalAttributes] = (0, TypeRef_1.typeAndAttributesForTypeRef)(originalRef, this.originalGraph);
        const index = (0, TypeRef_1.typeRefIndex)(originalRef);
        if (this.debugPrint) {
          console.log(`${this.debugPrintIndentation}reconstituting ${index}`);
          this.changeDebugPrintIndent(1);
        }
        if (attributes === void 0) {
          attributes = this.reconstituteTypeAttributes(originalAttributes);
        } else {
          attributes = (0, TypeAttributes_1.combineTypeAttributes)("union", attributes, this.reconstituteTypeAttributes(originalAttributes));
        }
        const reconstituter = new TypeReconstituter(this, this.canonicalOrder, attributes, maybeForwardingRef, (tref) => {
          if (this.debugPrint) {
            this.changeDebugPrintIndent(-1);
            console.log(`${this.debugPrintIndentation}reconstituted ${index} as ${(0, TypeRef_1.typeRefIndex)(tref)}`);
          }
          if (maybeForwardingRef !== void 0) {
            (0, Support_1.assert)(tref === maybeForwardingRef, "We didn't pass the forwarding ref");
          }
          const alreadyReconstitutedType = this.reconstitutedTypes.get(index);
          if (alreadyReconstitutedType === void 0) {
            this.reconstitutedTypes.set(index, tref);
          } else {
            (0, Support_1.assert)(tref === alreadyReconstitutedType, "We reconstituted a type twice differently");
          }
        });
        originalType.reconstitute(reconstituter, this.canonicalOrder);
        return reconstituter.getResult();
      }
      /*
         public reconstituteTypeUnmodified(originalType: Type): TypeRef {
            const reconstituter = new TypeReconstituter(
                this,
                this.alphabetizeProperties,
                emptyTypeAttributes,
                undefined,
                () => {}
            );
            originalType.reconstitute(reconstituter);
            return reconstituter.getResult();
        }
        */
      // If the union of these type refs have been, or are supposed to be, reconstituted to
      // one target type, return it.  Otherwise return undefined.
      lookupTypeRefs(typeRefs, forwardingRef, replaceSet = true) {
        this.assertTypeRefsToReconstitute(typeRefs, forwardingRef);
        let maybeRef = this.reconstitutedTypes.get((0, TypeRef_1.typeRefIndex)(typeRefs[0]));
        if (maybeRef !== void 0 && maybeRef !== forwardingRef) {
          let allEqual = true;
          for (let i2 = 1; i2 < typeRefs.length; i2++) {
            if (this.reconstitutedTypes.get((0, TypeRef_1.typeRefIndex)(typeRefs[i2])) !== maybeRef) {
              allEqual = false;
              break;
            }
          }
          if (allEqual) {
            return this.forwardIfNecessary(forwardingRef, maybeRef);
          }
        }
        maybeRef = this._reconstitutedUnions.get(new Set(typeRefs));
        if (maybeRef !== void 0 && maybeRef !== forwardingRef) {
          return this.forwardIfNecessary(forwardingRef, maybeRef);
        }
        const maybeSet = this._setsToReplaceByMember.get((0, TypeRef_1.typeRefIndex)(typeRefs[0]));
        if (maybeSet === void 0) {
          return void 0;
        }
        for (let i2 = 1; i2 < typeRefs.length; i2++) {
          if (this._setsToReplaceByMember.get((0, TypeRef_1.typeRefIndex)(typeRefs[i2])) !== maybeSet) {
            return void 0;
          }
        }
        if (!replaceSet) return void 0;
        return this.replaceSet(maybeSet, forwardingRef);
      }
    };
    exports.GraphRewriteBuilder = GraphRewriteBuilder;
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/Type/TypeGraphUtils.js
var require_TypeGraphUtils = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/Type/TypeGraphUtils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.noneToAny = noneToAny;
    exports.optionalToNullable = optionalToNullable;
    exports.removeIndirectionIntersections = removeIndirectionIntersections;
    var collection_utils_1 = require_dist();
    var TypeNames_1 = require_TypeNames();
    var Support_1 = require_Support();
    var Type_1 = require_Type();
    var TypeUtils_1 = require_TypeUtils();
    function noneToAny(graph, stringTypeMapping, debugPrintReconstitution) {
      const noneTypes = (0, collection_utils_1.setFilter)(graph.allTypesUnordered(), (t) => t.kind === "none");
      if (noneTypes.size === 0) {
        return graph;
      }
      (0, Support_1.assert)(noneTypes.size === 1, "Cannot have more than one none type");
      return graph.rewrite("none to any", stringTypeMapping, false, [
        Array.from(noneTypes)
      ], debugPrintReconstitution, (types, builder, forwardingRef) => {
        const attributes = (0, TypeUtils_1.combineTypeAttributesOfTypes)("union", types);
        const tref = builder.getPrimitiveType("any", attributes, forwardingRef);
        return tref;
      });
    }
    function optionalToNullable(graph, stringTypeMapping, debugPrintReconstitution) {
      function rewriteClass(c, builder, forwardingRef) {
        const properties = (0, collection_utils_1.mapMap)(c.getProperties(), (p, name) => {
          const t = p.type;
          let ref;
          if (!p.isOptional || t.isNullable) {
            ref = builder.reconstituteType(t);
          } else {
            const nullType = builder.getPrimitiveType("null");
            let members;
            if (t instanceof Type_1.UnionType) {
              members = (0, collection_utils_1.setMap)(t.members, (m) => builder.reconstituteType(m)).add(nullType);
            } else {
              members = /* @__PURE__ */ new Set([
                builder.reconstituteType(t),
                nullType
              ]);
            }
            const attributes = TypeNames_1.namesTypeAttributeKind.setDefaultInAttributes(t.getAttributes(), () => TypeNames_1.TypeNames.make(/* @__PURE__ */ new Set([
              name
            ]), /* @__PURE__ */ new Set(), true));
            ref = builder.getUnionType(attributes, members);
          }
          return builder.makeClassProperty(ref, p.isOptional);
        });
        if (c.isFixed) {
          return builder.getUniqueClassType(c.getAttributes(), true, properties, forwardingRef);
        } else {
          return builder.getClassType(c.getAttributes(), properties, forwardingRef);
        }
      }
      const classesWithOptional = (0, collection_utils_1.setFilter)(graph.allTypesUnordered(), (t) => t instanceof Type_1.ClassType && (0, collection_utils_1.mapSome)(t.getProperties(), (p) => p.isOptional));
      const replacementGroups = Array.from(classesWithOptional).map((c) => [
        c
      ]);
      if (classesWithOptional.size === 0) {
        return graph;
      }
      return graph.rewrite("optional to nullable", stringTypeMapping, false, replacementGroups, debugPrintReconstitution, (setOfClass, builder, forwardingRef) => {
        (0, Support_1.assert)(setOfClass.size === 1);
        const c = (0, Support_1.defined)((0, collection_utils_1.iterableFirst)(setOfClass));
        return rewriteClass(c, builder, forwardingRef);
      });
    }
    function removeIndirectionIntersections(graph, stringTypeMapping, debugPrintRemapping) {
      const map = [];
      for (const t of graph.allTypesUnordered()) {
        if (!(t instanceof Type_1.IntersectionType)) continue;
        const seen = /* @__PURE__ */ new Set([
          t
        ]);
        let current = t;
        while (current.members.size === 1) {
          const member = (0, Support_1.defined)((0, collection_utils_1.iterableFirst)(current.members));
          if (!(member instanceof Type_1.IntersectionType)) {
            map.push([
              t,
              member
            ]);
            break;
          }
          if (seen.has(member)) {
            return (0, Support_1.panic)("There's a cycle of intersection types");
          }
          seen.add(member);
          current = member;
        }
      }
      return graph.remap("remove indirection intersections", stringTypeMapping, false, new Map(map), debugPrintRemapping);
    }
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/Type/TypeGraph.js
var require_TypeGraph = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/Type/TypeGraph.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.TypeGraph = exports.TypeAttributeStoreView = exports.TypeAttributeStore = void 0;
    var collection_utils_1 = require_dist();
    var TypeAttributes_1 = require_TypeAttributes();
    var Graph_1 = require_Graph();
    var GraphRewriting_1 = require_GraphRewriting();
    var Messages_1 = require_Messages();
    var Support_1 = require_Support();
    var ProvenanceTypeAttributeKind_1 = require_ProvenanceTypeAttributeKind();
    var TypeBuilderUtils_1 = require_TypeBuilderUtils();
    var TypeGraphUtils_1 = require_TypeGraphUtils();
    var TypeRef_1 = require_TypeRef();
    var TypeUtils_1 = require_TypeUtils();
    var TypeAttributeStore = class {
      constructor(_typeGraph, _values) {
        this._typeGraph = _typeGraph;
        this._values = _values;
        this._topLevelValues = /* @__PURE__ */ new Map();
      }
      getTypeIndex(t) {
        const tref = t.typeRef;
        (0, TypeRef_1.assertTypeRefGraph)(tref, this._typeGraph);
        return (0, TypeRef_1.typeRefIndex)(tref);
      }
      attributesForType(t) {
        const index = this.getTypeIndex(t);
        const maybeAttributes = this._values[index];
        if (maybeAttributes !== void 0) {
          return maybeAttributes;
        }
        return TypeAttributes_1.emptyTypeAttributes;
      }
      attributesForTopLevel(name) {
        const maybeAttributes = this._topLevelValues.get(name);
        if (maybeAttributes !== void 0) {
          return maybeAttributes;
        }
        return TypeAttributes_1.emptyTypeAttributes;
      }
      setInMap(attributes, kind, value) {
        return new Map(attributes).set(kind, value);
      }
      set(kind, t, value) {
        const index = this.getTypeIndex(t);
        while (index >= this._values.length) {
          this._values.push(void 0);
        }
        this._values[index] = this.setInMap(this.attributesForType(t), kind, value);
      }
      setForTopLevel(kind, topLevelName, value) {
        this._topLevelValues.set(topLevelName, this.setInMap(this.attributesForTopLevel(topLevelName), kind, value));
      }
      tryGetInMap(attributes, kind) {
        return attributes.get(kind);
      }
      tryGet(kind, t) {
        return this.tryGetInMap(this.attributesForType(t), kind);
      }
      tryGetForTopLevel(kind, topLevelName) {
        return this.tryGetInMap(this.attributesForTopLevel(topLevelName), kind);
      }
    };
    exports.TypeAttributeStore = TypeAttributeStore;
    var TypeAttributeStoreView = class {
      constructor(_attributeStore, _definition) {
        this._attributeStore = _attributeStore;
        this._definition = _definition;
      }
      set(t, value) {
        this._attributeStore.set(this._definition, t, value);
      }
      setForTopLevel(name, value) {
        this._attributeStore.setForTopLevel(this._definition, name, value);
      }
      tryGet(t) {
        return this._attributeStore.tryGet(this._definition, t);
      }
      get(t) {
        return (0, Support_1.defined)(this.tryGet(t));
      }
      tryGetForTopLevel(name) {
        return this._attributeStore.tryGetForTopLevel(this._definition, name);
      }
      getForTopLevel(name) {
        return (0, Support_1.defined)(this.tryGetForTopLevel(name));
      }
    };
    exports.TypeAttributeStoreView = TypeAttributeStoreView;
    var TypeGraph = class _TypeGraph {
      constructor(typeBuilder, serial, _haveProvenanceAttributes) {
        this.serial = serial;
        this._haveProvenanceAttributes = _haveProvenanceAttributes;
        this._attributeStore = void 0;
        this._topLevels = /* @__PURE__ */ new Map();
        this._parents = void 0;
        this._printOnRewrite = false;
        this._typeBuilder = typeBuilder;
      }
      get isFrozen() {
        return this._typeBuilder === void 0;
      }
      get attributeStore() {
        return (0, Support_1.defined)(this._attributeStore);
      }
      freeze(topLevels, types, typeAttributes) {
        (0, Support_1.assert)(!this.isFrozen, "Tried to freeze TypeGraph a second time");
        for (const t of types) {
          (0, TypeRef_1.assertTypeRefGraph)(t.typeRef, this);
        }
        this._attributeStore = new TypeAttributeStore(this, typeAttributes);
        this._types = types;
        this._typeBuilder = void 0;
        this._topLevels = (0, collection_utils_1.mapMap)(topLevels, (tref) => (0, TypeRef_1.derefTypeRef)(tref, this));
      }
      get topLevels() {
        (0, Support_1.assert)(this.isFrozen, "Cannot get top-levels from a non-frozen graph");
        return this._topLevels;
      }
      typeAtIndex(index) {
        if (this._typeBuilder !== void 0) {
          return this._typeBuilder.typeAtIndex(index);
        }
        return (0, Support_1.defined)(this._types)[index];
      }
      atIndex(index) {
        if (this._typeBuilder !== void 0) {
          return this._typeBuilder.atIndex(index);
        }
        const t = this.typeAtIndex(index);
        return [
          t,
          (0, Support_1.defined)(this._attributeStore).attributesForType(t)
        ];
      }
      filterTypes(predicate) {
        const seen = /* @__PURE__ */ new Set();
        const types = [];
        function addFromType(t) {
          if (seen.has(t)) {
            return;
          }
          seen.add(t);
          const required = predicate === void 0 || predicate(t);
          if (required) {
            types.push(t);
          }
          for (const c of t.getChildren()) {
            addFromType(c);
          }
        }
        for (const [, t] of this.topLevels) {
          addFromType(t);
        }
        return new Set(types);
      }
      allNamedTypes() {
        return this.filterTypes(TypeUtils_1.isNamedType);
      }
      allNamedTypesSeparated() {
        const types = this.allNamedTypes();
        return (0, TypeUtils_1.separateNamedTypes)(types);
      }
      allProvenance() {
        (0, Support_1.assert)(this._haveProvenanceAttributes);
        const view = new TypeAttributeStoreView(this.attributeStore, ProvenanceTypeAttributeKind_1.provenanceTypeAttributeKind);
        const sets = Array.from(this.allTypesUnordered()).map((t) => {
          const maybeSet = view.tryGet(t);
          if (maybeSet !== void 0) return maybeSet;
          return /* @__PURE__ */ new Set();
        });
        const result = /* @__PURE__ */ new Set();
        (0, collection_utils_1.setUnionManyInto)(result, sets);
        return result;
      }
      setPrintOnRewrite() {
        this._printOnRewrite = true;
      }
      checkLostTypeAttributes(builder, newGraph) {
        if (!this._haveProvenanceAttributes || builder.lostTypeAttributes) {
          return;
        }
        const oldProvenance = this.allProvenance();
        const newProvenance = newGraph.allProvenance();
        if (oldProvenance.size !== newProvenance.size) {
          const difference = (0, collection_utils_1.setSubtract)(oldProvenance, newProvenance);
          const indexes = Array.from(difference);
          (0, Messages_1.messageError)("IRTypeAttributesNotPropagated", {
            count: difference.size,
            indexes
          });
        }
      }
      printRewrite(title) {
        if (!this._printOnRewrite) {
          return;
        }
        console.log(`
# ${title}`);
      }
      // Each array in `replacementGroups` is a bunch of types to be replaced by a
      // single new type.  `replacer` is a function that takes a group and a
      // TypeBuilder, and builds a new type with that builder that replaces the group.
      // That particular TypeBuilder will have to take as inputs types in the old
      // graph, but return types in the new graph.  Recursive types must be handled
      // carefully.
      rewrite(title, stringTypeMapping, alphabetizeProperties, replacementGroups, debugPrintReconstitution, replacer, force = false) {
        this.printRewrite(title);
        if (!force && replacementGroups.length === 0) {
          return this;
        }
        const builder = new GraphRewriting_1.GraphRewriteBuilder(this, stringTypeMapping, alphabetizeProperties, this._haveProvenanceAttributes, replacementGroups, debugPrintReconstitution, replacer);
        builder.typeGraph = new _TypeGraph(builder, this.serial + 1, this._haveProvenanceAttributes);
        const newGraph = builder.finish();
        this.checkLostTypeAttributes(builder, newGraph);
        if (this._printOnRewrite) {
          newGraph.setPrintOnRewrite();
          newGraph.printGraph();
        }
        if (!builder.didAddForwardingIntersection) {
          return newGraph;
        }
        return (0, TypeGraphUtils_1.removeIndirectionIntersections)(newGraph, stringTypeMapping, debugPrintReconstitution);
      }
      remap(title, stringTypeMapping, alphabetizeProperties, map, debugPrintRemapping, force = false) {
        this.printRewrite(title);
        if (!force && map.size === 0) {
          return this;
        }
        const builder = new GraphRewriting_1.GraphRemapBuilder(this, stringTypeMapping, alphabetizeProperties, this._haveProvenanceAttributes, map, debugPrintRemapping);
        builder.typeGraph = new _TypeGraph(builder, this.serial + 1, this._haveProvenanceAttributes);
        const newGraph = builder.finish();
        this.checkLostTypeAttributes(builder, newGraph);
        if (this._printOnRewrite) {
          newGraph.setPrintOnRewrite();
          newGraph.printGraph();
        }
        (0, Support_1.assert)(!builder.didAddForwardingIntersection);
        return newGraph;
      }
      garbageCollect(alphabetizeProperties, debugPrintReconstitution) {
        const newGraph = this.remap("GC", (0, TypeBuilderUtils_1.getNoStringTypeMapping)(), alphabetizeProperties, /* @__PURE__ */ new Map(), debugPrintReconstitution, true);
        return newGraph;
      }
      rewriteFixedPoint(alphabetizeProperties, debugPrintReconstitution) {
        let graph = this;
        for (; ; ) {
          const newGraph = this.rewrite("fixed-point", (0, TypeBuilderUtils_1.getNoStringTypeMapping)(), alphabetizeProperties, [], debugPrintReconstitution, Support_1.mustNotHappen, true);
          if (graph.allTypesUnordered().size === newGraph.allTypesUnordered().size) {
            return graph;
          }
          graph = newGraph;
        }
      }
      allTypesUnordered() {
        (0, Support_1.assert)(this.isFrozen, "Tried to get all graph types before it was frozen");
        return new Set((0, Support_1.defined)(this._types));
      }
      makeGraph(invertDirection, childrenOfType) {
        return new Graph_1.Graph((0, Support_1.defined)(this._types), invertDirection, childrenOfType);
      }
      getParentsOfType(t) {
        (0, TypeRef_1.assertTypeRefGraph)(t.typeRef, this);
        if (this._parents === void 0) {
          const parents = (0, Support_1.defined)(this._types).map((_) => /* @__PURE__ */ new Set());
          for (const p of this.allTypesUnordered()) {
            for (const c of p.getChildren()) {
              const index = c.index;
              parents[index] = parents[index].add(p);
            }
          }
          this._parents = parents;
        }
        return this._parents[t.index];
      }
      printGraph() {
        const types = (0, Support_1.defined)(this._types);
        for (let i2 = 0; i2 < types.length; i2++) {
          const t = types[i2];
          const parts = [];
          parts.push(`${t.debugPrintKind}${t.hasNames ? ` ${t.getCombinedName()}` : ""}`);
          const children = t.getChildren();
          if (children.size > 0) {
            parts.push(`children ${Array.from(children).map((c) => c.index).join(",")}`);
          }
          for (const [kind, value] of t.getAttributes()) {
            const maybeString = kind.stringify(value);
            if (maybeString !== void 0) {
              parts.push(maybeString);
            }
          }
          console.log(`${i2}: ${parts.join(" | ")}`);
        }
      }
    };
    exports.TypeGraph = TypeGraph;
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/Type/index.js
var require_Type2 = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/Type/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
          enumerable: true,
          get: function() {
            return m[k];
          }
        };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    __exportStar(require_Type(), exports);
    __exportStar(require_TypeBuilder(), exports);
    __exportStar(require_TypeGraph(), exports);
    __exportStar(require_TypeUtils(), exports);
    __exportStar(require_TransformedStringType(), exports);
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/Transformers.js
var require_Transformers = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/Transformers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.transformationTypeAttributeKind = exports.Transformation = exports.MinMaxValueTransformer = exports.MinMaxLengthCheckTransformer = exports.StringifyTransformer = exports.ParseStringTransformer = exports.StringProducerTransformer = exports.UnionInstantiationTransformer = exports.StringMatchTransformer = exports.UnionMemberMatchTransformer = exports.DecodingChoiceTransformer = exports.ChoiceTransformer = exports.ArrayEncodingTransformer = exports.ArrayDecodingTransformer = exports.EncodingTransformer = exports.DecodingTransformer = exports.MatchTransformer = exports.ProducerTransformer = exports.Transformer = void 0;
    exports.transformationForType = transformationForType;
    exports.followTargetType = followTargetType;
    var collection_utils_1 = require_dist();
    var TypeAttributes_1 = require_TypeAttributes();
    var Support_1 = require_Support();
    var Type_1 = require_Type2();
    var TypeRef_1 = require_TypeRef();
    function debugStringForType(t) {
      const target = followTargetType(t);
      if (t === target) {
        return t.kind;
      }
      return `${t.kind} (${target.kind})`;
    }
    function getNumberOfNodes(xfer) {
      return (0, collection_utils_1.definedMapWithDefault)(xfer, 0, (x) => x.getNumberOfNodes());
    }
    var Transformer = class {
      constructor(kind, graph, sourceTypeRef) {
        this.kind = kind;
        this.graph = graph;
        this.sourceTypeRef = sourceTypeRef;
      }
      get sourceType() {
        return (0, TypeRef_1.derefTypeRef)(this.sourceTypeRef, this.graph);
      }
      /** This must return a newly constructed set. */
      getChildren() {
        return /* @__PURE__ */ new Set([
          this.sourceType
        ]);
      }
      getNumberOfNodes() {
        return 1;
      }
      equals(other) {
        return this.sourceTypeRef === other.sourceTypeRef;
      }
      hashCode() {
        return (0, collection_utils_1.hashCodeOf)(this.sourceTypeRef);
      }
      debugDescription() {
        return `${debugStringForType(this.sourceType)} -> ${this.kind}`;
      }
      debugPrintContinuations(_indent) {
        return;
      }
      debugPrint(indent) {
        console.log((0, Support_1.indentationString)(indent) + this.debugDescription());
        this.debugPrintContinuations(indent + 1);
      }
    };
    exports.Transformer = Transformer;
    var ProducerTransformer = class _ProducerTransformer extends Transformer {
      constructor(kind, graph, sourceTypeRef, consumer) {
        super(kind, graph, sourceTypeRef);
        this.consumer = consumer;
      }
      getChildren() {
        const children = super.getChildren();
        if (this.consumer === void 0) return children;
        return (0, collection_utils_1.setUnionInto)(children, this.consumer.getChildren());
      }
      getNumberOfNodes() {
        return super.getNumberOfNodes() + getNumberOfNodes(this.consumer);
      }
      equals(other) {
        if (!super.equals(other)) return false;
        if (!(other instanceof _ProducerTransformer)) return false;
        return (0, collection_utils_1.areEqual)(this.consumer, other.consumer);
      }
      hashCode() {
        const h = super.hashCode();
        return (0, collection_utils_1.addHashCode)(h, (0, collection_utils_1.hashCodeOf)(this.consumer));
      }
      debugPrintContinuations(indent) {
        if (this.consumer === void 0) return;
        this.consumer.debugPrint(indent);
      }
    };
    exports.ProducerTransformer = ProducerTransformer;
    var MatchTransformer = class _MatchTransformer extends Transformer {
      constructor(kind, graph, sourceTypeRef, transformer) {
        super(kind, graph, sourceTypeRef);
        this.transformer = transformer;
      }
      getChildren() {
        return (0, collection_utils_1.setUnionInto)(super.getChildren(), this.transformer.getChildren());
      }
      getNumberOfNodes() {
        return super.getNumberOfNodes() + this.transformer.getNumberOfNodes();
      }
      equals(other) {
        if (!super.equals(other)) return false;
        if (!(other instanceof _MatchTransformer)) return false;
        return this.transformer.equals(other.transformer);
      }
      hashCode() {
        const h = super.hashCode();
        return (0, collection_utils_1.addHashCode)(h, this.transformer.hashCode());
      }
      debugPrintContinuations(indent) {
        this.transformer.debugPrint(indent);
      }
    };
    exports.MatchTransformer = MatchTransformer;
    var DecodingTransformer = class _DecodingTransformer extends ProducerTransformer {
      constructor(graph, sourceTypeRef, consumer) {
        super("decode", graph, sourceTypeRef, consumer);
      }
      get canFail() {
        return false;
      }
      reverse(targetTypeRef, continuationTransformer) {
        if (continuationTransformer !== void 0) {
          return (0, Support_1.panic)("Reversing a decoding transformer cannot have a continuation");
        }
        if (this.consumer === void 0) {
          return new EncodingTransformer(this.graph, targetTypeRef);
        }
        return this.consumer.reverse(targetTypeRef, new EncodingTransformer(this.graph, this.consumer.sourceTypeRef));
      }
      reconstitute(builder) {
        return new _DecodingTransformer(builder.typeGraph, builder.reconstituteTypeRef(this.sourceTypeRef), (0, collection_utils_1.definedMap)(this.consumer, (xfer) => xfer.reconstitute(builder)));
      }
      equals(other) {
        if (!super.equals(other)) return false;
        return other instanceof _DecodingTransformer;
      }
    };
    exports.DecodingTransformer = DecodingTransformer;
    var EncodingTransformer = class _EncodingTransformer extends Transformer {
      constructor(graph, sourceTypeRef) {
        super("encode", graph, sourceTypeRef);
      }
      get canFail() {
        return false;
      }
      reverse(_targetTypeRef, _continuationTransformer) {
        return (0, Support_1.panic)("Can't reverse encoding transformer");
      }
      reconstitute(builder) {
        return new _EncodingTransformer(builder.typeGraph, builder.reconstituteTypeRef(this.sourceTypeRef));
      }
      equals(other) {
        if (!super.equals(other)) return false;
        if (!(other instanceof _EncodingTransformer)) return false;
        return true;
      }
    };
    exports.EncodingTransformer = EncodingTransformer;
    var ArrayDecodingTransformer = class _ArrayDecodingTransformer extends ProducerTransformer {
      constructor(graph, sourceTypeRef, consumer, _itemTargetTypeRef, itemTransformer) {
        super("decode-array", graph, sourceTypeRef, consumer);
        this._itemTargetTypeRef = _itemTargetTypeRef;
        this.itemTransformer = itemTransformer;
      }
      getChildren() {
        const children = super.getChildren();
        children.add(this.itemTargetType);
        return (0, collection_utils_1.setUnionInto)(children, this.itemTransformer.getChildren());
      }
      getNumberOfNodes() {
        return super.getNumberOfNodes() + this.itemTransformer.getNumberOfNodes();
      }
      get canFail() {
        return false;
      }
      get itemTargetType() {
        return (0, TypeRef_1.derefTypeRef)(this._itemTargetTypeRef, this.graph);
      }
      reverse(targetTypeRef, continuationTransformer) {
        if (continuationTransformer !== void 0) {
          return (0, Support_1.panic)("Reversing a decoding transformer cannot have a continuation");
        }
        const itemTransformer = this.itemTransformer.reverse(this._itemTargetTypeRef, void 0);
        if (this.consumer === void 0) {
          return new ArrayEncodingTransformer(this.graph, targetTypeRef, this.itemTransformer.sourceTypeRef, itemTransformer);
        }
        return this.consumer.reverse(targetTypeRef, new ArrayEncodingTransformer(this.graph, this.consumer.sourceTypeRef, this.itemTransformer.sourceTypeRef, itemTransformer));
      }
      reconstitute(builder) {
        return new _ArrayDecodingTransformer(builder.typeGraph, builder.reconstituteTypeRef(this.sourceTypeRef), (0, collection_utils_1.definedMap)(this.consumer, (xfer) => xfer.reconstitute(builder)), builder.reconstituteTypeRef(this._itemTargetTypeRef), this.itemTransformer.reconstitute(builder));
      }
      hashCode() {
        let h = super.hashCode();
        h = (0, collection_utils_1.addHashCode)(h, (0, collection_utils_1.hashCodeOf)(this._itemTargetTypeRef));
        h = (0, collection_utils_1.addHashCode)(h, this.itemTransformer.hashCode());
        return h;
      }
      equals(other) {
        if (!super.equals(other)) return false;
        if (!(other instanceof _ArrayDecodingTransformer)) return false;
        if (!(0, collection_utils_1.areEqual)(this._itemTargetTypeRef, other._itemTargetTypeRef)) return false;
        return this.itemTransformer.equals(other.itemTransformer);
      }
      debugPrintContinuations(indent) {
        this.itemTransformer.debugPrint(indent);
        super.debugPrintContinuations(indent);
      }
    };
    exports.ArrayDecodingTransformer = ArrayDecodingTransformer;
    var ArrayEncodingTransformer = class _ArrayEncodingTransformer extends Transformer {
      constructor(graph, sourceTypeRef, _itemTargetTypeRef, itemTransformer) {
        super("encode-array", graph, sourceTypeRef);
        this._itemTargetTypeRef = _itemTargetTypeRef;
        this.itemTransformer = itemTransformer;
      }
      getChildren() {
        const children = super.getChildren();
        children.add(this.itemTargetType);
        return (0, collection_utils_1.setUnionInto)(children, this.itemTransformer.getChildren());
      }
      getNumberOfNodes() {
        return super.getNumberOfNodes() + this.itemTransformer.getNumberOfNodes();
      }
      get canFail() {
        return false;
      }
      get itemTargetType() {
        return (0, TypeRef_1.derefTypeRef)(this._itemTargetTypeRef, this.graph);
      }
      reverse(_targetTypeRef, _continuationTransformer) {
        return (0, Support_1.panic)("Can't reverse array encoding transformer");
      }
      reconstitute(builder) {
        return new _ArrayEncodingTransformer(builder.typeGraph, builder.reconstituteTypeRef(this.sourceTypeRef), builder.reconstituteTypeRef(this._itemTargetTypeRef), this.itemTransformer.reconstitute(builder));
      }
      hashCode() {
        let h = super.hashCode();
        h = (0, collection_utils_1.addHashCode)(h, (0, collection_utils_1.hashCodeOf)(this._itemTargetTypeRef));
        return (0, collection_utils_1.addHashCode)(h, this.itemTransformer.hashCode());
      }
      equals(other) {
        if (!super.equals(other)) return false;
        if (!(other instanceof _ArrayEncodingTransformer)) return false;
        if (!(0, collection_utils_1.areEqual)(this._itemTargetTypeRef, other._itemTargetTypeRef)) return false;
        return this.itemTransformer.equals(other.itemTransformer);
      }
      debugPrintContinuations(indent) {
        this.itemTransformer.debugPrint(indent);
        super.debugPrintContinuations(indent);
      }
    };
    exports.ArrayEncodingTransformer = ArrayEncodingTransformer;
    var ChoiceTransformer = class _ChoiceTransformer extends Transformer {
      constructor(graph, sourceTypeRef, transformers) {
        super("choice", graph, sourceTypeRef);
        this.transformers = transformers;
        (0, Support_1.assert)(transformers.length > 0, "Choice must have at least one transformer");
      }
      getChildren() {
        const children = super.getChildren();
        for (const xfer of this.transformers) {
          (0, collection_utils_1.setUnionInto)(children, xfer.getChildren());
        }
        return children;
      }
      getNumberOfNodes() {
        let n = 0;
        for (const xfer of this.transformers) {
          n += xfer.getNumberOfNodes();
        }
        return super.getNumberOfNodes() + n;
      }
      get canFail() {
        return this.transformers.some((xfer) => xfer.canFail);
      }
      reverse(targetTypeRef, continuationTransformer) {
        const transformers = this.transformers.map((xfer) => xfer.reverse(targetTypeRef, continuationTransformer));
        if (transformers.every((xfer) => xfer instanceof UnionMemberMatchTransformer)) {
          const memberMatchers = transformers;
          const first = memberMatchers[0];
          if (memberMatchers.every((xfer) => first.memberType.equals(xfer.memberType))) {
            const subTransformers = memberMatchers.map((xfer) => xfer.transformer);
            return new UnionMemberMatchTransformer(this.graph, targetTypeRef, new _ChoiceTransformer(this.graph, subTransformers[0].sourceTypeRef, subTransformers), first.memberTypeRef);
          }
        }
        return new _ChoiceTransformer(this.graph, targetTypeRef, transformers);
      }
      reconstitute(builder) {
        return new _ChoiceTransformer(builder.typeGraph, builder.reconstituteTypeRef(this.sourceTypeRef), this.transformers.map((xfer) => xfer.reconstitute(builder)));
      }
      equals(other) {
        if (!super.equals(other)) return false;
        if (!(other instanceof _ChoiceTransformer)) return false;
        return (0, collection_utils_1.areEqual)(this.transformers, other.transformers);
      }
      hashCode() {
        const h = super.hashCode();
        return (0, collection_utils_1.addHashCode)(h, (0, collection_utils_1.hashCodeOf)(this.transformers));
      }
      debugPrintContinuations(indent) {
        for (const xfer of this.transformers) {
          xfer.debugPrint(indent);
        }
      }
    };
    exports.ChoiceTransformer = ChoiceTransformer;
    var DecodingChoiceTransformer = class _DecodingChoiceTransformer extends Transformer {
      constructor(graph, sourceTypeRef, nullTransformer, integerTransformer, doubleTransformer, boolTransformer, stringTransformer, arrayTransformer, objectTransformer) {
        super("decoding-choice", graph, sourceTypeRef);
        this.nullTransformer = nullTransformer;
        this.integerTransformer = integerTransformer;
        this.doubleTransformer = doubleTransformer;
        this.boolTransformer = boolTransformer;
        this.stringTransformer = stringTransformer;
        this.arrayTransformer = arrayTransformer;
        this.objectTransformer = objectTransformer;
      }
      get transformers() {
        const transformers = [];
        function add(xfer) {
          if (xfer === void 0) return;
          transformers.push(xfer);
        }
        add(this.nullTransformer);
        add(this.integerTransformer);
        add(this.doubleTransformer);
        add(this.boolTransformer);
        add(this.stringTransformer);
        add(this.arrayTransformer);
        add(this.objectTransformer);
        return transformers;
      }
      getChildren() {
        const children = super.getChildren();
        for (const xfer of this.transformers) {
          (0, collection_utils_1.setUnionInto)(children, xfer.getChildren());
        }
        return children;
      }
      getNumberOfNodes() {
        let n = super.getNumberOfNodes();
        for (const xfer of this.transformers) {
          n += getNumberOfNodes(xfer);
        }
        return n;
      }
      get canFail() {
        return false;
      }
      reverse(targetTypeRef, continuationTransformer) {
        (0, Support_1.assert)(continuationTransformer === void 0, "Reversing a decoding transformer can't have a target transformer");
        const transformers = /* @__PURE__ */ new Map();
        const memberMatchTransformers = /* @__PURE__ */ new Map();
        function addCase(reversed) {
          if (reversed instanceof UnionMemberMatchTransformer) {
            const memberType = reversed.memberType;
            let arr = memberMatchTransformers.get(memberType);
            if (arr === void 0) {
              arr = [];
              memberMatchTransformers.set(memberType, arr);
            }
            arr.push(reversed);
          } else {
            const kind = reversed.sourceType.kind;
            let arr = transformers.get(kind);
            if (arr === void 0) {
              arr = [];
              transformers.set(kind, arr);
            }
            arr.push(reversed);
          }
        }
        function reverseAndAdd(transformer) {
          const reversed = transformer.reverse(targetTypeRef, void 0);
          let cases = [];
          if (reversed instanceof ChoiceTransformer) {
            cases = reversed.transformers;
          } else {
            cases = [
              reversed
            ];
          }
          for (const xfer of cases) {
            addCase(xfer);
          }
        }
        function filter(xfers) {
          (0, Support_1.assert)(xfers.length > 0, "Must have at least one transformer");
          const nonfailing = xfers.filter((xfer) => {
            if (xfer instanceof UnionMemberMatchTransformer) {
              return !xfer.transformer.canFail;
            }
            return !xfer.canFail;
          });
          if (nonfailing.length === 0) return xfers;
          const smallest = (0, collection_utils_1.arraySortByInto)(nonfailing.map((x) => [
            x.getNumberOfNodes(),
            x
          ]), ([c, _]) => c)[0][1];
          return [
            smallest
          ];
        }
        this.transformers.forEach(reverseAndAdd);
        const allTransformers = Array.from(transformers.values()).concat(Array.from(memberMatchTransformers.values()));
        const resultingTransformers = [].concat(...allTransformers.map(filter));
        if (resultingTransformers.length === 1) {
          return resultingTransformers[0];
        }
        return new ChoiceTransformer(this.graph, targetTypeRef, resultingTransformers);
      }
      reconstitute(builder) {
        function reconstitute(xf) {
          if (xf === void 0) return void 0;
          return xf.reconstitute(builder);
        }
        return new _DecodingChoiceTransformer(builder.typeGraph, builder.reconstituteTypeRef(this.sourceTypeRef), reconstitute(this.nullTransformer), reconstitute(this.integerTransformer), reconstitute(this.doubleTransformer), reconstitute(this.boolTransformer), reconstitute(this.stringTransformer), reconstitute(this.arrayTransformer), reconstitute(this.objectTransformer));
      }
      equals(other) {
        if (!super.equals(other)) return false;
        if (!(other instanceof _DecodingChoiceTransformer)) return false;
        if (!(0, collection_utils_1.areEqual)(this.nullTransformer, other.nullTransformer)) return false;
        if (!(0, collection_utils_1.areEqual)(this.integerTransformer, other.integerTransformer)) return false;
        if (!(0, collection_utils_1.areEqual)(this.doubleTransformer, other.doubleTransformer)) return false;
        if (!(0, collection_utils_1.areEqual)(this.boolTransformer, other.boolTransformer)) return false;
        if (!(0, collection_utils_1.areEqual)(this.stringTransformer, other.stringTransformer)) return false;
        if (!(0, collection_utils_1.areEqual)(this.arrayTransformer, other.arrayTransformer)) return false;
        if (!(0, collection_utils_1.areEqual)(this.objectTransformer, other.objectTransformer)) return false;
        return true;
      }
      hashCode() {
        let h = super.hashCode();
        h = (0, collection_utils_1.addHashCode)(h, (0, collection_utils_1.hashCodeOf)(this.nullTransformer));
        h = (0, collection_utils_1.addHashCode)(h, (0, collection_utils_1.hashCodeOf)(this.integerTransformer));
        h = (0, collection_utils_1.addHashCode)(h, (0, collection_utils_1.hashCodeOf)(this.doubleTransformer));
        h = (0, collection_utils_1.addHashCode)(h, (0, collection_utils_1.hashCodeOf)(this.boolTransformer));
        h = (0, collection_utils_1.addHashCode)(h, (0, collection_utils_1.hashCodeOf)(this.stringTransformer));
        h = (0, collection_utils_1.addHashCode)(h, (0, collection_utils_1.hashCodeOf)(this.arrayTransformer));
        h = (0, collection_utils_1.addHashCode)(h, (0, collection_utils_1.hashCodeOf)(this.objectTransformer));
        return h;
      }
      debugPrintContinuations(indent) {
        for (const xfer of this.transformers) {
          xfer.debugPrint(indent);
        }
      }
    };
    exports.DecodingChoiceTransformer = DecodingChoiceTransformer;
    var UnionMemberMatchTransformer = class _UnionMemberMatchTransformer extends MatchTransformer {
      constructor(graph, sourceTypeRef, transformer, memberTypeRef) {
        super("union-member-match", graph, sourceTypeRef, transformer);
        this.memberTypeRef = memberTypeRef;
      }
      get sourceType() {
        const t = (0, TypeRef_1.derefTypeRef)(this.sourceTypeRef, this.graph);
        if (!(t instanceof Type_1.UnionType)) {
          return (0, Support_1.panic)("The source of a union member match transformer must be a union type");
        }
        return t;
      }
      get canFail() {
        return true;
      }
      get memberType() {
        return (0, TypeRef_1.derefTypeRef)(this.memberTypeRef, this.graph);
      }
      getChildren() {
        return super.getChildren().add(this.memberType);
      }
      reverse(_targetTypeRef, _continuationTransformer) {
        return (0, Support_1.panic)("Can't reverse union member match transformer");
      }
      reconstitute(builder) {
        return new _UnionMemberMatchTransformer(builder.typeGraph, builder.reconstituteTypeRef(this.sourceTypeRef), this.transformer.reconstitute(builder), builder.reconstituteTypeRef(this.memberTypeRef));
      }
      equals(other) {
        if (!super.equals(other)) return false;
        if (!(other instanceof _UnionMemberMatchTransformer)) return false;
        return this.memberTypeRef === other.memberTypeRef;
      }
      hashCode() {
        const h = super.hashCode();
        return (0, collection_utils_1.addHashCode)(h, (0, collection_utils_1.hashCodeOf)(this.memberTypeRef));
      }
      debugDescription() {
        return `${super.debugDescription()} - member: ${debugStringForType(this.memberType)}`;
      }
    };
    exports.UnionMemberMatchTransformer = UnionMemberMatchTransformer;
    var StringMatchTransformer = class _StringMatchTransformer extends MatchTransformer {
      constructor(graph, sourceTypeRef, transformer, stringCase) {
        super("string-match", graph, sourceTypeRef, transformer);
        this.stringCase = stringCase;
      }
      get sourceType() {
        const t = (0, TypeRef_1.derefTypeRef)(this.sourceTypeRef, this.graph);
        if (!(t instanceof Type_1.EnumType) && !(t instanceof Type_1.PrimitiveType && t.kind === "string")) {
          return (0, Support_1.panic)("The source of a string match transformer must be an enum or string type");
        }
        return t;
      }
      get canFail() {
        return true;
      }
      reverse(targetTypeRef, continuationTransformer) {
        return this.transformer.reverse(targetTypeRef, new StringProducerTransformer(this.graph, this.transformer.sourceTypeRef, continuationTransformer, this.stringCase));
      }
      reconstitute(builder) {
        return new _StringMatchTransformer(builder.typeGraph, builder.reconstituteTypeRef(this.sourceTypeRef), this.transformer.reconstitute(builder), this.stringCase);
      }
      equals(other) {
        if (!super.equals(other)) return false;
        if (!(other instanceof _StringMatchTransformer)) return false;
        return this.stringCase !== other.stringCase;
      }
      hashCode() {
        const h = super.hashCode();
        return (0, collection_utils_1.addHashCode)(h, (0, collection_utils_1.hashString)(this.stringCase));
      }
      debugDescription() {
        return `${super.debugDescription()} - case: ${this.stringCase}`;
      }
    };
    exports.StringMatchTransformer = StringMatchTransformer;
    var UnionInstantiationTransformer = class _UnionInstantiationTransformer extends Transformer {
      constructor(graph, sourceTypeRef) {
        super("union-instantiation", graph, sourceTypeRef);
      }
      get canFail() {
        return false;
      }
      reverse(targetTypeRef, continuationTransformer) {
        if (continuationTransformer === void 0) {
          return (0, Support_1.panic)("Union instantiation transformer reverse must have a continuation");
        }
        return new UnionMemberMatchTransformer(this.graph, targetTypeRef, continuationTransformer, this.sourceTypeRef);
      }
      reconstitute(builder) {
        return new _UnionInstantiationTransformer(builder.typeGraph, builder.reconstituteTypeRef(this.sourceTypeRef));
      }
      equals(other) {
        if (!super.equals(other)) return false;
        return other instanceof _UnionInstantiationTransformer;
      }
    };
    exports.UnionInstantiationTransformer = UnionInstantiationTransformer;
    var StringProducerTransformer = class _StringProducerTransformer extends ProducerTransformer {
      constructor(graph, sourceTypeRef, consumer, result) {
        super("string-producer", graph, sourceTypeRef, consumer);
        this.result = result;
      }
      get canFail() {
        return false;
      }
      reverse(targetTypeRef, continuationTransformer) {
        if (continuationTransformer === void 0) {
          return (0, Support_1.panic)("Reversing a string producer transformer must have a continuation");
        }
        if (this.consumer === void 0) {
          return new StringMatchTransformer(this.graph, targetTypeRef, continuationTransformer, this.result);
        }
        return this.consumer.reverse(targetTypeRef, new StringMatchTransformer(this.graph, this.consumer.sourceTypeRef, continuationTransformer, this.result));
      }
      reconstitute(builder) {
        return new _StringProducerTransformer(builder.typeGraph, builder.reconstituteTypeRef(this.sourceTypeRef), (0, collection_utils_1.definedMap)(this.consumer, (xfer) => xfer.reconstitute(builder)), this.result);
      }
      equals(other) {
        if (!super.equals(other)) return false;
        if (!(other instanceof _StringProducerTransformer)) return false;
        return this.result === other.result;
      }
      hashCode() {
        const h = super.hashCode();
        return (0, collection_utils_1.addHashCode)(h, (0, collection_utils_1.hashCodeOf)(this.consumer));
      }
      debugDescription() {
        return `${super.debugDescription()} - result: ${this.result}`;
      }
    };
    exports.StringProducerTransformer = StringProducerTransformer;
    var ParseStringTransformer = class _ParseStringTransformer extends ProducerTransformer {
      constructor(graph, sourceTypeRef, consumer) {
        super("parse-string", graph, sourceTypeRef, consumer);
      }
      get canFail() {
        return true;
      }
      reverse(targetTypeRef, continuationTransformer) {
        if (this.consumer === void 0) {
          return new StringifyTransformer(this.graph, targetTypeRef, continuationTransformer);
        }
        return this.consumer.reverse(targetTypeRef, new StringifyTransformer(this.graph, this.consumer.sourceTypeRef, continuationTransformer));
      }
      reconstitute(builder) {
        return new _ParseStringTransformer(builder.typeGraph, builder.reconstituteTypeRef(this.sourceTypeRef), (0, collection_utils_1.definedMap)(this.consumer, (xfer) => xfer.reconstitute(builder)));
      }
      equals(other) {
        if (!super.equals(other)) return false;
        return other instanceof _ParseStringTransformer;
      }
    };
    exports.ParseStringTransformer = ParseStringTransformer;
    var StringifyTransformer = class _StringifyTransformer extends ProducerTransformer {
      constructor(graph, sourceTypeRef, consumer) {
        super("stringify", graph, sourceTypeRef, consumer);
      }
      get canFail() {
        return false;
      }
      reverse(targetTypeRef, continuationTransformer) {
        if (this.consumer === void 0) {
          return new ParseStringTransformer(this.graph, targetTypeRef, continuationTransformer);
        }
        return this.consumer.reverse(targetTypeRef, new ParseStringTransformer(this.graph, this.consumer.sourceTypeRef, continuationTransformer));
      }
      reconstitute(builder) {
        return new _StringifyTransformer(builder.typeGraph, builder.reconstituteTypeRef(this.sourceTypeRef), (0, collection_utils_1.definedMap)(this.consumer, (xfer) => xfer.reconstitute(builder)));
      }
      equals(other) {
        if (!super.equals(other)) return false;
        return other instanceof _StringifyTransformer;
      }
    };
    exports.StringifyTransformer = StringifyTransformer;
    var MinMaxLengthCheckTransformer = class _MinMaxLengthCheckTransformer extends ProducerTransformer {
      constructor(graph, sourceTypeRef, consumer, minLength, maxLength) {
        super("min-max-length-check", graph, sourceTypeRef, consumer);
        this.minLength = minLength;
        this.maxLength = maxLength;
      }
      get canFail() {
        return true;
      }
      reverse(targetTypeRef, continuationTransformer) {
        if (this.consumer === void 0) {
          return new _MinMaxLengthCheckTransformer(this.graph, targetTypeRef, continuationTransformer, this.minLength, this.maxLength);
        }
        return this.consumer.reverse(targetTypeRef, new _MinMaxLengthCheckTransformer(this.graph, this.consumer.sourceTypeRef, continuationTransformer, this.minLength, this.maxLength));
      }
      reconstitute(builder) {
        return new _MinMaxLengthCheckTransformer(builder.typeGraph, builder.reconstituteTypeRef(this.sourceTypeRef), (0, collection_utils_1.definedMap)(this.consumer, (xfer) => xfer.reconstitute(builder)), this.minLength, this.maxLength);
      }
      equals(other) {
        if (!super.equals(other)) return false;
        return other instanceof _MinMaxLengthCheckTransformer && this.minLength === other.minLength && this.maxLength === other.maxLength;
      }
    };
    exports.MinMaxLengthCheckTransformer = MinMaxLengthCheckTransformer;
    var MinMaxValueTransformer = class _MinMaxValueTransformer extends ProducerTransformer {
      constructor(graph, sourceTypeRef, consumer, minimum, maximum) {
        super("min-max-value-check", graph, sourceTypeRef, consumer);
        this.minimum = minimum;
        this.maximum = maximum;
      }
      get canFail() {
        return true;
      }
      reverse(targetTypeRef, continuationTransformer) {
        if (this.consumer === void 0) {
          return new _MinMaxValueTransformer(this.graph, targetTypeRef, continuationTransformer, this.minimum, this.maximum);
        }
        return this.consumer.reverse(targetTypeRef, new _MinMaxValueTransformer(this.graph, this.consumer.sourceTypeRef, continuationTransformer, this.minimum, this.maximum));
      }
      reconstitute(builder) {
        return new _MinMaxValueTransformer(builder.typeGraph, builder.reconstituteTypeRef(this.sourceTypeRef), (0, collection_utils_1.definedMap)(this.consumer, (xfer) => xfer.reconstitute(builder)), this.minimum, this.maximum);
      }
      equals(other) {
        if (!super.equals(other)) return false;
        return other instanceof _MinMaxValueTransformer && this.minimum === other.minimum && this.maximum === other.maximum;
      }
    };
    exports.MinMaxValueTransformer = MinMaxValueTransformer;
    var Transformation = class _Transformation {
      constructor(_graph, _targetTypeRef, transformer) {
        this._graph = _graph;
        this._targetTypeRef = _targetTypeRef;
        this.transformer = transformer;
      }
      get sourceType() {
        return this.transformer.sourceType;
      }
      get targetType() {
        return (0, TypeRef_1.derefTypeRef)(this._targetTypeRef, this._graph);
      }
      get reverse() {
        return new _Transformation(this._graph, this.transformer.sourceTypeRef, this.transformer.reverse(this._targetTypeRef, void 0));
      }
      getChildren() {
        return this.transformer.getChildren().add(this.targetType);
      }
      reconstitute(builder) {
        return new _Transformation(builder.typeGraph, builder.reconstituteTypeRef(this._targetTypeRef), this.transformer.reconstitute(builder));
      }
      equals(other) {
        if (!(other instanceof _Transformation)) return false;
        return this._targetTypeRef === other._targetTypeRef && this.transformer.equals(other.transformer);
      }
      hashCode() {
        let h = (0, collection_utils_1.hashCodeOf)(this._targetTypeRef);
        h = (0, collection_utils_1.addHashCode)(h, this.transformer.hashCode());
        return h;
      }
      debugPrint() {
        this.transformer.debugPrint(0);
        console.log(`-> ${debugStringForType(this.targetType)}`);
      }
    };
    exports.Transformation = Transformation;
    var TransformationTypeAttributeKind = class extends TypeAttributes_1.TypeAttributeKind {
      constructor() {
        super("transformation");
      }
      appliesToTypeKind(_kind) {
        return true;
      }
      get inIdentity() {
        return true;
      }
      children(xf) {
        return xf.getChildren();
      }
      reconstitute(builder, xf) {
        return xf.reconstitute(builder);
      }
      stringify(_) {
        return "transformation";
      }
    };
    exports.transformationTypeAttributeKind = new TransformationTypeAttributeKind();
    function transformationForType(t) {
      return exports.transformationTypeAttributeKind.tryGetInAttributes(t.getAttributes());
    }
    function followTargetType(t) {
      for (; ; ) {
        const xf = transformationForType(t);
        if (xf === void 0) {
          return t;
        }
        t = xf.targetType;
      }
    }
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/ConvenienceRenderer.js
var require_ConvenienceRenderer = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/ConvenienceRenderer.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : {
        "default": mod
      };
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.ConvenienceRenderer = exports.inferredNameOrder = exports.topLevelNameOrder = void 0;
    var collection_utils_1 = require_dist();
    var wordwrap_1 = __importDefault(require_wordwrap());
    var AccessorNames_1 = require_AccessorNames();
    var Description_1 = require_Description();
    var TypeAttributes_1 = require_TypeAttributes();
    var DeclarationIR_1 = require_DeclarationIR();
    var Naming_1 = require_Naming();
    var Renderer_1 = require_Renderer();
    var Source_1 = require_Source();
    var Comments_1 = require_Comments();
    var Strings_1 = require_Strings();
    var Support_1 = require_Support();
    var Transformers_1 = require_Transformers();
    var Type_1 = require_Type2();
    var TypeGraph_1 = require_TypeGraph();
    var TypeUtils_1 = require_TypeUtils();
    var wordWrap = (0, wordwrap_1.default)(90);
    exports.topLevelNameOrder = 1;
    var givenNameOrder = 10;
    exports.inferredNameOrder = 30;
    var classPropertyNameOrder = 20;
    var assignedClassPropertyNameOrder = 10;
    var enumCaseNameOrder = 20;
    var assignedEnumCaseNameOrder = 10;
    var unionMemberNameOrder = 40;
    function splitDescription(descriptions) {
      if (descriptions === void 0) return void 0;
      const description = Array.from(descriptions).join("\n\n").trim();
      if (description === "") return void 0;
      return wordWrap(description).split("\n").map((l) => l.trim());
    }
    var assignedNameAttributeKind = new TypeAttributes_1.TypeAttributeKind("assignedName");
    var assignedPropertyNamesAttributeKind = new TypeAttributes_1.TypeAttributeKind("assignedPropertyNames");
    var assignedMemberNamesAttributeKind = new TypeAttributes_1.TypeAttributeKind("assignedMemberNames");
    var assignedCaseNamesAttributeKind = new TypeAttributes_1.TypeAttributeKind("assignedCaseNames");
    var ConvenienceRenderer = class extends Renderer_1.Renderer {
      constructor(targetLanguage, renderContext) {
        super(targetLanguage, renderContext);
        this._alphabetizeProperties = false;
      }
      get topLevels() {
        return this.typeGraph.topLevels;
      }
      /**
         * Return an array of strings which are not allowed as names in the global
         * namespace.  Since names of generated types are in the global namespace,
         * this will include anything built into the language or default libraries
         * that can conflict with that, such as reserved keywords or common type
         * names.
         */
      forbiddenNamesForGlobalNamespace() {
        return [];
      }
      /**
         * Returns which names are forbidden for the property names of an object
         * type.  `names` can contain strings as well as `Name`s.  In some
         * languages, the class name can't be used as the name for a property, for
         * example, in which case `_className` would have to be return in `names`.
         * If `includeGlobalForbidden` is set, then all names that are forbidden
         * in the global namespace will also be forbidden for the properties.
         * Note: That doesn't mean that the names in the global namespace will be
         * forbidden, too!
         */
      forbiddenForObjectProperties(_o, _className) {
        return {
          names: [],
          includeGlobalForbidden: false
        };
      }
      forbiddenForUnionMembers(_u, _unionName) {
        return {
          names: [],
          includeGlobalForbidden: false
        };
      }
      forbiddenForEnumCases(_e, _enumName) {
        return {
          names: [],
          includeGlobalForbidden: false
        };
      }
      makeTopLevelDependencyNames(_t, _topLevelName) {
        return [];
      }
      makeNamedTypeDependencyNames(_t, _name) {
        return [];
      }
      makeNameForTransformation(_xf, _typeName) {
        return void 0;
      }
      namedTypeToNameForTopLevel(type) {
        if ((0, TypeUtils_1.isNamedType)(type)) {
          return type;
        }
        return void 0;
      }
      get unionMembersInGlobalNamespace() {
        return false;
      }
      get enumCasesInGlobalNamespace() {
        return false;
      }
      get needsTypeDeclarationBeforeUse() {
        return false;
      }
      canBeForwardDeclared(_t) {
        return (0, Support_1.panic)("If needsTypeDeclarationBeforeUse returns true, canBeForwardDeclared must be implemented");
      }
      unionNeedsName(u) {
        return (0, TypeUtils_1.nullableFromUnion)(u) === null;
      }
      get globalNamespace() {
        return (0, Support_1.defined)(this._globalNamespace);
      }
      get nameStoreView() {
        return (0, Support_1.defined)(this._nameStoreView);
      }
      descriptionForType(t) {
        const description = this.typeGraph.attributeStore.tryGet(Description_1.descriptionTypeAttributeKind, t);
        return splitDescription(description);
      }
      descriptionForClassProperty(o, name) {
        const descriptions = this.typeGraph.attributeStore.tryGet(Description_1.propertyDescriptionsTypeAttributeKind, o);
        if (descriptions === void 0) return void 0;
        return splitDescription(descriptions.get(name));
      }
      setUpNaming() {
        this._nameStoreView = new TypeGraph_1.TypeAttributeStoreView(this.typeGraph.attributeStore, assignedNameAttributeKind);
        this._propertyNamesStoreView = new TypeGraph_1.TypeAttributeStoreView(this.typeGraph.attributeStore, assignedPropertyNamesAttributeKind);
        this._memberNamesStoreView = new TypeGraph_1.TypeAttributeStoreView(this.typeGraph.attributeStore, assignedMemberNamesAttributeKind);
        this._caseNamesStoreView = new TypeGraph_1.TypeAttributeStoreView(this.typeGraph.attributeStore, assignedCaseNamesAttributeKind);
        this._namesForTransformations = /* @__PURE__ */ new Map();
        this._namedTypeNamer = this.makeNamedTypeNamer();
        this._unionMemberNamer = this.makeUnionMemberNamer();
        this._enumCaseNamer = this.makeEnumCaseNamer();
        this._globalForbiddenNamespace = (0, Naming_1.keywordNamespace)("forbidden", this.forbiddenNamesForGlobalNamespace());
        this._otherForbiddenNamespaces = /* @__PURE__ */ new Map();
        this._globalNamespace = new Naming_1.Namespace("global", void 0, [
          this._globalForbiddenNamespace
        ], []);
        const { objects, enums, unions } = this.typeGraph.allNamedTypesSeparated();
        const namedUnions = (0, collection_utils_1.setFilter)(unions, (u) => this.unionNeedsName(u));
        for (const [name, t] of this.topLevels) {
          this.nameStoreView.setForTopLevel(name, this.addNameForTopLevel(t, name));
        }
        for (const o of objects) {
          const name = this.addNameForNamedType(o);
          this.addPropertyNames(o, name);
        }
        for (const e of enums) {
          const name = this.addNameForNamedType(e);
          this.addEnumCaseNames(e, name);
        }
        for (const u of namedUnions) {
          const name = this.addNameForNamedType(u);
          this.addUnionMemberNames(u, name);
        }
        for (const t of this.typeGraph.allTypesUnordered()) {
          this.addNameForTransformation(t);
        }
        return (0, collection_utils_1.setUnion)([
          this._globalForbiddenNamespace,
          this._globalNamespace
        ], this._otherForbiddenNamespaces.values());
      }
      addDependenciesForNamedType(type, named) {
        const dependencyNames = this.makeNamedTypeDependencyNames(type, named);
        for (const dn of dependencyNames) {
          this.globalNamespace.add(dn);
        }
      }
      makeNameForTopLevel(_t, givenName, _maybeNamedType) {
        return new Naming_1.SimpleName([
          givenName
        ], (0, Support_1.defined)(this._namedTypeNamer), exports.topLevelNameOrder);
      }
      addNameForTopLevel(type, givenName) {
        const maybeNamedType = this.namedTypeToNameForTopLevel(type);
        const name = this.makeNameForTopLevel(type, givenName, maybeNamedType);
        this.globalNamespace.add(name);
        const dependencyNames = this.makeTopLevelDependencyNames(type, name);
        for (const dn of dependencyNames) {
          this.globalNamespace.add(dn);
        }
        if (maybeNamedType !== void 0) {
          this.addDependenciesForNamedType(maybeNamedType, name);
          this.nameStoreView.set(maybeNamedType, name);
        }
        return name;
      }
      makeNameForType(t, namer, givenOrder, inferredOrder) {
        const names = t.getNames();
        const order = names.areInferred ? inferredOrder : givenOrder;
        return new Naming_1.SimpleName(names.proposedNames, namer, order);
      }
      makeNameForNamedType(t) {
        return this.makeNameForType(t, (0, Support_1.defined)(this._namedTypeNamer), givenNameOrder, exports.inferredNameOrder);
      }
      addNameForNamedType(type) {
        const existing = this.nameStoreView.tryGet(type);
        if (existing !== void 0) return existing;
        const name = this.globalNamespace.add(this.makeNameForNamedType(type));
        this.addDependenciesForNamedType(type, name);
        this.nameStoreView.set(type, name);
        return name;
      }
      get typesWithNamedTransformations() {
        return (0, Support_1.defined)(this._namesForTransformations);
      }
      nameForTransformation(t) {
        const xf = (0, Transformers_1.transformationForType)(t);
        if (xf === void 0) return void 0;
        const name = (0, Support_1.defined)(this._namesForTransformations).get(t);
        if (name === void 0) {
          return (0, Support_1.panic)("No name for transformation");
        }
        return name;
      }
      addNameForTransformation(t) {
        const xf = (0, Transformers_1.transformationForType)(t);
        if (xf === void 0) return;
        (0, Support_1.assert)((0, Support_1.defined)(this._namesForTransformations).get(t) === void 0, "Tried to give two names to the same transformation");
        const name = this.makeNameForTransformation(xf, this.nameStoreView.tryGet(xf.targetType));
        if (name === void 0) return;
        this.globalNamespace.add(name);
        (0, Support_1.defined)(this._namesForTransformations).set(t, name);
      }
      processForbiddenWordsInfo(info, namespaceName) {
        const forbiddenNames = [];
        const forbiddenStrings = [];
        for (const nameOrString of info.names) {
          if (typeof nameOrString === "string") {
            forbiddenStrings.push(nameOrString);
          } else {
            forbiddenNames.push(nameOrString);
          }
        }
        let namespace = (0, Support_1.defined)(this._otherForbiddenNamespaces).get(namespaceName);
        if (forbiddenStrings.length > 0 && namespace === void 0) {
          namespace = (0, Naming_1.keywordNamespace)(namespaceName, forbiddenStrings);
          this._otherForbiddenNamespaces = (0, Support_1.defined)(this._otherForbiddenNamespaces).set(namespaceName, namespace);
        }
        let forbiddenNamespaces = /* @__PURE__ */ new Set();
        if (info.includeGlobalForbidden) {
          forbiddenNamespaces = forbiddenNamespaces.add((0, Support_1.defined)(this._globalForbiddenNamespace));
        }
        if (namespace !== void 0) {
          forbiddenNamespaces = forbiddenNamespaces.add(namespace);
        }
        return {
          forbiddenNames: new Set(forbiddenNames),
          forbiddenNamespaces
        };
      }
      makeNameForProperty(o, _className, p, jsonName, assignedName) {
        const namer = this.namerForObjectProperty(o, p);
        if (namer === null) return void 0;
        const alternative = `${o.getCombinedName()}_${jsonName}`;
        const order = assignedName === void 0 ? classPropertyNameOrder : assignedClassPropertyNameOrder;
        const names = assignedName === void 0 ? [
          jsonName,
          alternative
        ] : [
          assignedName
        ];
        return new Naming_1.SimpleName(names, namer, order);
      }
      makePropertyDependencyNames(_o, _className, _p, _jsonName, _name) {
        return [];
      }
      addPropertyNames(o, className) {
        const { forbiddenNames, forbiddenNamespaces } = this.processForbiddenWordsInfo(this.forbiddenForObjectProperties(o, className), "forbidden-for-properties");
        let ns;
        const accessorNames = (0, AccessorNames_1.objectPropertyNames)(o, this.targetLanguage.name);
        const names = (0, collection_utils_1.mapFilterMap)(o.getSortedProperties(), (p, jsonName) => {
          const [assignedName, isFixed] = (0, AccessorNames_1.getAccessorName)(accessorNames, jsonName);
          let name;
          if (isFixed) {
            name = new Naming_1.FixedName((0, Support_1.defined)(assignedName));
          } else {
            name = this.makeNameForProperty(o, className, p, jsonName, assignedName);
          }
          if (name === void 0) return void 0;
          if (ns === void 0) {
            ns = new Naming_1.Namespace(o.getCombinedName(), this.globalNamespace, forbiddenNamespaces, forbiddenNames);
          }
          ns.add(name);
          for (const depName of this.makePropertyDependencyNames(o, className, p, jsonName, name)) {
            ns.add(depName);
          }
          return name;
        });
        (0, Support_1.defined)(this._propertyNamesStoreView).set(o, names);
      }
      makeNameForUnionMember(u, unionName, t) {
        const [assignedName, isFixed] = (0, AccessorNames_1.unionMemberName)(u, t, this.targetLanguage.name);
        if (isFixed) {
          return new Naming_1.FixedName((0, Support_1.defined)(assignedName));
        }
        return new Naming_1.DependencyName((0, Support_1.nonNull)(this._unionMemberNamer), unionMemberNameOrder, (lookup) => {
          if (assignedName !== void 0) return assignedName;
          return this.proposeUnionMemberName(u, unionName, t, lookup);
        });
      }
      addUnionMemberNames(u, unionName) {
        const memberNamer = this._unionMemberNamer;
        if (memberNamer === null) return;
        const { forbiddenNames, forbiddenNamespaces } = this.processForbiddenWordsInfo(this.forbiddenForUnionMembers(u, unionName), "forbidden-for-union-members");
        let ns;
        if (this.unionMembersInGlobalNamespace) {
          ns = this.globalNamespace;
        } else {
          ns = new Naming_1.Namespace(u.getCombinedName(), this.globalNamespace, forbiddenNamespaces, forbiddenNames);
        }
        const names = /* @__PURE__ */ new Map();
        for (const t of u.members) {
          const name = this.makeNameForUnionMember(u, unionName, (0, Transformers_1.followTargetType)(t));
          names.set(t, ns.add(name));
        }
        (0, Support_1.defined)(this._memberNamesStoreView).set(u, names);
      }
      makeNameForEnumCase(e, _enumName, caseName, assignedName) {
        const alternative = `${e.getCombinedName()}_${caseName}`;
        const order = assignedName === void 0 ? enumCaseNameOrder : assignedEnumCaseNameOrder;
        const names = assignedName === void 0 ? [
          caseName,
          alternative
        ] : [
          assignedName
        ];
        return new Naming_1.SimpleName(names, (0, Support_1.nonNull)(this._enumCaseNamer), order);
      }
      // FIXME: this is very similar to addPropertyNameds and addUnionMemberNames
      addEnumCaseNames(e, enumName) {
        if (this._enumCaseNamer === null) return;
        const { forbiddenNames, forbiddenNamespaces } = this.processForbiddenWordsInfo(this.forbiddenForEnumCases(e, enumName), "forbidden-for-enum-cases");
        let ns;
        if (this.enumCasesInGlobalNamespace) {
          ns = this.globalNamespace;
        } else {
          ns = new Naming_1.Namespace(e.getCombinedName(), this.globalNamespace, forbiddenNamespaces, forbiddenNames);
        }
        const names = /* @__PURE__ */ new Map();
        const accessorNames = (0, AccessorNames_1.enumCaseNames)(e, this.targetLanguage.name);
        for (const caseName of e.cases) {
          const [assignedName, isFixed] = (0, AccessorNames_1.getAccessorName)(accessorNames, caseName);
          let name;
          if (isFixed) {
            name = new Naming_1.FixedName((0, Support_1.defined)(assignedName));
          } else {
            name = this.makeNameForEnumCase(e, enumName, caseName, assignedName);
          }
          names.set(caseName, ns.add(name));
        }
        (0, Support_1.defined)(this._caseNamesStoreView).set(e, names);
      }
      childrenOfType(t) {
        const names = this.names;
        if (t instanceof Type_1.ClassType) {
          const propertyNameds = (0, Support_1.defined)(this._propertyNamesStoreView).get(t);
          const filteredMap = (0, collection_utils_1.mapFilterMap)(t.getProperties(), (p, n) => {
            if (propertyNameds.get(n) === void 0) return void 0;
            return p.type;
          });
          const sortedMap = (0, collection_utils_1.mapSortBy)(filteredMap, (_, n) => (0, Support_1.defined)(names.get((0, Support_1.defined)(propertyNameds.get(n)))));
          return new Set(sortedMap.values());
        }
        return t.getChildren();
      }
      get namedUnions() {
        return (0, Support_1.defined)(this._namedUnions);
      }
      get haveNamedUnions() {
        return this.namedUnions.size > 0;
      }
      get haveNamedTypes() {
        return (0, Support_1.defined)(this._namedTypes).length > 0;
      }
      get haveUnions() {
        return (0, Support_1.defined)(this._haveUnions);
      }
      get haveMaps() {
        return (0, Support_1.defined)(this._haveMaps);
      }
      get haveOptionalProperties() {
        return (0, Support_1.defined)(this._haveOptionalProperties);
      }
      // FIXME: Inconsistently named, though technically correct.  Right now all enums are named,
      // but this should really be called `namedEnums`.
      get enums() {
        return (0, Support_1.defined)(this._namedEnums);
      }
      get haveEnums() {
        return this.enums.size > 0;
      }
      proposedUnionMemberNameForTypeKind(_kind) {
        return null;
      }
      proposeUnionMemberName(_u, _unionName, fieldType, lookup) {
        const simpleName = this.proposedUnionMemberNameForTypeKind(fieldType.kind);
        if (simpleName !== null) {
          return simpleName;
        }
        const typeNameForUnionMember = (t) => (0, TypeUtils_1.matchTypeExhaustive)(t, (_noneType) => {
          return (0, Support_1.panic)("none type should have been replaced");
        }, (_anyType) => "anything", (_nullType) => "null", (_boolType) => "bool", (_integerType) => "integer", (_doubleType) => "double", (_stringType) => "string", (arrayType) => typeNameForUnionMember(arrayType.items) + "_array", (classType) => lookup(this.nameForNamedType(classType)), (mapType) => typeNameForUnionMember(mapType.values) + "_map", (objectType) => {
          (0, Support_1.assert)(this.targetLanguage.supportsFullObjectType, "Object type should have been replaced in `replaceObjectType`");
          return lookup(this.nameForNamedType(objectType));
        }, (_enumType) => "enum", (_unionType) => "union", (transformedType) => transformedType.kind.replace("-", "_"));
        return typeNameForUnionMember(fieldType);
      }
      nameForNamedType(t) {
        return this.nameStoreView.get(t);
      }
      isForwardDeclaredType(t) {
        return (0, Support_1.defined)(this._declarationIR).forwardedTypes.has(t);
      }
      isImplicitCycleBreaker(_t) {
        return (0, Support_1.panic)("A renderer that invokes isCycleBreakerType must implement isImplicitCycleBreaker");
      }
      canBreakCycles(_t) {
        return true;
      }
      isCycleBreakerType(t) {
        if (this._cycleBreakerTypes === void 0) {
          this._cycleBreakerTypes = (0, DeclarationIR_1.cycleBreakerTypesForGraph)(this.typeGraph, (s) => this.isImplicitCycleBreaker(s), (s) => this.canBreakCycles(s));
        }
        return this._cycleBreakerTypes.has(t);
      }
      forEachTopLevel(blankLocations, f, predicate) {
        let topLevels;
        if (predicate !== void 0) {
          topLevels = (0, collection_utils_1.mapFilter)(this.topLevels, predicate);
        } else {
          topLevels = this.topLevels;
        }
        return this.forEachWithBlankLines(topLevels, blankLocations, (t, name, pos) => f(t, this.nameStoreView.getForTopLevel(name), pos));
      }
      forEachDeclaration(blankLocations, f) {
        this.forEachWithBlankLines((0, collection_utils_1.iterableEnumerate)((0, Support_1.defined)(this._declarationIR).declarations), blankLocations, (decl, _, pos) => f(decl, pos));
      }
      setAlphabetizeProperties(value) {
        this._alphabetizeProperties = value;
      }
      getAlphabetizeProperties() {
        return this._alphabetizeProperties;
      }
      // Returns the number of properties defined for the specified object type.
      propertyCount(o) {
        const propertyNames = (0, Support_1.defined)(this._propertyNamesStoreView).get(o);
        return propertyNames.size;
      }
      sortClassProperties(properties, propertyNames) {
        if (this._alphabetizeProperties) {
          return (0, collection_utils_1.mapSortBy)(properties, (_p, jsonName) => {
            const name = (0, Support_1.defined)(propertyNames.get(jsonName));
            return (0, Support_1.defined)(this.names.get(name));
          });
        }
        return properties;
      }
      forEachClassProperty(o, blankLocations, f) {
        const propertyNames = (0, Support_1.defined)(this._propertyNamesStoreView).get(o);
        const sortedProperties = this.sortClassProperties(o.getProperties(), propertyNames);
        this.forEachWithBlankLines(sortedProperties, blankLocations, (p, jsonName, pos) => {
          const name = (0, Support_1.defined)(propertyNames.get(jsonName));
          f(name, jsonName, p, pos);
        });
      }
      nameForUnionMember(u, t) {
        return (0, Support_1.defined)((0, Support_1.defined)(this._memberNamesStoreView).get(u).get(t));
      }
      nameForEnumCase(e, caseName) {
        const caseNames = (0, Support_1.defined)(this._caseNamesStoreView).get(e);
        return (0, Support_1.defined)(caseNames.get(caseName));
      }
      forEachUnionMember(u, members, blankLocations, sortOrder, f) {
        const iterateMembers = members !== null && members !== void 0 ? members : u.members;
        if (sortOrder === null) {
          sortOrder = (n) => (0, Support_1.defined)(this.names.get(n));
        }
        const memberNames = (0, collection_utils_1.mapFilter)((0, Support_1.defined)(this._memberNamesStoreView).get(u), (_, t) => iterateMembers.has(t));
        const sortedMemberNames = (0, collection_utils_1.mapSortBy)(memberNames, sortOrder);
        this.forEachWithBlankLines(sortedMemberNames, blankLocations, f);
      }
      forEachEnumCase(e, blankLocations, f) {
        const caseNames = (0, Support_1.defined)(this._caseNamesStoreView).get(e);
        const sortedCaseNames = (0, collection_utils_1.mapSortBy)(caseNames, (n) => (0, Support_1.defined)(this.names.get(n)));
        this.forEachWithBlankLines(sortedCaseNames, blankLocations, f);
      }
      forEachTransformation(blankLocations, f) {
        this.forEachWithBlankLines((0, Support_1.defined)(this._namesForTransformations), blankLocations, f);
      }
      forEachSpecificNamedType(blankLocations, types, f) {
        this.forEachWithBlankLines(types, blankLocations, (t, _, pos) => f(t, this.nameForNamedType(t), pos));
      }
      forEachObject(blankLocations, f) {
        this.forEachSpecificNamedType(blankLocations, (0, Support_1.defined)(this._namedObjects).entries(), f);
      }
      forEachEnum(blankLocations, f) {
        this.forEachSpecificNamedType(blankLocations, this.enums.entries(), f);
      }
      forEachUnion(blankLocations, f) {
        this.forEachSpecificNamedType(blankLocations, this.namedUnions.entries(), f);
      }
      forEachUniqueUnion(blankLocations, uniqueValue, f) {
        const firstUnionByValue = /* @__PURE__ */ new Map();
        for (const u of this.namedUnions) {
          const v = uniqueValue(u);
          if (!firstUnionByValue.has(v)) {
            firstUnionByValue.set(v, u);
          }
        }
        this.forEachWithBlankLines(firstUnionByValue, blankLocations, f);
      }
      forEachNamedType(blankLocations, objectFunc, enumFunc, unionFunc) {
        this.forEachWithBlankLines((0, Support_1.defined)(this._namedTypes).entries(), blankLocations, (t, _, pos) => {
          const name = this.nameForNamedType(t);
          if (t instanceof Type_1.ObjectType) {
            objectFunc(t, name, pos);
          } else if (t instanceof Type_1.EnumType) {
            enumFunc(t, name, pos);
          } else if (t instanceof Type_1.UnionType) {
            unionFunc(t, name, pos);
          } else {
            return (0, Support_1.panic)("Named type that's neither a class nor union");
          }
        });
      }
      // You should never have to use this to produce parts of your generated
      // code.  If you need to modify a Name, for example to change its casing,
      // use `modifySource`.
      sourcelikeToString(src) {
        return (0, Source_1.serializeRenderResult)((0, Source_1.sourcelikeToSource)(src), this.names, "").lines.join("\n");
      }
      get commentLineStart() {
        return "// ";
      }
      emitComments(comments) {
        comments.forEach((comment) => {
          if ((0, Comments_1.isStringComment)(comment)) {
            this.emitCommentLines([
              comment
            ]);
          } else if ("lines" in comment) {
            this.emitCommentLines(comment.lines);
          } else if ("descriptionBlock" in comment) {
            this.emitDescriptionBlock(comment.descriptionBlock);
          } else {
            this.emitCommentLines(comment.customLines, comment);
          }
          this.ensureBlankLine();
        });
      }
      emitCommentLines(lines, { lineStart = this.commentLineStart, firstLineStart = lineStart, lineEnd, beforeComment, afterComment } = {}) {
        if (beforeComment !== void 0) {
          this.emitLine(beforeComment);
        }
        let first = true;
        for (const line of lines) {
          let start = first ? firstLineStart : lineStart;
          first = false;
          if (this.sourcelikeToString(line) === "") {
            start = (0, Strings_1.trimEnd)(start);
          }
          if (lineEnd) {
            this.emitLine(start, line, lineEnd);
          } else {
            this.emitLine(start, line);
          }
        }
        if (afterComment !== void 0) {
          this.emitLine(afterComment);
        }
      }
      emitDescription(description) {
        if (description === void 0) return;
        this.emitDescriptionBlock(description);
      }
      emitDescriptionBlock(lines) {
        this.emitCommentLines(lines);
      }
      emitPropertyTable(c, makePropertyRow) {
        let table = [];
        const emitTable = () => {
          if (table.length === 0) return;
          this.emitTable(table);
          table = [];
        };
        this.forEachClassProperty(c, "none", (name, jsonName, p) => {
          const description = this.descriptionForClassProperty(c, jsonName);
          if (description !== void 0) {
            emitTable();
            this.emitDescription(description);
          }
          table.push(makePropertyRow(name, jsonName, p));
        });
        emitTable();
      }
      processGraph() {
        this._declarationIR = (0, DeclarationIR_1.declarationsForGraph)(this.typeGraph, this.needsTypeDeclarationBeforeUse ? (t) => this.canBeForwardDeclared(t) : void 0, (t) => this.childrenOfType(t), (t) => {
          if (t instanceof Type_1.UnionType) {
            return this.unionNeedsName(t);
          }
          return (0, TypeUtils_1.isNamedType)(t);
        });
        const types = this.typeGraph.allTypesUnordered();
        this._haveUnions = (0, collection_utils_1.iterableSome)(types, (t) => t instanceof Type_1.UnionType);
        this._haveMaps = (0, collection_utils_1.iterableSome)(types, (t) => t instanceof Type_1.MapType);
        const classTypes = (0, collection_utils_1.setFilter)(types, (t) => t instanceof Type_1.ClassType);
        this._haveOptionalProperties = (0, collection_utils_1.iterableSome)(classTypes, (c) => (0, collection_utils_1.mapSome)(c.getProperties(), (p) => p.isOptional));
        this._namedTypes = this._declarationIR.declarations.filter((d) => d.kind === "define").map((d) => d.type);
        const { objects, enums, unions } = (0, TypeUtils_1.separateNamedTypes)(this._namedTypes);
        this._namedObjects = new Set(objects);
        this._namedEnums = new Set(enums);
        this._namedUnions = new Set(unions);
      }
      emitSource(givenOutputFilename) {
        this.processGraph();
        this.emitSourceStructure(givenOutputFilename);
      }
      forEachType(process2) {
        const visitedTypes = /* @__PURE__ */ new Set();
        const processed = /* @__PURE__ */ new Set();
        const queue = Array.from(this.typeGraph.topLevels.values());
        function visit(t) {
          if (visitedTypes.has(t)) return;
          for (const c of t.getChildren()) {
            queue.push(c);
          }
          visitedTypes.add(t);
          processed.add(process2(t));
        }
        for (; ; ) {
          const maybeType = queue.pop();
          if (maybeType === void 0) {
            break;
          }
          visit(maybeType);
        }
        return processed;
      }
    };
    exports.ConvenienceRenderer = ConvenienceRenderer;
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/DateTime.js
var require_DateTime = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/DateTime.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.DefaultDateTimeRecognizer = void 0;
    var DATE = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
    var DAYS = [
      0,
      31,
      29,
      31,
      30,
      31,
      30,
      31,
      31,
      30,
      31,
      30,
      31
    ];
    var TIME = /^(\d\d):(\d\d):(\d\d)(\.\d+)?(z|[+-]\d\d:\d\d)?$/i;
    var DATE_TIME_SEPARATOR = /t|\s/i;
    var DefaultDateTimeRecognizer = class {
      isDate(str) {
        const matches = DATE.exec(str);
        if (matches === null) return false;
        const month = +matches[2];
        const day = +matches[3];
        return month >= 1 && month <= 12 && day >= 1 && day <= DAYS[month];
      }
      isTime(str) {
        const matches = TIME.exec(str);
        if (matches === null) return false;
        const hour = +matches[1];
        const minute = +matches[2];
        const second = +matches[3];
        return hour <= 23 && minute <= 59 && second <= 59;
      }
      isDateTime(str) {
        const dateTime = str.split(DATE_TIME_SEPARATOR);
        return dateTime.length === 2 && this.isDate(dateTime[0]) && this.isTime(dateTime[1]);
      }
    };
    exports.DefaultDateTimeRecognizer = DefaultDateTimeRecognizer;
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/TargetLanguage.js
var require_TargetLanguage = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/TargetLanguage.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.TargetLanguage = void 0;
    var collection_utils_1 = require_dist();
    var ConvenienceRenderer_1 = require_ConvenienceRenderer();
    var DateTime_1 = require_DateTime();
    var Source_1 = require_Source();
    var Support_1 = require_Support();
    var TargetLanguage = class {
      constructor({ displayName, names, extension }) {
        this.displayName = displayName;
        this.names = names;
        this.extension = extension;
      }
      get optionDefinitions() {
        return Object.values(this.getOptions()).map((o) => o.definition);
      }
      get cliOptionDefinitions() {
        let actual = [];
        let display = [];
        for (const { cliDefinitions } of Object.values(this.getOptions())) {
          actual = actual.concat(cliDefinitions.actual);
          display = display.concat(cliDefinitions.display);
        }
        return {
          actual,
          display
        };
      }
      get name() {
        return (0, Support_1.defined)(this.names[0]);
      }
      renderGraphAndSerialize(typeGraph, givenOutputFilename, alphabetizeProperties, leadingComments, rendererOptions, indentation) {
        if (indentation === void 0) {
          indentation = this.defaultIndentation;
        }
        const renderContext = {
          typeGraph,
          leadingComments
        };
        const renderer = this.makeRenderer(renderContext, rendererOptions);
        if (renderer instanceof ConvenienceRenderer_1.ConvenienceRenderer) {
          renderer.setAlphabetizeProperties(alphabetizeProperties);
        }
        const renderResult = renderer.render(givenOutputFilename);
        return (0, collection_utils_1.mapMap)(renderResult.sources, (s) => (0, Source_1.serializeRenderResult)(s, renderResult.names, (0, Support_1.defined)(indentation)));
      }
      get defaultIndentation() {
        return "    ";
      }
      get stringTypeMapping() {
        return /* @__PURE__ */ new Map();
      }
      get supportsOptionalClassProperties() {
        return false;
      }
      get supportsUnionsWithBothNumberTypes() {
        return false;
      }
      get supportsFullObjectType() {
        return false;
      }
      needsTransformerForType(_t) {
        return false;
      }
      get dateTimeRecognizer() {
        return new DateTime_1.DefaultDateTimeRecognizer();
      }
    };
    exports.TargetLanguage = TargetLanguage;
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/attributes/EnumValues.js
var require_EnumValues = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/attributes/EnumValues.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.enumValuesTypeAttributeKind = void 0;
    exports.enumCaseValues = enumCaseValues;
    exports.enumValuesAttributeProducer = enumValuesAttributeProducer;
    var collection_utils_1 = require_dist();
    var AccessorNames_1 = require_AccessorNames();
    var TypeAttributes_1 = require_TypeAttributes();
    var EnumValuesTypeAttributeKind = class extends TypeAttributes_1.TypeAttributeKind {
      constructor() {
        super("enumValues");
      }
      makeInferred(_) {
        return void 0;
      }
    };
    exports.enumValuesTypeAttributeKind = new EnumValuesTypeAttributeKind();
    function enumCaseValues(e, language) {
      const enumValues = exports.enumValuesTypeAttributeKind.tryGetInAttributes(e.getAttributes());
      if (enumValues === void 0) return (0, collection_utils_1.mapMap)(e.cases.entries(), (_) => void 0);
      return (0, collection_utils_1.mapMap)(e.cases.entries(), (c) => (0, AccessorNames_1.lookupKey)(enumValues, c, language));
    }
    function enumValuesAttributeProducer(schema, _canonicalRef, _types) {
      if (typeof schema !== "object") return void 0;
      const maybeEnumValues = schema["qt-enum-values"];
      if (maybeEnumValues === void 0) return void 0;
      return {
        forType: exports.enumValuesTypeAttributeKind.makeAttributes((0, AccessorNames_1.makeAccessorNames)(maybeEnumValues))
      };
    }
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/CJSON/constants.js
var require_constants2 = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/CJSON/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.keywords = void 0;
    exports.keywords = [
      /* C and C++ keywords */
      "alignas",
      "alignof",
      "and",
      "and_eq",
      "asm",
      "atomic_cancel",
      "atomic_commit",
      "atomic_noexcept",
      "auto",
      "bitand",
      "bitor",
      "bool",
      "break",
      "case",
      "catch",
      "char",
      "char16_t",
      "char32_t",
      "class",
      "compl",
      "concept",
      "const",
      "constexpr",
      "const_cast",
      "continue",
      "co_await",
      "co_return",
      "co_yield",
      "decltype",
      "default",
      "delete",
      "do",
      "double",
      "dynamic_cast",
      "else",
      "enum",
      "explicit",
      "export",
      "extern",
      "false",
      "float",
      "for",
      "friend",
      "goto",
      "if",
      "import",
      "inline",
      "int",
      "long",
      "module",
      "mutable",
      "namespace",
      "new",
      "noexcept",
      "not",
      "not_eq",
      "nullptr",
      "operator",
      "or",
      "or_eq",
      "private",
      "protected",
      "public",
      "register",
      "reinterpret_cast",
      "requires",
      "restrict",
      "return",
      "short",
      "signed",
      "sizeof",
      "static",
      "static_assert",
      "static_cast",
      "struct",
      "switch",
      "synchronized",
      "template",
      "this",
      "thread_local",
      "throw",
      "true",
      "try",
      "typedef",
      "typeid",
      "typename",
      "typeof",
      "union",
      "unsigned",
      "using",
      "virtual",
      "void",
      "volatile",
      "wchar_t",
      "while",
      "xor",
      "xor_eq",
      "override",
      "final",
      "transaction_safe",
      "transaction_safe_dynamic",
      "NULL",
      /* cJSON keywords */
      "Array",
      "ArrayReference",
      "Bool",
      "DoubleArray",
      "False",
      "FloatArray",
      "IntArray",
      "Object",
      "Null",
      "Number",
      "Raw",
      "String",
      "StringArray",
      "StringReference",
      "True"
    ];
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/CJSON/utils.js
var require_utils = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/CJSON/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.IncludeKind = exports.GlobalNames = exports.legalizeName = void 0;
    var Strings_1 = require_Strings();
    exports.legalizeName = (0, Strings_1.legalizeCharacters)((cp) => (0, Strings_1.isAscii)(cp) && (0, Strings_1.isLetterOrUnderscoreOrDigit)(cp));
    var GlobalNames;
    (function(GlobalNames2) {
      GlobalNames2[GlobalNames2["ClassMemberConstraints"] = 1] = "ClassMemberConstraints";
      GlobalNames2[GlobalNames2["ClassMemberConstraintException"] = 2] = "ClassMemberConstraintException";
      GlobalNames2[GlobalNames2["ValueTooLowException"] = 3] = "ValueTooLowException";
      GlobalNames2[GlobalNames2["ValueTooHighException"] = 4] = "ValueTooHighException";
      GlobalNames2[GlobalNames2["ValueTooShortException"] = 5] = "ValueTooShortException";
      GlobalNames2[GlobalNames2["ValueTooLongException"] = 6] = "ValueTooLongException";
      GlobalNames2[GlobalNames2["InvalidPatternException"] = 7] = "InvalidPatternException";
      GlobalNames2[GlobalNames2["CheckConstraint"] = 8] = "CheckConstraint";
    })(GlobalNames || (exports.GlobalNames = GlobalNames = {}));
    var IncludeKind;
    (function(IncludeKind2) {
      IncludeKind2["ForwardDeclare"] = "ForwardDeclare";
      IncludeKind2["Include"] = "Include";
    })(IncludeKind || (exports.IncludeKind = IncludeKind = {}));
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/CJSON/CJSONRenderer.js
var require_CJSONRenderer = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/CJSON/CJSONRenderer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.CJSONRenderer = void 0;
    var AccessorNames_1 = require_AccessorNames();
    var EnumValues_1 = require_EnumValues();
    var ConvenienceRenderer_1 = require_ConvenienceRenderer();
    var Naming_1 = require_Naming();
    var Strings_1 = require_Strings();
    var Support_1 = require_Support();
    var Type_1 = require_Type2();
    var TypeUtils_1 = require_TypeUtils();
    var constants_1 = require_constants2();
    var utils_1 = require_utils();
    var CJSONRenderer = class extends ConvenienceRenderer_1.ConvenienceRenderer {
      /**
         * Constructor
         * @param targetLanguage: target language
         * @param renderContext: render context
         * @param _options: renderer options
         */
      constructor(targetLanguage, renderContext, _options) {
        super(targetLanguage, renderContext);
        this._options = _options;
        this.typeIntegerSize = _options.typeIntegerSize;
        this.hashtableSize = _options.hashtableSize;
        this.typeNamingStyle = _options.typeNamingStyle;
        this.namedTypeNameStyle = (0, Strings_1.makeNameStyle)(this.typeNamingStyle, utils_1.legalizeName);
        this.enumeratorNamingStyle = _options.enumeratorNamingStyle;
        this.memberNameStyle = (0, Strings_1.makeNameStyle)(_options.memberNamingStyle, utils_1.legalizeName);
        this.forbiddenGlobalNames = [];
        this.includes = [];
        for (const type of (0, Support_1.numberEnumValues)(utils_1.GlobalNames)) {
          const genName = this.namedTypeNameStyle(utils_1.GlobalNames[type]);
          this.forbiddenGlobalNames.push(genName);
        }
      }
      /**
         * Build forbidden names for namespace
         * @return Forbidden names for namespace
         */
      forbiddenNamesForGlobalNamespace() {
        return [
          ...constants_1.keywords,
          ...this.forbiddenGlobalNames
        ];
      }
      /**
         * Build forbidden names for enums
         * @return Forbidden names for enums
         */
      forbiddenForEnumCases(_enumType, _enumName) {
        return {
          names: [],
          includeGlobalForbidden: true
        };
      }
      /**
         * Build forbidden names for unions members
         * @return Forbidden names for unions members
         */
      forbiddenForUnionMembers(_u, _unionName) {
        return {
          names: [],
          includeGlobalForbidden: true
        };
      }
      /**
         * Build forbidden names for objects
         * @return Forbidden names for objects
         */
      forbiddenForObjectProperties(_c, _className) {
        return {
          names: [],
          includeGlobalForbidden: true
        };
      }
      /**
         * Build types member names
         * @return types member namer
         */
      makeNamedTypeNamer() {
        return (0, Naming_1.funPrefixNamer)("types", this.namedTypeNameStyle);
      }
      /**
         * Build object properties member names
         * @return object properties member namer
         */
      namerForObjectProperty() {
        return (0, Naming_1.funPrefixNamer)("members", this.memberNameStyle);
      }
      /**
         * Build union member names
         * @return union member namer
         */
      makeUnionMemberNamer() {
        return (0, Naming_1.funPrefixNamer)("members", this.memberNameStyle);
      }
      /**
         * Build enum member names
         * @return enum member namer
         */
      makeEnumCaseNamer() {
        return (0, Naming_1.funPrefixNamer)("enumerators", (0, Strings_1.makeNameStyle)(this.enumeratorNamingStyle, utils_1.legalizeName));
      }
      /**
         * Override of super proposeUnionMemberName function
         * @param unionType: union type
         * @param unionName: union name
         * @param fieldType: field type
         * @param lookup: Lookup function
         * @return Proposed union member name
         */
      proposeUnionMemberName(unionType, unionName, fieldType, lookup) {
        let fieldName = super.proposeUnionMemberName(unionType, unionName, fieldType, lookup);
        if ("bool" === fieldName) {
          fieldName = "boolean";
        } else if ("double" === fieldName) {
          fieldName = "number";
        }
        return fieldName;
      }
      /**
         * Function called to emit typedef alias for a a given type
         * @param fieldType: the variable type
         * @param fieldName: name of the variable
         */
      emitTypedefAlias(fieldType, fieldName) {
        if (this._options.addTypedefAlias) {
          this.emitLine("typedef ", this.quicktypeTypeToCJSON(fieldType, false).cType, " ", fieldName, ";");
          this.ensureBlankLine();
        }
      }
      /**
         * Function called to create header file(s)
         * @param proposedFilename: source filename provided from stdin
         */
      emitSourceStructure(proposedFilename) {
        if (this._options.typeSourceStyle) {
          this.emitSingleSourceStructure(proposedFilename);
        } else {
          this.emitMultiSourceStructure();
        }
      }
      /**
         * Function called to create a single header file with types and generators
         * @param proposedFilename: source filename provided from stdin
         */
      emitSingleSourceStructure(proposedFilename) {
        this.startFile(proposedFilename);
        this.forEachDeclaration("leading-and-interposing", (decl) => {
          if (decl.kind === "forward") {
            this.emitLine("struct ", this.nameForNamedType(decl.type), ";");
          } else if (decl.kind === "define") {
            const type = decl.type;
            if (type instanceof Type_1.ClassType) {
              this.emitClassTypedef(type);
            } else if (type instanceof Type_1.EnumType) {
              this.emitEnumTypedef(type);
            } else if (type instanceof Type_1.UnionType) {
              this.emitUnionTypedef(type);
            } else {
              (0, Support_1.panic)("Cannot declare type");
            }
          } else {
            (0, Support_1.assertNever)(decl.kind);
          }
        });
        this.forEachTopLevel("leading", (type, className) => this.emitTopLevelTypedef(type, className), (type) => this.namedTypeToNameForTopLevel(type) === void 0);
        this.forEachEnum("leading-and-interposing", (enumType, _enumName) => this.emitEnumPrototypes(enumType));
        this.forEachUnion("leading-and-interposing", (unionType) => this.emitUnionPrototypes(unionType));
        this.forEachObject("leading-and-interposing", (classType, _className) => this.emitClassPrototypes(classType));
        this.forEachTopLevel("leading", (type, className) => this.emitTopLevelPrototypes(type, className), (type) => this.namedTypeToNameForTopLevel(type) === void 0);
        this.forEachEnum("leading-and-interposing", (enumType, _enumName) => this.emitEnumFunctions(enumType));
        this.forEachUnion("leading-and-interposing", (unionType) => this.emitUnionFunctions(unionType));
        this.forEachObject("leading-and-interposing", (classType, _className) => this.emitClassFunctions(classType));
        this.forEachTopLevel("leading", (type, className) => this.emitTopLevelFunctions(type, className), (type) => this.namedTypeToNameForTopLevel(type) === void 0);
        this.finishFile();
      }
      /**
         * Function called to create a multiple header files with types and generators
         */
      emitMultiSourceStructure() {
        this.forEachNamedType("leading-and-interposing", (classType, _name) => {
          this.emitClass(classType);
        }, (enumType, _name) => {
          this.emitEnum(enumType);
        }, (unionType, _name) => {
          this.emitUnion(unionType);
        });
        this.forEachTopLevel("leading", (type, className) => this.emitTopLevel(type, className, this.includes), (type) => this.namedTypeToNameForTopLevel(type) === void 0);
      }
      /**
         * Function called to create an enum header files with types and generators
         * @param enumType: enum type
         */
      emitEnum(enumType) {
        const enumName = this.nameForNamedType(enumType);
        const filename = this.sourcelikeToString(enumName).concat(".h");
        this.includes.push(filename);
        this.startFile(filename);
        this.emitIncludes(enumType, this.sourcelikeToString(filename));
        this.emitEnumTypedef(enumType);
        this.emitEnumPrototypes(enumType);
        this.emitEnumFunctions(enumType);
        this.finishFile();
      }
      /**
         * Function called to create enum typedef
         * @param enumType: enum type
         */
      emitEnumTypedef(enumType) {
        const enumName = this.nameForNamedType(enumType);
        const enumValues = (0, EnumValues_1.enumCaseValues)(enumType, this.targetLanguage.name);
        this.emitDescription(this.descriptionForType(enumType));
        this.emitBlock([
          "enum ",
          enumName
        ], () => {
          const combinedName = (0, Strings_1.allUpperWordStyle)(this.sourcelikeToString(enumName));
          this.forEachEnumCase(enumType, "none", (name, jsonName) => {
            if (enumValues !== void 0) {
              const [enumValue] = (0, AccessorNames_1.getAccessorName)(enumValues, jsonName);
              if (enumValue !== void 0) {
                this.emitLine(combinedName, "_", name, " = ", enumValue.toString(), ",");
              } else {
                this.emitLine(combinedName, "_", name, ",");
              }
            } else {
              this.emitLine(combinedName, "_", name, ",");
            }
          });
        }, "", true);
        this.ensureBlankLine();
        this.emitTypedefAlias(enumType, enumName);
      }
      /**
         * Function called to create enum prototypes
         * @param enumType: enum type
         */
      emitEnumPrototypes(enumType) {
        const enumName = this.nameForNamedType(enumType);
        this.emitLine("enum ", enumName, " cJSON_Get", enumName, "Value(", this.withConst("cJSON"), " * j);");
        this.emitLine("cJSON * cJSON_Create", enumName, "(", this.withConst([
          "enum ",
          enumName
        ]), " x);");
        this.ensureBlankLine();
      }
      /**
         * Function called to create enum functions
         * @param enumType: enum type
         */
      emitEnumFunctions(enumType) {
        const enumName = this.nameForNamedType(enumType);
        this.emitBlock([
          "enum ",
          enumName,
          " cJSON_Get",
          enumName,
          "Value(",
          this.withConst("cJSON"),
          " * j)"
        ], () => {
          this.emitLine("enum ", enumName, " x = 0;");
          this.emitBlock([
            "if (NULL != j)"
          ], () => {
            let onFirst = true;
            const combinedName = (0, Strings_1.allUpperWordStyle)(this.sourcelikeToString(enumName));
            this.forEachEnumCase(enumType, "none", (name, jsonName) => {
              this.emitLine(onFirst ? "" : "else ", 'if (!strcmp(cJSON_GetStringValue(j), "', jsonName, '")) x = ', combinedName, "_", name, ";");
              onFirst = false;
            });
          });
          this.emitLine("return x;");
        });
        this.ensureBlankLine();
        this.emitBlock([
          "cJSON * cJSON_Create",
          enumName,
          "(",
          this.withConst([
            "enum ",
            enumName
          ]),
          " x)"
        ], () => {
          this.emitLine("cJSON * j = NULL;");
          this.emitBlock([
            "switch (x)"
          ], () => {
            const combinedName = (0, Strings_1.allUpperWordStyle)(this.sourcelikeToString(enumName));
            this.forEachEnumCase(enumType, "none", (name, jsonName) => {
              this.emitLine("case ", combinedName, "_", name, ': j = cJSON_CreateString("', jsonName, '"); break;');
            });
          });
          this.emitLine("return j;");
        });
        this.ensureBlankLine();
      }
      /**
         * Function called to create a union header files with types and generators
         * @param unionType: union type
         */
      emitUnion(unionType) {
        const unionName = this.nameForNamedType(unionType);
        const filename = this.sourcelikeToString(unionName).concat(".h");
        this.includes.push(filename);
        this.startFile(filename);
        this.emitIncludes(unionType, this.sourcelikeToString(filename));
        this.emitUnionTypedef(unionType);
        this.emitUnionPrototypes(unionType);
        this.emitUnionFunctions(unionType);
        this.finishFile();
      }
      /**
         * Function called to create union typedef
         * @param unionType: union type
         */
      emitUnionTypedef(unionType) {
        const [_hasNull, nonNulls] = (0, TypeUtils_1.removeNullFromUnion)(unionType);
        const unionName = this.nameForNamedType(unionType);
        this.emitDescription(this.descriptionForType(unionType));
        this.emitBlock([
          "struct ",
          unionName
        ], () => {
          this.emitLine("int type;");
          this.emitBlock([
            "union"
          ], () => {
            for (const type of nonNulls) {
              const cJSON = this.quicktypeTypeToCJSON(type, false);
              this.emitLine(cJSON.cType, cJSON.optionalQualifier !== "" ? " " : "", cJSON.optionalQualifier, " ", this.nameForUnionMember(unionType, type), ";");
            }
          }, "value", true);
        }, "", true);
        this.ensureBlankLine();
        this.emitTypedefAlias(unionType, unionName);
      }
      /**
         * Function called to create union prototypes
         * @param unionType: union type
         */
      emitUnionPrototypes(unionType) {
        const unionName = this.nameForNamedType(unionType);
        this.emitLine("struct ", unionName, " * cJSON_Get", unionName, "Value(const cJSON * j);");
        this.emitLine("cJSON * cJSON_Create", unionName, "(", this.withConst([
          "struct ",
          unionName
        ]), " * x);");
        this.emitLine("void cJSON_Delete", unionName, "(struct ", unionName, " * x);");
        this.ensureBlankLine();
      }
      /**
         * Function called to create union functions
         * @param unionType: union type
         */
      emitUnionFunctions(unionType) {
        const [hasNull, nonNulls] = (0, TypeUtils_1.removeNullFromUnion)(unionType);
        const unionName = this.nameForNamedType(unionType);
        this.emitBlock([
          "struct ",
          unionName,
          " * cJSON_Get",
          unionName,
          "Value(const cJSON * j)"
        ], () => {
          let onFirst = true;
          this.emitLine("struct ", unionName, " * x = cJSON_malloc(sizeof(struct ", unionName, "));");
          this.emitBlock([
            "if (NULL != x)"
          ], () => {
            this.emitLine("memset(x, 0, sizeof(struct ", unionName, "));");
            if (hasNull !== null) {
              this.emitBlock([
                "if (cJSON_IsNull(j))"
              ], () => {
                this.emitLine("x->type = cJSON_NULL;");
              });
              onFirst = false;
            }
            for (const type of nonNulls) {
              const cJSON = this.quicktypeTypeToCJSON(type, false);
              this.emitBlock([
                onFirst === true ? "if (" : "else if (",
                cJSON.isType,
                "(j))"
              ], () => {
                this.emitLine("x->type = ", cJSON.cjsonType, ";");
                if (cJSON.cjsonType === "cJSON_Array" && cJSON.items !== void 0) {
                  const level = 0;
                  const child_level = 1;
                  this.emitLine(cJSON.cType, " * x", child_level.toString(), " = list_create(false, NULL);");
                  this.emitBlock([
                    "if (NULL != x",
                    child_level.toString(),
                    ")"
                  ], () => {
                    this.emitLine("cJSON * e", child_level.toString(), " = NULL;");
                    this.emitBlock([
                      "cJSON_ArrayForEach(e",
                      child_level.toString(),
                      ", j",
                      level > 0 ? level.toString() : "",
                      ")"
                    ], () => {
                      var _a;
                      const add = (cJSON2, level2, child_level2) => {
                        var _a2, _b, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r;
                        if (((_a2 = cJSON2.items) === null || _a2 === void 0 ? void 0 : _a2.cjsonType) === "cJSON_Array") {
                        } else if (((_b = cJSON2.items) === null || _b === void 0 ? void 0 : _b.cjsonType) === "cJSON_Map") {
                        } else if (((_d = cJSON2.items) === null || _d === void 0 ? void 0 : _d.cjsonType) === "cJSON_Invalid" || ((_e = cJSON2.items) === null || _e === void 0 ? void 0 : _e.cjsonType) === "cJSON_NULL") {
                          this.emitLine("list_add_tail(x", child_level2.toString(), ", (", (_f = cJSON2.items) === null || _f === void 0 ? void 0 : _f.cType, " *)0xDEADBEEF, sizeof(", (_g = cJSON2.items) === null || _g === void 0 ? void 0 : _g.cType, " *));");
                        } else if (((_h = cJSON2.items) === null || _h === void 0 ? void 0 : _h.cjsonType) === "cJSON_String") {
                          this.emitLine("list_add_tail(x", child_level2.toString(), ", strdup(", (_j = cJSON2.items) === null || _j === void 0 ? void 0 : _j.getValue, "(e", child_level2.toString(), ")), sizeof(", (_k = cJSON2.items) === null || _k === void 0 ? void 0 : _k.cType, " *));");
                        } else if (((_l = cJSON2.items) === null || _l === void 0 ? void 0 : _l.cjsonType) === "cJSON_Object" || ((_m = cJSON2.items) === null || _m === void 0 ? void 0 : _m.cjsonType) === "cJSON_Union") {
                          this.emitLine("list_add_tail(x", child_level2.toString(), ", ", (_o = cJSON2.items) === null || _o === void 0 ? void 0 : _o.getValue, "(e", child_level2.toString(), "), sizeof(", (_p = cJSON2.items) === null || _p === void 0 ? void 0 : _p.cType, " *));");
                        } else {
                          this.emitLine(
                            // @ts-expect-error awaiting refactor
                            (_q = cJSON2.items) === null || _q === void 0 ? void 0 : _q.cType,
                            " * tmp",
                            level2 > 0 ? level2.toString() : "",
                            " = cJSON_malloc(sizeof(",
                            (_r = cJSON2.items) === null || _r === void 0 ? void 0 : _r.cType,
                            "));"
                          );
                          this.emitBlock([
                            "if (NULL != tmp",
                            level2 > 0 ? level2.toString() : "",
                            ")"
                          ], () => {
                            var _a3, _b2;
                            this.emitLine(
                              "* tmp",
                              level2 > 0 ? level2.toString() : "",
                              " = ",
                              // @ts-expect-error awaiting refactor
                              (_a3 = cJSON2.items) === null || _a3 === void 0 ? void 0 : _a3.getValue,
                              "(e",
                              child_level2.toString(),
                              ");"
                            );
                            this.emitLine(
                              "list_add_tail(x",
                              child_level2.toString(),
                              ", tmp",
                              level2 > 0 ? level2.toString() : "",
                              ", sizeof(",
                              // @ts-expect-error awaiting refactor
                              (_b2 = cJSON2.items) === null || _b2 === void 0 ? void 0 : _b2.cType,
                              " *));"
                            );
                          });
                        }
                      };
                      if ((_a = cJSON.items) === null || _a === void 0 ? void 0 : _a.isNullable) {
                        this.emitBlock([
                          "if (!cJSON_IsNull(e",
                          child_level.toString(),
                          "))"
                        ], () => {
                          add(cJSON, level, child_level);
                        });
                        this.emitBlock([
                          "else"
                        ], () => {
                          this.emitLine("list_add_tail(x", child_level.toString(), ", (void *)0xDEADBEEF, sizeof(void *));");
                        });
                      } else {
                        add(cJSON, level, child_level);
                      }
                    });
                    this.emitLine("x->value.", this.nameForUnionMember(unionType, type), " = x", child_level.toString(), ";");
                  });
                } else if (cJSON.cjsonType === "cJSON_Map" && cJSON.items !== void 0) {
                  const level = 0;
                  const child_level = 1;
                  this.emitLine(cJSON.cType, " * x", child_level.toString(), " = hashtable_create(", this.hashtableSize, ", false);");
                  this.emitBlock([
                    "if (NULL != x",
                    child_level.toString(),
                    ")"
                  ], () => {
                    this.emitLine("cJSON * e", child_level.toString(), " = NULL;");
                    this.emitBlock([
                      "cJSON_ArrayForEach(e",
                      child_level.toString(),
                      ", j",
                      level > 0 ? level.toString() : "",
                      ")"
                    ], () => {
                      var _a;
                      const add = (cJSON2, level2, child_level2) => {
                        var _a2, _b, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r;
                        if (((_a2 = cJSON2.items) === null || _a2 === void 0 ? void 0 : _a2.cjsonType) === "cJSON_Array") {
                        } else if (((_b = cJSON2.items) === null || _b === void 0 ? void 0 : _b.cjsonType) === "cJSON_Map") {
                        } else if (((_d = cJSON2.items) === null || _d === void 0 ? void 0 : _d.cjsonType) === "cJSON_Invalid" || ((_e = cJSON2.items) === null || _e === void 0 ? void 0 : _e.cjsonType) === "cJSON_NULL") {
                          this.emitLine("hashtable_add(x", child_level2.toString(), ", e", child_level2.toString(), "->string, (", (_f = cJSON2.items) === null || _f === void 0 ? void 0 : _f.cType, " *)0xDEADBEEF, sizeof(", (_g = cJSON2.items) === null || _g === void 0 ? void 0 : _g.cType, " *));");
                        } else if (((_h = cJSON2.items) === null || _h === void 0 ? void 0 : _h.cjsonType) === "cJSON_String") {
                          this.emitLine("hashtable_add(x", child_level2.toString(), ", e", child_level2.toString(), "->string, strdup(", (_j = cJSON2.items) === null || _j === void 0 ? void 0 : _j.getValue, "(e", child_level2.toString(), ")), sizeof(", (_k = cJSON2.items) === null || _k === void 0 ? void 0 : _k.cType, " *));");
                        } else if (((_l = cJSON2.items) === null || _l === void 0 ? void 0 : _l.cjsonType) === "cJSON_Object" || ((_m = cJSON2.items) === null || _m === void 0 ? void 0 : _m.cjsonType) === "cJSON_Union") {
                          this.emitLine("hashtable_add(x", child_level2.toString(), ", e", child_level2.toString(), "->string, ", (_o = cJSON2.items) === null || _o === void 0 ? void 0 : _o.getValue, "(e", child_level2.toString(), "), sizeof(", (_p = cJSON2.items) === null || _p === void 0 ? void 0 : _p.cType, " *));");
                        } else {
                          this.emitLine(
                            // @ts-expect-error awaiting refactor
                            (_q = cJSON2.items) === null || _q === void 0 ? void 0 : _q.cType,
                            " * tmp",
                            level2 > 0 ? level2.toString() : "",
                            " = cJSON_malloc(sizeof(",
                            (_r = cJSON2.items) === null || _r === void 0 ? void 0 : _r.cType,
                            "));"
                          );
                          this.emitBlock([
                            "if (NULL != tmp",
                            level2 > 0 ? level2.toString() : "",
                            ")"
                          ], () => {
                            var _a3, _b2;
                            this.emitLine(
                              "* tmp",
                              level2 > 0 ? level2.toString() : "",
                              " = ",
                              // @ts-expect-error awaiting refactor
                              (_a3 = cJSON2.items) === null || _a3 === void 0 ? void 0 : _a3.getValue,
                              "(e",
                              child_level2.toString(),
                              ");"
                            );
                            this.emitLine(
                              "hashtable_add(x",
                              child_level2.toString(),
                              ", e",
                              child_level2.toString(),
                              "->string, tmp",
                              level2 > 0 ? level2.toString() : "",
                              ", sizeof(",
                              // @ts-expect-error awaiting refactor
                              (_b2 = cJSON2.items) === null || _b2 === void 0 ? void 0 : _b2.cType,
                              " *));"
                            );
                          });
                        }
                      };
                      if ((_a = cJSON.items) === null || _a === void 0 ? void 0 : _a.isNullable) {
                        this.emitBlock([
                          "if (!cJSON_IsNull(e",
                          child_level.toString(),
                          "))"
                        ], () => {
                          add(cJSON, level, child_level);
                        });
                        this.emitBlock([
                          "else"
                        ], () => {
                          this.emitLine("hashtable_add(x", child_level.toString(), ", e", child_level.toString(), "->string, (void *)0xDEADBEEF, sizeof(void *));");
                        });
                      } else {
                        add(cJSON, level, child_level);
                      }
                    });
                    this.emitLine("x->value.", this.nameForUnionMember(unionType, type), " = x", child_level.toString(), ";");
                  });
                } else if (cJSON.cjsonType === "cJSON_Invalid" || cJSON.cjsonType === "cJSON_NULL") {
                  this.emitLine("x->value.", this.nameForUnionMember(unionType, type), " = (", cJSON.cType, " *)0xDEADBEEF;");
                } else if (cJSON.cjsonType === "cJSON_String") {
                  this.emitLine("x->value.", this.nameForUnionMember(unionType, type), " = strdup(", cJSON.getValue, "(j));");
                } else {
                  this.emitLine("x->value.", this.nameForUnionMember(unionType, type), " = ", cJSON.getValue, "(j);");
                }
              });
              onFirst = false;
            }
          });
          this.emitLine("return x;");
        });
        this.ensureBlankLine();
        this.emitBlock([
          "cJSON * cJSON_Create",
          unionName,
          "(",
          this.withConst([
            "struct ",
            unionName
          ]),
          " * x)"
        ], () => {
          this.emitLine("cJSON * j = NULL;");
          this.emitBlock([
            "if (NULL != x)"
          ], () => {
            let onFirst = true;
            if (hasNull !== null) {
              this.emitBlock([
                "if (cJSON_NULL == x->type)"
              ], () => {
                this.emitLine("j = cJSON_CreateNull();");
              });
              onFirst = false;
            }
            for (const type of nonNulls) {
              const cJSON = this.quicktypeTypeToCJSON(type, false);
              this.emitBlock([
                onFirst === true ? "if (" : "else if (",
                cJSON.cjsonType,
                " == x->type)"
              ], () => {
                if (cJSON.cjsonType === "cJSON_Array" && cJSON.items !== void 0) {
                  const level = 0;
                  const child_level = 1;
                  this.emitLine("cJSON * j", child_level.toString(), " = ", cJSON.createObject, "();");
                  this.emitBlock([
                    "if (NULL != j",
                    child_level.toString(),
                    ")"
                  ], () => {
                    var _a;
                    this.emitLine(
                      // @ts-expect-error awaiting refactor
                      (_a = cJSON.items) === null || _a === void 0 ? void 0 : _a.cType,
                      " * x",
                      child_level.toString(),
                      " = list_get_head(x",
                      level > 0 ? level.toString() : "",
                      "->value.",
                      this.nameForUnionMember(unionType, type),
                      ");"
                    );
                    this.emitBlock([
                      "while (NULL != x",
                      child_level.toString(),
                      ")"
                    ], () => {
                      var _a2;
                      const add = (cJSON2, child_level2) => {
                        var _a3, _b, _d, _e, _f, _g, _h, _j, _k, _l;
                        if (((_a3 = cJSON2.items) === null || _a3 === void 0 ? void 0 : _a3.cjsonType) === "cJSON_Array") {
                        } else if (((_b = cJSON2.items) === null || _b === void 0 ? void 0 : _b.cjsonType) === "cJSON_Map") {
                        } else if (((_d = cJSON2.items) === null || _d === void 0 ? void 0 : _d.cjsonType) === "cJSON_Invalid") {
                        } else if (((_e = cJSON2.items) === null || _e === void 0 ? void 0 : _e.cjsonType) === "cJSON_NULL") {
                          this.emitLine("cJSON_AddItemToArray(j", child_level2.toString(), ", ", (_f = cJSON2.items) === null || _f === void 0 ? void 0 : _f.createObject, "());");
                        } else if (((_g = cJSON2.items) === null || _g === void 0 ? void 0 : _g.cjsonType) === "cJSON_String" || ((_h = cJSON2.items) === null || _h === void 0 ? void 0 : _h.cjsonType) === "cJSON_Object" || ((_j = cJSON2.items) === null || _j === void 0 ? void 0 : _j.cjsonType) === "cJSON_Union") {
                          this.emitLine("cJSON_AddItemToArray(j", child_level2.toString(), ", ", (_k = cJSON2.items) === null || _k === void 0 ? void 0 : _k.createObject, "(x", child_level2.toString(), "));");
                        } else {
                          this.emitLine(
                            "cJSON_AddItemToArray(j",
                            child_level2.toString(),
                            ", ",
                            // @ts-expect-error awaiting refactor
                            (_l = cJSON2.items) === null || _l === void 0 ? void 0 : _l.createObject,
                            "(*x",
                            child_level2.toString(),
                            "));"
                          );
                        }
                      };
                      if ((_a2 = cJSON.items) === null || _a2 === void 0 ? void 0 : _a2.isNullable) {
                        this.emitBlock([
                          "if ((void *)0xDEADBEEF != x",
                          child_level.toString(),
                          ")"
                        ], () => {
                          add(cJSON, child_level);
                        });
                        this.emitBlock([
                          "else"
                        ], () => {
                          this.emitLine("cJSON_AddItemToArray(j", child_level.toString(), ", cJSON_CreateNull());");
                        });
                      } else {
                        add(cJSON, child_level);
                      }
                      this.emitLine("x", child_level.toString(), " = list_get_next(x", level > 0 ? level.toString() : "", "->value.", this.nameForUnionMember(unionType, type), ");");
                    });
                    this.emitLine("j = j", child_level.toString(), ";");
                  });
                } else if (cJSON.cjsonType === "cJSON_Map" && cJSON.items !== void 0) {
                  const level = 0;
                  const child_level = 1;
                  this.emitLine("cJSON * j", child_level.toString(), " = ", cJSON.createObject, "();");
                  this.emitBlock([
                    "if (NULL != j",
                    child_level.toString(),
                    ")"
                  ], () => {
                    this.emitLine("char **keys", child_level.toString(), " = NULL;");
                    this.emitLine("size_t count", child_level.toString(), " = hashtable_get_keys(x", level > 0 ? level.toString() : "", "->value.", this.nameForUnionMember(unionType, type), ", &keys", child_level.toString(), ");");
                    this.emitBlock([
                      "if (NULL != keys",
                      child_level.toString(),
                      ")"
                    ], () => {
                      this.emitBlock([
                        "for (size_t index",
                        child_level.toString(),
                        " = 0; index",
                        child_level.toString(),
                        " < count",
                        child_level.toString(),
                        "; index",
                        child_level.toString(),
                        "++)"
                      ], () => {
                        var _a, _b;
                        this.emitLine(
                          // @ts-expect-error awaiting refactor
                          (_a = cJSON.items) === null || _a === void 0 ? void 0 : _a.cType,
                          " *x",
                          child_level.toString(),
                          " = hashtable_lookup(x",
                          level > 0 ? level.toString() : "",
                          "->value.",
                          this.nameForUnionMember(unionType, type),
                          ", keys",
                          child_level.toString(),
                          "[index",
                          child_level.toString(),
                          "]);"
                        );
                        const add = (cJSON2, child_level2) => {
                          var _a2, _b2, _d, _e, _f, _g, _h, _j, _k, _l;
                          if (((_a2 = cJSON2.items) === null || _a2 === void 0 ? void 0 : _a2.cjsonType) === "cJSON_Array") {
                          } else if (((_b2 = cJSON2.items) === null || _b2 === void 0 ? void 0 : _b2.cjsonType) === "cJSON_Map") {
                          } else if (((_d = cJSON2.items) === null || _d === void 0 ? void 0 : _d.cjsonType) === "cJSON_Invalid") {
                          } else if (((_e = cJSON2.items) === null || _e === void 0 ? void 0 : _e.cjsonType) === "cJSON_NULL") {
                            this.emitLine(cJSON2.addToObject, "(j", child_level2.toString(), ", keys", child_level2.toString(), "[index", child_level2.toString(), "], ", (_f = cJSON2.items) === null || _f === void 0 ? void 0 : _f.createObject, "());");
                          } else if (((_g = cJSON2.items) === null || _g === void 0 ? void 0 : _g.cjsonType) === "cJSON_String" || ((_h = cJSON2.items) === null || _h === void 0 ? void 0 : _h.cjsonType) === "cJSON_Object" || ((_j = cJSON2.items) === null || _j === void 0 ? void 0 : _j.cjsonType) === "cJSON_Union") {
                            this.emitLine(cJSON2.addToObject, "(j", child_level2.toString(), ", keys", child_level2.toString(), "[index", child_level2.toString(), "], ", (_k = cJSON2.items) === null || _k === void 0 ? void 0 : _k.createObject, "(x", child_level2.toString(), "));");
                          } else {
                            this.emitLine(
                              cJSON2.addToObject,
                              "(j",
                              child_level2.toString(),
                              ", keys",
                              child_level2.toString(),
                              "[index",
                              child_level2.toString(),
                              "], ",
                              // @ts-expect-error awaiting refactor
                              (_l = cJSON2.items) === null || _l === void 0 ? void 0 : _l.createObject,
                              "(*x",
                              child_level2.toString(),
                              "));"
                            );
                          }
                        };
                        if ((_b = cJSON.items) === null || _b === void 0 ? void 0 : _b.isNullable) {
                          this.emitBlock([
                            "if ((void *)0xDEADBEEF != x",
                            child_level.toString(),
                            ")"
                          ], () => {
                            add(cJSON, child_level);
                          });
                          this.emitBlock([
                            "else"
                          ], () => {
                            this.emitLine(cJSON.addToObject, "(j", child_level.toString(), ", keys", child_level.toString(), "[index", child_level.toString(), "], cJSON_CreateNull());");
                          });
                        } else {
                          add(cJSON, child_level);
                        }
                      });
                      this.emitLine("cJSON_free(keys", child_level.toString(), ");");
                    });
                    this.emitLine("j = j", child_level.toString(), ";");
                  });
                } else if (cJSON.cjsonType === "cJSON_Invalid") {
                } else if (cJSON.cjsonType === "cJSON_NULL") {
                  this.emitLine("j = ", cJSON.createObject, "();");
                } else {
                  this.emitLine("j = ", cJSON.createObject, "(x->value.", this.nameForUnionMember(unionType, type), ");");
                }
              });
              onFirst = false;
            }
          });
          this.emitLine("return j;");
        });
        this.ensureBlankLine();
        this.emitBlock([
          "void cJSON_Delete",
          unionName,
          "(struct ",
          unionName,
          " * x)"
        ], () => {
          this.emitBlock([
            "if (NULL != x)"
          ], () => {
            let onFirst = true;
            for (const type of nonNulls) {
              const cJSON = this.quicktypeTypeToCJSON(type, false);
              this.emitBlock([
                onFirst === true ? "if (" : "else if (",
                cJSON.cjsonType,
                " == x->type)"
              ], () => {
                if (cJSON.cjsonType === "cJSON_Array" && cJSON.items !== void 0) {
                  const level = 0;
                  const child_level = 1;
                  this.emitBlock([
                    "if (NULL != x",
                    level > 0 ? level.toString() : "",
                    "->value.",
                    this.nameForUnionMember(unionType, type),
                    ")"
                  ], () => {
                    var _a;
                    this.emitLine(
                      // @ts-expect-error awaiting refactor
                      (_a = cJSON.items) === null || _a === void 0 ? void 0 : _a.cType,
                      " * x",
                      child_level.toString(),
                      " = list_get_head(x",
                      level > 0 ? level.toString() : "",
                      "->value.",
                      this.nameForUnionMember(unionType, type),
                      ");"
                    );
                    this.emitBlock([
                      "while (NULL != x",
                      child_level.toString(),
                      ")"
                    ], () => {
                      var _a2, _b, _d, _e, _f, _g;
                      if (((_a2 = cJSON.items) === null || _a2 === void 0 ? void 0 : _a2.cjsonType) === "cJSON_Array") {
                      } else if (((_b = cJSON.items) === null || _b === void 0 ? void 0 : _b.cjsonType) === "cJSON_Map") {
                      } else if (((_d = cJSON.items) === null || _d === void 0 ? void 0 : _d.cjsonType) === "cJSON_Invalid" || ((_e = cJSON.items) === null || _e === void 0 ? void 0 : _e.cjsonType) === "cJSON_NULL") {
                      } else {
                        if ((_f = cJSON.items) === null || _f === void 0 ? void 0 : _f.isNullable) {
                          this.emitBlock([
                            "if ((void *)0xDEADBEEF != x",
                            child_level.toString(),
                            ")"
                          ], () => {
                            var _a3;
                            this.emitLine(
                              // @ts-expect-error awaiting refactor
                              (_a3 = cJSON.items) === null || _a3 === void 0 ? void 0 : _a3.deleteType,
                              "(x",
                              child_level.toString(),
                              ");"
                            );
                          });
                        } else {
                          this.emitLine(
                            // @ts-expect-error awaiting refactor
                            (_g = cJSON.items) === null || _g === void 0 ? void 0 : _g.deleteType,
                            "(x",
                            child_level.toString(),
                            ");"
                          );
                        }
                      }
                      this.emitLine("x", child_level.toString(), " = list_get_next(x", level > 0 ? level.toString() : "", "->value.", this.nameForUnionMember(unionType, type), ");");
                    });
                    this.emitLine(cJSON.deleteType, "(x", level > 0 ? level.toString() : "", "->value.", this.nameForUnionMember(unionType, type), ");");
                  });
                } else if (cJSON.cjsonType === "cJSON_Map" && cJSON.items !== void 0) {
                  const level = 0;
                  const child_level = 1;
                  this.emitBlock([
                    "if (NULL != x",
                    level > 0 ? level.toString() : "",
                    "->value.",
                    this.nameForUnionMember(unionType, type),
                    ")"
                  ], () => {
                    this.emitLine("char **keys", child_level.toString(), " = NULL;");
                    this.emitLine("size_t count", child_level.toString(), " = hashtable_get_keys(x", level > 0 ? level.toString() : "", "->value.", this.nameForUnionMember(unionType, type), ", &keys", child_level.toString(), ");");
                    this.emitBlock([
                      "if (NULL != keys",
                      child_level.toString(),
                      ")"
                    ], () => {
                      this.emitBlock([
                        "for (size_t index",
                        child_level.toString(),
                        " = 0; index",
                        child_level.toString(),
                        " < count",
                        child_level.toString(),
                        "; index",
                        child_level.toString(),
                        "++)"
                      ], () => {
                        var _a;
                        this.emitLine(
                          // @ts-expect-error awaiting refactor
                          (_a = cJSON.items) === null || _a === void 0 ? void 0 : _a.cType,
                          " *x",
                          child_level.toString(),
                          " = hashtable_lookup(x",
                          level > 0 ? level.toString() : "",
                          "->value.",
                          this.nameForUnionMember(unionType, type),
                          ", keys",
                          child_level.toString(),
                          "[index",
                          child_level.toString(),
                          "]);"
                        );
                        this.emitBlock([
                          "if (NULL != x",
                          child_level.toString(),
                          ")"
                        ], () => {
                          var _a2, _b, _d, _e, _f, _g;
                          if (((_a2 = cJSON.items) === null || _a2 === void 0 ? void 0 : _a2.cjsonType) === "cJSON_Array") {
                          } else if (((_b = cJSON.items) === null || _b === void 0 ? void 0 : _b.cjsonType) === "cJSON_Map") {
                          } else if (((_d = cJSON.items) === null || _d === void 0 ? void 0 : _d.cjsonType) === "cJSON_Invalid" || ((_e = cJSON.items) === null || _e === void 0 ? void 0 : _e.cjsonType) === "cJSON_NULL") {
                          } else {
                            if ((_f = cJSON.items) === null || _f === void 0 ? void 0 : _f.isNullable) {
                              this.emitBlock([
                                "if ((void *)0xDEADBEEF != x",
                                child_level.toString(),
                                ")"
                              ], () => {
                                var _a3;
                                this.emitLine(
                                  // @ts-expect-error awaiting refactor
                                  (_a3 = cJSON.items) === null || _a3 === void 0 ? void 0 : _a3.deleteType,
                                  "(x",
                                  child_level.toString(),
                                  ");"
                                );
                              });
                            } else {
                              this.emitLine(
                                // @ts-expect-error awaiting refactor
                                (_g = cJSON.items) === null || _g === void 0 ? void 0 : _g.deleteType,
                                "(x",
                                child_level.toString(),
                                ");"
                              );
                            }
                          }
                        });
                      });
                      this.emitLine("cJSON_free(keys", child_level.toString(), ");");
                    });
                    this.emitLine(cJSON.deleteType, "(x", level > 0 ? level.toString() : "", "->value.", this.nameForUnionMember(unionType, type), ");");
                  });
                } else if (cJSON.cjsonType === "cJSON_Invalid" || cJSON.cjsonType === "cJSON_NULL") {
                } else if (cJSON.cjsonType === "cJSON_String" || cJSON.cjsonType === "cJSON_Object" || cJSON.cjsonType === "cJSON_Union") {
                  this.emitLine(cJSON.deleteType, "(x->value.", this.nameForUnionMember(unionType, type), ");");
                } else {
                }
              });
              onFirst = false;
            }
            this.emitLine("cJSON_free(x);");
          });
        });
        this.ensureBlankLine();
      }
      /**
         * Function called to create a class header files with types and generators
         * @param classType: class type
         */
      emitClass(classType) {
        const className = this.nameForNamedType(classType);
        const filename = this.sourcelikeToString(className).concat(".h");
        this.includes.push(filename);
        this.startFile(filename);
        this.emitIncludes(classType, this.sourcelikeToString(filename));
        this.emitClassTypedef(classType);
        this.emitClassPrototypes(classType);
        this.emitClassFunctions(classType);
        this.finishFile();
      }
      /**
         * Function called to create class typedef
         * @param classType: class type
         */
      emitClassTypedef(classType) {
        const className = this.nameForNamedType(classType);
        this.emitDescription(this.descriptionForType(classType));
        this.emitBlock([
          "struct ",
          className
        ], () => {
          this.forEachClassProperty(classType, "none", (name, jsonName, property) => {
            this.emitDescription(this.descriptionForClassProperty(classType, jsonName));
            const cJSON = this.quicktypeTypeToCJSON(property.type, property.isOptional);
            this.emitLine(cJSON.cType, cJSON.optionalQualifier !== "" ? " " : "", cJSON.optionalQualifier, " ", name, ";");
          });
        }, "", true);
        this.ensureBlankLine();
        this.emitTypedefAlias(classType, className);
      }
      /**
         * Function called to create class prototypes
         * @param classType: class type
         */
      emitClassPrototypes(classType) {
        const className = this.nameForNamedType(classType);
        this.emitLine("struct ", className, " * cJSON_Parse", className, "(", this.withConst("char"), " * s);");
        this.emitLine("struct ", className, " * cJSON_Get", className, "Value(", this.withConst("cJSON"), " * j);");
        this.emitLine("cJSON * cJSON_Create", className, "(", this.withConst([
          "struct ",
          className
        ]), " * x);");
        this.emitLine("char * cJSON_Print", className, "(", this.withConst([
          "struct ",
          className
        ]), " * x);");
        this.emitLine("void cJSON_Delete", className, "(struct ", className, " * x);");
        this.ensureBlankLine();
      }
      /**
         * Function called to create class functions
         * @param classType: class type
         */
      emitClassFunctions(classType) {
        const className = this.nameForNamedType(classType);
        this.emitBlock([
          "struct ",
          className,
          " * cJSON_Parse",
          className,
          "(",
          this.withConst("char"),
          " * s)"
        ], () => {
          this.emitLine("struct ", className, " * x = NULL;");
          this.emitBlock([
            "if (NULL != s)"
          ], () => {
            this.emitLine("cJSON * j = cJSON_Parse(s);");
            this.emitBlock([
              "if (NULL != j)"
            ], () => {
              this.emitLine("x = cJSON_Get", className, "Value(j);");
              this.emitLine("cJSON_Delete(j);");
            });
          });
          this.emitLine("return x;");
        });
        this.ensureBlankLine();
        this.emitBlock([
          "struct ",
          className,
          " * cJSON_Get",
          className,
          "Value(",
          this.withConst("cJSON"),
          " * j)"
        ], () => {
          this.emitLine("struct ", className, " * x = NULL;");
          this.emitBlock([
            "if (NULL != j)"
          ], () => {
            this.emitBlock([
              "if (NULL != (x = cJSON_malloc(sizeof(struct ",
              className,
              "))))"
            ], () => {
              this.emitLine("memset(x, 0, sizeof(struct ", className, "));");
              const recur = (type, level) => {
                if (type instanceof Type_1.ArrayType) {
                  const child_level = level + 1;
                  const cJSON = this.quicktypeTypeToCJSON(type.items, false);
                  this.emitLine("list_t * x", child_level.toString(), " = list_create(false, NULL);");
                  this.emitBlock([
                    "if (NULL != x",
                    child_level.toString(),
                    ")"
                  ], () => {
                    this.emitLine("cJSON * e", child_level.toString(), " = NULL;");
                    this.emitBlock([
                      "cJSON_ArrayForEach(e",
                      child_level.toString(),
                      ", e",
                      level.toString(),
                      ")"
                    ], () => {
                      var _a;
                      if (cJSON.cjsonType === "cJSON_Array") {
                        const child_level2 = child_level + 1;
                        recur(type.items, child_level);
                        this.emitLine(
                          "list_add_tail(x",
                          child_level.toString(),
                          ", x",
                          child_level2.toString(),
                          ", sizeof(",
                          // @ts-expect-error awaiting refactor
                          (_a = cJSON.items) === null || _a === void 0 ? void 0 : _a.cType,
                          " *));"
                        );
                      } else if (cJSON.cjsonType === "cJSON_Map") {
                      } else if (cJSON.cjsonType === "cJSON_Invalid" || cJSON.cjsonType === "cJSON_NULL") {
                        this.emitLine("list_add_tail(x", child_level.toString(), ", (", cJSON.cType, " *)0xDEADBEEF, sizeof(", cJSON.cType, " *));");
                      } else if (cJSON.cjsonType === "cJSON_String") {
                        this.emitLine("list_add_tail(x", child_level.toString(), ", strdup(", cJSON.getValue, "(e", child_level.toString(), ")), sizeof(", cJSON.cType, " *));");
                      } else if (cJSON.cjsonType === "cJSON_Object" || cJSON.cjsonType === "cJSON_Union") {
                        this.emitLine("list_add_tail(x", child_level.toString(), ", ", cJSON.getValue, "(e", child_level.toString(), "), sizeof(", cJSON.cType, " *));");
                      } else {
                        this.emitLine(cJSON.cType, " * tmp", level > 0 ? level.toString() : "", " = cJSON_malloc(sizeof(", cJSON.cType, "));");
                        this.emitBlock([
                          "if (NULL != tmp",
                          level > 0 ? level.toString() : "",
                          ")"
                        ], () => {
                          this.emitLine("* tmp", level > 0 ? level.toString() : "", " = ", cJSON.getValue, "(e", child_level.toString(), ");");
                          this.emitLine("list_add_tail(x", child_level.toString(), ", tmp", level > 0 ? level.toString() : "", ", sizeof(", cJSON.cType, " *));");
                        });
                      }
                    });
                  });
                } else if (type instanceof Type_1.ClassType) {
                  this.forEachClassProperty(type, "none", (name, jsonName, property) => {
                    const cJSON = this.quicktypeTypeToCJSON(property.type, property.isOptional);
                    this.emitBlock(!cJSON.isNullable ? [
                      "if (cJSON_HasObjectItem(j",
                      level > 0 ? level.toString() : "",
                      ', "',
                      jsonName,
                      '"))'
                    ] : [
                      "if ((cJSON_HasObjectItem(j",
                      level > 0 ? level.toString() : "",
                      ', "',
                      jsonName,
                      '")) && (!cJSON_IsNull(cJSON_GetObjectItemCaseSensitive(j',
                      level > 0 ? level.toString() : "",
                      ', "',
                      jsonName,
                      '"))))'
                    ], () => {
                      if (cJSON.cjsonType === "cJSON_Array" && cJSON.items !== void 0) {
                        const child_level = level + 1;
                        this.emitLine(cJSON.cType, " * x", child_level.toString(), " = list_create(false, NULL);");
                        this.emitBlock([
                          "if (NULL != x",
                          child_level.toString(),
                          ")"
                        ], () => {
                          this.emitLine("cJSON * e", child_level.toString(), " = NULL;");
                          this.emitLine("cJSON * j", child_level.toString(), " = cJSON_GetObjectItemCaseSensitive(j", level > 0 ? level.toString() : "", ', "', jsonName, '");');
                          this.emitBlock([
                            "cJSON_ArrayForEach(e",
                            child_level.toString(),
                            ", j",
                            child_level.toString(),
                            ")"
                          ], () => {
                            var _a;
                            const add = (type2, cJSON2, level2, child_level2) => {
                              var _a2, _b, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s;
                              if (((_a2 = cJSON2.items) === null || _a2 === void 0 ? void 0 : _a2.cjsonType) === "cJSON_Array") {
                                if (type2 instanceof Type_1.ArrayType) {
                                  const child_level22 = child_level2 + 1;
                                  recur(type2.items, child_level2);
                                  this.emitLine("list_add_tail(x", child_level2.toString(), ", x", child_level22.toString(), ", sizeof(", (_b = cJSON2.items) === null || _b === void 0 ? void 0 : _b.cType, " *));");
                                } else {
                                  (0, Support_1.panic)("Invalid type");
                                }
                              } else if (((_d = cJSON2.items) === null || _d === void 0 ? void 0 : _d.cjsonType) === "cJSON_Map") {
                              } else if (((_e = cJSON2.items) === null || _e === void 0 ? void 0 : _e.cjsonType) === "cJSON_Invalid" || ((_f = cJSON2.items) === null || _f === void 0 ? void 0 : _f.cjsonType) === "cJSON_NULL") {
                                this.emitLine("list_add_tail(x", child_level2.toString(), ", (", (_g = cJSON2.items) === null || _g === void 0 ? void 0 : _g.cType, " *)0xDEADBEEF, sizeof(", (_h = cJSON2.items) === null || _h === void 0 ? void 0 : _h.cType, " *));");
                              } else if (((_j = cJSON2.items) === null || _j === void 0 ? void 0 : _j.cjsonType) === "cJSON_String") {
                                this.emitLine("list_add_tail(x", child_level2.toString(), ", strdup(", (_k = cJSON2.items) === null || _k === void 0 ? void 0 : _k.getValue, "(e", child_level2.toString(), ")), sizeof(", (_l = cJSON2.items) === null || _l === void 0 ? void 0 : _l.cType, " *));");
                              } else if (((_m = cJSON2.items) === null || _m === void 0 ? void 0 : _m.cjsonType) === "cJSON_Object" || ((_o = cJSON2.items) === null || _o === void 0 ? void 0 : _o.cjsonType) === "cJSON_Union") {
                                this.emitLine("list_add_tail(x", child_level2.toString(), ", ", (_p = cJSON2.items) === null || _p === void 0 ? void 0 : _p.getValue, "(e", child_level2.toString(), "), sizeof(", (_q = cJSON2.items) === null || _q === void 0 ? void 0 : _q.cType, " *));");
                              } else {
                                this.emitLine(
                                  // @ts-expect-error awaiting refactor
                                  (_r = cJSON2.items) === null || _r === void 0 ? void 0 : _r.cType,
                                  " * tmp",
                                  level2 > 0 ? level2.toString() : "",
                                  " = cJSON_malloc(sizeof(",
                                  (_s = cJSON2.items) === null || _s === void 0 ? void 0 : _s.cType,
                                  "));"
                                );
                                this.emitBlock([
                                  "if (NULL != tmp",
                                  level2 > 0 ? level2.toString() : "",
                                  ")"
                                ], () => {
                                  var _a3, _b2;
                                  this.emitLine(
                                    "* tmp",
                                    level2 > 0 ? level2.toString() : "",
                                    " = ",
                                    // @ts-expect-error awaiting refactor
                                    (_a3 = cJSON2.items) === null || _a3 === void 0 ? void 0 : _a3.getValue,
                                    "(e",
                                    child_level2.toString(),
                                    ");"
                                  );
                                  this.emitLine(
                                    "list_add_tail(x",
                                    child_level2.toString(),
                                    ", tmp",
                                    level2 > 0 ? level2.toString() : "",
                                    ", sizeof(",
                                    // @ts-expect-error awaiting refactor
                                    (_b2 = cJSON2.items) === null || _b2 === void 0 ? void 0 : _b2.cType,
                                    " *));"
                                  );
                                });
                              }
                            };
                            if ((_a = cJSON.items) === null || _a === void 0 ? void 0 : _a.isNullable) {
                              this.emitBlock([
                                "if (!cJSON_IsNull(e",
                                child_level.toString(),
                                "))"
                              ], () => {
                                add(property.type, cJSON, level, child_level);
                              });
                              this.emitBlock([
                                "else"
                              ], () => {
                                this.emitLine("list_add_tail(x", child_level.toString(), ", (void *)0xDEADBEEF, sizeof(void *));");
                              });
                            } else {
                              add(property.type, cJSON, level, child_level);
                            }
                          });
                          this.emitLine("x", level > 0 ? level.toString() : "", "->", name, " = x", child_level.toString(), ";");
                        });
                      } else if (cJSON.cjsonType === "cJSON_Map" && cJSON.items !== void 0) {
                        const child_level = level + 1;
                        this.emitLine(cJSON.cType, " * x", child_level.toString(), " = hashtable_create(", this.hashtableSize, ", false);");
                        this.emitBlock([
                          "if (NULL != x",
                          child_level.toString(),
                          ")"
                        ], () => {
                          this.emitLine("cJSON * e", child_level.toString(), " = NULL;");
                          this.emitLine("cJSON * j", child_level.toString(), " = cJSON_GetObjectItemCaseSensitive(j", level > 0 ? level.toString() : "", ', "', jsonName, '");');
                          this.emitBlock([
                            "cJSON_ArrayForEach(e",
                            child_level.toString(),
                            ", j",
                            child_level.toString(),
                            ")"
                          ], () => {
                            var _a;
                            const add = (type2, cJSON2, level2, child_level2) => {
                              var _a2, _b, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s;
                              if (((_a2 = cJSON2.items) === null || _a2 === void 0 ? void 0 : _a2.cjsonType) === "cJSON_Array") {
                                if (type2 instanceof Type_1.MapType) {
                                  const child_level22 = child_level2 + 1;
                                  recur(type2.values, child_level2);
                                  this.emitLine("hashtable_add(x", child_level2.toString(), ", e", child_level2.toString(), "->string, x", child_level22.toString(), ", sizeof(", (_b = cJSON2.items) === null || _b === void 0 ? void 0 : _b.cType, " *));");
                                } else {
                                  (0, Support_1.panic)("Invalid type");
                                }
                              } else if (((_d = cJSON2.items) === null || _d === void 0 ? void 0 : _d.cjsonType) === "cJSON_Map") {
                              } else if (((_e = cJSON2.items) === null || _e === void 0 ? void 0 : _e.cjsonType) === "cJSON_Invalid" || ((_f = cJSON2.items) === null || _f === void 0 ? void 0 : _f.cjsonType) === "cJSON_NULL") {
                                this.emitLine("hashtable_add(x", child_level2.toString(), ", e", child_level2.toString(), "->string, (", (_g = cJSON2.items) === null || _g === void 0 ? void 0 : _g.cType, " *)0xDEADBEEF, sizeof(", (_h = cJSON2.items) === null || _h === void 0 ? void 0 : _h.cType, " *));");
                              } else if (((_j = cJSON2.items) === null || _j === void 0 ? void 0 : _j.cjsonType) === "cJSON_String") {
                                this.emitLine("hashtable_add(x", child_level2.toString(), ", e", child_level2.toString(), "->string, strdup(", (_k = cJSON2.items) === null || _k === void 0 ? void 0 : _k.getValue, "(e", child_level2.toString(), ")), sizeof(", (_l = cJSON2.items) === null || _l === void 0 ? void 0 : _l.cType, " *));");
                              } else if (((_m = cJSON2.items) === null || _m === void 0 ? void 0 : _m.cjsonType) === "cJSON_Object" || ((_o = cJSON2.items) === null || _o === void 0 ? void 0 : _o.cjsonType) === "cJSON_Union") {
                                this.emitLine("hashtable_add(x", child_level2.toString(), ", e", child_level2.toString(), "->string, ", (_p = cJSON2.items) === null || _p === void 0 ? void 0 : _p.getValue, "(e", child_level2.toString(), "), sizeof(", (_q = cJSON2.items) === null || _q === void 0 ? void 0 : _q.cType, " *));");
                              } else {
                                this.emitLine(
                                  // @ts-expect-error awaiting refactor
                                  (_r = cJSON2.items) === null || _r === void 0 ? void 0 : _r.cType,
                                  " * tmp",
                                  level2 > 0 ? level2.toString() : "",
                                  " = cJSON_malloc(sizeof(",
                                  (_s = cJSON2.items) === null || _s === void 0 ? void 0 : _s.cType,
                                  "));"
                                );
                                this.emitBlock([
                                  "if (NULL != tmp",
                                  level2 > 0 ? level2.toString() : "",
                                  ")"
                                ], () => {
                                  var _a3, _b2;
                                  this.emitLine(
                                    "* tmp",
                                    level2 > 0 ? level2.toString() : "",
                                    " = ",
                                    // @ts-expect-error awaiting refactor
                                    (_a3 = cJSON2.items) === null || _a3 === void 0 ? void 0 : _a3.getValue,
                                    "(e",
                                    child_level2.toString(),
                                    ");"
                                  );
                                  this.emitLine(
                                    "hashtable_add(x",
                                    child_level2.toString(),
                                    ", e",
                                    child_level2.toString(),
                                    "->string, tmp",
                                    level2 > 0 ? level2.toString() : "",
                                    ", sizeof(",
                                    // @ts-expect-error awaiting refactor
                                    (_b2 = cJSON2.items) === null || _b2 === void 0 ? void 0 : _b2.cType,
                                    " *));"
                                  );
                                });
                              }
                            };
                            if ((_a = cJSON.items) === null || _a === void 0 ? void 0 : _a.isNullable) {
                              this.emitBlock([
                                "if (!cJSON_IsNull(e",
                                child_level.toString(),
                                "))"
                              ], () => {
                                add(property.type, cJSON, level, child_level);
                              });
                              this.emitBlock([
                                "else"
                              ], () => {
                                this.emitLine("hashtable_add(x", child_level.toString(), ", e", child_level.toString(), "->string, (void *)0xDEADBEEF, sizeof(void *));");
                              });
                            } else {
                              add(property.type, cJSON, level, child_level);
                            }
                          });
                          this.emitLine("x", level > 0 ? level.toString() : "", "->", name, " = x", child_level.toString(), ";");
                        });
                      } else if (cJSON.cjsonType === "cJSON_Invalid" || cJSON.cjsonType === "cJSON_NULL") {
                        this.emitLine("x", level > 0 ? level.toString() : "", "->", name, " = (", cJSON.cType, " *)0xDEADBEEF;");
                      } else if (cJSON.cjsonType === "cJSON_String") {
                        this.emitLine("x", level > 0 ? level.toString() : "", "->", name, " = strdup(", cJSON.getValue, "(cJSON_GetObjectItemCaseSensitive(j", level > 0 ? level.toString() : "", ', "', jsonName, '")));');
                      } else if (cJSON.cjsonType === "cJSON_Object" || cJSON.cjsonType === "cJSON_Union") {
                        this.emitLine("x", level > 0 ? level.toString() : "", "->", name, " = ", cJSON.getValue, "(cJSON_GetObjectItemCaseSensitive(j", level > 0 ? level.toString() : "", ', "', jsonName, '"));');
                      } else {
                        if (property.isOptional || cJSON.isNullable) {
                          this.emitBlock([
                            "if (NULL != (x",
                            level > 0 ? level.toString() : "",
                            "->",
                            name,
                            " = cJSON_malloc(sizeof(",
                            cJSON.cType,
                            "))))"
                          ], () => {
                            this.emitLine("*x", level > 0 ? level.toString() : "", "->", name, " = ", cJSON.getValue, "(cJSON_GetObjectItemCaseSensitive(j", level > 0 ? level.toString() : "", ', "', jsonName, '"));');
                          });
                        } else {
                          this.emitLine("x", level > 0 ? level.toString() : "", "->", name, " = ", cJSON.getValue, "(cJSON_GetObjectItemCaseSensitive(j", level > 0 ? level.toString() : "", ', "', jsonName, '"));');
                        }
                      }
                    });
                    if (!property.isOptional && !cJSON.isNullable) {
                      if (cJSON.cjsonType === "cJSON_Array") {
                        this.emitBlock([
                          "else"
                        ], () => {
                          this.emitLine("x", level > 0 ? level.toString() : "", "->", name, " = list_create(false, NULL);");
                        });
                      } else if (cJSON.cjsonType === "cJSON_Map") {
                        this.emitBlock([
                          "else"
                        ], () => {
                          this.emitLine("x", level > 0 ? level.toString() : "", "->", name, " = hashtable_create(", this.hashtableSize, ", false);");
                        });
                      } else if (cJSON.cjsonType === "cJSON_Invalid" || cJSON.cjsonType === "cJSON_NULL") {
                        this.emitBlock([
                          "else"
                        ], () => {
                          this.emitLine("x", level > 0 ? level.toString() : "", "->", name, " = (", cJSON.cType, " *)0xDEADBEEF;");
                        });
                      } else if (cJSON.cjsonType === "cJSON_String") {
                        this.emitBlock([
                          "else"
                        ], () => {
                          this.emitBlock([
                            "if (NULL != (x",
                            level > 0 ? level.toString() : "",
                            "->",
                            name,
                            " = cJSON_malloc(sizeof(",
                            cJSON.cType,
                            "))))"
                          ], () => {
                            this.emitLine("x", level > 0 ? level.toString() : "", "->", name, "[0] = '\\0';");
                          });
                        });
                      } else {
                      }
                    }
                  });
                }
              };
              recur(classType, 0);
            });
          });
          this.emitLine("return x;");
        });
        this.ensureBlankLine();
        this.emitBlock([
          "cJSON * cJSON_Create",
          className,
          "(",
          this.withConst([
            "struct ",
            className
          ]),
          " * x)"
        ], () => {
          this.emitLine("cJSON * j = NULL;");
          this.emitBlock([
            "if (NULL != x)"
          ], () => {
            this.emitBlock([
              "if (NULL != (j = cJSON_CreateObject()))"
            ], () => {
              const recur = (type, level) => {
                if (type instanceof Type_1.ArrayType) {
                  const child_level = level + 1;
                  const cJSON = this.quicktypeTypeToCJSON(type.items, false);
                  this.emitLine("cJSON * j", child_level.toString(), " = cJSON_CreateArray();");
                  this.emitBlock([
                    "if (NULL != j",
                    child_level.toString(),
                    ")"
                  ], () => {
                    this.emitLine(cJSON.cType, " * x", child_level.toString(), " = list_get_head(x", level.toString(), ");");
                    this.emitBlock([
                      "while (NULL != x",
                      child_level.toString(),
                      ")"
                    ], () => {
                      if (cJSON.cjsonType === "cJSON_Array") {
                        const child_level2 = child_level + 1;
                        recur(type.items, child_level);
                        this.emitLine("cJSON_AddItemToArray(j", child_level.toString(), ", j", child_level2.toString(), ");");
                      } else if (cJSON.cjsonType === "cJSON_Map") {
                      } else if (cJSON.cjsonType === "cJSON_Invalid") {
                      } else if (cJSON.cjsonType === "cJSON_NULL") {
                        this.emitLine("cJSON_AddItemToArray(j", child_level.toString(), ", ", cJSON.createObject, "());");
                      } else if (cJSON.cjsonType === "cJSON_String" || cJSON.cjsonType === "cJSON_Object" || cJSON.cjsonType === "cJSON_Union") {
                        this.emitLine("cJSON_AddItemToArray(j", child_level.toString(), ", ", cJSON.createObject, "(x", child_level.toString(), "));");
                      } else {
                        this.emitLine("cJSON_AddItemToArray(j", child_level.toString(), ", ", cJSON.createObject, "(*x", child_level.toString(), "));");
                      }
                      this.emitLine("x", child_level.toString(), " = list_get_next(x", level.toString(), ");");
                    });
                  });
                } else if (type instanceof Type_1.ClassType) {
                  this.forEachClassProperty(type, "none", (name, jsonName, property) => {
                    const cJSON = this.quicktypeTypeToCJSON(property.type, property.isOptional);
                    if (cJSON.cjsonType === "cJSON_Array" && cJSON.items !== void 0) {
                      const child_level = level + 1;
                      this.emitBlock([
                        "if (NULL != x",
                        level > 0 ? level.toString() : "",
                        "->",
                        name,
                        ")"
                      ], () => {
                        this.emitLine("cJSON * j", child_level.toString(), " = cJSON_AddArrayToObject(j", level > 0 ? level.toString() : "", ', "', jsonName, '");');
                        this.emitBlock([
                          "if (NULL != j",
                          child_level.toString(),
                          ")"
                        ], () => {
                          var _a;
                          this.emitLine(
                            // @ts-expect-error awaiting refactor
                            (_a = cJSON.items) === null || _a === void 0 ? void 0 : _a.cType,
                            " * x",
                            child_level.toString(),
                            " = list_get_head(x",
                            level > 0 ? level.toString() : "",
                            "->",
                            name,
                            ");"
                          );
                          this.emitBlock([
                            "while (NULL != x",
                            child_level.toString(),
                            ")"
                          ], () => {
                            var _a2;
                            const add = (type2, cJSON2, child_level2) => {
                              var _a3, _b, _d, _e, _f, _g, _h, _j, _k, _l;
                              if (((_a3 = cJSON2.items) === null || _a3 === void 0 ? void 0 : _a3.cjsonType) === "cJSON_Array") {
                                if (type2 instanceof Type_1.ArrayType) {
                                  const child_level22 = child_level2 + 1;
                                  recur(type2.items, child_level2);
                                  this.emitLine("cJSON_AddItemToArray(j", child_level2.toString(), ", j", child_level22.toString(), ");");
                                } else {
                                  (0, Support_1.panic)("Invalid type");
                                }
                              } else if (((_b = cJSON2.items) === null || _b === void 0 ? void 0 : _b.cjsonType) === "cJSON_Map") {
                              } else if (((_d = cJSON2.items) === null || _d === void 0 ? void 0 : _d.cjsonType) === "cJSON_Invalid") {
                              } else if (((_e = cJSON2.items) === null || _e === void 0 ? void 0 : _e.cjsonType) === "cJSON_NULL") {
                                this.emitLine("cJSON_AddItemToArray(j", child_level2.toString(), ", ", (_f = cJSON2.items) === null || _f === void 0 ? void 0 : _f.createObject, "());");
                              } else if (((_g = cJSON2.items) === null || _g === void 0 ? void 0 : _g.cjsonType) === "cJSON_String" || ((_h = cJSON2.items) === null || _h === void 0 ? void 0 : _h.cjsonType) === "cJSON_Object" || ((_j = cJSON2.items) === null || _j === void 0 ? void 0 : _j.cjsonType) === "cJSON_Union") {
                                this.emitLine("cJSON_AddItemToArray(j", child_level2.toString(), ", ", (_k = cJSON2.items) === null || _k === void 0 ? void 0 : _k.createObject, "(x", child_level2.toString(), "));");
                              } else {
                                this.emitLine(
                                  "cJSON_AddItemToArray(j",
                                  child_level2.toString(),
                                  ", ",
                                  // @ts-expect-error awaiting refactor
                                  (_l = cJSON2.items) === null || _l === void 0 ? void 0 : _l.createObject,
                                  "(*x",
                                  child_level2.toString(),
                                  "));"
                                );
                              }
                            };
                            if ((_a2 = cJSON.items) === null || _a2 === void 0 ? void 0 : _a2.isNullable) {
                              this.emitBlock([
                                "if ((void *)0xDEADBEEF != x",
                                child_level.toString(),
                                ")"
                              ], () => {
                                add(property.type, cJSON, child_level);
                              });
                              this.emitBlock([
                                "else"
                              ], () => {
                                this.emitLine("cJSON_AddItemToArray(j", child_level.toString(), ", cJSON_CreateNull());");
                              });
                            } else {
                              add(property.type, cJSON, child_level);
                            }
                            this.emitLine("x", child_level.toString(), " = list_get_next(x", level > 0 ? level.toString() : "", "->", name, ");");
                          });
                        });
                      });
                    } else if (cJSON.cjsonType === "cJSON_Map" && cJSON.items !== void 0) {
                      const child_level = level + 1;
                      this.emitBlock([
                        "if (NULL != x",
                        level > 0 ? level.toString() : "",
                        "->",
                        name,
                        ")"
                      ], () => {
                        this.emitLine("cJSON * j", child_level.toString(), " = ", cJSON.createObject, "();");
                        this.emitBlock([
                          "if (NULL != j",
                          child_level.toString(),
                          ")"
                        ], () => {
                          this.emitLine("char **keys", child_level.toString(), " = NULL;");
                          this.emitLine("size_t count", child_level.toString(), " = hashtable_get_keys(x", level > 0 ? level.toString() : "", "->", name, ", &keys", child_level.toString(), ");");
                          this.emitBlock([
                            "if (NULL != keys",
                            child_level.toString(),
                            ")"
                          ], () => {
                            this.emitBlock([
                              "for (size_t index",
                              child_level.toString(),
                              " = 0; index",
                              child_level.toString(),
                              " < count",
                              child_level.toString(),
                              "; index",
                              child_level.toString(),
                              "++)"
                            ], () => {
                              var _a, _b;
                              this.emitLine(
                                // @ts-expect-error awaiting refactor
                                (_a = cJSON.items) === null || _a === void 0 ? void 0 : _a.cType,
                                " *x",
                                child_level.toString(),
                                " = hashtable_lookup(x",
                                level > 0 ? level.toString() : "",
                                "->",
                                name,
                                ", keys",
                                child_level.toString(),
                                "[index",
                                child_level.toString(),
                                "]);"
                              );
                              const add = (type2, cJSON2, child_level2) => {
                                var _a2, _b2, _d, _e, _f, _g, _h, _j, _k, _l;
                                if (((_a2 = cJSON2.items) === null || _a2 === void 0 ? void 0 : _a2.cjsonType) === "cJSON_Array") {
                                  if (type2 instanceof Type_1.MapType) {
                                    const child_level22 = child_level2 + 1;
                                    recur(type2.values, child_level2);
                                    this.emitLine(cJSON2.addToObject, "(j", child_level2.toString(), ", keys", child_level2.toString(), "[index", child_level2.toString(), "], j", child_level22.toString(), ");");
                                  } else {
                                    (0, Support_1.panic)("Invalid type");
                                  }
                                } else if (((_b2 = cJSON2.items) === null || _b2 === void 0 ? void 0 : _b2.cjsonType) === "cJSON_Map") {
                                } else if (((_d = cJSON2.items) === null || _d === void 0 ? void 0 : _d.cjsonType) === "cJSON_Invalid") {
                                } else if (((_e = cJSON2.items) === null || _e === void 0 ? void 0 : _e.cjsonType) === "cJSON_NULL") {
                                  this.emitLine(cJSON2.addToObject, "(j", child_level2.toString(), ", keys", child_level2.toString(), "[index", child_level2.toString(), "], ", (_f = cJSON2.items) === null || _f === void 0 ? void 0 : _f.createObject, "());");
                                } else if (((_g = cJSON2.items) === null || _g === void 0 ? void 0 : _g.cjsonType) === "cJSON_String" || ((_h = cJSON2.items) === null || _h === void 0 ? void 0 : _h.cjsonType) === "cJSON_Object" || ((_j = cJSON2.items) === null || _j === void 0 ? void 0 : _j.cjsonType) === "cJSON_Union") {
                                  this.emitLine(cJSON2.addToObject, "(j", child_level2.toString(), ", keys", child_level2.toString(), "[index", child_level2.toString(), "], ", (_k = cJSON2.items) === null || _k === void 0 ? void 0 : _k.createObject, "(x", child_level2.toString(), "));");
                                } else {
                                  this.emitLine(
                                    cJSON2.addToObject,
                                    "(j",
                                    child_level2.toString(),
                                    ", keys",
                                    child_level2.toString(),
                                    "[index",
                                    child_level2.toString(),
                                    "], ",
                                    // @ts-expect-error awaiting refactor
                                    (_l = cJSON2.items) === null || _l === void 0 ? void 0 : _l.createObject,
                                    "(*x",
                                    child_level2.toString(),
                                    "));"
                                  );
                                }
                              };
                              if ((_b = cJSON.items) === null || _b === void 0 ? void 0 : _b.isNullable) {
                                this.emitBlock([
                                  "if ((void *)0xDEADBEEF != x",
                                  child_level.toString(),
                                  ")"
                                ], () => {
                                  add(property.type, cJSON, child_level);
                                });
                                this.emitBlock([
                                  "else"
                                ], () => {
                                  this.emitLine(cJSON.addToObject, "(j", child_level.toString(), ", keys", child_level.toString(), "[index", child_level.toString(), "], cJSON_CreateNull());");
                                });
                              } else {
                                add(property.type, cJSON, child_level);
                              }
                            });
                            this.emitLine("cJSON_free(keys", child_level.toString(), ");");
                          });
                          this.emitLine(cJSON.addToObject, "(j", level > 0 ? level.toString() : "", ', "', jsonName, '", j', child_level.toString(), ");");
                        });
                      });
                    } else if (cJSON.cjsonType === "cJSON_Invalid") {
                    } else if (cJSON.cjsonType === "cJSON_NULL") {
                      if (property.isOptional) {
                        this.emitBlock([
                          "if (NULL != x",
                          level > 0 ? level.toString() : "",
                          "->",
                          name,
                          ")"
                        ], () => {
                          this.emitLine(cJSON.addToObject, "(j", level > 0 ? level.toString() : "", ', "', jsonName, '");');
                        });
                      } else {
                        this.emitLine(cJSON.addToObject, "(j", level > 0 ? level.toString() : "", ', "', jsonName, '");');
                      }
                    } else if (cJSON.cjsonType === "cJSON_String") {
                      this.emitBlock([
                        "if (NULL != x",
                        level > 0 ? level.toString() : "",
                        "->",
                        name,
                        ")"
                      ], () => {
                        this.emitLine(cJSON.addToObject, "(j", level > 0 ? level.toString() : "", ', "', jsonName, '", x', level > 0 ? level.toString() : "", "->", name, ");");
                      });
                      if (!property.isOptional && !cJSON.isNullable) {
                        this.emitBlock([
                          "else"
                        ], () => {
                          this.emitLine(cJSON.addToObject, "(j", level > 0 ? level.toString() : "", ', "', jsonName, '", "");');
                        });
                      }
                    } else if (cJSON.cjsonType === "cJSON_Object" || cJSON.cjsonType === "cJSON_Union") {
                      if (property.isOptional || cJSON.isNullable) {
                        this.emitBlock([
                          "if (NULL != x",
                          level > 0 ? level.toString() : "",
                          "->",
                          name,
                          ")"
                        ], () => {
                          this.emitLine(cJSON.addToObject, "(j", level > 0 ? level.toString() : "", ', "', jsonName, '", ', cJSON.createObject, "(x", level > 0 ? level.toString() : "", "->", name, "));");
                        });
                      } else {
                        this.emitLine(cJSON.addToObject, "(j", level > 0 ? level.toString() : "", ', "', jsonName, '", ', cJSON.createObject, "(x", level > 0 ? level.toString() : "", "->", name, "));");
                      }
                    } else if (cJSON.cjsonType === "cJSON_Enum") {
                      if (property.isOptional || cJSON.isNullable) {
                        this.emitBlock([
                          "if (NULL != x",
                          level > 0 ? level.toString() : "",
                          "->",
                          name,
                          ")"
                        ], () => {
                          this.emitLine(cJSON.addToObject, "(j", level > 0 ? level.toString() : "", ', "', jsonName, '", ', cJSON.createObject, "(*x", level > 0 ? level.toString() : "", "->", name, "));");
                        });
                      } else {
                        this.emitLine(cJSON.addToObject, "(j", level > 0 ? level.toString() : "", ', "', jsonName, '", ', cJSON.createObject, "(x", level > 0 ? level.toString() : "", "->", name, "));");
                      }
                    } else {
                      if (property.isOptional || cJSON.isNullable) {
                        this.emitBlock([
                          "if (NULL != x",
                          level > 0 ? level.toString() : "",
                          "->",
                          name,
                          ")"
                        ], () => {
                          this.emitLine(cJSON.addToObject, "(j", level > 0 ? level.toString() : "", ', "', jsonName, '", *x', level > 0 ? level.toString() : "", "->", name, ");");
                        });
                      } else {
                        this.emitLine(cJSON.addToObject, "(j", level > 0 ? level.toString() : "", ', "', jsonName, '", x', level > 0 ? level.toString() : "", "->", name, ");");
                      }
                    }
                    if (cJSON.isNullable) {
                      this.emitBlock([
                        "else"
                      ], () => {
                        this.emitLine("cJSON_AddNullToObject(j", level > 0 ? level.toString() : "", ', "', jsonName, '");');
                      });
                    }
                  });
                }
              };
              recur(classType, 0);
            });
          });
          this.emitLine("return j;");
        });
        this.ensureBlankLine();
        this.emitBlock([
          "char * cJSON_Print",
          className,
          "(",
          this.withConst([
            "struct ",
            className
          ]),
          " * x)"
        ], () => {
          this.emitLine("char * s = NULL;");
          this.emitBlock([
            "if (NULL != x)"
          ], () => {
            this.emitLine("cJSON * j = cJSON_Create", className, "(x);");
            this.emitBlock([
              "if (NULL != j)"
            ], () => {
              this.emitLine(this._options.printStyle ? "s = cJSON_PrintUnformatted(j);" : "s = cJSON_Print(j);");
              this.emitLine("cJSON_Delete(j);");
            });
          });
          this.emitLine("return s;");
        });
        this.ensureBlankLine();
        this.emitBlock([
          "void cJSON_Delete",
          className,
          "(struct ",
          className,
          " * x)"
        ], () => {
          this.emitBlock([
            "if (NULL != x)"
          ], () => {
            const recur = (type, level) => {
              if (type instanceof Type_1.ArrayType) {
                const child_level = level + 1;
                const cJSON = this.quicktypeTypeToCJSON(type.items, false);
                this.emitLine(cJSON.cType, " * x", child_level.toString(), " = list_get_head(x", level.toString(), ");");
                this.emitBlock([
                  "while (NULL != x",
                  child_level.toString(),
                  ")"
                ], () => {
                  if (cJSON.cjsonType === "cJSON_Array") {
                    recur(type.items, child_level);
                    this.emitLine(cJSON.deleteType, "(x", child_level.toString(), ");");
                  } else if (cJSON.cjsonType === "cJSON_Map") {
                  } else if (cJSON.cjsonType === "cJSON_Invalid" || cJSON.cjsonType === "cJSON_NULL") {
                  } else {
                    this.emitLine(cJSON.deleteType, "(x", child_level.toString(), ");");
                  }
                  this.emitLine("x", child_level.toString(), " = list_get_next(x", level.toString(), ");");
                });
              } else if (type instanceof Type_1.ClassType) {
                this.forEachClassProperty(type, "none", (name, _jsonName, property) => {
                  const cJSON = this.quicktypeTypeToCJSON(property.type, property.isOptional);
                  if (cJSON.cjsonType === "cJSON_Array" && cJSON.items !== void 0) {
                    const child_level = level + 1;
                    this.emitBlock([
                      "if (NULL != x",
                      level > 0 ? level.toString() : "",
                      "->",
                      name,
                      ")"
                    ], () => {
                      var _a;
                      this.emitLine(
                        // @ts-expect-error awaiting refactor
                        (_a = cJSON.items) === null || _a === void 0 ? void 0 : _a.cType,
                        " * x",
                        child_level.toString(),
                        " = list_get_head(x",
                        level > 0 ? level.toString() : "",
                        "->",
                        name,
                        ");"
                      );
                      this.emitBlock([
                        "while (NULL != x",
                        child_level.toString(),
                        ")"
                      ], () => {
                        var _a2, _b, _d, _e, _f, _g, _h;
                        if (((_a2 = cJSON.items) === null || _a2 === void 0 ? void 0 : _a2.cjsonType) === "cJSON_Array") {
                          if (property.type instanceof Type_1.ArrayType) {
                            recur(property.type.items, child_level);
                            this.emitLine((_b = cJSON.items) === null || _b === void 0 ? void 0 : _b.deleteType, "(x", child_level.toString(), ");");
                          } else {
                            (0, Support_1.panic)("Invalid type");
                          }
                        } else if (((_d = cJSON.items) === null || _d === void 0 ? void 0 : _d.cjsonType) === "cJSON_Map") {
                        } else if (((_e = cJSON.items) === null || _e === void 0 ? void 0 : _e.cjsonType) === "cJSON_Invalid" || ((_f = cJSON.items) === null || _f === void 0 ? void 0 : _f.cjsonType) === "cJSON_NULL") {
                        } else {
                          if ((_g = cJSON.items) === null || _g === void 0 ? void 0 : _g.isNullable) {
                            this.emitBlock([
                              "if ((void *)0xDEADBEEF != x",
                              child_level.toString(),
                              ")"
                            ], () => {
                              var _a3;
                              this.emitLine(
                                // @ts-expect-error awaiting refactor
                                (_a3 = cJSON.items) === null || _a3 === void 0 ? void 0 : _a3.deleteType,
                                "(x",
                                child_level.toString(),
                                ");"
                              );
                            });
                          } else {
                            this.emitLine(
                              // @ts-expect-error awaiting refactor
                              (_h = cJSON.items) === null || _h === void 0 ? void 0 : _h.deleteType,
                              "(x",
                              child_level.toString(),
                              ");"
                            );
                          }
                        }
                        this.emitLine("x", child_level.toString(), " = list_get_next(x", level > 0 ? level.toString() : "", "->", name, ");");
                      });
                      this.emitLine(cJSON.deleteType, "(x", level > 0 ? level.toString() : "", "->", name, ");");
                    });
                  } else if (cJSON.cjsonType === "cJSON_Map" && cJSON.items !== void 0) {
                    const child_level = level + 1;
                    this.emitBlock([
                      "if (NULL != x",
                      level > 0 ? level.toString() : "",
                      "->",
                      name,
                      ")"
                    ], () => {
                      this.emitLine("char **keys", child_level.toString(), " = NULL;");
                      this.emitLine("size_t count", child_level.toString(), " = hashtable_get_keys(x", level > 0 ? level.toString() : "", "->", name, ", &keys", child_level.toString(), ");");
                      this.emitBlock([
                        "if (NULL != keys",
                        child_level.toString(),
                        ")"
                      ], () => {
                        this.emitBlock([
                          "for (size_t index",
                          child_level.toString(),
                          " = 0; index",
                          child_level.toString(),
                          " < count",
                          child_level.toString(),
                          "; index",
                          child_level.toString(),
                          "++)"
                        ], () => {
                          var _a;
                          this.emitLine(
                            // @ts-expect-error awaiting refactor
                            (_a = cJSON.items) === null || _a === void 0 ? void 0 : _a.cType,
                            " *x",
                            child_level.toString(),
                            " = hashtable_lookup(x",
                            level > 0 ? level.toString() : "",
                            "->",
                            name,
                            ", keys",
                            child_level.toString(),
                            "[index",
                            child_level.toString(),
                            "]);"
                          );
                          this.emitBlock([
                            "if (NULL != x",
                            child_level.toString(),
                            ")"
                          ], () => {
                            var _a2, _b, _d, _e, _f, _g, _h;
                            if (((_a2 = cJSON.items) === null || _a2 === void 0 ? void 0 : _a2.cjsonType) === "cJSON_Array") {
                              if (property.type instanceof Type_1.MapType) {
                                recur(property.type.values, child_level);
                                this.emitLine((_b = cJSON.items) === null || _b === void 0 ? void 0 : _b.deleteType, "(x", child_level.toString(), ");");
                              } else {
                                (0, Support_1.panic)("Invalid type");
                              }
                            } else if (((_d = cJSON.items) === null || _d === void 0 ? void 0 : _d.cjsonType) === "cJSON_Map") {
                            } else if (((_e = cJSON.items) === null || _e === void 0 ? void 0 : _e.cjsonType) === "cJSON_Invalid" || ((_f = cJSON.items) === null || _f === void 0 ? void 0 : _f.cjsonType) === "cJSON_NULL") {
                            } else {
                              if ((_g = cJSON.items) === null || _g === void 0 ? void 0 : _g.isNullable) {
                                this.emitBlock([
                                  "if ((void *)0xDEADBEEF != x",
                                  child_level.toString(),
                                  ")"
                                ], () => {
                                  var _a3;
                                  this.emitLine(
                                    // @ts-expect-error awaiting refactor
                                    (_a3 = cJSON.items) === null || _a3 === void 0 ? void 0 : _a3.deleteType,
                                    "(x",
                                    child_level.toString(),
                                    ");"
                                  );
                                });
                              } else {
                                this.emitLine(
                                  // @ts-expect-error awaiting refactor
                                  (_h = cJSON.items) === null || _h === void 0 ? void 0 : _h.deleteType,
                                  "(x",
                                  child_level.toString(),
                                  ");"
                                );
                              }
                            }
                          });
                        });
                        this.emitLine("cJSON_free(keys", child_level.toString(), ");");
                      });
                      this.emitLine(cJSON.deleteType, "(x", level > 0 ? level.toString() : "", "->", name, ");");
                    });
                  } else if (cJSON.cjsonType === "cJSON_Invalid" || cJSON.cjsonType === "cJSON_NULL") {
                  } else if (cJSON.cjsonType === "cJSON_String" || cJSON.cjsonType === "cJSON_Object" || cJSON.cjsonType === "cJSON_Union") {
                    this.emitBlock([
                      "if (NULL != x",
                      level > 0 ? level.toString() : "",
                      "->",
                      name,
                      ")"
                    ], () => {
                      this.emitLine(cJSON.deleteType, "(x", level > 0 ? level.toString() : "", "->", name, ");");
                    });
                  } else {
                    if (property.isOptional || cJSON.isNullable) {
                      this.emitBlock([
                        "if (NULL != x",
                        level > 0 ? level.toString() : "",
                        "->",
                        name,
                        ")"
                      ], () => {
                        this.emitLine(cJSON.deleteType, "(x", level > 0 ? level.toString() : "", "->", name, ");");
                      });
                    }
                  }
                });
              }
            };
            recur(classType, 0);
            this.emitLine("cJSON_free(x);");
          });
        });
        this.ensureBlankLine();
      }
      /**
         * Function called to create a top level header files with types and generators
         * @param type: type of the top level element
         * @param className: top level class name
         * @param includes: Array of includes
         */
      emitTopLevel(type, className, includes) {
        const filename = this.sourcelikeToString(className).concat(".h");
        this.startFile(filename);
        includes.forEach((name) => {
          this.emitIncludeLine(name);
        });
        this.ensureBlankLine();
        this.emitTopLevelTypedef(type, className);
        this.emitTopLevelPrototypes(type, className);
        this.emitTopLevelFunctions(type, className);
        this.finishFile();
      }
      /**
         * Function called to create top level typedef
         * @param type: type of the top level element
         * @param className: top level class name
         */
      emitTopLevelTypedef(type, className) {
        this.emitBlock([
          "struct ",
          className
        ], () => {
          const cJSON = this.quicktypeTypeToCJSON(type, false);
          this.emitLine(cJSON.cType, cJSON.optionalQualifier !== "" ? " " : "", cJSON.optionalQualifier, " value;");
        }, "", true);
        this.ensureBlankLine();
        this.emitTypedefAlias(type, className);
      }
      /**
         * Function called to create top level prototypes
         * @param type: type of the top level element
         * @param className: top level class name
         */
      emitTopLevelPrototypes(_type, className) {
        this.emitLine("struct ", className, " * cJSON_Parse", className, "(", this.withConst("char"), " * s);");
        this.emitLine("struct ", className, " * cJSON_Get", className, "Value(", this.withConst("cJSON"), " * j);");
        this.emitLine("cJSON * cJSON_Create", className, "(", this.withConst([
          "struct ",
          className
        ]), " * x);");
        this.emitLine("char * cJSON_Print", className, "(", this.withConst([
          "struct ",
          className
        ]), " * x);");
        this.emitLine("void cJSON_Delete", className, "(struct ", className, " * x);");
        this.ensureBlankLine();
      }
      /**
         * Function called to create top level functions
         * @param type: type of the top level element
         * @param className: top level class name
         */
      emitTopLevelFunctions(type, className) {
        this.emitBlock([
          "struct ",
          className,
          " * cJSON_Parse",
          className,
          "(",
          this.withConst("char"),
          " * s)"
        ], () => {
          this.emitLine("struct ", className, " * x = NULL;");
          this.emitBlock([
            "if (NULL != s)"
          ], () => {
            this.emitLine("cJSON * j = cJSON_Parse(s);");
            this.emitBlock([
              "if (NULL != j)"
            ], () => {
              this.emitLine("x = cJSON_Get", className, "Value(j);");
              this.emitLine("cJSON_Delete(j);");
            });
          });
          this.emitLine("return x;");
        });
        this.ensureBlankLine();
        this.emitBlock([
          "struct ",
          className,
          " * cJSON_Get",
          className,
          "Value(",
          this.withConst("cJSON"),
          " * j)"
        ], () => {
          this.emitLine("struct ", className, " * x = NULL;");
          this.emitBlock([
            "if (NULL != j)"
          ], () => {
            this.emitBlock([
              "if (NULL != (x = cJSON_malloc(sizeof(struct ",
              className,
              "))))"
            ], () => {
              this.emitLine("memset(x, 0, sizeof(struct ", className, "));");
              const cJSON = this.quicktypeTypeToCJSON(type, false);
              if (cJSON.cjsonType === "cJSON_Array" && cJSON.items !== void 0) {
                this.emitLine("x->value = list_create(false, NULL);");
                this.emitBlock([
                  "if (NULL != x->value)"
                ], () => {
                  this.emitLine("cJSON * e = NULL;");
                  this.emitBlock([
                    "cJSON_ArrayForEach(e, j)"
                  ], () => {
                    var _a;
                    const add = (cJSON2) => {
                      var _a2, _b, _d, _e, _f, _g, _h, _j, _k, _l, _m;
                      if (((_a2 = cJSON2.items) === null || _a2 === void 0 ? void 0 : _a2.cjsonType) === "cJSON_Array") {
                      } else if (((_b = cJSON2.items) === null || _b === void 0 ? void 0 : _b.cjsonType) === "cJSON_Map") {
                      } else if (((_d = cJSON2.items) === null || _d === void 0 ? void 0 : _d.cjsonType) === "cJSON_Invalid" || ((_e = cJSON2.items) === null || _e === void 0 ? void 0 : _e.cjsonType) === "cJSON_NULL") {
                        this.emitLine("list_add_tail(x->value, (", (_f = cJSON2.items) === null || _f === void 0 ? void 0 : _f.cType, " *)0xDEADBEAF, sizeof(", (_g = cJSON2.items) === null || _g === void 0 ? void 0 : _g.cType, " *));");
                      } else if (((_h = cJSON2.items) === null || _h === void 0 ? void 0 : _h.cjsonType) === "cJSON_String") {
                        this.emitLine("list_add_tail(x->value, strdup(", (_j = cJSON2.items) === null || _j === void 0 ? void 0 : _j.getValue, "(e)), sizeof(", (_k = cJSON2.items) === null || _k === void 0 ? void 0 : _k.cType, " *));");
                      } else {
                        this.emitLine(
                          "list_add_tail(x->value, ",
                          // @ts-expect-error awaiting refactor
                          (_l = cJSON2.items) === null || _l === void 0 ? void 0 : _l.getValue,
                          "(e), sizeof(",
                          (_m = cJSON2.items) === null || _m === void 0 ? void 0 : _m.cType,
                          " *));"
                        );
                      }
                    };
                    if ((_a = cJSON.items) === null || _a === void 0 ? void 0 : _a.isNullable) {
                      this.emitBlock([
                        "if (!cJSON_IsNull(e))"
                      ], () => {
                        add(cJSON);
                      });
                      this.emitBlock([
                        "else"
                      ], () => {
                        this.emitLine("list_add_tail(x->value, (void *)0xDEADBEEF, sizeof(void *));");
                      });
                    } else {
                      add(cJSON);
                    }
                  });
                });
              } else if (cJSON.cjsonType === "cJSON_Map" && cJSON.items !== void 0) {
                this.emitLine("x->value = hashtable_create(", this.hashtableSize, ", false);");
                this.emitBlock([
                  "if (NULL != x->value)"
                ], () => {
                  this.emitLine("cJSON * e = NULL;");
                  this.emitBlock([
                    "cJSON_ArrayForEach(e, j)"
                  ], () => {
                    var _a;
                    const add = (cJSON2) => {
                      var _a2, _b, _d, _e, _f, _g, _h, _j, _k, _l, _m;
                      if (((_a2 = cJSON2.items) === null || _a2 === void 0 ? void 0 : _a2.cjsonType) === "cJSON_Array") {
                      } else if (((_b = cJSON2.items) === null || _b === void 0 ? void 0 : _b.cjsonType) === "cJSON_Map") {
                      } else if (((_d = cJSON2.items) === null || _d === void 0 ? void 0 : _d.cjsonType) === "cJSON_Invalid" || ((_e = cJSON2.items) === null || _e === void 0 ? void 0 : _e.cjsonType) === "cJSON_NULL") {
                        this.emitLine("hashtable_add(x->value, e->string, (", (_f = cJSON2.items) === null || _f === void 0 ? void 0 : _f.cType, " *)0xDEADBEEF, sizeof(", (_g = cJSON2.items) === null || _g === void 0 ? void 0 : _g.cType, " *));");
                      } else if (((_h = cJSON2.items) === null || _h === void 0 ? void 0 : _h.cjsonType) === "cJSON_String") {
                        this.emitLine("hashtable_add(x->value, e->string, strdup(", (_j = cJSON2.items) === null || _j === void 0 ? void 0 : _j.getValue, "(e)), sizeof(", (_k = cJSON2.items) === null || _k === void 0 ? void 0 : _k.cType, " *));");
                      } else {
                        this.emitLine(
                          "hashtable_add(x->value, e->string, ",
                          // @ts-expect-error awaiting refactor
                          (_l = cJSON2.items) === null || _l === void 0 ? void 0 : _l.getValue,
                          "(e), sizeof(",
                          (_m = cJSON2.items) === null || _m === void 0 ? void 0 : _m.cType,
                          " *));"
                        );
                      }
                    };
                    if ((_a = cJSON.items) === null || _a === void 0 ? void 0 : _a.isNullable) {
                      this.emitBlock([
                        "if (!cJSON_IsNull(e))"
                      ], () => {
                        add(cJSON);
                      });
                      this.emitBlock([
                        "else"
                      ], () => {
                        this.emitLine("hashtable_add(x->value, e->string, (void *)0xDEADBEEF, sizeof(void *));");
                      });
                    } else {
                      add(cJSON);
                    }
                  });
                });
              } else if (cJSON.cjsonType === "cJSON_Invalid") {
              } else if (cJSON.cjsonType === "cJSON_NULL") {
                this.emitLine("x->value = (", cJSON.cType, " *)0xDEADBEEF;");
              } else if (cJSON.cjsonType === "cJSON_String") {
                this.emitLine("x->value = strdup(", cJSON.getValue, "(j));");
              } else {
                this.emitLine("x->value = ", cJSON.getValue, "(j);");
              }
            });
          });
          this.emitLine("return x;");
        });
        this.ensureBlankLine();
        this.emitBlock([
          "cJSON * cJSON_Create",
          className,
          "(",
          this.withConst([
            "struct ",
            className
          ]),
          " * x)"
        ], () => {
          this.emitLine("cJSON * j = NULL;");
          this.emitBlock([
            "if (NULL != x)"
          ], () => {
            const cJSON = this.quicktypeTypeToCJSON(type, false);
            if (cJSON.cjsonType === "cJSON_Array" && cJSON.items !== void 0) {
              this.emitBlock([
                "if (NULL != x->value)"
              ], () => {
                this.emitLine("j = ", cJSON.createObject, "();");
                this.emitBlock([
                  "if (NULL != j)"
                ], () => {
                  var _a;
                  this.emitLine(
                    // @ts-expect-error awaiting refactor
                    (_a = cJSON.items) === null || _a === void 0 ? void 0 : _a.cType,
                    " * x1 = list_get_head(x->value);"
                  );
                  this.emitBlock([
                    "while (NULL != x1)"
                  ], () => {
                    var _a2;
                    const add = (cJSON2) => {
                      var _a3, _b, _d, _e, _f, _g, _h, _j, _k, _l;
                      if (((_a3 = cJSON2.items) === null || _a3 === void 0 ? void 0 : _a3.cjsonType) === "cJSON_Array") {
                      } else if (((_b = cJSON2.items) === null || _b === void 0 ? void 0 : _b.cjsonType) === "cJSON_Map") {
                      } else if (((_d = cJSON2.items) === null || _d === void 0 ? void 0 : _d.cjsonType) === "cJSON_Invalid") {
                      } else if (((_e = cJSON2.items) === null || _e === void 0 ? void 0 : _e.cjsonType) === "cJSON_NULL") {
                        this.emitLine("cJSON_AddItemToArray(j, ", (_f = cJSON2.items) === null || _f === void 0 ? void 0 : _f.createObject, "());");
                      } else if (((_g = cJSON2.items) === null || _g === void 0 ? void 0 : _g.cjsonType) === "cJSON_String" || ((_h = cJSON2.items) === null || _h === void 0 ? void 0 : _h.cjsonType) === "cJSON_Object" || ((_j = cJSON2.items) === null || _j === void 0 ? void 0 : _j.cjsonType) === "cJSON_Union") {
                        this.emitLine("cJSON_AddItemToArray(j, ", (_k = cJSON2.items) === null || _k === void 0 ? void 0 : _k.createObject, "(x1));");
                      } else {
                        this.emitLine(
                          "cJSON_AddItemToArray(j, ",
                          // @ts-expect-error awaiting refactor
                          (_l = cJSON2.items) === null || _l === void 0 ? void 0 : _l.createObject,
                          "(*x1));"
                        );
                      }
                    };
                    if ((_a2 = cJSON.items) === null || _a2 === void 0 ? void 0 : _a2.isNullable) {
                      this.emitBlock([
                        "if ((void *)0xDEADBEEF != x1)"
                      ], () => {
                        add(cJSON);
                      });
                      this.emitBlock([
                        "else"
                      ], () => {
                        this.emitLine("cJSON_AddItemToArray(j, cJSON_CreateNull());");
                      });
                    } else {
                      add(cJSON);
                    }
                    this.emitLine("x1 = list_get_next(x->value);");
                  });
                });
              });
            } else if (cJSON.cjsonType === "cJSON_Map" && cJSON.items !== void 0) {
              this.emitBlock([
                "if (NULL != x->value)"
              ], () => {
                this.emitLine("j = ", cJSON.createObject, "();");
                this.emitBlock([
                  "if (NULL != j)"
                ], () => {
                  this.emitLine("char **keys = NULL;");
                  this.emitLine("size_t count = hashtable_get_keys(x->value, &keys);");
                  this.emitBlock([
                    "if (NULL != keys)"
                  ], () => {
                    this.emitBlock([
                      "for (size_t index = 0; index < count; index++)"
                    ], () => {
                      var _a, _b;
                      this.emitLine(
                        // @ts-expect-error awaiting refactor
                        (_a = cJSON.items) === null || _a === void 0 ? void 0 : _a.cType,
                        " *x2 = hashtable_lookup(x->value, keys[index]);"
                      );
                      const add = (cJSON2) => {
                        var _a2, _b2, _d, _e, _f, _g, _h, _j, _k, _l;
                        if (((_a2 = cJSON2.items) === null || _a2 === void 0 ? void 0 : _a2.cjsonType) === "cJSON_Array") {
                        } else if (((_b2 = cJSON2.items) === null || _b2 === void 0 ? void 0 : _b2.cjsonType) === "cJSON_Map") {
                        } else if (((_d = cJSON2.items) === null || _d === void 0 ? void 0 : _d.cjsonType) === "cJSON_Invalid") {
                        } else if (((_e = cJSON2.items) === null || _e === void 0 ? void 0 : _e.cjsonType) === "cJSON_NULL") {
                          this.emitLine(cJSON2.addToObject, "(j, keys[index], ", (_f = cJSON2.items) === null || _f === void 0 ? void 0 : _f.createObject, "());");
                        } else if (((_g = cJSON2.items) === null || _g === void 0 ? void 0 : _g.cjsonType) === "cJSON_String" || ((_h = cJSON2.items) === null || _h === void 0 ? void 0 : _h.cjsonType) === "cJSON_Object" || ((_j = cJSON2.items) === null || _j === void 0 ? void 0 : _j.cjsonType) === "cJSON_Union") {
                          this.emitLine(cJSON2.addToObject, "(j, keys[index], ", (_k = cJSON2.items) === null || _k === void 0 ? void 0 : _k.createObject, "(x2));");
                        } else {
                          this.emitLine(
                            cJSON2.addToObject,
                            "(j, keys[index], ",
                            // @ts-expect-error awaiting refactor
                            (_l = cJSON2.items) === null || _l === void 0 ? void 0 : _l.createObject,
                            "(*x2));"
                          );
                        }
                      };
                      if ((_b = cJSON.items) === null || _b === void 0 ? void 0 : _b.isNullable) {
                        this.emitBlock([
                          "if ((void *)0xDEADBEEF != x2)"
                        ], () => {
                          add(cJSON);
                        });
                        this.emitBlock([
                          "else"
                        ], () => {
                          this.emitLine(cJSON.addToObject, "(j, keys[index], cJSON_CreateNull());");
                        });
                      } else {
                        add(cJSON);
                      }
                    });
                    this.emitLine("cJSON_free(keys);");
                  });
                });
              });
            } else if (cJSON.cjsonType === "cJSON_Invalid") {
            } else if (cJSON.cjsonType === "cJSON_NULL") {
              this.emitLine("j = ", cJSON.createObject, "();");
            } else {
              this.emitLine("j = ", cJSON.createObject, "(x->value);");
            }
          });
          this.emitLine("return j;");
        });
        this.ensureBlankLine();
        this.emitBlock([
          "char * cJSON_Print",
          className,
          "(",
          this.withConst([
            "struct ",
            className
          ]),
          " * x)"
        ], () => {
          this.emitLine("char * s = NULL;");
          this.emitBlock([
            "if (NULL != x)"
          ], () => {
            this.emitLine("cJSON * j = cJSON_Create", className, "(x);");
            this.emitBlock([
              "if (NULL != j)"
            ], () => {
              this.emitLine("s = cJSON_Print(j);");
              this.emitLine("cJSON_Delete(j);");
            });
          });
          this.emitLine("return s;");
        });
        this.ensureBlankLine();
        this.emitBlock([
          "void cJSON_Delete",
          className,
          "(struct ",
          className,
          " * x)"
        ], () => {
          this.emitBlock([
            "if (NULL != x)"
          ], () => {
            const cJSON = this.quicktypeTypeToCJSON(type, false);
            if (cJSON.cjsonType === "cJSON_Array" && cJSON.items !== void 0) {
              this.emitBlock([
                "if (NULL != x->value)"
              ], () => {
                var _a;
                this.emitLine(
                  // @ts-expect-error awaiting refactor
                  (_a = cJSON.items) === null || _a === void 0 ? void 0 : _a.cType,
                  " * x1 = list_get_head(x->value);"
                );
                this.emitBlock([
                  "while (NULL != x1)"
                ], () => {
                  var _a2, _b;
                  if ((_a2 = cJSON.items) === null || _a2 === void 0 ? void 0 : _a2.isNullable) {
                    this.emitBlock([
                      "if ((void *)0xDEADBEEF != x1)"
                    ], () => {
                      var _a3;
                      this.emitLine(
                        // @ts-expect-error awaiting refactor
                        (_a3 = cJSON.items) === null || _a3 === void 0 ? void 0 : _a3.deleteType,
                        "(x1);"
                      );
                    });
                  } else {
                    this.emitLine(
                      // @ts-expect-error awaiting refactor
                      (_b = cJSON.items) === null || _b === void 0 ? void 0 : _b.deleteType,
                      "(x1);"
                    );
                  }
                  this.emitLine("x1 = list_get_next(x->value);");
                });
                this.emitLine(cJSON.deleteType, "(x->value);");
              });
            } else if (cJSON.cjsonType === "cJSON_Map" && cJSON.items !== void 0) {
              this.emitBlock([
                "if (NULL != x->value)"
              ], () => {
                this.emitLine("char **keys = NULL;");
                this.emitLine("size_t count = hashtable_get_keys(x->value, &keys);");
                this.emitBlock([
                  "if (NULL != keys)"
                ], () => {
                  this.emitBlock([
                    "for (size_t index = 0; index < count; index++)"
                  ], () => {
                    var _a;
                    this.emitLine(
                      // @ts-expect-error awaiting refactor
                      (_a = cJSON.items) === null || _a === void 0 ? void 0 : _a.cType,
                      " *x2 = hashtable_lookup(x->value, keys[index]);"
                    );
                    this.emitBlock([
                      "if (NULL != x2)"
                    ], () => {
                      var _a2, _b, _d;
                      if ((_a2 = cJSON.items) === null || _a2 === void 0 ? void 0 : _a2.isNullable) {
                        this.emitBlock([
                          "if ((",
                          (_b = cJSON.items) === null || _b === void 0 ? void 0 : _b.cType,
                          " *)0xDEADBEEF != x2)"
                        ], () => {
                          var _a3;
                          this.emitLine(
                            // @ts-expect-error awaiting refactor
                            (_a3 = cJSON.items) === null || _a3 === void 0 ? void 0 : _a3.deleteType,
                            "(x2);"
                          );
                        });
                      } else {
                        this.emitLine(
                          // @ts-expect-error awaiting refactor
                          (_d = cJSON.items) === null || _d === void 0 ? void 0 : _d.deleteType,
                          "(x2);"
                        );
                      }
                    });
                  });
                  this.emitLine("cJSON_free(keys);");
                });
                this.emitLine(cJSON.deleteType, "(x->value);");
              });
            } else if (cJSON.cjsonType === "cJSON_Invalid" || cJSON.cjsonType === "cJSON_NULL") {
            } else if (cJSON.cjsonType === "cJSON_String" || cJSON.cjsonType === "cJSON_Object" || cJSON.cjsonType === "cJSON_Union") {
              this.emitLine(cJSON.deleteType, "(x->value);");
            } else {
            }
            this.emitLine("cJSON_free(x);");
          });
        });
        this.ensureBlankLine();
      }
      /**
         * Convert quicktype type to cJSON type
         * @param t: quicktype type
         * @param isOptional: true if the field is optional
         * @param isNullable: true if the field is nullable
         * @return cJSON type
         */
      quicktypeTypeToCJSON(t, isOptional, isNullable = false) {
        return (0, TypeUtils_1.matchType)(t, (_anyType) => {
          return {
            cType: "void",
            optionalQualifier: "*",
            cjsonType: "cJSON_Invalid",
            isType: "cJSON_IsInvalid",
            getValue: "",
            addToObject: "",
            createObject: "",
            deleteType: "",
            items: void 0,
            isNullable
          };
        }, (_nullType) => {
          return {
            cType: "void",
            optionalQualifier: "*",
            cjsonType: "cJSON_NULL",
            isType: "cJSON_IsNull",
            getValue: "",
            addToObject: "cJSON_AddNullToObject",
            createObject: "cJSON_CreateNull",
            deleteType: "cJSON_free",
            items: void 0,
            isNullable
          };
        }, (_boolType) => {
          return {
            cType: "bool",
            optionalQualifier: isOptional === true ? "*" : "",
            cjsonType: "cJSON_Bool",
            isType: "cJSON_IsBool",
            getValue: "cJSON_IsTrue",
            addToObject: "cJSON_AddBoolToObject",
            createObject: "cJSON_CreateBool",
            deleteType: "cJSON_free",
            items: void 0,
            isNullable
          };
        }, (_integerType) => {
          return {
            cType: this.typeIntegerSize,
            optionalQualifier: isOptional === true ? "*" : "",
            cjsonType: "cJSON_Number",
            isType: "cJSON_IsNumber",
            getValue: "cJSON_GetNumberValue",
            addToObject: "cJSON_AddNumberToObject",
            createObject: "cJSON_CreateNumber",
            deleteType: "cJSON_free",
            items: void 0,
            isNullable
          };
        }, (_doubleType) => {
          return {
            cType: "double",
            optionalQualifier: isOptional === true ? "*" : "",
            cjsonType: "cJSON_Number",
            isType: "cJSON_IsNumber",
            getValue: "cJSON_GetNumberValue",
            addToObject: "cJSON_AddNumberToObject",
            createObject: "cJSON_CreateNumber",
            deleteType: "cJSON_free",
            items: void 0,
            isNullable
          };
        }, (_stringType) => {
          return {
            cType: "char",
            optionalQualifier: "*",
            cjsonType: "cJSON_String",
            isType: "cJSON_IsString",
            getValue: "cJSON_GetStringValue",
            addToObject: "cJSON_AddStringToObject",
            createObject: "cJSON_CreateString",
            deleteType: "cJSON_free",
            items: void 0,
            isNullable
          };
        }, (arrayType) => {
          const items = this.quicktypeTypeToCJSON(arrayType.items, false);
          return {
            cType: "list_t",
            optionalQualifier: "*",
            cjsonType: "cJSON_Array",
            isType: "cJSON_IsArray",
            getValue: "cJSON_GetArrayItem",
            addToObject: "cJSON_AddItemToObject",
            createObject: "cJSON_CreateArray",
            deleteType: "list_release",
            items,
            isNullable
          };
        }, (classType) => {
          return {
            cType: [
              "struct ",
              this.nameForNamedType(classType)
            ],
            optionalQualifier: "*",
            cjsonType: "cJSON_Object",
            isType: "cJSON_IsObject",
            getValue: [
              "cJSON_Get",
              this.nameForNamedType(classType),
              "Value"
            ],
            addToObject: "cJSON_AddItemToObject",
            createObject: [
              "cJSON_Create",
              this.nameForNamedType(classType)
            ],
            deleteType: [
              "cJSON_Delete",
              this.nameForNamedType(classType)
            ],
            items: void 0,
            isNullable
          };
        }, (mapType) => {
          const items = this.quicktypeTypeToCJSON(mapType.values, false);
          return {
            cType: "hashtable_t",
            optionalQualifier: "*",
            cjsonType: "cJSON_Map",
            isType: "cJSON_IsObject",
            getValue: "",
            addToObject: "cJSON_AddItemToObject",
            createObject: "cJSON_CreateObject",
            deleteType: "hashtable_release",
            items,
            isNullable
          };
        }, (enumType) => {
          return {
            cType: [
              "enum ",
              this.nameForNamedType(enumType)
            ],
            optionalQualifier: isOptional === true ? "*" : "",
            cjsonType: "cJSON_Enum",
            isType: "cJSON_IsString",
            getValue: [
              "cJSON_Get",
              this.nameForNamedType(enumType),
              "Value"
            ],
            addToObject: "cJSON_AddItemToObject",
            createObject: [
              "cJSON_Create",
              this.nameForNamedType(enumType)
            ],
            deleteType: "cJSON_free",
            items: void 0,
            isNullable
          };
        }, (unionType) => {
          const nullable = (0, TypeUtils_1.nullableFromUnion)(unionType);
          if (nullable !== null) {
            return this.quicktypeTypeToCJSON(nullable, true, true);
          }
          return {
            cType: [
              "struct ",
              this.nameForNamedType(unionType)
            ],
            optionalQualifier: "*",
            cjsonType: "cJSON_Union",
            isType: "",
            getValue: [
              "cJSON_Get",
              this.nameForNamedType(unionType),
              "Value"
            ],
            addToObject: "cJSON_AddItemToObject",
            createObject: [
              "cJSON_Create",
              this.nameForNamedType(unionType)
            ],
            deleteType: [
              "cJSON_Delete",
              this.nameForNamedType(unionType)
            ],
            items: void 0,
            isNullable
          };
        });
      }
      /**
         * Function called to create a file
         * @param proposedFilename: source filename provided from stdin
         */
      startFile(proposedFilename) {
        (0, Support_1.assert)(this.currentFilename === void 0, "Previous file wasn't finished");
        if (proposedFilename !== void 0) {
          this.currentFilename = this.sourcelikeToString(proposedFilename);
        }
        if (this.currentFilename !== void 0) {
          this.emitDescriptionBlock([
            this.currentFilename,
            "This file has been autogenerated using quicktype https://github.com/quicktype/quicktype - DO NOT EDIT",
            "This file depends of https://github.com/DaveGamble/cJSON, https://github.com/joelguittet/c-list and https://github.com/joelguittet/c-hashtable",
            "To parse json data from json string use the following: struct <type> * data = cJSON_Parse<type>(<string>);",
            "To get json data from cJSON object use the following: struct <type> * data = cJSON_Get<type>Value(<cjson>);",
            "To get cJSON object from json data use the following: cJSON * cjson = cJSON_Create<type>(<data>);",
            "To print json string from json data use the following: char * string = cJSON_Print<type>(<data>);",
            "To delete json data use the following: cJSON_Delete<type>(<data>);"
          ]);
          this.ensureBlankLine();
          this.emitLine("#ifndef __", (0, Strings_1.allUpperWordStyle)(this.currentFilename.replace(new RegExp(/[^a-zA-Z0-9]+/, "g"), "_")), "__");
          this.emitLine("#define __", (0, Strings_1.allUpperWordStyle)(this.currentFilename.replace(new RegExp(/[^a-zA-Z0-9]+/, "g"), "_")), "__");
          this.ensureBlankLine();
          this.emitLine("#ifdef __cplusplus");
          this.emitLine('extern "C" {');
          this.emitLine("#endif");
          this.ensureBlankLine();
          this.emitIncludeLine("stdint.h", true);
          this.emitIncludeLine("stdbool.h", true);
          this.emitIncludeLine("stdlib.h", true);
          this.emitIncludeLine("string.h", true);
          this.emitIncludeLine("cJSON.h", true);
          this.emitIncludeLine("hashtable.h", true);
          this.emitIncludeLine("list.h", true);
          this.ensureBlankLine();
          this.emitLine("#ifndef cJSON_Bool");
          this.emitLine("#define cJSON_Bool (cJSON_True | cJSON_False)");
          this.emitLine("#endif");
          this.emitLine("#ifndef cJSON_Map");
          this.emitLine("#define cJSON_Map (1 << 16)");
          this.emitLine("#endif");
          this.emitLine("#ifndef cJSON_Enum");
          this.emitLine("#define cJSON_Enum (1 << 17)");
          this.emitLine("#endif");
          this.ensureBlankLine();
        }
      }
      /**
         * Function called to close current file
         */
      finishFile() {
        if (this.currentFilename !== void 0) {
          this.emitLine("#ifdef __cplusplus");
          this.emitLine("}");
          this.emitLine("#endif");
          this.ensureBlankLine();
          this.emitLine("#endif /* __", (0, Strings_1.allUpperWordStyle)(this.currentFilename.replace(new RegExp(/[^a-zA-Z0-9]+/, "g"), "_")), "__ */");
          this.ensureBlankLine();
          super.finishFile((0, Support_1.defined)(this.currentFilename));
          this.currentFilename = void 0;
        }
      }
      /**
         * Check if type need declaration before use
         * @note If returning true, canBeForwardDeclared must be declared
         * @return Always returns true
         */
      get needsTypeDeclarationBeforeUse() {
        return true;
      }
      /**
         * Check if type can be forward declared
         * @return true for classes, false otherwise
         */
      canBeForwardDeclared(type) {
        return type.kind === "class";
      }
      /**
         * Add const to wanted Sourcelike
         * @return Const Sourcelike
         */
      withConst(s) {
        return [
          "const ",
          s
        ];
      }
      /**
         * Emit include line
         * @param name: filename to include
         * @pram global: true if global include, false otherwise (default)
         */
      emitIncludeLine(name, global2 = false) {
        this.emitLine("#include ", global2 ? "<" : '"', name, global2 ? ">" : '"');
      }
      /**
         * Emit description block
         * @param lines: description block lines
         */
      emitDescriptionBlock(lines) {
        this.emitCommentLines(lines, {
          lineStart: " * ",
          beforeComment: "/**",
          afterComment: " */"
        });
      }
      /**
         * Emit code block
         * @param line: code block line
         * @param f: callback function
         * @param withName: name of the block as string
         * @param withSemicolon: true to add semicolon at the end of the block, false otherwise
         * @param withIndent: true to indent the block (default), false otherwise
         */
      emitBlock(line, f, withName = "", withSemicolon = false, withIndent = true) {
        this.emitLine(line, " {");
        this.preventBlankLine();
        if (withIndent) {
          this.indent(f);
        } else {
          f();
        }
        this.preventBlankLine();
        if (withSemicolon) {
          if (withName !== "") {
            this.emitLine("} ", withName, ";");
          } else {
            this.emitLine("};");
          }
        } else {
          if (withName !== "") {
            this.emitLine("} ", withName);
          } else {
            this.emitLine("}");
          }
        }
      }
      /**
         * Emit includes
         * @param type: class, union or enum type
         * @param filename: current file name
         */
      emitIncludes(type, filename) {
        const includes = /* @__PURE__ */ new Map();
        if (type instanceof Type_1.UnionType) {
          this.updateIncludes(false, includes, type);
        } else if (type instanceof Type_1.ClassType) {
          this.forEachClassProperty(type, "none", (_name, _jsonName, property) => {
            this.updateIncludes(true, includes, property.type);
          });
        }
        if (includes.size !== 0) {
          includes.forEach((_rec, name) => {
            name = name.concat(".h");
            if (name !== filename) {
              this.emitIncludeLine(name);
            }
          });
        }
        this.ensureBlankLine();
      }
      /**
         * Compute includes
         * @param isClassMender: true if class, false otherwise
         * @param includes: include map
         * @param propertyType: property type
         */
      updateIncludes(isClassMember, includes, propertyType) {
        const propTypes = this.generatedTypes(isClassMember, propertyType);
        for (const t of propTypes) {
          const typeName = this.sourcelikeToString(t.name);
          const propRecord = {
            kind: void 0,
            typeKind: void 0
          };
          if (t.type instanceof Type_1.ClassType) {
            propRecord.typeKind = "class";
            propRecord.kind = t.level === 0 ? utils_1.IncludeKind.Include : utils_1.IncludeKind.ForwardDeclare;
            if (t.forceInclude) {
              propRecord.kind = utils_1.IncludeKind.Include;
            }
          } else if (t.type instanceof Type_1.EnumType) {
            propRecord.typeKind = "enum";
            propRecord.kind = utils_1.IncludeKind.ForwardDeclare;
          } else if (t.type instanceof Type_1.UnionType) {
            propRecord.typeKind = "union";
            const [maybeNull] = (0, TypeUtils_1.removeNullFromUnion)(t.type, true);
            if (maybeNull !== void 0) {
              propRecord.kind = utils_1.IncludeKind.Include;
            } else {
              if (t.forceInclude) {
                propRecord.kind = utils_1.IncludeKind.Include;
              } else {
                propRecord.kind = utils_1.IncludeKind.ForwardDeclare;
              }
            }
          }
          if (includes.has(typeName)) {
            const incKind = includes.get(typeName);
            if (incKind !== void 0 && incKind.kind === utils_1.IncludeKind.ForwardDeclare) {
              includes.set(typeName, propRecord);
            }
          } else {
            includes.set(typeName, propRecord);
          }
        }
      }
      /**
         * Compute generated types
         * @param isClassMender: true if class, false otherwise
         * @param type: type
         * @return Type record array
         */
      generatedTypes(isClassMember, type) {
        const result = [];
        const recur = (forceInclude, isVariant, l, t) => {
          if (t instanceof Type_1.ArrayType) {
            recur(forceInclude, isVariant, l + 1, t.items);
          } else if (t instanceof Type_1.ClassType) {
            result.push({
              name: this.nameForNamedType(t),
              type: t,
              level: l,
              variant: isVariant,
              forceInclude
            });
          } else if (t instanceof Type_1.MapType) {
            recur(forceInclude, isVariant, l + 1, t.values);
          } else if (t instanceof Type_1.EnumType) {
            result.push({
              name: this.nameForNamedType(t),
              type: t,
              level: l,
              variant: isVariant,
              forceInclude: false
            });
          } else if (t instanceof Type_1.UnionType) {
            if (this.unionNeedsName(t) && isClassMember) {
              forceInclude = true;
              result.push({
                name: this.nameForNamedType(t),
                type: t,
                level: l,
                variant: true,
                forceInclude
              });
            }
            const [hasNull, nonNulls] = (0, TypeUtils_1.removeNullFromUnion)(t);
            isVariant = hasNull !== null;
            for (const tt of nonNulls) {
              recur(forceInclude, isVariant, l + 1, tt);
            }
          }
        };
        recur(false, false, 0, type);
        return result;
      }
    };
    exports.CJSONRenderer = CJSONRenderer;
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/CJSON/language.js
var require_language = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/CJSON/language.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.CJSONTargetLanguage = exports.cJSONLanguageConfig = exports.cJSONOptions = void 0;
    var RendererOptions_1 = require_RendererOptions();
    var TargetLanguage_1 = require_TargetLanguage();
    var CJSONRenderer_1 = require_CJSONRenderer();
    var namingStyles = {
      "pascal-case": "pascal",
      "underscore-case": "underscore",
      "camel-case": "camel",
      "upper-underscore-case": "upper-underscore",
      "pascal-case-upper-acronyms": "pascal-upper-acronyms",
      "camel-case-upper-acronyms": "camel-upper-acronyms"
    };
    exports.cJSONOptions = {
      typeSourceStyle: new RendererOptions_1.EnumOption("source-style", "Source code generation type, whether to generate single or multiple source files", {
        "single-source": true,
        "multi-source": false
      }, "single-source", "secondary"),
      typeIntegerSize: new RendererOptions_1.EnumOption("integer-size", "Integer code generation type (int64_t by default)", {
        int8_t: "int8_t",
        int16_t: "int16_t",
        int32_t: "int32_t",
        int64_t: "int64_t"
      }, "int64_t", "secondary"),
      hashtableSize: new RendererOptions_1.StringOption("hashtable-size", "Hashtable size, used when maps are created (64 by default)", "SIZE", "64"),
      addTypedefAlias: new RendererOptions_1.EnumOption("typedef-alias", "Add typedef alias to unions, structs, and enums (no typedef by default)", {
        "no-typedef": false,
        "add-typedef": true
      }, "no-typedef", "secondary"),
      printStyle: new RendererOptions_1.EnumOption("print-style", "Which cJSON print should be used (formatted by default)", {
        "print-formatted": false,
        "print-unformatted": true
      }, "print-formatted", "secondary"),
      typeNamingStyle: new RendererOptions_1.EnumOption("type-style", "Naming style for types", namingStyles, "pascal-case"),
      memberNamingStyle: new RendererOptions_1.EnumOption("member-style", "Naming style for members", namingStyles, "underscore-case"),
      enumeratorNamingStyle: new RendererOptions_1.EnumOption("enumerator-style", "Naming style for enumerators", namingStyles, "upper-underscore-case")
    };
    exports.cJSONLanguageConfig = {
      displayName: "C (cJSON)",
      names: [
        "cjson",
        "cJSON"
      ],
      extension: "h"
    };
    var CJSONTargetLanguage = class extends TargetLanguage_1.TargetLanguage {
      constructor() {
        super(exports.cJSONLanguageConfig);
      }
      /**
         * Return cJSON generator options
         * @return cJSON generator options array
         */
      getOptions() {
        return exports.cJSONOptions;
      }
      /**
         * Indicate if language support union with both number types
         * @return true
         */
      get supportsUnionsWithBothNumberTypes() {
        return true;
      }
      /**
         * Indicate if language support optional class properties
         * @return true
         */
      get supportsOptionalClassProperties() {
        return true;
      }
      /**
         * Create renderer
         * @param renderContext: render context
         * @param untypedOptionValues
         * @return cJSON renderer
         */
      makeRenderer(renderContext, untypedOptionValues) {
        return new CJSONRenderer_1.CJSONRenderer(this, renderContext, (0, RendererOptions_1.getOptionValues)(exports.cJSONOptions, untypedOptionValues));
      }
    };
    exports.CJSONTargetLanguage = CJSONTargetLanguage;
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/CJSON/index.js
var require_CJSON = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/CJSON/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.CJSONRenderer = exports.cJSONOptions = exports.CJSONTargetLanguage = void 0;
    var language_1 = require_language();
    Object.defineProperty(exports, "CJSONTargetLanguage", {
      enumerable: true,
      get: function() {
        return language_1.CJSONTargetLanguage;
      }
    });
    Object.defineProperty(exports, "cJSONOptions", {
      enumerable: true,
      get: function() {
        return language_1.cJSONOptions;
      }
    });
    var CJSONRenderer_1 = require_CJSONRenderer();
    Object.defineProperty(exports, "CJSONRenderer", {
      enumerable: true,
      get: function() {
        return CJSONRenderer_1.CJSONRenderer;
      }
    });
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/CPlusPlus/constants.js
var require_constants3 = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/CPlusPlus/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.keywords = void 0;
    exports.keywords = [
      "alignas",
      "alignof",
      "and",
      "and_eq",
      "asm",
      "atomic_cancel",
      "atomic_commit",
      "atomic_noexcept",
      "auto",
      "bitand",
      "bitor",
      "bool",
      "break",
      "case",
      "catch",
      "char",
      "char16_t",
      "char32_t",
      "class",
      "compl",
      "concept",
      "const",
      "constexpr",
      "const_cast",
      "continue",
      "co_await",
      "co_return",
      "co_yield",
      "decltype",
      "default",
      "delete",
      "do",
      "double",
      "dynamic_cast",
      "else",
      "enum",
      "explicit",
      "export",
      "extern",
      "false",
      "float",
      "for",
      "friend",
      "goto",
      "if",
      "import",
      "inline",
      "int",
      "long",
      "module",
      "mutable",
      "namespace",
      "new",
      "noexcept",
      "not",
      "not_eq",
      "nullptr",
      "operator",
      "or",
      "or_eq",
      "private",
      "protected",
      "public",
      "register",
      "reinterpret_cast",
      "requires",
      "return",
      "short",
      "signed",
      "sizeof",
      "static",
      "static_assert",
      "static_cast",
      "struct",
      "switch",
      "synchronized",
      "template",
      "this",
      "thread_local",
      "throw",
      "true",
      "try",
      "typedef",
      "typeid",
      "typename",
      "union",
      "unsigned",
      "using",
      "virtual",
      "void",
      "volatile",
      "wchar_t",
      "while",
      "xor",
      "xor_eq",
      "override",
      "final",
      "transaction_safe",
      "transaction_safe_dynamic",
      "NULL"
    ];
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/attributes/Constraints.js
var require_Constraints = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/attributes/Constraints.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.patternTypeAttributeKind = exports.PatternTypeAttributeKind = exports.minMaxLengthTypeAttributeKind = exports.minMaxTypeAttributeKind = exports.MinMaxConstraintTypeAttributeKind = void 0;
    exports.minMaxAttributeProducer = minMaxAttributeProducer;
    exports.minMaxLengthAttributeProducer = minMaxLengthAttributeProducer;
    exports.minMaxValueForType = minMaxValueForType;
    exports.minMaxLengthForType = minMaxLengthForType;
    exports.patternAttributeProducer = patternAttributeProducer;
    exports.patternForType = patternForType;
    var Messages_1 = require_Messages();
    var Support_1 = require_Support();
    var TypeAttributes_1 = require_TypeAttributes();
    function checkMinMaxConstraint(minmax) {
      const [min, max] = minmax;
      if (typeof min === "number" && typeof max === "number" && min > max) {
        return (0, Messages_1.messageError)("MiscInvalidMinMaxConstraint", {
          min,
          max
        });
      }
      if (min === void 0 && max === void 0) {
        return void 0;
      }
      return minmax;
    }
    var MinMaxConstraintTypeAttributeKind = class extends TypeAttributes_1.TypeAttributeKind {
      constructor(name, _typeKinds, _minSchemaProperty, _maxSchemaProperty) {
        super(name);
        this._typeKinds = _typeKinds;
        this._minSchemaProperty = _minSchemaProperty;
        this._maxSchemaProperty = _maxSchemaProperty;
      }
      get inIdentity() {
        return true;
      }
      combine(arr) {
        (0, Support_1.assert)(arr.length > 0);
        let [min, max] = arr[0];
        for (let i2 = 1; i2 < arr.length; i2++) {
          const [otherMin, otherMax] = arr[i2];
          if (typeof min === "number" && typeof otherMin === "number") {
            min = Math.min(min, otherMin);
          } else {
            min = void 0;
          }
          if (typeof max === "number" && typeof otherMax === "number") {
            max = Math.max(max, otherMax);
          } else {
            max = void 0;
          }
        }
        return checkMinMaxConstraint([
          min,
          max
        ]);
      }
      intersect(arr) {
        (0, Support_1.assert)(arr.length > 0);
        let [min, max] = arr[0];
        for (let i2 = 1; i2 < arr.length; i2++) {
          const [otherMin, otherMax] = arr[i2];
          if (typeof min === "number" && typeof otherMin === "number") {
            min = Math.max(min, otherMin);
          } else if (min === void 0) {
            min = otherMin;
          }
          if (typeof max === "number" && typeof otherMax === "number") {
            max = Math.min(max, otherMax);
          } else if (max === void 0) {
            max = otherMax;
          }
        }
        return checkMinMaxConstraint([
          min,
          max
        ]);
      }
      makeInferred(_) {
        return void 0;
      }
      addToSchema(schema, t, attr) {
        if (this._typeKinds.has(t.kind)) return;
        const [min, max] = attr;
        if (min !== void 0) {
          schema[this._minSchemaProperty] = min;
        }
        if (max !== void 0) {
          schema[this._maxSchemaProperty] = max;
        }
      }
      stringify([min, max]) {
        return `${min}-${max}`;
      }
    };
    exports.MinMaxConstraintTypeAttributeKind = MinMaxConstraintTypeAttributeKind;
    exports.minMaxTypeAttributeKind = new MinMaxConstraintTypeAttributeKind("minMax", /* @__PURE__ */ new Set([
      "integer",
      "double"
    ]), "minimum", "maximum");
    exports.minMaxLengthTypeAttributeKind = new MinMaxConstraintTypeAttributeKind("minMaxLength", /* @__PURE__ */ new Set([
      "string"
    ]), "minLength", "maxLength");
    function producer(schema, minProperty, maxProperty) {
      if (!(typeof schema === "object")) return void 0;
      let min = void 0;
      let max = void 0;
      if (typeof schema[minProperty] === "number") {
        min = schema[minProperty];
      }
      if (typeof schema[maxProperty] === "number") {
        max = schema[maxProperty];
      }
      if (min === void 0 && max === void 0) return void 0;
      return [
        min,
        max
      ];
    }
    function minMaxAttributeProducer(schema, _ref, types) {
      if (!types.has("number") && !types.has("integer")) return void 0;
      const maybeMinMax = producer(schema, "minimum", "maximum");
      if (maybeMinMax === void 0) return void 0;
      return {
        forNumber: exports.minMaxTypeAttributeKind.makeAttributes(maybeMinMax)
      };
    }
    function minMaxLengthAttributeProducer(schema, _ref, types) {
      if (!types.has("string")) return void 0;
      const maybeMinMaxLength = producer(schema, "minLength", "maxLength");
      if (maybeMinMaxLength === void 0) return void 0;
      return {
        forString: exports.minMaxLengthTypeAttributeKind.makeAttributes(maybeMinMaxLength)
      };
    }
    function minMaxValueForType(t) {
      return exports.minMaxTypeAttributeKind.tryGetInAttributes(t.getAttributes());
    }
    function minMaxLengthForType(t) {
      return exports.minMaxLengthTypeAttributeKind.tryGetInAttributes(t.getAttributes());
    }
    var PatternTypeAttributeKind = class extends TypeAttributes_1.TypeAttributeKind {
      constructor() {
        super("pattern");
      }
      get inIdentity() {
        return true;
      }
      combine(arr) {
        (0, Support_1.assert)(arr.length > 0);
        return arr.map((p) => `(${p})`).join("|");
      }
      intersect(_arr) {
        return void 0;
      }
      makeInferred(_) {
        return void 0;
      }
      addToSchema(schema, t, attr) {
        if (t.kind !== "string") return;
        schema.pattern = attr;
      }
    };
    exports.PatternTypeAttributeKind = PatternTypeAttributeKind;
    exports.patternTypeAttributeKind = new PatternTypeAttributeKind();
    function patternAttributeProducer(schema, _ref, types) {
      if (!(typeof schema === "object")) return void 0;
      if (!types.has("string")) return void 0;
      const patt = schema.pattern;
      if (typeof patt !== "string") return void 0;
      return {
        forString: exports.patternTypeAttributeKind.makeAttributes(patt)
      };
    }
    function patternForType(t) {
      return exports.patternTypeAttributeKind.tryGetInAttributes(t.getAttributes());
    }
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/CPlusPlus/utils.js
var require_utils2 = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/CPlusPlus/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.BaseString = exports.WrappingCode = exports.MemberNames = exports.GlobalNames = exports.IncludeKind = exports.optionalFactoryAsSharedType = exports.optionalAsSharedType = exports.legalizeName = void 0;
    exports.constraintsForType = constraintsForType;
    exports.addQualifier = addQualifier;
    var Constraints_1 = require_Constraints();
    var Strings_1 = require_Strings();
    function constraintsForType(t) {
      const minMax = (0, Constraints_1.minMaxValueForType)(t);
      const minMaxLength = (0, Constraints_1.minMaxLengthForType)(t);
      const pattern = (0, Constraints_1.patternForType)(t);
      if (minMax === void 0 && minMaxLength === void 0 && pattern === void 0) return void 0;
      return {
        minMax,
        minMaxLength,
        pattern
      };
    }
    exports.legalizeName = (0, Strings_1.legalizeCharacters)((cp) => (0, Strings_1.isAscii)(cp) && (0, Strings_1.isLetterOrUnderscoreOrDigit)(cp));
    exports.optionalAsSharedType = "std::shared_ptr";
    exports.optionalFactoryAsSharedType = "std::make_shared";
    var IncludeKind;
    (function(IncludeKind2) {
      IncludeKind2["ForwardDeclare"] = "ForwardDeclare";
      IncludeKind2["Include"] = "Include";
    })(IncludeKind || (exports.IncludeKind = IncludeKind = {}));
    var GlobalNames;
    (function(GlobalNames2) {
      GlobalNames2[GlobalNames2["ClassMemberConstraints"] = 1] = "ClassMemberConstraints";
      GlobalNames2[GlobalNames2["ClassMemberConstraintException"] = 2] = "ClassMemberConstraintException";
      GlobalNames2[GlobalNames2["ValueTooLowException"] = 3] = "ValueTooLowException";
      GlobalNames2[GlobalNames2["ValueTooHighException"] = 4] = "ValueTooHighException";
      GlobalNames2[GlobalNames2["ValueTooShortException"] = 5] = "ValueTooShortException";
      GlobalNames2[GlobalNames2["ValueTooLongException"] = 6] = "ValueTooLongException";
      GlobalNames2[GlobalNames2["InvalidPatternException"] = 7] = "InvalidPatternException";
      GlobalNames2[GlobalNames2["CheckConstraint"] = 8] = "CheckConstraint";
    })(GlobalNames || (exports.GlobalNames = GlobalNames = {}));
    var MemberNames;
    (function(MemberNames2) {
      MemberNames2[MemberNames2["MinIntValue"] = 1] = "MinIntValue";
      MemberNames2[MemberNames2["GetMinIntValue"] = 2] = "GetMinIntValue";
      MemberNames2[MemberNames2["SetMinIntValue"] = 3] = "SetMinIntValue";
      MemberNames2[MemberNames2["MaxIntValue"] = 4] = "MaxIntValue";
      MemberNames2[MemberNames2["GetMaxIntValue"] = 5] = "GetMaxIntValue";
      MemberNames2[MemberNames2["SetMaxIntValue"] = 6] = "SetMaxIntValue";
      MemberNames2[MemberNames2["MinDoubleValue"] = 7] = "MinDoubleValue";
      MemberNames2[MemberNames2["GetMinDoubleValue"] = 8] = "GetMinDoubleValue";
      MemberNames2[MemberNames2["SetMinDoubleValue"] = 9] = "SetMinDoubleValue";
      MemberNames2[MemberNames2["MaxDoubleValue"] = 10] = "MaxDoubleValue";
      MemberNames2[MemberNames2["GetMaxDoubleValue"] = 11] = "GetMaxDoubleValue";
      MemberNames2[MemberNames2["SetMaxDoubleValue"] = 12] = "SetMaxDoubleValue";
      MemberNames2[MemberNames2["MinLength"] = 13] = "MinLength";
      MemberNames2[MemberNames2["GetMinLength"] = 14] = "GetMinLength";
      MemberNames2[MemberNames2["SetMinLength"] = 15] = "SetMinLength";
      MemberNames2[MemberNames2["MaxLength"] = 16] = "MaxLength";
      MemberNames2[MemberNames2["GetMaxLength"] = 17] = "GetMaxLength";
      MemberNames2[MemberNames2["SetMaxLength"] = 18] = "SetMaxLength";
      MemberNames2[MemberNames2["Pattern"] = 19] = "Pattern";
      MemberNames2[MemberNames2["GetPattern"] = 20] = "GetPattern";
      MemberNames2[MemberNames2["SetPattern"] = 21] = "SetPattern";
    })(MemberNames || (exports.MemberNames = MemberNames = {}));
    function addQualifier(qualifier, qualified) {
      if (qualified.length === 0) {
        return [];
      }
      return [
        qualifier,
        qualified
      ];
    }
    var WrappingCode = class {
      constructor(start, end) {
        this.start = start;
        this.end = end;
      }
      wrap(qualifier, inner) {
        return [
          addQualifier(qualifier, this.start),
          inner,
          this.end
        ];
      }
    };
    exports.WrappingCode = WrappingCode;
    var BaseString = class {
      constructor(stringType, constStringType, smatch, regex, stringLiteralPrefix, toString, encodingClass, encodingFunction) {
        this._stringType = stringType;
        this._constStringType = constStringType;
        this._smatch = smatch;
        this._regex = regex;
        this._stringLiteralPrefix = stringLiteralPrefix;
        this._toString = toString;
        this._encodingClass = encodingClass;
        this._encodingFunction = encodingFunction;
      }
      getType() {
        return this._stringType;
      }
      getConstType() {
        return this._constStringType;
      }
      getSMatch() {
        return this._smatch;
      }
      getRegex() {
        return this._regex;
      }
      createStringLiteral(inner) {
        return [
          this._stringLiteralPrefix,
          '"',
          inner,
          '"'
        ];
      }
      wrapToString(inner) {
        return this._toString.wrap([], inner);
      }
    };
    exports.BaseString = BaseString;
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/CPlusPlus/CPlusPlusRenderer.js
var require_CPlusPlusRenderer = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/CPlusPlus/CPlusPlusRenderer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.CPlusPlusRenderer = void 0;
    var collection_utils_1 = require_dist();
    var Annotation_1 = require_Annotation();
    var AccessorNames_1 = require_AccessorNames();
    var EnumValues_1 = require_EnumValues();
    var ConvenienceRenderer_1 = require_ConvenienceRenderer();
    var Naming_1 = require_Naming();
    var Source_1 = require_Source();
    var Strings_1 = require_Strings();
    var Support_1 = require_Support();
    var Type_1 = require_Type2();
    var TypeUtils_1 = require_TypeUtils();
    var constants_1 = require_constants3();
    var utils_1 = require_utils2();
    var CPlusPlusRenderer = class extends ConvenienceRenderer_1.ConvenienceRenderer {
      constructor(targetLanguage, renderContext, _options) {
        super(targetLanguage, renderContext);
        this._options = _options;
        this._gettersAndSettersForPropertyName = /* @__PURE__ */ new Map();
        this.NarrowString = new class extends utils_1.BaseString {
          constructor() {
            super("std::string", "const std::string & ", "std::smatch", "std::regex", "", new utils_1.WrappingCode([
              "std::to_string("
            ], [
              ")"
            ]), "", "");
          }
          wrapEncodingChange(_qualifier, _fromType, _toType, inner) {
            return inner;
          }
          emitHelperFunctions() {
            return;
          }
        }();
        this.WideString = new class extends utils_1.BaseString {
          constructor(superThis) {
            super("std::wstring", "const std::wstring & ", "std::wsmatch", "std::wregex", "L", new utils_1.WrappingCode([
              "std::to_wstring("
            ], [
              ")"
            ]), "Utf16_Utf8", "convert");
            this.superThis = superThis;
          }
          wrapEncodingChange(qualifier, fromType, toType, inner) {
            if (this.superThis.sourcelikeToString(fromType) === this.superThis.sourcelikeToString(toType)) {
              return inner;
            }
            return [
              (0, utils_1.addQualifier)(qualifier, [
                this._encodingClass
              ]),
              "<",
              fromType,
              ", ",
              toType,
              ">::",
              this._encodingFunction,
              "(",
              inner,
              ")"
            ];
          }
          emitHelperFunctions() {
            this.superThis.emitLine("template<typename T>");
            this.superThis.emitLine("struct tag {};");
            this.superThis.ensureBlankLine();
            this.superThis.emitLine("template<typename fromType, typename toType>");
            this.superThis.emitBlock([
              "class Utf16_Utf8"
            ], true, () => {
              this.superThis.emitLine("private:");
              this.superThis.emitLine("template<typename TF, typename TT>");
              this.superThis.emitBlock([
                "static toType convert(tag<std::shared_ptr<TF> >, tag<std::shared_ptr<TT> >, fromType ptr)"
              ], false, () => {
                this.superThis.emitLine("if (ptr == nullptr) return std::unique_ptr<TT>(); else return std::unique_ptr<TT>(new TT(Utf16_Utf8<TF,TT>::convert(*ptr)));");
              });
              this.superThis.ensureBlankLine();
              this.superThis.emitLine("template<typename TF, typename TT>");
              this.superThis.emitBlock([
                "static toType convert(tag<std::vector<TF> >, tag<std::vector<TT> >, fromType v)"
              ], false, () => {
                this.superThis.emitLine("auto it = v.begin();");
                this.superThis.emitLine("auto newVector = std::vector<TT>();");
                this.superThis.emitBlock([
                  "while (it != v.end())"
                ], false, () => {
                  this.superThis.emitLine("newVector.push_back(Utf16_Utf8<TF,TT>::convert(*it));");
                  this.superThis.emitLine("it++;");
                });
                this.superThis.emitLine("return newVector;");
              });
              this.superThis.ensureBlankLine();
              this.superThis.emitLine("template<typename KF, typename VF, typename KT, typename VT>");
              this.superThis.emitBlock([
                "static toType convert(tag<std::map<KF,VF> >, tag<std::map<KT,VT> >, fromType m)"
              ], false, () => {
                this.superThis.emitLine("auto it = m.begin();");
                this.superThis.emitLine("auto newMap = std::map<KT, VT>();");
                this.superThis.emitBlock([
                  "while (it != m.end())"
                ], false, () => {
                  this.superThis.emitLine("newMap.insert(std::pair<KT, VT>(Utf16_Utf8<KF, KT>::convert(it->first), Utf16_Utf8<VF, VT>::convert(it->second)));");
                  this.superThis.emitLine("it++;");
                });
                this.superThis.emitLine("return newMap;");
              });
              this.superThis.ensureBlankLine();
              this.superThis.emitLine("template<typename TF, typename TT>");
              this.superThis.emitBlock([
                "static fromType convert(tag<TF>, tag<TT>, fromType from)"
              ], false, () => {
                this.superThis.emitLine("return from;");
              });
              this.superThis.ensureBlankLine();
              this.superThis.emitBlock([
                "static std::wstring convert(tag<std::string>, tag<std::wstring>, std::string str)"
              ], false, () => {
                this.superThis.emitLine("return std::wstring_convert<std::codecvt_utf8_utf16<wchar_t, 0x10ffff, std::little_endian>, wchar_t>{}.from_bytes(str.data());");
              });
              this.superThis.ensureBlankLine();
              this.superThis.emitBlock([
                "static std::string convert(tag<std::wstring>, tag<std::string>, std::wstring str)"
              ], false, () => {
                this.superThis.emitLine("return std::wstring_convert<std::codecvt_utf8_utf16<wchar_t, 0x10ffff, std::little_endian>, wchar_t>{}.to_bytes(str.data());");
              });
              this.superThis.ensureBlankLine();
              this.superThis.emitLine("public:");
              this.superThis.emitBlock([
                "static toType convert(fromType in)"
              ], false, () => {
                this.superThis.emitLine("return convert(tag<fromType>(), tag<toType>(), in);");
              });
            });
            this.superThis.ensureBlankLine();
            this.superThis.emitLine("template<typename T>");
            this.superThis.emitBlock([
              "std::wstring wdump(const T& j)"
            ], false, () => {
              this.superThis.emitLine("std::ostringstream s;");
              this.superThis.emitLine("s << j;");
              this.superThis.emitLine("return ", this.superThis.ourQualifier(false), "Utf16_Utf8<std::string, std::wstring>::convert(s.str()); ");
            });
            this.superThis.ensureBlankLine();
          }
        }(this);
        this._enumType = _options.enumType;
        this._namespaceNames = _options.namespace.split("::");
        this.typeNamingStyle = _options.typeNamingStyle;
        this._namedTypeNameStyle = (0, Strings_1.makeNameStyle)(this.typeNamingStyle, utils_1.legalizeName);
        this.enumeratorNamingStyle = _options.enumeratorNamingStyle;
        this._memberNameStyle = (0, Strings_1.makeNameStyle)(_options.memberNamingStyle, utils_1.legalizeName);
        this._memberNamingFunction = (0, Naming_1.funPrefixNamer)("members", this._memberNameStyle);
        this._gettersAndSettersForPropertyName = /* @__PURE__ */ new Map();
        this._allTypeNames = /* @__PURE__ */ new Set();
        this._generatedFiles = /* @__PURE__ */ new Set();
        this._generatedGlobalNames = /* @__PURE__ */ new Map();
        this._generatedMemberNames = /* @__PURE__ */ new Map();
        this._forbiddenGlobalNames = [];
        if (_options.wstring) {
          this._stringType = this.WideString;
        } else {
          this._stringType = this.NarrowString;
        }
        if (_options.boost) {
          this._optionalType = "boost::optional";
          this._optionalFactory = "boost::optional";
          this._nulloptType = "boost::none";
          this._variantType = "boost::variant";
          this._variantIndexMethodName = "which";
        } else {
          this._optionalType = "std::optional";
          this._optionalFactory = "std::make_optional";
          this._nulloptType = "std::nullopt";
          this._variantType = "std::variant";
          this._variantIndexMethodName = "index";
        }
        this.setupGlobalNames();
      }
      // union typeguard
      isUnion(t) {
        return t.kind === "union";
      }
      // Returns true if the type can be stored in
      // a stack based optional type. This requires
      // that the type does not require forward declaration.
      isOptionalAsValuePossible(t) {
        if (this.isForwardDeclaredType(t)) return false;
        if (this.isUnion(t)) {
          const [, nonNulls] = (0, TypeUtils_1.removeNullFromUnion)(t);
          if (nonNulls.size === 1) {
            const tt = (0, Support_1.defined)((0, collection_utils_1.iterableFirst)(nonNulls));
            return !this.isCycleBreakerType(tt);
          }
        }
        return !this.isCycleBreakerType(t);
      }
      isImplicitCycleBreaker(t) {
        const kind = t.kind;
        return kind === "array" || kind === "map";
      }
      // Is likely to return std::optional or boost::optional
      optionalTypeStack() {
        return this._optionalType;
      }
      // Is likely to return std::make_optional or boost::optional
      optionalFactoryStack() {
        return this._optionalFactory;
      }
      // Is likely to return std::shared_ptr
      optionalTypeHeap() {
        return utils_1.optionalAsSharedType;
      }
      // Is likely to return std::make_shared
      optionalFactoryHeap() {
        return utils_1.optionalFactoryAsSharedType;
      }
      // Returns the optional type most suitable for the given type.
      // Classes that don't require forward declarations can be stored
      // in std::optional ( or boost::optional )
      optionalType(t) {
        if (this.isOptionalAsValuePossible(t)) {
          return this.optionalTypeStack();
        }
        return this.optionalTypeHeap();
      }
      // Returns a label that can be used to distinguish between
      // heap and stack based optional handling methods
      optionalTypeLabel(t) {
        if (this.isOptionalAsValuePossible(t)) {
          return "stack";
        }
        return "heap";
      }
      getConstraintMembers() {
        return [
          {
            name: utils_1.MemberNames.MinIntValue,
            getter: utils_1.MemberNames.GetMinIntValue,
            setter: utils_1.MemberNames.SetMinIntValue,
            cppType: "int64_t"
          },
          {
            name: utils_1.MemberNames.MaxIntValue,
            getter: utils_1.MemberNames.GetMaxIntValue,
            setter: utils_1.MemberNames.SetMaxIntValue,
            cppType: "int64_t"
          },
          {
            name: utils_1.MemberNames.MinDoubleValue,
            getter: utils_1.MemberNames.GetMinDoubleValue,
            setter: utils_1.MemberNames.SetMinDoubleValue,
            cppType: "double"
          },
          {
            name: utils_1.MemberNames.MaxDoubleValue,
            getter: utils_1.MemberNames.GetMaxDoubleValue,
            setter: utils_1.MemberNames.SetMaxDoubleValue,
            cppType: "double"
          },
          {
            name: utils_1.MemberNames.MinLength,
            getter: utils_1.MemberNames.GetMinLength,
            setter: utils_1.MemberNames.SetMinLength,
            cppType: "size_t"
          },
          {
            name: utils_1.MemberNames.MaxLength,
            getter: utils_1.MemberNames.GetMaxLength,
            setter: utils_1.MemberNames.SetMaxLength,
            cppType: "size_t"
          },
          {
            name: utils_1.MemberNames.Pattern,
            getter: utils_1.MemberNames.GetPattern,
            setter: utils_1.MemberNames.SetPattern,
            cppType: this._stringType.getType(),
            cppConstType: this._stringType.getConstType()
          }
        ];
      }
      lookupGlobalName(type) {
        return (0, Support_1.defined)(this._generatedGlobalNames.get(type));
      }
      lookupMemberName(type) {
        return (0, Support_1.defined)(this._generatedMemberNames.get(type));
      }
      addGlobalName(type) {
        const genName = this._namedTypeNameStyle(utils_1.GlobalNames[type]);
        this._generatedGlobalNames.set(type, genName);
        this._forbiddenGlobalNames.push(genName);
      }
      addMemberName(type) {
        this._generatedMemberNames.set(type, this._memberNameStyle(utils_1.MemberNames[type]));
      }
      setupGlobalNames() {
        for (const v of (0, Support_1.numberEnumValues)(utils_1.GlobalNames)) {
          this.addGlobalName(v);
        }
        for (const v of (0, Support_1.numberEnumValues)(utils_1.MemberNames)) {
          this.addMemberName(v);
        }
      }
      forbiddenNamesForGlobalNamespace() {
        return [
          ...constants_1.keywords,
          ...this._forbiddenGlobalNames
        ];
      }
      forbiddenForObjectProperties(_c, _className) {
        return {
          names: [],
          includeGlobalForbidden: true
        };
      }
      forbiddenForEnumCases(_e, _enumName) {
        return {
          names: [],
          includeGlobalForbidden: true
        };
      }
      makeNamedTypeNamer() {
        return (0, Naming_1.funPrefixNamer)("types", this._namedTypeNameStyle);
      }
      namerForObjectProperty() {
        return this._memberNamingFunction;
      }
      makeUnionMemberNamer() {
        return null;
      }
      makeEnumCaseNamer() {
        return (0, Naming_1.funPrefixNamer)("enumerators", (0, Strings_1.makeNameStyle)(this.enumeratorNamingStyle, utils_1.legalizeName));
      }
      makeNamesForPropertyGetterAndSetter(_c, _className, _p, _jsonName, name) {
        const getterName = new Naming_1.DependencyName(this._memberNamingFunction, name.order, (lookup) => `get_${lookup(name)}`);
        const mutableGetterName = new Naming_1.DependencyName(this._memberNamingFunction, name.order, (lookup) => `getMutable_${lookup(name)}`);
        const setterName = new Naming_1.DependencyName(this._memberNamingFunction, name.order, (lookup) => `set_${lookup(name)}`);
        return [
          getterName,
          mutableGetterName,
          setterName
        ];
      }
      makePropertyDependencyNames(c, className, p, jsonName, name) {
        const getterAndSetterNames = this.makeNamesForPropertyGetterAndSetter(c, className, p, jsonName, name);
        this._gettersAndSettersForPropertyName.set(name, getterAndSetterNames);
        return getterAndSetterNames;
      }
      withConst(s) {
        if (this._options.westConst) {
          return [
            "const ",
            s
          ];
        }
        return [
          s,
          " const"
        ];
      }
      emitInclude(global2, name) {
        this.emitLine("#include ", global2 ? "<" : '"', name, global2 ? ">" : '"');
      }
      startFile(basename, includeHelper = true) {
        (0, Support_1.assert)(this._currentFilename === void 0, "Previous file wasn't finished");
        if (basename !== void 0) {
          this._currentFilename = this.sourcelikeToString(basename);
        }
        if (this.leadingComments !== void 0) {
          this.emitComments(this.leadingComments);
        } else if (!this._options.justTypes) {
          this.emitCommentLines([
            " To parse this JSON data, first install",
            ""
          ]);
          if (this._options.boost) {
            this.emitCommentLines([
              "     Boost     http://www.boost.org"
            ]);
          }
          this.emitCommentLines([
            "     json.hpp  https://github.com/nlohmann/json",
            "",
            " Then include this file, and then do",
            ""
          ]);
          if (this._options.typeSourceStyle) {
            this.forEachTopLevel("none", (_, topLevelName) => {
              this.emitLine("//     ", topLevelName, " data = nlohmann::json::parse(jsonString);");
            });
          } else {
            this.emitLine("//     ", basename, " data = nlohmann::json::parse(jsonString);");
          }
          if (this._options.wstring) {
            this.emitLine("//");
            this.emitLine("//  You can get std::wstring data back out using");
            this.emitLine("//");
            this.forEachTopLevel("none", (_, topLevelName) => {
              this.emitLine("//     std::wcout << ", "wdump((nlohmann::json) ", topLevelName, ");");
            });
          }
        }
        this.ensureBlankLine();
        this.emitLine("#pragma once");
        this.ensureBlankLine();
        if (this.haveOptionalProperties) {
          if (this._options.boost) {
            this.emitInclude(true, "boost/optional.hpp");
          } else {
            this.emitInclude(true, "optional");
          }
        }
        if (this.haveNamedUnions) {
          if (this._options.boost) {
            this.emitInclude(true, "boost/variant.hpp");
          } else {
            this.emitInclude(true, "variant");
          }
        }
        if (!this._options.justTypes) {
          if (!this._options.includeLocation) {
            this.emitInclude(true, "nlohmann/json.hpp");
          } else {
            this.emitInclude(false, "json.hpp");
          }
          if (includeHelper && !this._options.typeSourceStyle) {
            this.emitInclude(false, "helper.hpp");
          }
        }
        this.ensureBlankLine();
      }
      finishFile() {
        super.finishFile((0, Support_1.defined)(this._currentFilename));
        this._currentFilename = void 0;
      }
      get needsTypeDeclarationBeforeUse() {
        return true;
      }
      canBeForwardDeclared(t) {
        const kind = t.kind;
        return kind === "class";
      }
      emitDescriptionBlock(lines) {
        this.emitCommentLines(lines, {
          lineStart: " * ",
          beforeComment: "/**",
          afterComment: " */"
        });
      }
      emitBlock(line, withSemicolon, f, withIndent = true) {
        this.emitLine(line, " {");
        this.preventBlankLine();
        if (withIndent) {
          this.indent(f);
        } else {
          f();
        }
        this.preventBlankLine();
        if (withSemicolon) {
          this.emitLine("};");
        } else {
          this.emitLine("}");
        }
      }
      emitNamespaces(namespaceNames, f) {
        const namesArray = (0, collection_utils_1.toReadonlyArray)(namespaceNames);
        const first = namesArray[0];
        if (first === void 0) {
          f();
        } else {
          this.emitBlock([
            "namespace ",
            first
          ], false, () => this.emitNamespaces(namesArray.slice(1), f), namesArray.length === 1);
        }
      }
      cppTypeInOptional(nonNulls, ctx, withIssues, forceNarrowString) {
        if (nonNulls.size === 1) {
          return this.cppType((0, Support_1.defined)((0, collection_utils_1.iterableFirst)(nonNulls)), ctx, withIssues, forceNarrowString, false);
        }
        const typeList = [];
        for (const t of nonNulls) {
          if (typeList.length !== 0) {
            typeList.push(", ");
          }
          typeList.push(this.cppType(t, {
            needsForwardIndirection: true,
            needsOptionalIndirection: false,
            inJsonNamespace: ctx.inJsonNamespace
          }, withIssues, false, false));
        }
        return [
          this._variantType,
          "<",
          typeList,
          ">"
        ];
      }
      variantType(u, inJsonNamespace) {
        const [maybeNull, nonNulls] = (0, TypeUtils_1.removeNullFromUnion)(u, true);
        (0, Support_1.assert)(nonNulls.size >= 2, "Variant not needed for less than two types.");
        const indirection = maybeNull !== null;
        const variant = this.cppTypeInOptional(nonNulls, {
          needsForwardIndirection: !indirection,
          needsOptionalIndirection: !indirection,
          inJsonNamespace
        }, true, false);
        if (!indirection) {
          return variant;
        }
        return [
          this.optionalType(u),
          "<",
          variant,
          ">"
        ];
      }
      ourQualifier(inJsonNamespace) {
        return inJsonNamespace ? [
          (0, collection_utils_1.arrayIntercalate)("::", this._namespaceNames),
          "::"
        ] : [];
      }
      jsonQualifier(inJsonNamespace) {
        return inJsonNamespace ? [] : "nlohmann::";
      }
      variantIndirection(type, needIndirection, typeSrc) {
        if (!needIndirection) return typeSrc;
        return [
          this.optionalType(type),
          "<",
          typeSrc,
          ">"
        ];
      }
      cppType(t, ctx, withIssues, forceNarrowString, isOptional) {
        const inJsonNamespace = ctx.inJsonNamespace;
        if (isOptional && t instanceof Type_1.UnionType) {
          for (const tChild of t.getChildren()) {
            if (tChild.isNullable) {
              isOptional = false;
              break;
            }
          }
        }
        const typeSource = (0, TypeUtils_1.matchType)(t, (_anyType) => {
          isOptional = false;
          return (0, Source_1.maybeAnnotated)(withIssues, Annotation_1.anyTypeIssueAnnotation, [
            this.jsonQualifier(inJsonNamespace),
            "json"
          ]);
        }, (_nullType) => {
          isOptional = false;
          return (0, Source_1.maybeAnnotated)(withIssues, Annotation_1.nullTypeIssueAnnotation, [
            this.jsonQualifier(inJsonNamespace),
            "json"
          ]);
        }, (_boolType) => "bool", (_integerType) => "int64_t", (_doubleType) => "double", (_stringType) => {
          if (forceNarrowString) {
            return "std::string";
          }
          return this._stringType.getType();
        }, (arrayType) => [
          "std::vector<",
          this.cppType(arrayType.items, {
            needsForwardIndirection: false,
            needsOptionalIndirection: true,
            inJsonNamespace
          }, withIssues, forceNarrowString, false),
          ">"
        ], (classType) => this.variantIndirection(classType, ctx.needsForwardIndirection && this.isForwardDeclaredType(classType) && !isOptional, [
          this.ourQualifier(inJsonNamespace),
          this.nameForNamedType(classType)
        ]), (mapType) => {
          let keyType = this._stringType.getType();
          if (forceNarrowString) {
            keyType = "std::string";
          }
          return [
            "std::map<",
            keyType,
            ", ",
            this.cppType(mapType.values, {
              needsForwardIndirection: false,
              needsOptionalIndirection: true,
              inJsonNamespace
            }, withIssues, forceNarrowString, false),
            ">"
          ];
        }, (enumType) => [
          this.ourQualifier(inJsonNamespace),
          this.nameForNamedType(enumType)
        ], (unionType) => {
          const nullable = (0, TypeUtils_1.nullableFromUnion)(unionType);
          if (nullable !== null) {
            isOptional = true;
            return this.cppType(nullable, {
              needsForwardIndirection: false,
              needsOptionalIndirection: false,
              inJsonNamespace
            }, withIssues, forceNarrowString, false);
          }
          return [
            this.ourQualifier(inJsonNamespace),
            this.nameForNamedType(unionType)
          ];
        });
        if (!isOptional) return typeSource;
        return [
          this.optionalType(t),
          "<",
          typeSource,
          ">"
        ];
      }
      /**
         * similar to cppType, it practically gathers all the generated types within
         * 't'. It also records, whether a given sub-type is part of a variant or not.
         */
      generatedTypes(isClassMember, theType) {
        const result = [];
        const recur = (forceInclude, isVariant, l, t) => {
          if (t instanceof Type_1.ArrayType) {
            recur(true, isVariant, l + 1, t.items);
          } else if (t instanceof Type_1.ClassType) {
            result.push({
              name: this.nameForNamedType(t),
              type: t,
              level: l,
              variant: isVariant,
              forceInclude
            });
          } else if (t instanceof Type_1.MapType) {
            recur(true, isVariant, l + 1, t.values);
          } else if (t instanceof Type_1.EnumType) {
            result.push({
              name: this.nameForNamedType(t),
              type: t,
              level: l,
              variant: isVariant,
              forceInclude: false
            });
          } else if (t instanceof Type_1.UnionType) {
            if (this.unionNeedsName(t) && isClassMember) {
              forceInclude = true;
              result.push({
                name: this.nameForNamedType(t),
                type: t,
                level: l,
                variant: true,
                forceInclude
              });
            }
            const [hasNull, nonNulls] = (0, TypeUtils_1.removeNullFromUnion)(t);
            isVariant = hasNull !== null;
            for (const tt of nonNulls) {
              recur(forceInclude, isVariant, l + 1, tt);
            }
          }
        };
        recur(false, false, 0, theType);
        return result;
      }
      constraintMember(jsonName) {
        return this._memberNameStyle(`${jsonName}Constraint`);
      }
      emitMember(cppType, name) {
        this.emitLine(cppType, " ", name, ";");
      }
      emitClassMembers(c, constraints) {
        if (this._options.codeFormat) {
          this.emitLine("private:");
          this.forEachClassProperty(c, "none", (name, jsonName, property) => {
            this.emitMember(this.cppType(property.type, {
              needsForwardIndirection: true,
              needsOptionalIndirection: true,
              inJsonNamespace: false
            }, true, false, property.isOptional), name);
            if (constraints === null || constraints === void 0 ? void 0 : constraints.has(jsonName)) {
              const cnst = this.lookupGlobalName(utils_1.GlobalNames.ClassMemberConstraints);
              this.emitMember(cnst, this.constraintMember(jsonName));
            }
          });
          this.ensureBlankLine();
          this.emitLine("public:");
        }
        this.forEachClassProperty(c, "none", (name, jsonName, property) => {
          this.emitDescription(this.descriptionForClassProperty(c, jsonName));
          if (!this._options.codeFormat) {
            this.emitMember(this.cppType(property.type, {
              needsForwardIndirection: true,
              needsOptionalIndirection: true,
              inJsonNamespace: false
            }, true, false, property.isOptional), name);
          } else {
            const [getterName, mutableGetterName, setterName] = (0, Support_1.defined)(this._gettersAndSettersForPropertyName.get(name));
            const rendered = this.cppType(property.type, {
              needsForwardIndirection: true,
              needsOptionalIndirection: true,
              inJsonNamespace: false
            }, true, false, property.isOptional);
            const checkConst = this.lookupGlobalName(utils_1.GlobalNames.CheckConstraint);
            if (property.type instanceof Type_1.UnionType && property.type.findMember("null") !== void 0 || property.isOptional && property.type.kind !== "null" && property.type.kind !== "any") {
              this.emitLine(rendered, " ", getterName, "() const { return ", name, "; }");
              if (constraints === null || constraints === void 0 ? void 0 : constraints.has(jsonName)) {
                this.emitLine("void ", setterName, "(", rendered, " value) { if (value) ", checkConst, "(", this._stringType.createStringLiteral([
                  name
                ]), ", ", this.constraintMember(jsonName), ", *value); this->", name, " = value; }");
              } else {
                this.emitLine("void ", setterName, "(", rendered, " value) { this->", name, " = value; }");
              }
            } else {
              this.emitLine(this.withConst(rendered), " & ", getterName, "() const { return ", name, "; }");
              this.emitLine(rendered, " & ", mutableGetterName, "() { return ", name, "; }");
              if (constraints === null || constraints === void 0 ? void 0 : constraints.has(jsonName)) {
                this.emitLine("void ", setterName, "(", this.withConst(rendered), " & value) { ", checkConst, "(", this._stringType.createStringLiteral([
                  name
                ]), ", ", this.constraintMember(jsonName), ", value); this->", name, " = value; }");
              } else {
                this.emitLine("void ", setterName, "(", this.withConst(rendered), " & value) { this->", name, " = value; }");
              }
            }
            this.ensureBlankLine();
          }
        });
      }
      generateClassConstraints(c) {
        const res = /* @__PURE__ */ new Map();
        this.forEachClassProperty(c, "none", (_name, jsonName, property) => {
          const constraints = (0, utils_1.constraintsForType)(property.type);
          if (constraints === void 0) return;
          const { minMax, minMaxLength, pattern } = constraints;
          const cppType = this.cppType(property.type, {
            needsForwardIndirection: true,
            needsOptionalIndirection: true,
            inJsonNamespace: false
          }, true, false, property.isOptional);
          res.set(jsonName, [
            this.constraintMember(jsonName),
            "(",
            (minMax === null || minMax === void 0 ? void 0 : minMax[0]) && cppType === "int64_t" ? String(minMax[0]) : this._nulloptType,
            ", ",
            (minMax === null || minMax === void 0 ? void 0 : minMax[1]) && cppType === "int64_t" ? String(minMax[1]) : this._nulloptType,
            ", ",
            (minMax === null || minMax === void 0 ? void 0 : minMax[0]) && cppType === "double" ? String(minMax[0]) : this._nulloptType,
            ", ",
            (minMax === null || minMax === void 0 ? void 0 : minMax[1]) && cppType === "double" ? String(minMax[1]) : this._nulloptType,
            ", ",
            (minMaxLength === null || minMaxLength === void 0 ? void 0 : minMaxLength[0]) ? String(minMaxLength[0]) : this._nulloptType,
            ", ",
            (minMaxLength === null || minMaxLength === void 0 ? void 0 : minMaxLength[1]) ? String(minMaxLength[1]) : this._nulloptType,
            ", ",
            pattern === void 0 ? this._nulloptType : [
              this._stringType.getType(),
              "(",
              this._stringType.createStringLiteral([
                (0, Strings_1.stringEscape)(pattern)
              ]),
              ")"
            ],
            ")"
          ]);
        });
        return res.size === 0 ? void 0 : res;
      }
      emitClass(c, className) {
        this.emitDescription(this.descriptionForType(c));
        this.emitBlock([
          this._options.codeFormat ? "class " : "struct ",
          className
        ], true, () => {
          const constraints = this.generateClassConstraints(c);
          if (this._options.codeFormat) {
            this.emitLine("public:");
            if (constraints === void 0) {
              this.emitLine(className, "() = default;");
            } else {
              this.emitLine(className, "() :");
              let numEmits = 0;
              constraints.forEach((initializer, _propName) => {
                numEmits++;
                this.indent(() => {
                  if (numEmits === constraints.size) {
                    this.emitLine(initializer);
                  } else {
                    this.emitLine(initializer, ",");
                  }
                });
              });
              this.emitLine("{}");
            }
            this.emitLine("virtual ~", className, "() = default;");
            this.ensureBlankLine();
          }
          this.emitClassMembers(c, constraints);
        });
      }
      emitTopLevelHeaders(t, className) {
        if (t instanceof Type_1.MapType && this._stringType !== this.NarrowString) {
          const ourQualifier = this.ourQualifier(true);
          this.emitBlock([
            "struct adl_serializer<",
            ourQualifier,
            className,
            ">"
          ], true, () => {
            this.emitLine("template <>");
            this.emitLine("static void from_json(", this.withConst("json"), " & j, ", ourQualifier, className, " & x);");
            this.emitLine("static void to_json(json & j, ", this.withConst([
              ourQualifier,
              className
            ]), " & x);");
          });
        }
      }
      emitClassHeaders(className) {
        const ourQualifier = this.ourQualifier(false);
        this.emitLine("void from_json(", this.withConst("json"), " & j, ", ourQualifier, className, " & x);");
        this.emitLine("void to_json(json & j, ", this.withConst([
          ourQualifier,
          className
        ]), " & x);");
      }
      emitTopLevelFunction(t, className) {
        if (t instanceof Type_1.MapType && this._stringType !== this.NarrowString) {
          const ourQualifier = this.ourQualifier(true);
          let cppType;
          let toType;
          this.emitBlock([
            "inline void adl_serializer<",
            ourQualifier,
            className,
            ">::from_json(",
            this.withConst("json"),
            " & j, ",
            ourQualifier,
            className,
            "& x)"
          ], false, () => {
            cppType = this.cppType(t, {
              needsForwardIndirection: true,
              needsOptionalIndirection: true,
              inJsonNamespace: true
            }, false, true, false);
            toType = this.cppType(t, {
              needsForwardIndirection: true,
              needsOptionalIndirection: true,
              inJsonNamespace: true
            }, false, false, false);
            this.emitLine([
              "x = ",
              this._stringType.wrapEncodingChange([
                ourQualifier
              ], cppType, toType, [
                "j.get<",
                cppType,
                ">()"
              ]),
              ";"
            ]);
          });
          this.emitBlock([
            "inline void adl_serializer<",
            ourQualifier,
            className,
            ">::to_json(json & j, ",
            this.withConst([
              ourQualifier,
              className
            ]),
            " & x)"
          ], false, () => {
            cppType = this.cppType(t, {
              needsForwardIndirection: true,
              needsOptionalIndirection: true,
              inJsonNamespace: true
            }, false, false, false);
            toType = this.cppType(t, {
              needsForwardIndirection: true,
              needsOptionalIndirection: true,
              inJsonNamespace: true
            }, false, true, false);
            this.emitLine([
              "j = ",
              this._stringType.wrapEncodingChange([
                ourQualifier
              ], cppType, toType, "x"),
              ";"
            ]);
          });
        }
      }
      emitClassFunctions(c, className) {
        const ourQualifier = this.ourQualifier(false);
        let cppType;
        let toType;
        this.emitBlock([
          "inline void from_json(",
          this.withConst("json"),
          " & j, ",
          ourQualifier,
          className,
          "& x)"
        ], false, () => {
          this.forEachClassProperty(c, "none", (name, json, p) => {
            const [, , setterName] = (0, Support_1.defined)(this._gettersAndSettersForPropertyName.get(name));
            const propType = p.type;
            let assignment;
            if (this._options.codeFormat) {
              assignment = new utils_1.WrappingCode([
                "x.",
                setterName,
                "("
              ], [
                ")"
              ]);
            } else {
              assignment = new utils_1.WrappingCode([
                "x.",
                name,
                " = "
              ], []);
            }
            if (propType.kind === "null" || propType.kind === "any") {
              this.emitLine(assignment.wrap([], [
                ourQualifier,
                "get_untyped(j, ",
                this._stringType.wrapEncodingChange([
                  ourQualifier
                ], this._stringType.getType(), this.NarrowString.getType(), [
                  this._stringType.createStringLiteral([
                    (0, Strings_1.stringEscape)(json)
                  ])
                ]),
                ")"
              ]), ";");
              return;
            }
            if (p.isOptional || propType instanceof Type_1.UnionType) {
              const [nullOrOptional, typeSet] = (() => {
                if (propType instanceof Type_1.UnionType) {
                  const [maybeNull, nonNulls] = (0, TypeUtils_1.removeNullFromUnion)(propType, true);
                  return [
                    maybeNull !== null || p.isOptional,
                    nonNulls
                  ];
                }
                const set = /* @__PURE__ */ new Set();
                set.add(propType);
                return [
                  true,
                  set
                ];
              })();
              if (nullOrOptional) {
                cppType = this.cppTypeInOptional(typeSet, {
                  needsForwardIndirection: false,
                  needsOptionalIndirection: false,
                  inJsonNamespace: false
                }, false, true);
                toType = this.cppTypeInOptional(typeSet, {
                  needsForwardIndirection: false,
                  needsOptionalIndirection: false,
                  inJsonNamespace: false
                }, false, false);
                this.emitLine(assignment.wrap([], [
                  this._stringType.wrapEncodingChange([
                    ourQualifier
                  ], [
                    this.optionalType(propType),
                    "<",
                    cppType,
                    ">"
                  ], [
                    this.optionalType(propType),
                    "<",
                    toType,
                    ">"
                  ], [
                    ourQualifier,
                    `get_${this.optionalTypeLabel(propType)}_optional<`,
                    cppType,
                    ">(j, ",
                    this._stringType.wrapEncodingChange([
                      ourQualifier
                    ], this._stringType.getType(), this.NarrowString.getType(), [
                      this._stringType.createStringLiteral([
                        (0, Strings_1.stringEscape)(json)
                      ])
                    ]),
                    ")"
                  ])
                ]), ";");
                return;
              }
            }
            cppType = this.cppType(propType, {
              needsForwardIndirection: true,
              needsOptionalIndirection: true,
              inJsonNamespace: false
            }, false, true, p.isOptional);
            toType = this.cppType(propType, {
              needsForwardIndirection: true,
              needsOptionalIndirection: true,
              inJsonNamespace: false
            }, false, false, p.isOptional);
            this.emitLine(assignment.wrap([], this._stringType.wrapEncodingChange([
              ourQualifier
            ], cppType, toType, [
              "j.at(",
              this._stringType.wrapEncodingChange([
                ourQualifier
              ], this._stringType.getType(), this.NarrowString.getType(), this._stringType.createStringLiteral([
                (0, Strings_1.stringEscape)(json)
              ])),
              ").get<",
              cppType,
              ">()"
            ])), ";");
          });
        });
        this.ensureBlankLine();
        this.emitBlock([
          "inline void to_json(json & j, ",
          this.withConst([
            ourQualifier,
            className
          ]),
          " & x)"
        ], false, () => {
          this.emitLine("j = json::object();");
          this.forEachClassProperty(c, "none", (name, json, p) => {
            const propType = p.type;
            cppType = this.cppType(propType, {
              needsForwardIndirection: true,
              needsOptionalIndirection: true,
              inJsonNamespace: false
            }, false, false, p.isOptional);
            toType = this.cppType(propType, {
              needsForwardIndirection: true,
              needsOptionalIndirection: true,
              inJsonNamespace: false
            }, false, true, p.isOptional);
            const [getterName, ,] = (0, Support_1.defined)(this._gettersAndSettersForPropertyName.get(name));
            let getter;
            if (this._options.codeFormat) {
              getter = [
                getterName,
                "()"
              ];
            } else {
              getter = [
                name
              ];
            }
            const assignment = [
              "j[",
              this._stringType.wrapEncodingChange([
                ourQualifier
              ], this._stringType.getType(), this.NarrowString.getType(), this._stringType.createStringLiteral([
                (0, Strings_1.stringEscape)(json)
              ])),
              "] = ",
              this._stringType.wrapEncodingChange([
                ourQualifier
              ], cppType, toType, [
                "x.",
                getter
              ]),
              ";"
            ];
            if (p.isOptional && this._options.hideNullOptional) {
              this.emitBlock([
                "if (",
                this._stringType.wrapEncodingChange([
                  ourQualifier
                ], cppType, toType, [
                  "x.",
                  getter
                ]),
                ")"
              ], false, () => {
                this.emitLine(assignment);
              });
            } else {
              this.emitLine(assignment);
            }
          });
        });
      }
      emitEnum(e, enumName) {
        const caseNames = [];
        const enumValues = (0, EnumValues_1.enumCaseValues)(e, this.targetLanguage.name);
        this.forEachEnumCase(e, "none", (name, jsonName) => {
          if (caseNames.length > 0) caseNames.push(", ");
          caseNames.push(name);
          if (enumValues !== void 0) {
            const [enumValue] = (0, AccessorNames_1.getAccessorName)(enumValues, jsonName);
            if (enumValue !== void 0) {
              caseNames.push(" = ", enumValue.toString());
            }
          }
        });
        this.emitDescription(this.descriptionForType(e));
        this.emitLine("enum class ", enumName, " : ", this._enumType, " { ", caseNames, " };");
      }
      emitUnionTypedefs(u, unionName) {
        this.emitLine("using ", unionName, " = ", this.variantType(u, false), ";");
      }
      emitUnionHeaders(u) {
        const nonNulls = (0, TypeUtils_1.removeNullFromUnion)(u, true)[1];
        const variantType = this.cppTypeInOptional(nonNulls, {
          needsForwardIndirection: false,
          needsOptionalIndirection: false,
          inJsonNamespace: true
        }, false, false);
        this.emitLine("template <>");
        this.emitBlock([
          "struct adl_serializer<",
          variantType,
          ">"
        ], true, () => {
          this.emitLine("static void from_json(", this.withConst("json"), " & j, ", variantType, " & x);");
          this.emitLine("static void to_json(json & j, ", this.withConst(variantType), " & x);");
        });
      }
      emitUnionFunctions(u) {
        const ourQualifier = this.ourQualifier(true);
        const functionForKind = [
          [
            "bool",
            "is_boolean"
          ],
          [
            "integer",
            "is_number_integer"
          ],
          [
            "double",
            "is_number"
          ],
          [
            "string",
            "is_string"
          ],
          [
            "class",
            "is_object"
          ],
          [
            "map",
            "is_object"
          ],
          [
            "array",
            "is_array"
          ],
          [
            "enum",
            "is_string"
          ]
        ];
        const nonNulls = (0, TypeUtils_1.removeNullFromUnion)(u, true)[1];
        const variantType = this.cppTypeInOptional(nonNulls, {
          needsForwardIndirection: false,
          needsOptionalIndirection: false,
          inJsonNamespace: true
        }, false, false);
        this.emitBlock([
          "inline void adl_serializer<",
          variantType,
          ">::from_json(",
          this.withConst("json"),
          " & j, ",
          variantType,
          " & x)"
        ], false, () => {
          let onFirst = true;
          for (const [kind, func] of functionForKind) {
            const typeForKind = (0, collection_utils_1.iterableFind)(nonNulls, (t) => t.kind === kind);
            if (typeForKind === void 0) continue;
            this.emitLine(onFirst ? "if" : "else if", " (j.", func, "())");
            this.indent(() => {
              const cppType = this.cppType(typeForKind, {
                needsForwardIndirection: true,
                needsOptionalIndirection: true,
                inJsonNamespace: true
              }, false, true, false);
              const toType = this.cppType(typeForKind, {
                needsForwardIndirection: true,
                needsOptionalIndirection: true,
                inJsonNamespace: true
              }, false, false, false);
              this.emitLine("x = ", this._stringType.wrapEncodingChange([
                ourQualifier
              ], cppType, toType, [
                "j.get<",
                cppType,
                ">()"
              ]), ";");
            });
            onFirst = false;
          }
          this.emitLine('else throw std::runtime_error("Could not deserialise!");');
        });
        this.ensureBlankLine();
        this.emitBlock([
          "inline void adl_serializer<",
          variantType,
          ">::to_json(json & j, ",
          this.withConst(variantType),
          " & x)"
        ], false, () => {
          this.emitBlock([
            "switch (x.",
            this._variantIndexMethodName,
            "())"
          ], false, () => {
            let i2 = 0;
            for (const t of nonNulls) {
              this.emitLine("case ", i2.toString(), ":");
              this.indent(() => {
                const cppType = this.cppType(t, {
                  needsForwardIndirection: true,
                  needsOptionalIndirection: true,
                  inJsonNamespace: true
                }, false, false, false);
                const toType = this.cppType(t, {
                  needsForwardIndirection: true,
                  needsOptionalIndirection: true,
                  inJsonNamespace: true
                }, false, true, false);
                this.emitLine("j = ", this._stringType.wrapEncodingChange([
                  ourQualifier
                ], cppType, toType, [
                  this._options.boost ? "boost::get<" : "std::get<",
                  cppType,
                  ">(x)"
                ]), ";");
                this.emitLine("break;");
              });
              i2++;
            }
            this.emitLine('default: throw std::runtime_error("Input JSON does not conform to schema!");');
          });
        });
      }
      emitEnumHeaders(enumName) {
        const ourQualifier = this.ourQualifier(false);
        this.emitLine("void from_json(", this.withConst("json"), " & j, ", ourQualifier, enumName, " & x);");
        this.emitLine("void to_json(json & j, ", this.withConst([
          ourQualifier,
          enumName
        ]), " & x);");
      }
      isLargeEnum(e) {
        return e.cases.size > 15;
      }
      emitEnumFunctions(e, enumName) {
        const ourQualifier = this.ourQualifier(false);
        this.emitBlock([
          "inline void from_json(",
          this.withConst("json"),
          " & j, ",
          ourQualifier,
          enumName,
          " & x)"
        ], false, () => {
          if (this.isLargeEnum(e)) {
            this.emitBlock([
              "static std::unordered_map<",
              this._stringType.getType(),
              ", ",
              ourQualifier,
              enumName,
              "> enumValues"
            ], true, () => {
              this.forEachEnumCase(e, "none", (name, jsonName) => {
                this.emitLine("{", this._stringType.wrapEncodingChange([
                  ourQualifier
                ], this._stringType.getType(), this.NarrowString.getType(), [
                  this._stringType.createStringLiteral([
                    (0, Strings_1.stringEscape)(jsonName)
                  ])
                ]), ", ", ourQualifier, enumName, "::", name, "},");
              });
            });
            this.emitLine(`auto iter = enumValues.find(j.get<${this._stringType.getType()}>());`);
            this.emitBlock("if (iter != enumValues.end())", false, () => {
              this.emitLine("x = iter->second;");
            });
          } else {
            let onFirst = true;
            this.forEachEnumCase(e, "none", (name, jsonName) => {
              const maybeElse = onFirst ? "" : "else ";
              this.emitLine(maybeElse, "if (j == ", this._stringType.wrapEncodingChange([
                ourQualifier
              ], this._stringType.getType(), this.NarrowString.getType(), [
                this._stringType.createStringLiteral([
                  (0, Strings_1.stringEscape)(jsonName)
                ])
              ]), ") x = ", ourQualifier, enumName, "::", name, ";");
              onFirst = false;
            });
            this.emitLine('else { throw std::runtime_error("Input JSON does not conform to schema!"); }');
          }
        });
        this.ensureBlankLine();
        this.emitBlock([
          "inline void to_json(json & j, ",
          this.withConst([
            ourQualifier,
            enumName
          ]),
          " & x)"
        ], false, () => {
          this.emitBlock("switch (x)", false, () => {
            this.forEachEnumCase(e, "none", (name, jsonName) => {
              this.emitLine("case ", ourQualifier, enumName, "::", name, ": j = ", this._stringType.wrapEncodingChange([
                ourQualifier
              ], this._stringType.getType(), this.NarrowString.getType(), [
                this._stringType.createStringLiteral([
                  (0, Strings_1.stringEscape)(jsonName)
                ])
              ]), "; break;");
            });
            this.emitLine(`default: throw std::runtime_error("Unexpected value in enumeration \\"`, enumName, `\\": " + std::to_string(static_cast<int>(x)));`);
          });
        });
      }
      emitTopLevelTypedef(t, name) {
        this.emitLine("using ", name, " = ", this.cppType(t, {
          needsForwardIndirection: true,
          needsOptionalIndirection: true,
          inJsonNamespace: false
        }, true, false, false), ";");
      }
      emitAllUnionFunctions() {
        this.forEachUniqueUnion("leading-and-interposing", (u) => this.sourcelikeToString(this.cppTypeInOptional((0, TypeUtils_1.removeNullFromUnion)(u, true)[1], {
          needsForwardIndirection: false,
          needsOptionalIndirection: false,
          inJsonNamespace: true
        }, false, false)), (u) => this.emitUnionFunctions(u));
      }
      emitAllUnionHeaders() {
        this.forEachUniqueUnion("interposing", (u) => this.sourcelikeToString(this.cppTypeInOptional((0, TypeUtils_1.removeNullFromUnion)(u, true)[1], {
          needsForwardIndirection: false,
          needsOptionalIndirection: false,
          inJsonNamespace: true
        }, false, false)), (u) => this.emitUnionHeaders(u));
      }
      emitOptionalHelpers() {
        this.emitLine("#ifndef NLOHMANN_OPT_HELPER");
        this.emitLine("#define NLOHMANN_OPT_HELPER");
        this.emitNamespaces([
          "nlohmann"
        ], () => {
          const emitAdlStruct = (optType, factory) => {
            this.emitLine("template <typename T>");
            this.emitBlock([
              "struct adl_serializer<",
              optType,
              "<T>>"
            ], true, () => {
              this.emitBlock([
                "static void to_json(json & j, ",
                this.withConst([
                  optType,
                  "<T>"
                ]),
                " & opt)"
              ], false, () => {
                this.emitLine("if (!opt) j = nullptr; else j = *opt;");
              });
              this.ensureBlankLine();
              this.emitBlock([
                "static ",
                optType,
                "<T> from_json(",
                this.withConst("json"),
                " & j)"
              ], false, () => {
                this.emitLine(`if (j.is_null()) return ${factory}<T>(); else return ${factory}<T>(j.get<T>());`);
              });
            });
          };
          emitAdlStruct(this.optionalTypeHeap(), this.optionalFactoryHeap());
          emitAdlStruct(this.optionalTypeStack(), this.optionalFactoryStack());
        });
        this.emitLine("#endif");
      }
      emitDeclaration(decl) {
        if (decl.kind === "forward") {
          if (this._options.codeFormat) {
            this.emitLine("class ", this.nameForNamedType(decl.type), ";");
          } else {
            this.emitLine("struct ", this.nameForNamedType(decl.type), ";");
          }
        } else if (decl.kind === "define") {
          const type = decl.type;
          const name = this.nameForNamedType(type);
          if (type instanceof Type_1.ClassType) {
            this.emitClass(type, name);
          } else if (type instanceof Type_1.EnumType) {
            this.emitEnum(type, name);
          } else if (type instanceof Type_1.UnionType) {
            this.emitUnionTypedefs(type, name);
          } else {
            (0, Support_1.panic)(`Cannot declare type ${type.kind}`);
          }
        } else {
          (0, Support_1.assertNever)(decl.kind);
        }
      }
      emitGetterSetter(t, getterName, setterName, memberName) {
        this.emitLine("void ", setterName, "(", t, " ", memberName, ") { this->", memberName, " = ", memberName, "; }");
        this.emitLine("auto ", getterName, "() const { return ", memberName, "; }");
      }
      emitNumericCheckConstraints(checkConst, classConstraint, getterMinValue, getterMaxValue, cppType) {
        this.emitBlock([
          "inline void ",
          checkConst,
          "(",
          this._stringType.getConstType(),
          " name, ",
          this.withConst(classConstraint),
          " & c, ",
          cppType,
          " value)"
        ], false, () => {
          this.emitBlock([
            "if (c.",
            getterMinValue,
            "() != ",
            this._nulloptType,
            " && value < *c.",
            getterMinValue,
            "())"
          ], false, () => {
            this.emitLine("throw ", this.lookupGlobalName(utils_1.GlobalNames.ValueTooLowException), " (", this._stringType.createStringLiteral([
              "Value too low for "
            ]), " + name + ", this._stringType.createStringLiteral([
              " ("
            ]), " + ", this._stringType.wrapToString([
              "value"
            ]), " + ", this._stringType.createStringLiteral([
              "<"
            ]), " + ", this._stringType.wrapToString([
              "*c.",
              getterMinValue,
              "()"
            ]), " + ", this._stringType.createStringLiteral([
              ")"
            ]), ");");
          });
          this.ensureBlankLine();
          this.emitBlock([
            "if (c.",
            getterMaxValue,
            "() != ",
            this._nulloptType,
            " && value > *c.",
            getterMaxValue,
            "())"
          ], false, () => {
            this.emitLine("throw ", this.lookupGlobalName(utils_1.GlobalNames.ValueTooHighException), " (", this._stringType.createStringLiteral([
              "Value too high for "
            ]), " + name + ", this._stringType.createStringLiteral([
              " ("
            ]), " + ", this._stringType.wrapToString([
              "value"
            ]), " + ", this._stringType.createStringLiteral([
              ">"
            ]), " + ", this._stringType.wrapToString([
              "*c.",
              getterMaxValue,
              "()"
            ]), " + ", this._stringType.createStringLiteral([
              ")"
            ]), ");");
          });
          this.ensureBlankLine();
        });
        this.ensureBlankLine();
      }
      emitConstraintClasses() {
        const ourQualifier = this.ourQualifier(false);
        const getterMinIntValue = this.lookupMemberName(utils_1.MemberNames.GetMinIntValue);
        const getterMaxIntValue = this.lookupMemberName(utils_1.MemberNames.GetMaxIntValue);
        const getterMinDoubleValue = this.lookupMemberName(utils_1.MemberNames.GetMinDoubleValue);
        const getterMaxDoubleValue = this.lookupMemberName(utils_1.MemberNames.GetMaxDoubleValue);
        const getterMinLength = this.lookupMemberName(utils_1.MemberNames.GetMinLength);
        const getterMaxLength = this.lookupMemberName(utils_1.MemberNames.GetMaxLength);
        const getterPattern = this.lookupMemberName(utils_1.MemberNames.GetPattern);
        const classConstraint = this.lookupGlobalName(utils_1.GlobalNames.ClassMemberConstraints);
        this.emitBlock([
          "class ",
          classConstraint
        ], true, () => {
          this.emitLine("private:");
          const constraintMembers = this.getConstraintMembers();
          for (const member of constraintMembers) {
            this.emitMember([
              this._optionalType,
              "<",
              member.cppType,
              ">"
            ], this.lookupMemberName(member.name));
          }
          this.ensureBlankLine();
          this.emitLine("public:");
          this.emitLine(classConstraint, "(");
          this.indent(() => {
            this.iterableForEach(constraintMembers, ({ name, cppType }, pos) => {
              const comma = pos === "first" || pos === "middle" ? "," : [];
              this.emitLine(this._optionalType, "<", cppType, "> ", this.lookupMemberName(name), comma);
            });
          });
          const args = constraintMembers.map(({ name }) => {
            const member = this.lookupMemberName(name);
            return [
              member,
              "(",
              member,
              ")"
            ];
          });
          this.emitLine(") : ", (0, collection_utils_1.arrayIntercalate)([
            ", "
          ], args), " {}");
          this.emitLine(classConstraint, "() = default;");
          this.emitLine("virtual ~", classConstraint, "() = default;");
          for (const member of constraintMembers) {
            this.ensureBlankLine();
            this.emitGetterSetter((0, collection_utils_1.withDefault)(member.cppConstType, member.cppType), this.lookupMemberName(member.getter), this.lookupMemberName(member.setter), this.lookupMemberName(member.name));
          }
        });
        this.ensureBlankLine();
        const classConstEx = this.lookupGlobalName(utils_1.GlobalNames.ClassMemberConstraintException);
        this.emitBlock([
          "class ",
          classConstEx,
          " : public std::runtime_error"
        ], true, () => {
          this.emitLine("public:");
          this.emitLine(classConstEx, "(", this._stringType.getConstType(), " msg) : std::runtime_error(", this._stringType.wrapEncodingChange([
            ourQualifier
          ], this._stringType.getType(), this.NarrowString.getType(), [
            "msg"
          ]), ") {}");
        });
        this.ensureBlankLine();
        const exceptions = [
          utils_1.GlobalNames.ValueTooLowException,
          utils_1.GlobalNames.ValueTooHighException,
          utils_1.GlobalNames.ValueTooShortException,
          utils_1.GlobalNames.ValueTooLongException,
          utils_1.GlobalNames.InvalidPatternException
        ];
        for (const ex of exceptions) {
          const name = this.lookupGlobalName(ex);
          this.emitBlock([
            "class ",
            name,
            " : public ",
            classConstEx
          ], true, () => {
            this.emitLine("public:");
            this.emitLine(name, "(", this._stringType.getConstType(), " msg) : ", classConstEx, "(msg) {}");
          });
          this.ensureBlankLine();
        }
        const checkConst = this.lookupGlobalName(utils_1.GlobalNames.CheckConstraint);
        this.emitNumericCheckConstraints(checkConst, classConstraint, getterMinIntValue, getterMaxIntValue, "int64_t");
        this.emitNumericCheckConstraints(checkConst, classConstraint, getterMinDoubleValue, getterMaxDoubleValue, "double");
        this.emitBlock([
          "inline void ",
          checkConst,
          "(",
          this._stringType.getConstType(),
          " name, ",
          this.withConst(classConstraint),
          " & c, ",
          this._stringType.getConstType(),
          " value)"
        ], false, () => {
          this.emitBlock([
            "if (c.",
            getterMinLength,
            "() != ",
            this._nulloptType,
            " && value.length() < *c.",
            getterMinLength,
            "())"
          ], false, () => {
            this.emitLine("throw ", this.lookupGlobalName(utils_1.GlobalNames.ValueTooShortException), " (", this._stringType.createStringLiteral([
              "Value too short for "
            ]), " + name + ", this._stringType.createStringLiteral([
              " ("
            ]), " + ", this._stringType.wrapToString([
              "value.length()"
            ]), " + ", this._stringType.createStringLiteral([
              "<"
            ]), " + ", this._stringType.wrapToString([
              "*c.",
              getterMinLength,
              "()"
            ]), " + ", this._stringType.createStringLiteral([
              ")"
            ]), ");");
          });
          this.ensureBlankLine();
          this.emitBlock([
            "if (c.",
            getterMaxLength,
            "() != ",
            this._nulloptType,
            " && value.length() > *c.",
            getterMaxLength,
            "())"
          ], false, () => {
            this.emitLine("throw ", this.lookupGlobalName(utils_1.GlobalNames.ValueTooLongException), " (", this._stringType.createStringLiteral([
              "Value too long for "
            ]), " + name + ", this._stringType.createStringLiteral([
              " ("
            ]), " + ", this._stringType.wrapToString([
              "value.length()"
            ]), " + ", this._stringType.createStringLiteral([
              ">"
            ]), " + ", this._stringType.wrapToString([
              "*c.",
              getterMaxLength,
              "()"
            ]), " + ", this._stringType.createStringLiteral([
              ")"
            ]), ");");
          });
          this.ensureBlankLine();
          this.emitBlock([
            "if (c.",
            getterPattern,
            "() != ",
            this._nulloptType,
            ")"
          ], false, () => {
            this.emitLine(this._stringType.getSMatch(), " result;");
            this.emitLine("std::regex_search(value, result, ", this._stringType.getRegex(), "( *c.", getterPattern, "() ));");
            this.emitBlock([
              "if (result.empty())"
            ], false, () => {
              this.emitLine("throw ", this.lookupGlobalName(utils_1.GlobalNames.InvalidPatternException), " (", this._stringType.createStringLiteral([
                "Value doesn't match pattern for "
              ]), " + name + ", this._stringType.createStringLiteral([
                " ("
              ]), " + value +", this._stringType.createStringLiteral([
                " != "
              ]), " + *c.", getterPattern, "() + ", this._stringType.createStringLiteral([
                ")"
              ]), ");");
            });
          });
          this.ensureBlankLine();
        });
      }
      emitHelperFunctions() {
        this._stringType.emitHelperFunctions();
        if (this._options.codeFormat && (0, collection_utils_1.iterableSome)(this.typeGraph.allTypesUnordered(), (t) => (0, utils_1.constraintsForType)(t) !== void 0)) {
          this.emitConstraintClasses();
          this.ensureBlankLine();
        }
        this.ensureBlankLine();
        let untypedMacroName = "NLOHMANN_UNTYPED_";
        let optionalMacroName = "NLOHMANN_OPTIONAL_";
        this._namespaceNames.forEach((value) => {
          untypedMacroName += value;
          untypedMacroName += "_";
          optionalMacroName += value;
          optionalMacroName += "_";
        });
        untypedMacroName += "HELPER";
        optionalMacroName += "HELPER";
        this.emitLine(`#ifndef ${untypedMacroName}`);
        this.emitLine(`#define ${untypedMacroName}`);
        this.emitBlock([
          "inline json get_untyped(",
          this.withConst("json"),
          " & j, ",
          this.withConst("char"),
          " * property)"
        ], false, () => {
          this.emitBlock([
            "if (j.find(property) != j.end())"
          ], false, () => {
            this.emitLine("return j.at(property).get<json>();");
          });
          this.emitLine("return json();");
        });
        this.ensureBlankLine();
        this.emitBlock([
          "inline json get_untyped(",
          this.withConst("json"),
          " & j, std::string property)"
        ], false, () => {
          this.emitLine("return get_untyped(j, property.data());");
        });
        this.emitLine("#endif");
        this.ensureBlankLine();
        if (this.haveUnions || this.haveOptionalProperties) {
          this.ensureBlankLine();
          this.emitLine(`#ifndef ${optionalMacroName}`);
          this.emitLine(`#define ${optionalMacroName}`);
          const emitGetOptional = (optionalType, label) => {
            this.emitLine("template <typename T>");
            this.emitBlock([
              "inline ",
              optionalType,
              `<T> get_${label}_optional(`,
              this.withConst("json"),
              " & j, ",
              this.withConst("char"),
              " * property)"
            ], false, () => {
              this.emitLine([
                "auto it = j.find(property);"
              ]);
              this.emitBlock([
                "if (it != j.end() && !it->is_null())"
              ], false, () => {
                this.emitLine("return j.at(property).get<", optionalType, "<T>>();");
              });
              this.emitLine("return ", optionalType, "<T>();");
            });
            this.ensureBlankLine();
            this.emitLine("template <typename T>");
            this.emitBlock([
              "inline ",
              optionalType,
              `<T> get_${label}_optional(`,
              this.withConst("json"),
              " & j, std::string property)"
            ], false, () => {
              this.emitLine(`return get_${label}_optional<T>(j, property.data());`);
            });
          };
          emitGetOptional(this.optionalTypeHeap(), "heap");
          emitGetOptional(this.optionalTypeStack(), "stack");
          this.emitLine("#endif");
          this.ensureBlankLine();
        }
      }
      emitExtraIncludes() {
        this.ensureBlankLine();
        if (this._options.codeFormat) {
          if (this._options.boost) {
            this.emitInclude(true, "boost/optional.hpp");
          } else {
            this.emitInclude(true, "optional");
          }
          this.emitInclude(true, "stdexcept");
          this.emitInclude(true, "regex");
        }
        if (this._options.wstring) {
          this.emitInclude(true, "codecvt");
          this.emitInclude(true, "locale");
        }
        if (Array.from(this.enums).some((enumType) => this.isLargeEnum(enumType))) {
          this.emitInclude(true, "unordered_map");
        }
        this.ensureBlankLine();
      }
      emitHelper() {
        this.startFile("helper.hpp", false);
        this.emitExtraIncludes();
        this.emitInclude(true, "sstream");
        this.ensureBlankLine();
        this.emitNamespaces(this._namespaceNames, () => {
          this.emitLine("using nlohmann::json;");
          this.ensureBlankLine();
          this.emitHelperFunctions();
        });
        if (this.haveUnions || this.haveOptionalProperties) {
          this.ensureBlankLine();
          this.emitOptionalHelpers();
        }
        this.finishFile();
      }
      emitTypes() {
        if (!this._options.justTypes) {
          this.emitLine("using nlohmann::json;");
          this.ensureBlankLine();
          this.emitHelperFunctions();
        }
        this.forEachDeclaration("interposing", (decl) => this.emitDeclaration(decl));
        if (this._options.justTypes) return;
        this.forEachTopLevel("leading", (t, name) => this.emitTopLevelTypedef(t, name), (t) => this.namedTypeToNameForTopLevel(t) === void 0);
      }
      gatherUserNamespaceForwardDecls() {
        return this.gatherSource(() => {
          this.forEachObject("leading-and-interposing", (_, className) => this.emitClassHeaders(className));
          this.forEachEnum("leading-and-interposing", (_, enumName) => this.emitEnumHeaders(enumName));
        });
      }
      gatherNlohmannNamespaceForwardDecls() {
        return this.gatherSource(() => {
          this.forEachTopLevel("leading-and-interposing", (t, className) => this.emitTopLevelHeaders(t, className));
          this.ensureBlankLine();
          this.emitAllUnionHeaders();
        });
      }
      emitUserNamespaceImpls() {
        this.forEachObject("leading-and-interposing", (c, className) => this.emitClassFunctions(c, className));
        this.forEachEnum("leading-and-interposing", (e, enumName) => this.emitEnumFunctions(e, enumName));
      }
      emitNlohmannNamespaceImpls() {
        this.forEachTopLevel("leading-and-interposing", (t, name) => this.emitTopLevelFunction(t, name), (t) => this.namedTypeToNameForTopLevel(t) === void 0);
        this.ensureBlankLine();
        this.emitAllUnionFunctions();
      }
      emitGenerators() {
        if (this._options.justTypes) {
          let didEmit = false;
          const gathered = this.gatherSource(() => this.emitNamespaces(this._namespaceNames, () => {
            didEmit = this.forEachTopLevel("none", (t, name) => this.emitTopLevelTypedef(t, name), (t) => this.namedTypeToNameForTopLevel(t) === void 0);
          }));
          if (didEmit) {
            this.emitGatheredSource(gathered);
            this.ensureBlankLine();
          }
        } else {
          const userNamespaceForwardDecls = this.gatherUserNamespaceForwardDecls();
          const nlohmannNamespaceForwardDecls = this.gatherNlohmannNamespaceForwardDecls();
          if (userNamespaceForwardDecls.length === 0 && nlohmannNamespaceForwardDecls.length > 0) {
            this.emitNamespaces([
              "nlohmann"
            ], () => {
              this.emitGatheredSource(nlohmannNamespaceForwardDecls);
              this.emitNlohmannNamespaceImpls();
            });
          } else if (userNamespaceForwardDecls.length > 0 && nlohmannNamespaceForwardDecls.length === 0) {
            this.emitNamespaces(this._namespaceNames, () => {
              this.emitGatheredSource(userNamespaceForwardDecls);
              this.emitUserNamespaceImpls();
            });
          } else if (userNamespaceForwardDecls.length > 0 && nlohmannNamespaceForwardDecls.length > 0) {
            this.emitNamespaces(this._namespaceNames, () => {
              this.emitGatheredSource(userNamespaceForwardDecls);
            });
            this.emitNamespaces([
              "nlohmann"
            ], () => {
              this.emitGatheredSource(nlohmannNamespaceForwardDecls);
            });
            this.emitNamespaces(this._namespaceNames, () => {
              this.emitUserNamespaceImpls();
            });
            this.emitNamespaces([
              "nlohmann"
            ], () => {
              this.emitNlohmannNamespaceImpls();
            });
          }
        }
      }
      emitSingleSourceStructure(proposedFilename) {
        this.startFile(proposedFilename);
        this._generatedFiles.add(proposedFilename);
        this.emitExtraIncludes();
        if (this._options.justTypes) {
          this.emitTypes();
        } else {
          if (!this._options.justTypes && this.haveNamedTypes && (this.haveUnions || this.haveOptionalProperties)) {
            this.emitOptionalHelpers();
            this.ensureBlankLine();
          }
          this.emitNamespaces(this._namespaceNames, () => this.emitTypes());
        }
        this.ensureBlankLine();
        this.emitGenerators();
        this.finishFile();
      }
      updateIncludes(isClassMember, includes, propertyType, _defName) {
        const propTypes = this.generatedTypes(isClassMember, propertyType);
        for (const t of propTypes) {
          const typeName = this.sourcelikeToString(t.name);
          const propRecord = {
            kind: void 0,
            typeKind: void 0
          };
          if (t.type instanceof Type_1.ClassType) {
            propRecord.typeKind = "class";
            propRecord.kind = t.level === 0 ? utils_1.IncludeKind.Include : utils_1.IncludeKind.ForwardDeclare;
            if (t.forceInclude) {
              propRecord.kind = utils_1.IncludeKind.Include;
            }
          } else if (t.type instanceof Type_1.EnumType) {
            propRecord.typeKind = "enum";
            propRecord.kind = utils_1.IncludeKind.ForwardDeclare;
          } else if (t.type instanceof Type_1.UnionType) {
            propRecord.typeKind = "union";
            const [maybeNull] = (0, TypeUtils_1.removeNullFromUnion)(t.type, true);
            if (maybeNull !== void 0) {
              propRecord.kind = utils_1.IncludeKind.Include;
            } else {
              if (t.forceInclude) {
                propRecord.kind = utils_1.IncludeKind.Include;
              } else {
                propRecord.kind = utils_1.IncludeKind.ForwardDeclare;
              }
            }
          }
          if (includes.has(typeName)) {
            const incKind = includes.get(typeName);
            if (incKind !== void 0 && incKind.kind === utils_1.IncludeKind.ForwardDeclare) {
              includes.set(typeName, propRecord);
            }
          } else {
            includes.set(typeName, propRecord);
          }
        }
      }
      emitIncludes(c, defName) {
        const includes = /* @__PURE__ */ new Map();
        if (c instanceof Type_1.UnionType) {
          this.updateIncludes(false, includes, c, defName);
        } else if (c instanceof Type_1.ClassType) {
          this.forEachClassProperty(c, "none", (_name, _jsonName, property) => {
            this.updateIncludes(true, includes, property.type, defName);
          });
        }
        if (includes.size !== 0) {
          let numForwards = 0;
          let numIncludes = 0;
          includes.forEach((rec, name) => {
            if (name === defName) {
              return;
            }
            if (rec.kind !== utils_1.IncludeKind.ForwardDeclare) {
              this.emitInclude(false, [
                name,
                ".hpp"
              ]);
              numIncludes++;
            } else {
              numForwards++;
            }
          });
          if (numIncludes > 0) {
            this.ensureBlankLine();
          }
          if (numForwards > 0) {
            this.emitNamespaces(this._namespaceNames, () => {
              includes.forEach((rec, name) => {
                if (name === defName) {
                  return;
                }
                if (rec.kind !== utils_1.IncludeKind.ForwardDeclare) {
                  return;
                }
                if (rec.typeKind === "class" || rec.typeKind === "union") {
                  if (this._options.codeFormat) {
                    this.emitLine("class ", name, ";");
                  } else {
                    this.emitLine("struct ", name, ";");
                  }
                } else if (rec.typeKind === "enum") {
                  this.emitLine("enum class ", name, " : ", this._enumType, ";");
                } else {
                  (0, Support_1.panic)(`Invalid type "${rec.typeKind}" to forward declare`);
                }
              });
            });
          }
          this.ensureBlankLine();
        }
      }
      emitDefinition(d, defName) {
        const name = `${this.sourcelikeToString(defName)}.hpp`;
        this.startFile(name, true);
        this._generatedFiles.add(name);
        this.emitIncludes(d, this.sourcelikeToString(defName));
        this.emitNamespaces(this._namespaceNames, () => {
          this.emitDescription(this.descriptionForType(d));
          this.ensureBlankLine();
          this.emitLine("using nlohmann::json;");
          this.ensureBlankLine();
          if (d instanceof Type_1.ClassType) {
            this.emitClass(d, defName);
          } else if (d instanceof Type_1.EnumType) {
            this.emitEnum(d, defName);
          } else if (d instanceof Type_1.UnionType) {
            this.emitUnionTypedefs(d, defName);
          }
        });
        this.finishFile();
      }
      emitMultiSourceStructure(proposedFilename) {
        if (!this._options.justTypes && this.haveNamedTypes) {
          this.emitHelper();
          this.startFile("Generators.hpp", true);
          this._allTypeNames.forEach((t) => {
            this.emitInclude(false, [
              t,
              ".hpp"
            ]);
          });
          this.ensureBlankLine();
          this.emitGenerators();
          this.finishFile();
        }
        this.forEachNamedType("leading-and-interposing", (c, n) => {
          this.emitDefinition(c, n);
        }, (e, n) => {
          this.emitDefinition(e, n);
        }, (u, n) => {
          this.emitDefinition(u, n);
        });
        if (!this._generatedFiles.has(proposedFilename)) {
          if (!this.haveNamedTypes) {
            this.emitHelper();
          }
          this.startFile(proposedFilename);
          this._generatedFiles.forEach((f) => {
            this.emitInclude(false, f);
          });
          this.emitNamespaces(this._namespaceNames, () => {
            this.forEachTopLevel("leading", (t, name) => this.emitTopLevelTypedef(t, name), (t) => this.namedTypeToNameForTopLevel(t) === void 0);
          });
          this.finishFile();
        }
      }
      emitSourceStructure(proposedFilename) {
        this._generatedFiles.clear();
        this._allTypeNames.clear();
        this.forEachDeclaration("none", (decl) => {
          const definedTypes = (0, TypeUtils_1.directlyReachableTypes)(decl.type, (t) => {
            if ((0, TypeUtils_1.isNamedType)(t) && (t instanceof Type_1.ClassType || t instanceof Type_1.EnumType || t instanceof Type_1.UnionType)) {
              return /* @__PURE__ */ new Set([
                this.sourcelikeToString(this.cppType(t, {
                  needsForwardIndirection: false,
                  needsOptionalIndirection: false,
                  inJsonNamespace: false
                }, true, false, false))
              ]);
            }
            return null;
          });
          this._allTypeNames = (0, collection_utils_1.setUnion)(definedTypes, this._allTypeNames);
        });
        if (this._options.typeSourceStyle) {
          this.emitSingleSourceStructure(proposedFilename);
        } else {
          this.emitMultiSourceStructure(proposedFilename);
        }
      }
      isConversionRequired(t) {
        const originalType = this.cppType(t, {
          needsForwardIndirection: true,
          needsOptionalIndirection: true,
          inJsonNamespace: true
        }, false, false, false);
        const newType = this.cppType(t, {
          needsForwardIndirection: true,
          needsOptionalIndirection: true,
          inJsonNamespace: true
        }, false, true, false);
        return originalType !== newType;
      }
    };
    exports.CPlusPlusRenderer = CPlusPlusRenderer;
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/CPlusPlus/language.js
var require_language2 = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/CPlusPlus/language.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.CPlusPlusTargetLanguage = exports.cPlusPlusLanguageConfig = exports.cPlusPlusOptions = void 0;
    var RendererOptions_1 = require_RendererOptions();
    var TargetLanguage_1 = require_TargetLanguage();
    var CPlusPlusRenderer_1 = require_CPlusPlusRenderer();
    var namingStyles = {
      "pascal-case": "pascal",
      "underscore-case": "underscore",
      "camel-case": "camel",
      "upper-underscore-case": "upper-underscore",
      "pascal-case-upper-acronyms": "pascal-upper-acronyms",
      "camel-case-upper-acronyms": "camel-upper-acronyms"
    };
    exports.cPlusPlusOptions = {
      typeSourceStyle: new RendererOptions_1.EnumOption("source-style", "Source code generation type,  whether to generate single or multiple source files", {
        "single-source": true,
        "multi-source": false
      }, "single-source", "secondary"),
      includeLocation: new RendererOptions_1.EnumOption("include-location", "Whether json.hpp is to be located globally or locally", {
        "local-include": true,
        "global-include": false
      }, "local-include", "secondary"),
      codeFormat: new RendererOptions_1.EnumOption("code-format", "Generate classes with getters/setters, instead of structs", {
        "with-struct": false,
        "with-getter-setter": true
      }, "with-getter-setter"),
      wstring: new RendererOptions_1.EnumOption("wstring", "Store strings using Utf-16 std::wstring, rather than Utf-8 std::string", {
        "use-string": false,
        "use-wstring": true
      }, "use-string"),
      westConst: new RendererOptions_1.EnumOption("const-style", "Put const to the left/west (const T) or right/east (T const)", {
        "west-const": true,
        "east-const": false
      }, "west-const"),
      justTypes: new RendererOptions_1.BooleanOption("just-types", "Plain types only", false),
      namespace: new RendererOptions_1.StringOption("namespace", "Name of the generated namespace(s)", "NAME", "quicktype"),
      enumType: new RendererOptions_1.StringOption("enum-type", "Type of enum class", "NAME", "int", "secondary"),
      typeNamingStyle: new RendererOptions_1.EnumOption("type-style", "Naming style for types", namingStyles, "pascal-case"),
      memberNamingStyle: new RendererOptions_1.EnumOption("member-style", "Naming style for members", namingStyles, "underscore-case"),
      enumeratorNamingStyle: new RendererOptions_1.EnumOption("enumerator-style", "Naming style for enumerators", namingStyles, "upper-underscore-case"),
      boost: new RendererOptions_1.BooleanOption("boost", "Require a dependency on boost. Without boost, C++17 is required", true),
      hideNullOptional: new RendererOptions_1.BooleanOption("hide-null-optional", "Hide null value for optional field", false)
    };
    exports.cPlusPlusLanguageConfig = {
      displayName: "C++",
      names: [
        "c++",
        "cpp",
        "cplusplus"
      ],
      extension: "cpp"
    };
    var CPlusPlusTargetLanguage = class extends TargetLanguage_1.TargetLanguage {
      constructor() {
        super(exports.cPlusPlusLanguageConfig);
      }
      getOptions() {
        return exports.cPlusPlusOptions;
      }
      get supportsUnionsWithBothNumberTypes() {
        return true;
      }
      get supportsOptionalClassProperties() {
        return true;
      }
      makeRenderer(renderContext, untypedOptionValues) {
        return new CPlusPlusRenderer_1.CPlusPlusRenderer(this, renderContext, (0, RendererOptions_1.getOptionValues)(exports.cPlusPlusOptions, untypedOptionValues));
      }
    };
    exports.CPlusPlusTargetLanguage = CPlusPlusTargetLanguage;
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/CPlusPlus/index.js
var require_CPlusPlus = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/CPlusPlus/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.CPlusPlusRenderer = exports.cPlusPlusOptions = exports.CPlusPlusTargetLanguage = void 0;
    var language_1 = require_language2();
    Object.defineProperty(exports, "CPlusPlusTargetLanguage", {
      enumerable: true,
      get: function() {
        return language_1.CPlusPlusTargetLanguage;
      }
    });
    Object.defineProperty(exports, "cPlusPlusOptions", {
      enumerable: true,
      get: function() {
        return language_1.cPlusPlusOptions;
      }
    });
    var CPlusPlusRenderer_1 = require_CPlusPlusRenderer();
    Object.defineProperty(exports, "CPlusPlusRenderer", {
      enumerable: true,
      get: function() {
        return CPlusPlusRenderer_1.CPlusPlusRenderer;
      }
    });
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Crystal/constants.js
var require_constants4 = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Crystal/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.keywords = void 0;
    exports.keywords = [
      "Any",
      "Array",
      "Atomic",
      "Bool",
      "Channel",
      "Char",
      "Class",
      "Enum",
      "Enumerable",
      "Event",
      "Extern",
      "Exception",
      "File",
      "Float",
      "Float32",
      "Float64",
      "GC",
      "GZip",
      "Hash",
      "HTML",
      "HTTP",
      "Int",
      "Int128",
      "Int16",
      "Int32",
      "Int64",
      "Int8",
      "Iterable",
      "Link",
      "Logger",
      "Math",
      "Mutex",
      "Nil",
      "Number",
      "JSON",
      "IO",
      "Object",
      "Pointer",
      "Proc",
      "Process",
      "Range",
      "Random",
      "Regex",
      "Reference",
      "Set",
      "Signal",
      "Slice",
      "Spec",
      "StaticArray",
      "String",
      "Struct",
      "Symbol",
      "System",
      "TCPServer",
      "TCPSocket",
      "Socket",
      "Tempfile",
      "Termios",
      "Time",
      "Tuple",
      "ThreadLocal",
      "UDPSocket",
      "UInt128",
      "UInt16",
      "UInt32",
      "UInt64",
      "UInt8",
      "Union",
      "UNIXServer",
      "UNIXSocket",
      "UUID",
      "URI",
      "VaList",
      "Value",
      "Void",
      "WeakRef",
      "XML",
      "YAML",
      "Zip",
      "Zlib",
      "abstract",
      "alias",
      "as",
      "as?",
      "asm",
      "begin",
      "break",
      "case",
      "class",
      "def",
      "do",
      "else",
      "elsif",
      "end",
      "ensure",
      "enum",
      "extend",
      "false",
      "for",
      "fun",
      "if",
      "in",
      "include",
      "instance_sizeof",
      "is_a?",
      "lib",
      "macro",
      "module",
      "next",
      "nil",
      "nil?",
      "of",
      "out",
      "pointerof",
      "private",
      "protected",
      "require",
      "rescue",
      "return",
      "select",
      "self",
      "sizeof",
      "struct",
      "super",
      "then",
      "true",
      "type",
      "typeof",
      "uninitialized",
      "union",
      "unless",
      "until",
      "when",
      "while",
      "with",
      "yield"
    ];
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Crystal/utils.js
var require_utils3 = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Crystal/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.crystalStringEscape = exports.camelNamingFunction = exports.snakeNamingFunction = void 0;
    var Naming_1 = require_Naming();
    var Strings_1 = require_Strings();
    function isAsciiLetterOrUnderscoreOrDigit(codePoint) {
      if (!(0, Strings_1.isAscii)(codePoint)) {
        return false;
      }
      return (0, Strings_1.isLetterOrUnderscoreOrDigit)(codePoint);
    }
    function isAsciiLetterOrUnderscore(codePoint) {
      if (!(0, Strings_1.isAscii)(codePoint)) {
        return false;
      }
      return (0, Strings_1.isLetterOrUnderscore)(codePoint);
    }
    var legalizeName = (0, Strings_1.legalizeCharacters)(isAsciiLetterOrUnderscoreOrDigit);
    function crystalStyle(original, isSnakeCase) {
      const words = (0, Strings_1.splitIntoWords)(original);
      const wordStyle = isSnakeCase ? Strings_1.allLowerWordStyle : Strings_1.firstUpperWordStyle;
      const combined = (0, Strings_1.combineWords)(words, legalizeName, wordStyle, wordStyle, wordStyle, wordStyle, isSnakeCase ? "_" : "", isAsciiLetterOrUnderscore);
      return combined === "_" ? "_underscore" : combined;
    }
    exports.snakeNamingFunction = (0, Naming_1.funPrefixNamer)("default", (original) => crystalStyle(original, true));
    exports.camelNamingFunction = (0, Naming_1.funPrefixNamer)("camel", (original) => crystalStyle(original, false));
    function standardUnicodeCrystalEscape(codePoint) {
      if (codePoint <= 65535) {
        return "\\u{" + (0, Strings_1.intToHex)(codePoint, 4) + "}";
      } else {
        return "\\u{" + (0, Strings_1.intToHex)(codePoint, 6) + "}";
      }
    }
    exports.crystalStringEscape = (0, Strings_1.utf32ConcatMap)((0, Strings_1.escapeNonPrintableMapper)(Strings_1.isPrintable, standardUnicodeCrystalEscape));
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Crystal/CrystalRenderer.js
var require_CrystalRenderer = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Crystal/CrystalRenderer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.CrystalRenderer = void 0;
    var Annotation_1 = require_Annotation();
    var ConvenienceRenderer_1 = require_ConvenienceRenderer();
    var Source_1 = require_Source();
    var TypeUtils_1 = require_TypeUtils();
    var constants_1 = require_constants4();
    var utils_1 = require_utils3();
    var CrystalRenderer = class extends ConvenienceRenderer_1.ConvenienceRenderer {
      constructor(targetLanguage, renderContext) {
        super(targetLanguage, renderContext);
      }
      makeNamedTypeNamer() {
        return utils_1.camelNamingFunction;
      }
      namerForObjectProperty() {
        return utils_1.snakeNamingFunction;
      }
      makeUnionMemberNamer() {
        return utils_1.camelNamingFunction;
      }
      makeEnumCaseNamer() {
        return utils_1.camelNamingFunction;
      }
      forbiddenNamesForGlobalNamespace() {
        return constants_1.keywords;
      }
      forbiddenForObjectProperties(_c, _className) {
        return {
          names: [],
          includeGlobalForbidden: true
        };
      }
      forbiddenForUnionMembers(_u, _unionName) {
        return {
          names: [],
          includeGlobalForbidden: true
        };
      }
      forbiddenForEnumCases(_e, _enumName) {
        return {
          names: [],
          includeGlobalForbidden: true
        };
      }
      get commentLineStart() {
        return "# ";
      }
      nullableCrystalType(t, withIssues) {
        return [
          this.crystalType(t, withIssues),
          "?"
        ];
      }
      isImplicitCycleBreaker(t) {
        const kind = t.kind;
        return kind === "array" || kind === "map";
      }
      crystalType(t, withIssues = false) {
        return (0, TypeUtils_1.matchType)(t, (_anyType) => (0, Source_1.maybeAnnotated)(withIssues, Annotation_1.anyTypeIssueAnnotation, "JSON::Any?"), (_nullType) => (0, Source_1.maybeAnnotated)(withIssues, Annotation_1.nullTypeIssueAnnotation, "Nil"), (_boolType) => "Bool", (_integerType) => "Int32", (_doubleType) => "Float64", (_stringType) => "String", (arrayType) => [
          "Array(",
          this.crystalType(arrayType.items, withIssues),
          ")"
        ], (classType) => this.nameForNamedType(classType), (mapType) => [
          "Hash(String, ",
          this.crystalType(mapType.values, withIssues),
          ")"
        ], (_enumType) => "String", (unionType) => {
          const nullable = (0, TypeUtils_1.nullableFromUnion)(unionType);
          if (nullable !== null) return this.nullableCrystalType(nullable, withIssues);
          const [hasNull] = (0, TypeUtils_1.removeNullFromUnion)(unionType);
          const name = this.nameForNamedType(unionType);
          return hasNull !== null ? [
            name,
            "?"
          ] : name;
        });
      }
      breakCycle(t, withIssues) {
        return this.crystalType(t, withIssues);
      }
      emitRenameAttribute(propName, jsonName) {
        const escapedName = (0, utils_1.crystalStringEscape)(jsonName);
        const namesDiffer = this.sourcelikeToString(propName) !== escapedName;
        if (namesDiffer) {
          this.emitLine('@[JSON::Field(key: "', escapedName, '")]');
        }
      }
      emitStructDefinition(c, className) {
        this.emitDescription(this.descriptionForType(c));
        const structBody = () => this.forEachClassProperty(c, "none", (name, jsonName, prop) => {
          this.ensureBlankLine();
          this.emitDescription(this.descriptionForClassProperty(c, jsonName));
          this.emitRenameAttribute(name, jsonName);
          this.emitLine("property ", name, " : ", this.crystalType(prop.type, true));
        });
        this.emitBlock([
          "class ",
          className
        ], structBody);
      }
      emitBlock(line, f) {
        this.emitLine(line);
        this.indent(() => {
          this.emitLine("include JSON::Serializable");
        });
        this.ensureBlankLine();
        this.indent(f);
        this.emitLine("end");
      }
      emitEnum(line, f) {
        this.emitLine(line);
        this.indent(f);
        this.emitLine("end");
      }
      emitUnion(u, unionName) {
        const isMaybeWithSingleType = (0, TypeUtils_1.nullableFromUnion)(u);
        if (isMaybeWithSingleType !== null) {
          return;
        }
        this.emitDescription(this.descriptionForType(u));
        const [, nonNulls] = (0, TypeUtils_1.removeNullFromUnion)(u);
        const types = [];
        this.forEachUnionMember(u, nonNulls, "none", null, (_name, t) => {
          const crystalType = this.breakCycle(t, true);
          types.push([
            crystalType
          ]);
        });
        this.emitLine([
          "alias ",
          unionName,
          " = ",
          types.map((r) => r.map((sl) => this.sourcelikeToString(sl))).join(" | ")
        ]);
      }
      emitTopLevelAlias(t, name) {
        this.emitLine("alias ", name, " = ", this.crystalType(t));
      }
      emitLeadingComments() {
        if (this.leadingComments !== void 0) {
          this.emitComments(this.leadingComments);
          return;
        }
      }
      emitSourceStructure() {
        this.emitLeadingComments();
        this.ensureBlankLine();
        this.emitLine('require "json"');
        this.forEachTopLevel("leading", (t, name) => this.emitTopLevelAlias(t, name), (t) => this.namedTypeToNameForTopLevel(t) === void 0);
        this.forEachObject("leading-and-interposing", (c, name) => this.emitStructDefinition(c, name));
        this.forEachUnion("leading-and-interposing", (u, name) => this.emitUnion(u, name));
      }
    };
    exports.CrystalRenderer = CrystalRenderer;
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Crystal/language.js
var require_language3 = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Crystal/language.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.CrystalTargetLanguage = exports.crystalLanguageConfig = void 0;
    var TargetLanguage_1 = require_TargetLanguage();
    var CrystalRenderer_1 = require_CrystalRenderer();
    exports.crystalLanguageConfig = {
      displayName: "Crystal",
      names: [
        "crystal",
        "cr",
        "crystallang"
      ],
      extension: "cr"
    };
    var CrystalTargetLanguage = class extends TargetLanguage_1.TargetLanguage {
      constructor() {
        super(exports.crystalLanguageConfig);
      }
      makeRenderer(renderContext) {
        return new CrystalRenderer_1.CrystalRenderer(this, renderContext);
      }
      get defaultIndentation() {
        return "  ";
      }
      getOptions() {
        return {};
      }
    };
    exports.CrystalTargetLanguage = CrystalTargetLanguage;
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Crystal/index.js
var require_Crystal = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Crystal/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.CrystalRenderer = exports.CrystalTargetLanguage = void 0;
    var language_1 = require_language3();
    Object.defineProperty(exports, "CrystalTargetLanguage", {
      enumerable: true,
      get: function() {
        return language_1.CrystalTargetLanguage;
      }
    });
    var CrystalRenderer_1 = require_CrystalRenderer();
    Object.defineProperty(exports, "CrystalRenderer", {
      enumerable: true,
      get: function() {
        return CrystalRenderer_1.CrystalRenderer;
      }
    });
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/CSharp/constants.js
var require_constants5 = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/CSharp/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.keywords = void 0;
    exports.keywords = [
      "abstract",
      "as",
      "base",
      "bool",
      "break",
      "byte",
      "case",
      "catch",
      "char",
      "checked",
      "class",
      "const",
      "continue",
      "decimal",
      "default",
      "delegate",
      "do",
      "double",
      "else",
      "enum",
      "event",
      "explicit",
      "extern",
      "false",
      "finally",
      "fixed",
      "float",
      "for",
      "foreach",
      "goto",
      "if",
      "implicit",
      "in",
      "int",
      "interface",
      "internal",
      "is",
      "lock",
      "long",
      "namespace",
      "new",
      "null",
      "object",
      "operator",
      "out",
      "override",
      "params",
      "private",
      "protected",
      "public",
      "readonly",
      "ref",
      "return",
      "sbyte",
      "sealed",
      "short",
      "sizeof",
      "stackalloc",
      "static",
      "string",
      "struct",
      "switch",
      "this",
      "throw",
      "true",
      "try",
      "typeof",
      "uint",
      "ulong",
      "unchecked",
      "unsafe",
      "ushort",
      "using",
      "virtual",
      "void",
      "volatile",
      "while"
    ];
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/CSharp/utils.js
var require_utils4 = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/CSharp/utils.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : {
        "default": mod
      };
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.denseNullValueHandlingEnumName = exports.denseRequiredEnumName = exports.denseJsonPropertyName = exports.namingFunctionKeep = exports.namingFunction = exports.AccessModifier = void 0;
    exports.noFollow = noFollow;
    exports.needTransformerForType = needTransformerForType;
    exports.alwaysApplyTransformation = alwaysApplyTransformation;
    exports.csTypeForTransformedStringType = csTypeForTransformedStringType;
    exports.isStartCharacter = isStartCharacter;
    exports.csNameStyle = csNameStyle;
    exports.isValueType = isValueType;
    var unicode_properties_1 = __importDefault(require_main());
    var Constraints_1 = require_Constraints();
    var Naming_1 = require_Naming();
    var Strings_1 = require_Strings();
    var Support_1 = require_Support();
    var Type_1 = require_Type2();
    var TypeUtils_1 = require_TypeUtils();
    var constants_1 = require_constants5();
    var AccessModifier;
    (function(AccessModifier2) {
      AccessModifier2["None"] = "None";
      AccessModifier2["Public"] = "Public";
      AccessModifier2["Internal"] = "Internal";
    })(AccessModifier || (exports.AccessModifier = AccessModifier = {}));
    function noFollow(t) {
      return t;
    }
    function needTransformerForType(t) {
      if (t instanceof Type_1.UnionType) {
        const maybeNullable = (0, TypeUtils_1.nullableFromUnion)(t);
        if (maybeNullable === null) return "automatic";
        if (needTransformerForType(maybeNullable) === "manual") return "nullable";
        return "none";
      }
      if (t instanceof Type_1.ArrayType) {
        const itemsNeed = needTransformerForType(t.items);
        if (itemsNeed === "manual" || itemsNeed === "nullable") return "automatic";
        return "none";
      }
      if (t instanceof Type_1.EnumType) return "automatic";
      if (t.kind === "double") return (0, Constraints_1.minMaxValueForType)(t) !== void 0 ? "manual" : "none";
      if (t.kind === "integer-string" || t.kind === "bool-string") return "manual";
      if (t.kind === "string") {
        return (0, Constraints_1.minMaxLengthForType)(t) !== void 0 ? "manual" : "none";
      }
      return "none";
    }
    function alwaysApplyTransformation(xf) {
      const t = xf.targetType;
      if (t instanceof Type_1.EnumType) return true;
      if (t instanceof Type_1.UnionType) return (0, TypeUtils_1.nullableFromUnion)(t) === null;
      return false;
    }
    function csTypeForTransformedStringType(t) {
      switch (t.kind) {
        case "date-time":
          return "DateTimeOffset";
        case "uuid":
          return "Guid";
        case "uri":
          return "Uri";
        default:
          return (0, Support_1.panic)(`Transformed string type ${t.kind} not supported`);
      }
    }
    exports.namingFunction = (0, Naming_1.funPrefixNamer)("namer", csNameStyle);
    exports.namingFunctionKeep = (0, Naming_1.funPrefixNamer)("namerKeep", csNameStyleKeep);
    exports.denseJsonPropertyName = "J";
    exports.denseRequiredEnumName = "R";
    exports.denseNullValueHandlingEnumName = "N";
    function isStartCharacter(utf16Unit) {
      if (unicode_properties_1.default.isAlphabetic(utf16Unit)) {
        return true;
      }
      return utf16Unit === 95;
    }
    function isPartCharacter(utf16Unit) {
      const category = unicode_properties_1.default.getCategory(utf16Unit);
      if ([
        "Nd",
        "Pc",
        "Mn",
        "Mc"
      ].includes(category)) {
        return true;
      }
      return isStartCharacter(utf16Unit);
    }
    var legalizeName = (0, Strings_1.utf16LegalizeCharacters)(isPartCharacter);
    function csNameStyle(original) {
      const words = (0, Strings_1.splitIntoWords)(original);
      return (0, Strings_1.combineWords)(words, legalizeName, Strings_1.firstUpperWordStyle, Strings_1.firstUpperWordStyle, Strings_1.firstUpperWordStyle, Strings_1.firstUpperWordStyle, "", isStartCharacter);
    }
    function csNameStyleKeep(original) {
      const words = [
        {
          word: original,
          isAcronym: false
        }
      ];
      const result = (0, Strings_1.combineWords)(words, legalizeName, (x) => x, (x) => x, (x) => x, (x) => x, "", isStartCharacter);
      return constants_1.keywords.includes(result) ? `@${result}` : result;
    }
    function isValueType(t) {
      if (t instanceof Type_1.UnionType) {
        return (0, TypeUtils_1.nullableFromUnion)(t) === null;
      }
      return [
        "integer",
        "double",
        "bool",
        "enum",
        "date-time",
        "uuid"
      ].includes(t.kind);
    }
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/CSharp/CSharpRenderer.js
var require_CSharpRenderer = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/CSharp/CSharpRenderer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.CSharpRenderer = void 0;
    var collection_utils_1 = require_dist();
    var Annotation_1 = require_Annotation();
    var ConvenienceRenderer_1 = require_ConvenienceRenderer();
    var Source_1 = require_Source();
    var Support_1 = require_Support();
    var Transformers_1 = require_Transformers();
    var TypeUtils_1 = require_TypeUtils();
    var utils_1 = require_utils4();
    var CSharpRenderer = class extends ConvenienceRenderer_1.ConvenienceRenderer {
      constructor(targetLanguage, renderContext, _csOptions) {
        super(targetLanguage, renderContext);
        this._csOptions = _csOptions;
      }
      forbiddenNamesForGlobalNamespace() {
        return [
          "QuickType",
          "Type",
          "System",
          "Console",
          "Exception",
          "DateTimeOffset",
          "Guid",
          "Uri"
        ];
      }
      forbiddenForObjectProperties(_, classNamed) {
        return {
          names: [
            classNamed,
            "ToString",
            "GetHashCode",
            "Finalize",
            "Equals",
            "GetType",
            "MemberwiseClone",
            "ReferenceEquals"
          ],
          includeGlobalForbidden: false
        };
      }
      forbiddenForUnionMembers(_, unionNamed) {
        return {
          names: [
            unionNamed
          ],
          includeGlobalForbidden: true
        };
      }
      makeNamedTypeNamer() {
        return utils_1.namingFunction;
      }
      namerForObjectProperty() {
        return this._csOptions.keepPropertyName ? utils_1.namingFunctionKeep : utils_1.namingFunction;
      }
      makeUnionMemberNamer() {
        return utils_1.namingFunction;
      }
      makeEnumCaseNamer() {
        return utils_1.namingFunction;
      }
      unionNeedsName(u) {
        return (0, TypeUtils_1.nullableFromUnion)(u) === null;
      }
      namedTypeToNameForTopLevel(type) {
        return (0, TypeUtils_1.directlyReachableSingleNamedType)(type);
      }
      emitBlock(f, semicolon = false) {
        this.emitLine("{");
        this.indent(f);
        this.emitLine("}", semicolon ? ";" : "");
      }
      get doubleType() {
        return this._csOptions.useDecimal ? "decimal" : "double";
      }
      csType(t, follow = Transformers_1.followTargetType, withIssues = false) {
        const actualType = follow(t);
        return (0, TypeUtils_1.matchType)(actualType, (_anyType) => (0, Source_1.maybeAnnotated)(withIssues, Annotation_1.anyTypeIssueAnnotation, this._csOptions.typeForAny), (_nullType) => (0, Source_1.maybeAnnotated)(withIssues, Annotation_1.nullTypeIssueAnnotation, this._csOptions.typeForAny), (_boolType) => "bool", (_integerType) => "long", (_doubleType) => this.doubleType, (_stringType) => "string", (arrayType) => {
          const itemsType = this.csType(arrayType.items, follow, withIssues);
          if (this._csOptions.useList) {
            return [
              "List<",
              itemsType,
              ">"
            ];
          } else {
            return [
              itemsType,
              "[]"
            ];
          }
        }, (classType) => this.nameForNamedType(classType), (mapType) => [
          "Dictionary<string, ",
          this.csType(mapType.values, follow, withIssues),
          ">"
        ], (enumType) => this.nameForNamedType(enumType), (unionType) => {
          const nullable = (0, TypeUtils_1.nullableFromUnion)(unionType);
          if (nullable !== null) return this.nullableCSType(nullable, utils_1.noFollow);
          return this.nameForNamedType(unionType);
        }, (transformedStringType) => (0, utils_1.csTypeForTransformedStringType)(transformedStringType));
      }
      nullableCSType(t, follow = Transformers_1.followTargetType, withIssues = false) {
        t = (0, Transformers_1.followTargetType)(t);
        const csType = this.csType(t, follow, withIssues);
        if ((0, utils_1.isValueType)(t)) {
          return [
            csType,
            "?"
          ];
        } else {
          return csType;
        }
      }
      baseclassForType(_t) {
        return void 0;
      }
      emitType(description, accessModifier, declaration, name, baseclass, emitter) {
        switch (accessModifier) {
          case utils_1.AccessModifier.Public:
            declaration = [
              "public ",
              declaration
            ];
            break;
          case utils_1.AccessModifier.Internal:
            declaration = [
              "internal ",
              declaration
            ];
            break;
          default:
            break;
        }
        this.emitDescription(description);
        if (baseclass === void 0) {
          this.emitLine(declaration, " ", name);
        } else {
          this.emitLine(declaration, " ", name, " : ", baseclass);
        }
        this.emitBlock(emitter);
      }
      attributesForProperty(_property, _name, _c, _jsonName) {
        return void 0;
      }
      propertyDefinition(property, name, _c, _jsonName) {
        const t = property.type;
        const csType = property.isOptional ? this.nullableCSType(t, Transformers_1.followTargetType, true) : this.csType(t, Transformers_1.followTargetType, true);
        const propertyArray = [
          "public "
        ];
        if (this._csOptions.virtual) propertyArray.push("virtual ");
        return [
          ...propertyArray,
          csType,
          " ",
          name,
          " { get; set; }"
        ];
      }
      emitDescriptionBlock(lines) {
        const start = "/// <summary>";
        if (this._csOptions.dense) {
          this.emitLine(start, lines.join("; "), "</summary>");
        } else {
          this.emitCommentLines(lines, {
            lineStart: "/// ",
            beforeComment: start,
            afterComment: "/// </summary>"
          });
        }
      }
      blankLinesBetweenAttributes() {
        return false;
      }
      emitClassDefinition(c, className) {
        this.emitType(this.descriptionForType(c), utils_1.AccessModifier.Public, "partial class", className, this.baseclassForType(c), () => {
          if (c.getProperties().size === 0) return;
          const blankLines = this.blankLinesBetweenAttributes() ? "interposing" : "none";
          const columns = [];
          let isFirstProperty = true;
          let previousDescription = void 0;
          this.forEachClassProperty(c, blankLines, (name, jsonName, p) => {
            const attributes = this.attributesForProperty(p, name, c, jsonName);
            const description = this.descriptionForClassProperty(c, jsonName);
            const property = this.propertyDefinition(p, name, c, jsonName);
            if (attributes === void 0) {
              if (
                // Descriptions should be preceded by an empty line
                !isFirstProperty && description !== void 0 || // If the previous property has a description, leave an empty line
                previousDescription !== void 0
              ) {
                this.ensureBlankLine();
              }
              this.emitDescription(description);
              this.emitLine(property);
            } else if (this._csOptions.dense && attributes.length > 0) {
              const comment = description === void 0 ? "" : ` // ${description.join("; ")}`;
              columns.push([
                attributes,
                " ",
                property,
                comment
              ]);
            } else {
              this.emitDescription(description);
              for (const attribute of attributes) {
                this.emitLine(attribute);
              }
              this.emitLine(property);
            }
            isFirstProperty = false;
            previousDescription = description;
          });
          if (columns.length > 0) {
            this.emitTable(columns);
          }
        });
      }
      emitUnionDefinition(u, unionName) {
        const nonNulls = (0, TypeUtils_1.removeNullFromUnion)(u, true)[1];
        this.emitType(this.descriptionForType(u), utils_1.AccessModifier.Public, "partial struct", unionName, this.baseclassForType(u), () => {
          this.forEachUnionMember(u, nonNulls, "none", null, (fieldName, t) => {
            const csType = this.nullableCSType(t);
            this.emitLine("public ", csType, " ", fieldName, ";");
          });
          this.ensureBlankLine();
          const nullTests = Array.from(nonNulls).map((t) => [
            this.nameForUnionMember(u, t),
            " == null"
          ]);
          this.ensureBlankLine();
          this.forEachUnionMember(u, nonNulls, "none", null, (fieldName, t) => {
            const csType = this.csType(t);
            this.emitExpressionMember([
              "public static implicit operator ",
              unionName,
              "(",
              csType,
              " ",
              fieldName,
              ")"
            ], [
              "new ",
              unionName,
              " { ",
              fieldName,
              " = ",
              fieldName,
              " }"
            ]);
          });
          if (u.findMember("null") === void 0) return;
          this.emitExpressionMember("public bool IsNull", (0, collection_utils_1.arrayIntercalate)(" && ", nullTests), true);
        });
      }
      emitEnumDefinition(e, enumName) {
        const caseNames = [];
        this.forEachEnumCase(e, "none", (name) => {
          if (caseNames.length > 0) caseNames.push(", ");
          caseNames.push(name);
        });
        this.emitDescription(this.descriptionForType(e));
        this.emitLine("public enum ", enumName, " { ", caseNames, " };");
      }
      emitExpressionMember(declare, define2, isProperty = false) {
        if (this._csOptions.version === 5) {
          this.emitLine(declare);
          this.emitBlock(() => {
            const stmt = [
              "return ",
              define2,
              ";"
            ];
            if (isProperty) {
              this.emitLine("get");
              this.emitBlock(() => this.emitLine(stmt));
            } else {
              this.emitLine(stmt);
            }
          });
        } else {
          this.emitLine(declare, " => ", define2, ";");
        }
      }
      emitTypeSwitch(types, condition, withBlock, withReturn, f) {
        (0, Support_1.assert)(!withReturn || withBlock, "Can only have return with block");
        for (const t of types) {
          this.emitLine("if (", condition(t), ")");
          if (withBlock) {
            this.emitBlock(() => {
              f(t);
              if (withReturn) {
                this.emitLine("return;");
              }
            });
          } else {
            this.indent(() => f(t));
          }
        }
      }
      emitUsing(ns) {
        this.emitLine("using ", ns, ";");
      }
      emitUsings() {
        for (const ns of [
          "System",
          "System.Collections.Generic"
        ]) {
          this.emitUsing(ns);
        }
      }
      emitRequiredHelpers() {
        return;
      }
      emitTypesAndSupport() {
        this.forEachObject("leading-and-interposing", (c, name) => this.emitClassDefinition(c, name));
        this.forEachEnum("leading-and-interposing", (e, name) => this.emitEnumDefinition(e, name));
        this.forEachUnion("leading-and-interposing", (u, name) => this.emitUnionDefinition(u, name));
        this.emitRequiredHelpers();
      }
      emitDefaultLeadingComments() {
        return;
      }
      emitDefaultFollowingComments() {
        return;
      }
      needNamespace() {
        return true;
      }
      emitSourceStructure() {
        if (this.leadingComments !== void 0) {
          this.emitComments(this.leadingComments);
        } else {
          this.emitDefaultLeadingComments();
        }
        this.ensureBlankLine();
        if (this.needNamespace()) {
          this.emitLine("namespace ", this._csOptions.namespace);
          this.emitBlock(() => {
            this.emitUsings();
            this.emitTypesAndSupport();
          });
        } else {
          this.emitUsings();
          this.emitTypesAndSupport();
        }
        this.emitDefaultFollowingComments();
      }
      emitDependencyUsings() {
        let genericEmited = false;
        let ensureGenericOnce = () => {
          if (!genericEmited) {
            this.emitUsing("System.Collections.Generic");
            genericEmited = true;
          }
        };
        this.typeGraph.allTypesUnordered().forEach((_) => {
          (0, TypeUtils_1.matchCompoundType)(_, (_arrayType) => this._csOptions.useList ? ensureGenericOnce() : void 0, (_classType) => {
          }, (_mapType) => ensureGenericOnce(), (_objectType) => {
          }, (_unionType) => {
          });
        });
      }
    };
    exports.CSharpRenderer = CSharpRenderer;
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/CSharp/NewtonSoftCSharpRenderer.js
var require_NewtonSoftCSharpRenderer = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/CSharp/NewtonSoftCSharpRenderer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.NewtonsoftCSharpRenderer = void 0;
    var collection_utils_1 = require_dist();
    var ConvenienceRenderer_1 = require_ConvenienceRenderer();
    var Naming_1 = require_Naming();
    var Source_1 = require_Source();
    var Strings_1 = require_Strings();
    var Support_1 = require_Support();
    var Transformers_1 = require_Transformers();
    var Type_1 = require_Type2();
    var TypeUtils_1 = require_TypeUtils();
    var CSharpRenderer_1 = require_CSharpRenderer();
    var utils_1 = require_utils4();
    var NewtonsoftCSharpRenderer = class extends CSharpRenderer_1.CSharpRenderer {
      constructor(targetLanguage, renderContext, _options) {
        super(targetLanguage, renderContext, _options);
        this._options = _options;
        this._enumExtensionsNames = /* @__PURE__ */ new Map();
        this._needHelpers = _options.features.helpers;
        this._needAttributes = _options.features.attributes;
        this._needNamespaces = _options.features.namespaces;
      }
      forbiddenNamesForGlobalNamespace() {
        const forbidden = [
          "Converter",
          "JsonConverter",
          "JsonSerializer",
          "JsonWriter",
          "JsonToken",
          "Serialize",
          "Newtonsoft",
          "MetadataPropertyHandling",
          "DateParseHandling",
          "FromJson",
          "Required"
        ];
        if (this._options.dense) {
          forbidden.push("J", "R", "N");
        }
        if (this._options.baseclass !== void 0) {
          forbidden.push(this._options.baseclass);
        }
        return super.forbiddenNamesForGlobalNamespace().concat(forbidden);
      }
      forbiddenForObjectProperties(c, className) {
        const result = super.forbiddenForObjectProperties(c, className);
        result.names = result.names.concat([
          "ToJson",
          "FromJson",
          "Required"
        ]);
        return result;
      }
      makeNameForTransformation(xf, typeName) {
        if (typeName === void 0) {
          let xfer = xf.transformer;
          if (xfer instanceof Transformers_1.DecodingTransformer && xfer.consumer !== void 0) {
            xfer = xfer.consumer;
          }
          return new Naming_1.SimpleName([
            `${xfer.kind}_converter`
          ], utils_1.namingFunction, ConvenienceRenderer_1.inferredNameOrder + 30);
        }
        return new Naming_1.DependencyName(utils_1.namingFunction, typeName.order + 30, (lookup) => `${lookup(typeName)}_converter`);
      }
      makeNamedTypeDependencyNames(t, name) {
        if (!(t instanceof Type_1.EnumType)) return [];
        const extensionsName = new Naming_1.DependencyName(utils_1.namingFunction, name.order + 30, (lookup) => `${lookup(name)}_extensions`);
        this._enumExtensionsNames.set(name, extensionsName);
        return [
          extensionsName
        ];
      }
      emitUsings() {
        if (!this._needAttributes && !this._needHelpers) {
          this.emitDependencyUsings();
          return;
        }
        super.emitUsings();
        this.ensureBlankLine();
        for (const ns of [
          "System.Globalization",
          "Newtonsoft.Json",
          "Newtonsoft.Json.Converters"
        ]) {
          this.emitUsing(ns);
        }
        if (this._options.dense) {
          this.emitUsing([
            utils_1.denseJsonPropertyName,
            " = Newtonsoft.Json.JsonPropertyAttribute"
          ]);
          this.emitUsing([
            utils_1.denseRequiredEnumName,
            " = Newtonsoft.Json.Required"
          ]);
          this.emitUsing([
            utils_1.denseNullValueHandlingEnumName,
            " = Newtonsoft.Json.NullValueHandling"
          ]);
        }
        if (this._options.baseclass === "EntityData") {
          this.emitUsing("Microsoft.Azure.Mobile.Server");
        }
      }
      baseclassForType(_t) {
        return this._options.baseclass;
      }
      emitDefaultLeadingComments() {
        if (!this._needHelpers) return;
        this.emitLine("// <auto-generated />");
        this.emitLine("//");
        this.emitLine("// To parse this JSON data, add NuGet 'Newtonsoft.Json' then do", this.topLevels.size === 1 ? "" : " one of these", ":");
        this.emitLine("//");
        this.emitLine("//    using ", this._options.namespace, ";");
        this.emitLine("//");
        this.forEachTopLevel("none", (t, topLevelName) => {
          let rhs;
          if (t instanceof Type_1.EnumType) {
            rhs = [
              "JsonConvert.DeserializeObject<",
              topLevelName,
              ">(jsonString)"
            ];
          } else {
            rhs = [
              topLevelName,
              ".FromJson(jsonString)"
            ];
          }
          this.emitLine("//    var ", (0, Source_1.modifySource)(Strings_1.camelCase, topLevelName), " = ", rhs, ";");
        });
      }
      converterForType(t) {
        let xf = (0, Transformers_1.transformationForType)(t);
        if (xf === void 0 && t instanceof Type_1.UnionType) {
          const maybeNullable = (0, TypeUtils_1.nullableFromUnion)(t);
          if (maybeNullable !== null) {
            t = maybeNullable;
            xf = (0, Transformers_1.transformationForType)(t);
          }
        }
        if (xf === void 0) return void 0;
        if ((0, utils_1.alwaysApplyTransformation)(xf)) return void 0;
        return (0, Support_1.defined)(this.nameForTransformation(t));
      }
      attributesForProperty(property, _name, _c, jsonName) {
        if (!this._needAttributes) return void 0;
        const attributes = [];
        const jsonProperty = this._options.dense ? utils_1.denseJsonPropertyName : "JsonProperty";
        const escapedName = (0, Strings_1.utf16StringEscape)(jsonName);
        const isNullable = (0, Transformers_1.followTargetType)(property.type).isNullable;
        const isOptional = property.isOptional;
        const requiredClass = this._options.dense ? "R" : "Required";
        const nullValueHandlingClass = this._options.dense ? "N" : "NullValueHandling";
        const nullValueHandling = isOptional && !isNullable ? [
          ", NullValueHandling = ",
          nullValueHandlingClass,
          ".Ignore"
        ] : [];
        let required;
        if (!this._options.checkRequired || isOptional && isNullable) {
          required = [
            nullValueHandling
          ];
        } else if (isOptional && !isNullable) {
          required = [
            ", Required = ",
            requiredClass,
            ".DisallowNull",
            nullValueHandling
          ];
        } else if (!isOptional && isNullable) {
          required = [
            ", Required = ",
            requiredClass,
            ".AllowNull"
          ];
        } else {
          required = [
            ", Required = ",
            requiredClass,
            ".Always",
            nullValueHandling
          ];
        }
        attributes.push([
          "[",
          jsonProperty,
          '("',
          escapedName,
          '"',
          required,
          ")]"
        ]);
        const converter = this.converterForType(property.type);
        if (converter !== void 0) {
          attributes.push([
            "[JsonConverter(typeof(",
            converter,
            "))]"
          ]);
        }
        return attributes;
      }
      blankLinesBetweenAttributes() {
        return this._needAttributes && !this._options.dense;
      }
      // The "this" type can't be `dynamic`, so we have to force it to `object`.
      topLevelResultType(t) {
        return t.kind === "any" || t.kind === "none" ? "object" : this.csType(t);
      }
      emitFromJsonForTopLevel(t, name) {
        if (t instanceof Type_1.EnumType) return;
        let partial;
        let typeKind;
        const definedType = this.namedTypeToNameForTopLevel(t);
        if (definedType !== void 0) {
          partial = "partial ";
          typeKind = definedType instanceof Type_1.ClassType ? "class" : "struct";
        } else {
          partial = "";
          typeKind = "class";
        }
        const csType = this.topLevelResultType(t);
        this.emitType(void 0, utils_1.AccessModifier.Public, [
          partial,
          typeKind
        ], name, this.baseclassForType(t), () => {
          this.emitExpressionMember([
            "public static ",
            csType,
            " FromJson(string json)"
          ], [
            "JsonConvert.DeserializeObject<",
            csType,
            ">(json, ",
            this._options.namespace,
            ".Converter.Settings)"
          ]);
        });
      }
      emitDecoderSwitch(emitBody) {
        this.emitLine("switch (reader.TokenType)");
        this.emitBlock(emitBody);
      }
      emitTokenCase(tokenType) {
        this.emitLine("case JsonToken.", tokenType, ":");
      }
      emitThrow(message) {
        this.emitLine("throw new Exception(", message, ");");
      }
      deserializeTypeCode(typeName) {
        return [
          "serializer.Deserialize<",
          typeName,
          ">(reader)"
        ];
      }
      serializeValueCode(value) {
        return [
          "serializer.Serialize(writer, ",
          value,
          ")"
        ];
      }
      emitSerializeClass() {
        this.emitType(void 0, utils_1.AccessModifier.Public, "static class", "Serialize", void 0, () => {
          const seenTypes = /* @__PURE__ */ new Set();
          this.forEachTopLevel("none", (t) => {
            if (!seenTypes.has(t)) {
              seenTypes.add(t);
              this.emitExpressionMember([
                "public static string ToJson(this ",
                this.topLevelResultType(t),
                " self)"
              ], [
                "JsonConvert.SerializeObject(self, ",
                this._options.namespace,
                ".Converter.Settings)"
              ]);
            }
          });
        });
      }
      emitCanConvert(expr) {
        this.emitExpressionMember("public override bool CanConvert(Type t)", expr);
      }
      emitReadJson(emitBody) {
        this.emitLine("public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)");
        this.emitBlock(emitBody);
      }
      emitWriteJson(variable, emitBody) {
        this.emitLine("public override void WriteJson(JsonWriter writer, object ", variable, ", JsonSerializer serializer)");
        this.emitBlock(emitBody);
      }
      converterObject(converterName) {
        return [
          converterName,
          ".Singleton"
        ];
      }
      emitConverterClass() {
        const converterName = [
          "Converter"
        ];
        this.emitType(void 0, utils_1.AccessModifier.Internal, "static class", converterName, void 0, () => {
          this.emitLine("public static readonly JsonSerializerSettings Settings = new JsonSerializerSettings");
          this.emitBlock(() => {
            this.emitLine("MetadataPropertyHandling = MetadataPropertyHandling.Ignore,");
            this.emitLine("DateParseHandling = DateParseHandling.None,");
            this.emitLine("Converters =");
            this.emitLine("{");
            this.indent(() => {
              for (const [t, converter] of this.typesWithNamedTransformations) {
                if ((0, utils_1.alwaysApplyTransformation)((0, Support_1.defined)((0, Transformers_1.transformationForType)(t)))) {
                  this.emitLine(this.converterObject(converter), ",");
                }
              }
              this.emitLine("new IsoDateTimeConverter { DateTimeStyles = DateTimeStyles.AssumeUniversal }");
            });
            this.emitLine("},");
          }, true);
        });
      }
      emitDecoderTransformerCase(tokenCases, variableName, xfer, targetType, emitFinish) {
        if (xfer === void 0) return;
        for (const tokenCase of tokenCases) {
          this.emitTokenCase(tokenCase);
        }
        this.indent(() => {
          const allHandled = this.emitDecodeTransformer(xfer, targetType, emitFinish, variableName);
          if (!allHandled) {
            this.emitLine("break;");
          }
        });
      }
      emitConsume(value, consumer, targetType, emitFinish) {
        if (consumer === void 0) {
          emitFinish(value);
          return true;
        }
        return this.emitTransformer(value, consumer, targetType, emitFinish);
      }
      emitDecodeTransformer(xfer, targetType, emitFinish, variableName = "value") {
        if (xfer instanceof Transformers_1.DecodingTransformer) {
          const source = xfer.sourceType;
          const converter = this.converterForType(targetType);
          if (converter !== void 0) {
            const typeSource = this.csType(targetType);
            this.emitLine("var converter = ", this.converterObject(converter), ";");
            this.emitLine("var ", variableName, " = (", typeSource, ")converter.ReadJson(reader, typeof(", typeSource, "), null, serializer);");
          } else if (source.kind !== "null") {
            const output = targetType.kind === "double" ? targetType : source;
            this.emitLine("var ", variableName, " = ", this.deserializeTypeCode(this.csType(output)), ";");
          }
          return this.emitConsume(variableName, xfer.consumer, targetType, emitFinish);
        }
        if (xfer instanceof Transformers_1.ArrayDecodingTransformer) {
          if (!(targetType instanceof Type_1.ArrayType)) {
            return (0, Support_1.panic)("Array decoding must produce an array type");
          }
          this.emitLine("reader.Read();");
          this.emitLine("var ", variableName, " = new List<", this.csType(targetType.items), ">();");
          this.emitLine("while (reader.TokenType != JsonToken.EndArray)");
          this.emitBlock(() => {
            this.emitDecodeTransformer(xfer.itemTransformer, xfer.itemTargetType, (v) => this.emitLine(variableName, ".Add(", v, ");"), "arrayItem");
            this.emitLine("reader.Read();");
          });
          let result = variableName;
          if (!this._options.useList) {
            result = [
              result,
              ".ToArray()"
            ];
          }
          emitFinish(result);
          return true;
        }
        if (xfer instanceof Transformers_1.DecodingChoiceTransformer) {
          this.emitDecoderSwitch(() => {
            const nullTransformer = xfer.nullTransformer;
            if (nullTransformer !== void 0) {
              this.emitTokenCase("Null");
              this.indent(() => {
                const allHandled = this.emitDecodeTransformer(nullTransformer, targetType, emitFinish, "null");
                if (!allHandled) {
                  this.emitLine("break");
                }
              });
            }
            this.emitDecoderTransformerCase([
              "Integer"
            ], "integerValue", xfer.integerTransformer, targetType, emitFinish);
            this.emitDecoderTransformerCase(xfer.integerTransformer === void 0 ? [
              "Integer",
              "Float"
            ] : [
              "Float"
            ], "doubleValue", xfer.doubleTransformer, targetType, emitFinish);
            this.emitDecoderTransformerCase([
              "Boolean"
            ], "boolValue", xfer.boolTransformer, targetType, emitFinish);
            this.emitDecoderTransformerCase([
              "String",
              "Date"
            ], "stringValue", xfer.stringTransformer, targetType, emitFinish);
            this.emitDecoderTransformerCase([
              "StartObject"
            ], "objectValue", xfer.objectTransformer, targetType, emitFinish);
            this.emitDecoderTransformerCase([
              "StartArray"
            ], "arrayValue", xfer.arrayTransformer, targetType, emitFinish);
          });
          return false;
        }
        return (0, Support_1.panic)("Unknown transformer");
      }
      stringCaseValue(t, stringCase) {
        if (t.kind === "string") {
          return [
            '"',
            (0, Strings_1.utf16StringEscape)(stringCase),
            '"'
          ];
        }
        if (t instanceof Type_1.EnumType) {
          return [
            this.nameForNamedType(t),
            ".",
            this.nameForEnumCase(t, stringCase)
          ];
        }
        return (0, Support_1.panic)(`Type ${t.kind} does not have string cases`);
      }
      emitTransformer(variable, xfer, targetType, emitFinish) {
        function directTargetType(continuation) {
          if (continuation === void 0) {
            return targetType;
          }
          return (0, Transformers_1.followTargetType)(continuation.sourceType);
        }
        if (xfer instanceof Transformers_1.ChoiceTransformer) {
          const caseXfers = xfer.transformers;
          if (caseXfers.length > 1 && caseXfers.every((caseXfer) => caseXfer instanceof Transformers_1.StringMatchTransformer)) {
            this.emitLine("switch (", variable, ")");
            this.emitBlock(() => {
              for (const caseXfer of caseXfers) {
                const matchXfer = caseXfer;
                const value = this.stringCaseValue((0, Transformers_1.followTargetType)(matchXfer.sourceType), matchXfer.stringCase);
                this.emitLine("case ", value, ":");
                this.indent(() => {
                  const allDone = this.emitTransformer(variable, matchXfer.transformer, targetType, emitFinish);
                  if (!allDone) {
                    this.emitLine("break;");
                  }
                });
              }
            });
            return false;
          }
          for (const caseXfer of caseXfers) {
            this.emitTransformer(variable, caseXfer, targetType, emitFinish);
          }
        } else if (xfer instanceof Transformers_1.UnionMemberMatchTransformer) {
          const memberType = xfer.memberType;
          const maybeNullable = (0, TypeUtils_1.nullableFromUnion)(xfer.sourceType);
          let test;
          let member;
          if (maybeNullable !== null) {
            if (memberType.kind === "null") {
              test = [
                variable,
                " == null"
              ];
              member = "null";
            } else {
              test = [
                variable,
                " != null"
              ];
              member = variable;
            }
          } else if (memberType.kind === "null") {
            test = [
              variable,
              ".IsNull"
            ];
            member = "null";
          } else {
            const memberName = this.nameForUnionMember(xfer.sourceType, memberType);
            member = [
              variable,
              ".",
              memberName
            ];
            test = [
              member,
              " != null"
            ];
          }
          if (memberType.kind !== "null" && (0, utils_1.isValueType)(memberType)) {
            member = [
              member,
              ".Value"
            ];
          }
          this.emitLine("if (", test, ")");
          this.emitBlock(() => this.emitTransformer(member, xfer.transformer, targetType, emitFinish));
        } else if (xfer instanceof Transformers_1.StringMatchTransformer) {
          const value = this.stringCaseValue((0, Transformers_1.followTargetType)(xfer.sourceType), xfer.stringCase);
          this.emitLine("if (", variable, " == ", value, ")");
          this.emitBlock(() => this.emitTransformer(variable, xfer.transformer, targetType, emitFinish));
        } else if (xfer instanceof Transformers_1.EncodingTransformer) {
          const converter = this.converterForType(xfer.sourceType);
          if (converter !== void 0) {
            this.emitLine("var converter = ", this.converterObject(converter), ";");
            this.emitLine("converter.WriteJson(writer, ", variable, ", serializer);");
          } else {
            this.emitLine(this.serializeValueCode(variable), ";");
          }
          emitFinish([]);
          return true;
        } else if (xfer instanceof Transformers_1.ArrayEncodingTransformer) {
          this.emitLine("writer.WriteStartArray();");
          const itemVariable = "arrayItem";
          this.emitLine("foreach (var ", itemVariable, " in ", variable, ")");
          this.emitBlock(() => {
            this.emitTransformer(itemVariable, xfer.itemTransformer, xfer.itemTargetType, () => {
              return;
            });
          });
          this.emitLine("writer.WriteEndArray();");
          emitFinish([]);
          return true;
        } else if (xfer instanceof Transformers_1.ParseStringTransformer) {
          const immediateTargetType = xfer.consumer === void 0 ? targetType : xfer.consumer.sourceType;
          switch (immediateTargetType.kind) {
            case "date-time":
              this.emitLine("DateTimeOffset dt;");
              this.emitLine("if (DateTimeOffset.TryParse(", variable, ", out dt))");
              this.emitBlock(() => this.emitConsume("dt", xfer.consumer, targetType, emitFinish));
              break;
            case "uuid":
              this.emitLine("Guid guid;");
              this.emitLine("if (Guid.TryParse(", variable, ", out guid))");
              this.emitBlock(() => this.emitConsume("guid", xfer.consumer, targetType, emitFinish));
              break;
            case "uri":
              this.emitLine("try");
              this.emitBlock(() => {
                this.emitLine("var uri = new Uri(", variable, ");");
                this.emitConsume("uri", xfer.consumer, targetType, emitFinish);
              });
              this.emitLine("catch (UriFormatException) {}");
              break;
            case "integer":
              this.emitLine("long l;");
              this.emitLine("if (Int64.TryParse(", variable, ", out l))");
              this.emitBlock(() => this.emitConsume("l", xfer.consumer, targetType, emitFinish));
              break;
            case "bool":
              this.emitLine("bool b;");
              this.emitLine("if (Boolean.TryParse(", variable, ", out b))");
              this.emitBlock(() => this.emitConsume("b", xfer.consumer, targetType, emitFinish));
              break;
            default:
              return (0, Support_1.panic)(`Parsing string to ${immediateTargetType.kind} not supported`);
          }
        } else if (xfer instanceof Transformers_1.StringifyTransformer) {
          switch (xfer.sourceType.kind) {
            case "date-time":
              return this.emitConsume([
                variable,
                '.ToString("o", System.Globalization.CultureInfo.InvariantCulture)'
              ], xfer.consumer, targetType, emitFinish);
            case "uuid":
              return this.emitConsume([
                variable,
                '.ToString("D", System.Globalization.CultureInfo.InvariantCulture)'
              ], xfer.consumer, targetType, emitFinish);
            case "integer":
            case "uri":
              return this.emitConsume([
                variable,
                ".ToString()"
              ], xfer.consumer, targetType, emitFinish);
            case "bool":
              this.emitLine("var boolString = ", variable, ' ? "true" : "false";');
              return this.emitConsume("boolString", xfer.consumer, targetType, emitFinish);
            default:
              return (0, Support_1.panic)(`Stringifying ${xfer.sourceType.kind} not supported`);
          }
        } else if (xfer instanceof Transformers_1.StringProducerTransformer) {
          const value = this.stringCaseValue(directTargetType(xfer.consumer), xfer.result);
          return this.emitConsume(value, xfer.consumer, targetType, emitFinish);
        } else if (xfer instanceof Transformers_1.MinMaxLengthCheckTransformer) {
          const min = xfer.minLength;
          const max = xfer.maxLength;
          const conditions = [];
          if (min !== void 0) {
            conditions.push([
              variable,
              ".Length >= ",
              min.toString()
            ]);
          }
          if (max !== void 0) {
            conditions.push([
              variable,
              ".Length <= ",
              max.toString()
            ]);
          }
          this.emitLine("if (", (0, collection_utils_1.arrayIntercalate)([
            " && "
          ], conditions), ")");
          this.emitBlock(() => this.emitConsume(variable, xfer.consumer, targetType, emitFinish));
          return false;
        } else if (xfer instanceof Transformers_1.MinMaxValueTransformer) {
          const min = xfer.minimum;
          const max = xfer.maximum;
          const conditions = [];
          if (min !== void 0) {
            conditions.push([
              variable,
              " >= ",
              min.toString()
            ]);
          }
          if (max !== void 0) {
            conditions.push([
              variable,
              " <= ",
              max.toString()
            ]);
          }
          this.emitLine("if (", (0, collection_utils_1.arrayIntercalate)([
            " && "
          ], conditions), ")");
          this.emitBlock(() => this.emitConsume(variable, xfer.consumer, targetType, emitFinish));
          return false;
        } else if (xfer instanceof Transformers_1.UnionInstantiationTransformer) {
          if (!(targetType instanceof Type_1.UnionType)) {
            return (0, Support_1.panic)("Union instantiation transformer must produce a union type");
          }
          const maybeNullable = (0, TypeUtils_1.nullableFromUnion)(targetType);
          if (maybeNullable !== null) {
            emitFinish(variable);
          } else {
            const unionName = this.nameForNamedType(targetType);
            let initializer;
            if (xfer.sourceType.kind === "null") {
              initializer = " ";
            } else {
              const memberName = this.nameForUnionMember(targetType, xfer.sourceType);
              initializer = [
                " ",
                memberName,
                " = ",
                variable,
                " "
              ];
            }
            emitFinish([
              "new ",
              unionName,
              " {",
              initializer,
              "}"
            ]);
          }
          return true;
        } else {
          return (0, Support_1.panic)("Unknown transformer");
        }
        return false;
      }
      emitTransformation(converterName, t) {
        const xf = (0, Support_1.defined)((0, Transformers_1.transformationForType)(t));
        const reverse = xf.reverse;
        const targetType = xf.targetType;
        const xfer = xf.transformer;
        this.emitType(void 0, utils_1.AccessModifier.Internal, "class", converterName, "JsonConverter", () => {
          const csType = this.csType(targetType);
          let canConvertExpr = [
            "t == typeof(",
            csType,
            ")"
          ];
          const haveNullable = (0, utils_1.isValueType)(targetType);
          if (haveNullable) {
            canConvertExpr = [
              canConvertExpr,
              " || t == typeof(",
              csType,
              "?)"
            ];
          }
          this.emitCanConvert(canConvertExpr);
          this.ensureBlankLine();
          this.emitReadJson(() => {
            if (haveNullable && !(targetType instanceof Type_1.UnionType)) {
              this.emitLine("if (reader.TokenType == JsonToken.Null) return null;");
            }
            const allHandled = this.emitDecodeTransformer(xfer, targetType, (v) => this.emitLine("return ", v, ";"));
            if (!allHandled) {
              this.emitThrow([
                '"Cannot unmarshal type ',
                csType,
                '"'
              ]);
            }
          });
          this.ensureBlankLine();
          this.emitWriteJson("untypedValue", () => {
            if (haveNullable && !(targetType instanceof Type_1.UnionType)) {
              this.emitLine("if (untypedValue == null)");
              this.emitBlock(() => {
                this.emitLine("serializer.Serialize(writer, null);");
                this.emitLine("return;");
              });
            }
            this.emitLine("var value = (", csType, ")untypedValue;");
            const allHandled = this.emitTransformer("value", reverse.transformer, reverse.targetType, () => this.emitLine("return;"));
            if (!allHandled) {
              this.emitThrow([
                '"Cannot marshal type ',
                csType,
                '"'
              ]);
            }
          });
          this.ensureBlankLine();
          this.emitLine("public static readonly ", converterName, " Singleton = new ", converterName, "();");
        });
      }
      emitRequiredHelpers() {
        if (this._needHelpers) {
          this.forEachTopLevel("leading-and-interposing", (t, n) => this.emitFromJsonForTopLevel(t, n));
          this.ensureBlankLine();
          this.emitSerializeClass();
        }
        if (this._needHelpers || this._needAttributes && (this.haveNamedUnions || this.haveEnums)) {
          this.ensureBlankLine();
          this.emitConverterClass();
          this.forEachTransformation("leading-and-interposing", (n, t) => this.emitTransformation(n, t));
        }
      }
      needNamespace() {
        return this._needNamespaces;
      }
    };
    exports.NewtonsoftCSharpRenderer = NewtonsoftCSharpRenderer;
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/CSharp/SystemTextJsonCSharpRenderer.js
var require_SystemTextJsonCSharpRenderer = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/CSharp/SystemTextJsonCSharpRenderer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.SystemTextJsonCSharpRenderer = void 0;
    var collection_utils_1 = require_dist();
    var ConvenienceRenderer_1 = require_ConvenienceRenderer();
    var Naming_1 = require_Naming();
    var Source_1 = require_Source();
    var Strings_1 = require_Strings();
    var Support_1 = require_Support();
    var Transformers_1 = require_Transformers();
    var Type_1 = require_Type2();
    var TypeUtils_1 = require_TypeUtils();
    var CSharpRenderer_1 = require_CSharpRenderer();
    var utils_1 = require_utils4();
    var SystemTextJsonCSharpRenderer = class extends CSharpRenderer_1.CSharpRenderer {
      constructor(targetLanguage, renderContext, _options) {
        super(targetLanguage, renderContext, _options);
        this._options = _options;
        this._enumExtensionsNames = /* @__PURE__ */ new Map();
        this._needHelpers = _options.features.helpers;
        this._needAttributes = _options.features.attributes;
        this._needNamespaces = _options.features.namespaces;
      }
      forbiddenNamesForGlobalNamespace() {
        const forbidden = [
          "Converter",
          "JsonConverter",
          "JsonSerializer",
          "JsonWriter",
          "JsonToken",
          "Serialize",
          "JsonSerializerOptions",
          // "Newtonsoft",
          // "MetadataPropertyHandling",
          // "DateParseHandling",
          "FromJson",
          "Required"
        ];
        if (this._options.dense) {
          forbidden.push("J", "R", "N");
        }
        if (this._options.baseclass !== void 0) {
          forbidden.push(this._options.baseclass);
        }
        return super.forbiddenNamesForGlobalNamespace().concat(forbidden);
      }
      forbiddenForObjectProperties(c, className) {
        const result = super.forbiddenForObjectProperties(c, className);
        result.names = result.names.concat([
          "ToJson",
          "FromJson",
          "Required"
        ]);
        return result;
      }
      makeNameForTransformation(xf, typeName) {
        if (typeName === void 0) {
          let xfer = xf.transformer;
          if (xfer instanceof Transformers_1.DecodingTransformer && xfer.consumer !== void 0) {
            xfer = xfer.consumer;
          }
          return new Naming_1.SimpleName([
            `${xfer.kind}_converter`
          ], utils_1.namingFunction, ConvenienceRenderer_1.inferredNameOrder + 30);
        }
        return new Naming_1.DependencyName(utils_1.namingFunction, typeName.order + 30, (lookup) => `${lookup(typeName)}_converter`);
      }
      makeNamedTypeDependencyNames(t, name) {
        if (!(t instanceof Type_1.EnumType)) return [];
        const extensionsName = new Naming_1.DependencyName(utils_1.namingFunction, name.order + 30, (lookup) => `${lookup(name)}_extensions`);
        this._enumExtensionsNames.set(name, extensionsName);
        return [
          extensionsName
        ];
      }
      emitUsings() {
        if (!this._needAttributes && !this._needHelpers) {
          this.emitDependencyUsings();
          return;
        }
        super.emitUsings();
        this.ensureBlankLine();
        for (const ns of [
          "System.Text.Json",
          "System.Text.Json.Serialization",
          "System.Globalization"
        ]) {
          this.emitUsing(ns);
        }
        if (this._options.dense) {
          this.emitUsing([
            utils_1.denseJsonPropertyName,
            " = System.Text.Json.Serialization.JsonPropertyNameAttribute"
          ]);
          this.emitUsing([
            utils_1.denseNullValueHandlingEnumName,
            " = System.Text.Json.Serialization.JsonIgnoreCondition"
          ]);
        }
        if (this._options.baseclass === "EntityData") {
          this.emitUsing("Microsoft.Azure.Mobile.Server");
        }
      }
      baseclassForType(_t) {
        return this._options.baseclass;
      }
      emitDefaultFollowingComments() {
        if (!this._needHelpers) return;
        this.emitLine("#pragma warning restore CS8618");
        this.emitLine("#pragma warning restore CS8601");
        this.emitLine("#pragma warning restore CS8603");
      }
      emitDefaultLeadingComments() {
        if (!this._needHelpers) return;
        this.emitLine("// <auto-generated />");
        this.emitLine("//");
        this.emitLine("// To parse this JSON data, add NuGet 'System.Text.Json' then do", this.topLevels.size === 1 ? "" : " one of these", ":");
        this.emitLine("//");
        this.emitLine("//    using ", this._options.namespace, ";");
        this.emitLine("//");
        this.forEachTopLevel("none", (t, topLevelName) => {
          let rhs;
          if (t instanceof Type_1.EnumType) {
            rhs = [
              "JsonSerializer.Deserialize<",
              topLevelName,
              ">(jsonString)"
            ];
          } else {
            rhs = [
              topLevelName,
              ".FromJson(jsonString)"
            ];
          }
          this.emitLine("//    var ", (0, Source_1.modifySource)(Strings_1.camelCase, topLevelName), " = ", rhs, ";");
        });
        this.emitLine("#nullable enable");
        this.emitLine("#pragma warning disable CS8618");
        this.emitLine("#pragma warning disable CS8601");
        this.emitLine("#pragma warning disable CS8603");
      }
      converterForType(t) {
        let xf = (0, Transformers_1.transformationForType)(t);
        if (xf === void 0 && t instanceof Type_1.UnionType) {
          const maybeNullable = (0, TypeUtils_1.nullableFromUnion)(t);
          if (maybeNullable !== null) {
            t = maybeNullable;
            xf = (0, Transformers_1.transformationForType)(t);
          }
        }
        if (xf === void 0) return void 0;
        if ((0, utils_1.alwaysApplyTransformation)(xf)) return void 0;
        return (0, Support_1.defined)(this.nameForTransformation(t));
      }
      attributesForProperty(property, _name, _c, jsonName) {
        if (!this._needAttributes) return void 0;
        const attributes = [];
        const jsonPropertyName = this._options.dense ? utils_1.denseJsonPropertyName : "JsonPropertyName";
        const escapedName = (0, Strings_1.utf16StringEscape)(jsonName);
        const isNullable = (0, Transformers_1.followTargetType)(property.type).isNullable;
        const isOptional = property.isOptional;
        if (isOptional && !isNullable) {
          attributes.push([
            "[",
            "JsonIgnore",
            "(Condition = JsonIgnoreCondition.WhenWritingNull)]"
          ]);
        }
        attributes.push([
          "[",
          jsonPropertyName,
          '("',
          escapedName,
          '")]'
        ]);
        const converter = this.converterForType(property.type);
        if (converter !== void 0) {
          attributes.push([
            "[JsonConverter(typeof(",
            converter,
            "))]"
          ]);
        }
        return attributes;
      }
      blankLinesBetweenAttributes() {
        return this._needAttributes && !this._options.dense;
      }
      // The "this" type can't be `dynamic`, so we have to force it to `object`.
      topLevelResultType(t) {
        return t.kind === "any" || t.kind === "none" ? "object" : this.csType(t);
      }
      emitFromJsonForTopLevel(t, name) {
        if (t instanceof Type_1.EnumType) return;
        let partial;
        let typeKind;
        const definedType = this.namedTypeToNameForTopLevel(t);
        if (definedType !== void 0) {
          partial = "partial ";
          typeKind = definedType instanceof Type_1.ClassType ? "class" : "struct";
        } else {
          partial = "";
          typeKind = "class";
        }
        const csType = this.topLevelResultType(t);
        this.emitType(void 0, utils_1.AccessModifier.Public, [
          partial,
          typeKind
        ], name, this.baseclassForType(t), () => {
          this.emitExpressionMember([
            "public static ",
            csType,
            " FromJson(string json)"
          ], [
            "JsonSerializer.Deserialize<",
            csType,
            ">(json, ",
            this._options.namespace,
            ".Converter.Settings)"
          ]);
        });
      }
      emitDecoderSwitch(emitBody) {
        this.emitLine("switch (reader.TokenType)");
        this.emitBlock(emitBody);
      }
      emitTokenCase(tokenType) {
        this.emitLine("case JsonTokenType.", tokenType, ":");
      }
      emitThrow(message) {
        this.emitLine("throw new Exception(", message, ");");
      }
      deserializeTypeCode(typeName) {
        switch (typeName) {
          case "bool":
            return [
              "reader.GetBoolean()"
            ];
          case "long":
            return [
              "reader.GetInt64()"
            ];
          case "decimal":
            return [
              "reader.GetDecimal()"
            ];
          case "double":
            return [
              "reader.GetDouble()"
            ];
          case "string":
            return [
              "reader.GetString()"
            ];
          default:
            return [
              "JsonSerializer.Deserialize<",
              typeName,
              ">(ref reader, options)"
            ];
        }
      }
      serializeValueCode(value) {
        if (value !== "null") {
          return [
            "JsonSerializer.Serialize(writer, ",
            value,
            ", options)"
          ];
        }
        return [
          "writer.WriteNullValue()"
        ];
      }
      emitSerializeClass() {
        this.emitType(void 0, utils_1.AccessModifier.Public, "static class", "Serialize", void 0, () => {
          const seenTypes = /* @__PURE__ */ new Set();
          this.forEachTopLevel("none", (t) => {
            if (!seenTypes.has(t)) {
              seenTypes.add(t);
              this.emitExpressionMember([
                "public static string ToJson(this ",
                this.topLevelResultType(t),
                " self)"
              ], [
                "JsonSerializer.Serialize(self, ",
                this._options.namespace,
                ".Converter.Settings)"
              ]);
            }
          });
        });
      }
      emitCanConvert(expr) {
        this.emitExpressionMember("public override bool CanConvert(Type t)", expr);
      }
      emitReadJson(emitBody, csType) {
        this.emitLine("public override ", csType, " Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)");
        this.emitBlock(emitBody);
      }
      emitWriteJson(variable, emitBody, csType) {
        this.emitLine("public override void Write(Utf8JsonWriter writer, ", csType, " ", variable, ", JsonSerializerOptions options)");
        this.emitBlock(emitBody);
      }
      converterObject(converterName) {
        return [
          converterName,
          ".Singleton"
        ];
      }
      emitConverterClass() {
        const converterName = [
          "Converter"
        ];
        this.emitType(void 0, utils_1.AccessModifier.Internal, "static class", converterName, void 0, () => {
          this.emitLine("public static readonly JsonSerializerOptions Settings = new(JsonSerializerDefaults.General)");
          this.emitBlock(() => {
            this.emitLine("Converters =");
            this.emitLine("{");
            this.indent(() => {
              for (const [t, converter] of this.typesWithNamedTransformations) {
                if ((0, utils_1.alwaysApplyTransformation)((0, Support_1.defined)((0, Transformers_1.transformationForType)(t)))) {
                  this.emitLine(this.converterObject(converter), ",");
                }
              }
              this.emitLine("new DateOnlyConverter(),");
              this.emitLine("new TimeOnlyConverter(),");
              this.emitLine("IsoDateTimeOffsetConverter.Singleton");
            });
            this.emitLine("},");
          }, true);
        });
      }
      emitDecoderTransformerCase(tokenCases, variableName, xfer, targetType, emitFinish) {
        if (xfer === void 0) return;
        for (const tokenCase of tokenCases) {
          this.emitTokenCase(tokenCase);
        }
        this.indent(() => {
          const allHandled = this.emitDecodeTransformer(xfer, targetType, emitFinish, variableName);
          if (!allHandled) {
            this.emitLine("break;");
          }
        });
      }
      emitConsume(value, consumer, targetType, emitFinish) {
        if (consumer === void 0) {
          emitFinish(value);
          return true;
        }
        return this.emitTransformer(value, consumer, targetType, emitFinish);
      }
      emitDecodeTransformer(xfer, targetType, emitFinish, variableName = "value") {
        if (xfer instanceof Transformers_1.DecodingTransformer) {
          const source = xfer.sourceType;
          const converter = this.converterForType(targetType);
          if (converter !== void 0) {
            const typeSource = this.csType(targetType);
            this.emitLine("var converter = ", this.converterObject(converter), ";");
            this.emitLine("var ", variableName, " = (", typeSource, ")converter.ReadJson(reader, typeof(", typeSource, "), null, serializer);");
          } else if (source.kind !== "null") {
            const output = targetType.kind === "double" ? targetType : source;
            this.emitLine("var ", variableName, " = ", this.deserializeTypeCode(this.csType(output)), ";");
          }
          return this.emitConsume(variableName, xfer.consumer, targetType, emitFinish);
        }
        if (xfer instanceof Transformers_1.ArrayDecodingTransformer) {
          if (!(targetType instanceof Type_1.ArrayType)) {
            return (0, Support_1.panic)("Array decoding must produce an array type");
          }
          this.emitLine("reader.Read();");
          this.emitLine("var ", variableName, " = new List<", this.csType(targetType.items), ">();");
          this.emitLine("while (reader.TokenType != JsonToken.EndArray)");
          this.emitBlock(() => {
            this.emitDecodeTransformer(xfer.itemTransformer, xfer.itemTargetType, (v) => this.emitLine(variableName, ".Add(", v, ");"), "arrayItem");
            this.emitLine("reader.Read();");
          });
          let result = variableName;
          if (!this._options.useList) {
            result = [
              result,
              ".ToArray()"
            ];
          }
          emitFinish(result);
          return true;
        }
        if (xfer instanceof Transformers_1.DecodingChoiceTransformer) {
          this.emitDecoderSwitch(() => {
            const nullTransformer = xfer.nullTransformer;
            if (nullTransformer !== void 0) {
              this.emitTokenCase("Null");
              this.indent(() => {
                const allHandled = this.emitDecodeTransformer(nullTransformer, targetType, emitFinish, "null");
                if (!allHandled) {
                  this.emitLine("break");
                }
              });
            }
            this.emitDecoderTransformerCase([
              "Number"
            ], "integerValue", xfer.integerTransformer, targetType, emitFinish);
            this.emitDecoderTransformerCase(
              [
                "Number"
              ],
              // xfer.integerTransformer === undefined ? ["Integer", "Float"] : ["Float"],
              "doubleValue",
              xfer.doubleTransformer,
              targetType,
              emitFinish
            );
            this.emitDecoderTransformerCase([
              "True",
              "False"
            ], "boolValue", xfer.boolTransformer, targetType, emitFinish);
            this.emitDecoderTransformerCase(
              // ["String", "Date"],
              [
                "String"
              ],
              "stringValue",
              xfer.stringTransformer,
              targetType,
              emitFinish
            );
            this.emitDecoderTransformerCase([
              "StartObject"
            ], "objectValue", xfer.objectTransformer, targetType, emitFinish);
            this.emitDecoderTransformerCase([
              "StartArray"
            ], "arrayValue", xfer.arrayTransformer, targetType, emitFinish);
          });
          return false;
        }
        return (0, Support_1.panic)("Unknown transformer");
      }
      stringCaseValue(t, stringCase) {
        if (t.kind === "string") {
          return [
            '"',
            (0, Strings_1.utf16StringEscape)(stringCase),
            '"'
          ];
        }
        if (t instanceof Type_1.EnumType) {
          return [
            this.nameForNamedType(t),
            ".",
            this.nameForEnumCase(t, stringCase)
          ];
        }
        return (0, Support_1.panic)(`Type ${t.kind} does not have string cases`);
      }
      emitTransformer(variable, xfer, targetType, emitFinish) {
        function directTargetType(continuation) {
          if (continuation === void 0) {
            return targetType;
          }
          return (0, Transformers_1.followTargetType)(continuation.sourceType);
        }
        if (xfer instanceof Transformers_1.ChoiceTransformer) {
          const caseXfers = xfer.transformers;
          if (caseXfers.length > 1 && caseXfers.every((caseXfer) => caseXfer instanceof Transformers_1.StringMatchTransformer)) {
            this.emitLine("switch (", variable, ")");
            this.emitBlock(() => {
              for (const caseXfer of caseXfers) {
                const matchXfer = caseXfer;
                const value = this.stringCaseValue((0, Transformers_1.followTargetType)(matchXfer.sourceType), matchXfer.stringCase);
                this.emitLine("case ", value, ":");
                this.indent(() => {
                  const allDone = this.emitTransformer(variable, matchXfer.transformer, targetType, emitFinish);
                  if (!allDone) {
                    this.emitLine("break;");
                  }
                });
              }
            });
            return false;
          }
          for (const caseXfer of caseXfers) {
            this.emitTransformer(variable, caseXfer, targetType, emitFinish);
          }
        } else if (xfer instanceof Transformers_1.UnionMemberMatchTransformer) {
          const memberType = xfer.memberType;
          const maybeNullable = (0, TypeUtils_1.nullableFromUnion)(xfer.sourceType);
          let test;
          let member;
          if (maybeNullable !== null) {
            if (memberType.kind === "null") {
              test = [
                variable,
                " == null"
              ];
              member = "null";
            } else {
              test = [
                variable,
                " != null"
              ];
              member = variable;
            }
          } else if (memberType.kind === "null") {
            test = [
              variable,
              ".IsNull"
            ];
            member = "null";
          } else {
            const memberName = this.nameForUnionMember(xfer.sourceType, memberType);
            member = [
              variable,
              ".",
              memberName
            ];
            test = [
              member,
              " != null"
            ];
          }
          if (memberType.kind !== "null" && (0, utils_1.isValueType)(memberType)) {
            member = [
              member,
              ".Value"
            ];
          }
          this.emitLine("if (", test, ")");
          this.emitBlock(() => this.emitTransformer(member, xfer.transformer, targetType, emitFinish));
        } else if (xfer instanceof Transformers_1.StringMatchTransformer) {
          const value = this.stringCaseValue((0, Transformers_1.followTargetType)(xfer.sourceType), xfer.stringCase);
          this.emitLine("if (", variable, " == ", value, ")");
          this.emitBlock(() => this.emitTransformer(variable, xfer.transformer, targetType, emitFinish));
        } else if (xfer instanceof Transformers_1.EncodingTransformer) {
          const converter = this.converterForType(xfer.sourceType);
          if (converter !== void 0) {
            this.emitLine("var converter = ", this.converterObject(converter), ";");
            this.emitLine("converter.WriteJson(writer, ", variable, ", serializer);");
          } else {
            this.emitLine(this.serializeValueCode(variable), ";");
          }
          emitFinish([]);
          return true;
        } else if (xfer instanceof Transformers_1.ArrayEncodingTransformer) {
          this.emitLine("writer.WriteStartArray();");
          const itemVariable = "arrayItem";
          this.emitLine("foreach (var ", itemVariable, " in ", variable, ")");
          this.emitBlock(() => {
            this.emitTransformer(itemVariable, xfer.itemTransformer, xfer.itemTargetType, () => {
              return;
            });
          });
          this.emitLine("writer.WriteEndArray();");
          emitFinish([]);
          return true;
        } else if (xfer instanceof Transformers_1.ParseStringTransformer) {
          const immediateTargetType = xfer.consumer === void 0 ? targetType : xfer.consumer.sourceType;
          switch (immediateTargetType.kind) {
            case "date-time":
              this.emitLine("DateTimeOffset dt;");
              this.emitLine("if (DateTimeOffset.TryParse(", variable, ", out dt))");
              this.emitBlock(() => this.emitConsume("dt", xfer.consumer, targetType, emitFinish));
              break;
            case "uuid":
              this.emitLine("Guid guid;");
              this.emitLine("if (Guid.TryParse(", variable, ", out guid))");
              this.emitBlock(() => this.emitConsume("guid", xfer.consumer, targetType, emitFinish));
              break;
            case "uri":
              this.emitLine("try");
              this.emitBlock(() => {
                this.emitLine('var uri = new Uri("about:blank");');
                this.emitLine("if (!string.IsNullOrEmpty(stringValue))");
                this.emitBlock(() => {
                  this.emitLine("uri = new Uri(", variable, ");");
                });
                this.emitConsume("uri", xfer.consumer, targetType, emitFinish);
              });
              this.emitLine("catch (UriFormatException) {}");
              break;
            case "integer":
              this.emitLine("long l;");
              this.emitLine("if (Int64.TryParse(", variable, ", out l))");
              this.emitBlock(() => this.emitConsume("l", xfer.consumer, targetType, emitFinish));
              break;
            case "bool":
              this.emitLine("bool b;");
              this.emitLine("if (Boolean.TryParse(", variable, ", out b))");
              this.emitBlock(() => this.emitConsume("b", xfer.consumer, targetType, emitFinish));
              break;
            default:
              return (0, Support_1.panic)(`Parsing string to ${immediateTargetType.kind} not supported`);
          }
        } else if (xfer instanceof Transformers_1.StringifyTransformer) {
          switch (xfer.sourceType.kind) {
            case "date-time":
              return this.emitConsume([
                variable,
                '.ToString("o", System.Globalization.CultureInfo.InvariantCulture)'
              ], xfer.consumer, targetType, emitFinish);
            case "uuid":
              return this.emitConsume([
                variable,
                '.ToString("D", System.Globalization.CultureInfo.InvariantCulture)'
              ], xfer.consumer, targetType, emitFinish);
            case "integer":
            case "uri":
              return this.emitConsume([
                variable,
                ".ToString()"
              ], xfer.consumer, targetType, emitFinish);
            case "bool":
              this.emitLine("var boolString = ", variable, ' ? "true" : "false";');
              return this.emitConsume("boolString", xfer.consumer, targetType, emitFinish);
            default:
              return (0, Support_1.panic)(`Stringifying ${xfer.sourceType.kind} not supported`);
          }
        } else if (xfer instanceof Transformers_1.StringProducerTransformer) {
          const value = this.stringCaseValue(directTargetType(xfer.consumer), xfer.result);
          return this.emitConsume(value, xfer.consumer, targetType, emitFinish);
        } else if (xfer instanceof Transformers_1.MinMaxLengthCheckTransformer) {
          const min = xfer.minLength;
          const max = xfer.maxLength;
          const conditions = [];
          if (min !== void 0) {
            conditions.push([
              variable,
              ".Length >= ",
              min.toString()
            ]);
          }
          if (max !== void 0) {
            conditions.push([
              variable,
              ".Length <= ",
              max.toString()
            ]);
          }
          this.emitLine("if (", (0, collection_utils_1.arrayIntercalate)([
            " && "
          ], conditions), ")");
          this.emitBlock(() => this.emitConsume(variable, xfer.consumer, targetType, emitFinish));
          return false;
        } else if (xfer instanceof Transformers_1.MinMaxValueTransformer) {
          const min = xfer.minimum;
          const max = xfer.maximum;
          const conditions = [];
          if (min !== void 0) {
            conditions.push([
              variable,
              " >= ",
              min.toString()
            ]);
          }
          if (max !== void 0) {
            conditions.push([
              variable,
              " <= ",
              max.toString()
            ]);
          }
          this.emitLine("if (", (0, collection_utils_1.arrayIntercalate)([
            " && "
          ], conditions), ")");
          this.emitBlock(() => this.emitConsume(variable, xfer.consumer, targetType, emitFinish));
          return false;
        } else if (xfer instanceof Transformers_1.UnionInstantiationTransformer) {
          if (!(targetType instanceof Type_1.UnionType)) {
            return (0, Support_1.panic)("Union instantiation transformer must produce a union type");
          }
          const maybeNullable = (0, TypeUtils_1.nullableFromUnion)(targetType);
          if (maybeNullable !== null) {
            emitFinish(variable);
          } else {
            const unionName = this.nameForNamedType(targetType);
            let initializer;
            if (xfer.sourceType.kind === "null") {
              initializer = " ";
            } else {
              const memberName = this.nameForUnionMember(targetType, xfer.sourceType);
              initializer = [
                " ",
                memberName,
                " = ",
                variable,
                " "
              ];
            }
            emitFinish([
              "new ",
              unionName,
              " {",
              initializer,
              "}"
            ]);
          }
          return true;
        } else {
          return (0, Support_1.panic)("Unknown transformer");
        }
        return false;
      }
      emitTransformation(converterName, t) {
        const xf = (0, Support_1.defined)((0, Transformers_1.transformationForType)(t));
        const reverse = xf.reverse;
        const targetType = xf.targetType;
        const xfer = xf.transformer;
        const csType = this.csType(targetType);
        this.emitType(void 0, utils_1.AccessModifier.Internal, "class", converterName, [
          "JsonConverter<",
          csType,
          ">"
        ], () => {
          const canConvertExpr = [
            "t == typeof(",
            csType,
            ")"
          ];
          this.emitCanConvert(canConvertExpr);
          this.ensureBlankLine();
          this.emitReadJson(() => {
            const allHandled = this.emitDecodeTransformer(xfer, targetType, (v) => this.emitLine("return ", v, ";"));
            if (!allHandled) {
              this.emitThrow([
                '"Cannot unmarshal type ',
                csType,
                '"'
              ]);
            }
          }, csType);
          this.ensureBlankLine();
          this.emitWriteJson("value", () => {
            const allHandled = this.emitTransformer("value", reverse.transformer, reverse.targetType, () => this.emitLine("return;"));
            if (!allHandled) {
              this.emitThrow([
                '"Cannot marshal type ',
                csType,
                '"'
              ]);
            }
          }, csType);
          this.ensureBlankLine();
          this.emitLine("public static readonly ", converterName, " Singleton = new ", converterName, "();");
        });
      }
      emitRequiredHelpers() {
        if (this._needHelpers) {
          this.forEachTopLevel("leading-and-interposing", (t, n) => this.emitFromJsonForTopLevel(t, n));
          this.ensureBlankLine();
          this.emitSerializeClass();
        }
        if (this._needHelpers || this._needAttributes && (this.haveNamedUnions || this.haveEnums)) {
          this.ensureBlankLine();
          this.emitConverterClass();
          this.forEachTransformation("leading-and-interposing", (n, t) => this.emitTransformation(n, t));
          this.emitMultiline(`
public class DateOnlyConverter : JsonConverter<DateOnly>
{
	private readonly string serializationFormat;
	public DateOnlyConverter() : this(null) { }

	public DateOnlyConverter(string? serializationFormat)
	{
			this.serializationFormat = serializationFormat ?? "yyyy-MM-dd";
	}

	public override DateOnly Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
	{
			var value = reader.GetString();
			return DateOnly.Parse(value!);
	}

	public override void Write(Utf8JsonWriter writer, DateOnly value, JsonSerializerOptions options)
			=> writer.WriteStringValue(value.ToString(serializationFormat));
}

public class TimeOnlyConverter : JsonConverter<TimeOnly>
{
	private readonly string serializationFormat;

	public TimeOnlyConverter() : this(null) { }

	public TimeOnlyConverter(string? serializationFormat)
	{
			this.serializationFormat = serializationFormat ?? "HH:mm:ss.fff";
	}

	public override TimeOnly Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
	{
			var value = reader.GetString();
			return TimeOnly.Parse(value!);
	}

	public override void Write(Utf8JsonWriter writer, TimeOnly value, JsonSerializerOptions options)
			=> writer.WriteStringValue(value.ToString(serializationFormat));
}

internal class IsoDateTimeOffsetConverter : JsonConverter<DateTimeOffset>
{
	public override bool CanConvert(Type t) => t == typeof(DateTimeOffset);

	private const string DefaultDateTimeFormat = "yyyy'-'MM'-'dd'T'HH':'mm':'ss.FFFFFFFK";

	private DateTimeStyles _dateTimeStyles = DateTimeStyles.RoundtripKind;
	private string? _dateTimeFormat;
	private CultureInfo? _culture;

	public DateTimeStyles DateTimeStyles
	{
			get => _dateTimeStyles;
			set => _dateTimeStyles = value;
	}

	public string? DateTimeFormat
	{
			get => _dateTimeFormat ?? string.Empty;
			set => _dateTimeFormat = (string.IsNullOrEmpty(value)) ? null : value;
	}

	public CultureInfo Culture
	{
			get => _culture ?? CultureInfo.CurrentCulture;
			set => _culture = value;
	}

	public override void Write(Utf8JsonWriter writer, DateTimeOffset value, JsonSerializerOptions options)
	{
			string text;


			if ((_dateTimeStyles & DateTimeStyles.AdjustToUniversal) == DateTimeStyles.AdjustToUniversal
					|| (_dateTimeStyles & DateTimeStyles.AssumeUniversal) == DateTimeStyles.AssumeUniversal)
			{
					value = value.ToUniversalTime();
			}

			text = value.ToString(_dateTimeFormat ?? DefaultDateTimeFormat, Culture);

			writer.WriteStringValue(text);
	}

	public override DateTimeOffset Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
	{
			string? dateText = reader.GetString();
			
			if (string.IsNullOrEmpty(dateText) == false)
			{
					if (!string.IsNullOrEmpty(_dateTimeFormat))
					{
							return DateTimeOffset.ParseExact(dateText, _dateTimeFormat, Culture, _dateTimeStyles);
					}
					else
					{
							return DateTimeOffset.Parse(dateText, Culture, _dateTimeStyles);
					}
			}
			else
			{
					return default(DateTimeOffset);
			}
	}


	public static readonly IsoDateTimeOffsetConverter Singleton = new IsoDateTimeOffsetConverter();
}`);
        }
      }
      needNamespace() {
        return this._needNamespaces;
      }
    };
    exports.SystemTextJsonCSharpRenderer = SystemTextJsonCSharpRenderer;
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/CSharp/language.js
var require_language4 = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/CSharp/language.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.CSharpTargetLanguage = exports.cSharpLanguageConfig = exports.systemTextJsonCSharpOptions = exports.newtonsoftCSharpOptions = exports.cSharpOptions = void 0;
    var RendererOptions_1 = require_RendererOptions();
    var Support_1 = require_Support();
    var TargetLanguage_1 = require_TargetLanguage();
    var NewtonSoftCSharpRenderer_1 = require_NewtonSoftCSharpRenderer();
    var SystemTextJsonCSharpRenderer_1 = require_SystemTextJsonCSharpRenderer();
    var utils_1 = require_utils4();
    exports.cSharpOptions = {
      framework: new RendererOptions_1.EnumOption("framework", "Serialization framework", {
        NewtonSoft: "NewtonSoft",
        SystemTextJson: "SystemTextJson"
      }, "NewtonSoft"),
      useList: new RendererOptions_1.EnumOption("array-type", "Use T[] or List<T>", {
        array: false,
        list: true
      }, "array"),
      dense: new RendererOptions_1.EnumOption("density", "Property density", {
        normal: false,
        dense: true
      }, "normal", "secondary"),
      // FIXME: Do this via a configurable named eventually.
      namespace: new RendererOptions_1.StringOption("namespace", "Generated namespace", "NAME", "QuickType"),
      version: new RendererOptions_1.EnumOption("csharp-version", "C# version", {
        "5": 5,
        "6": 6
      }, "6", "secondary"),
      virtual: new RendererOptions_1.BooleanOption("virtual", "Generate virtual properties", false),
      typeForAny: new RendererOptions_1.EnumOption("any-type", 'Type to use for "any"', {
        object: "object",
        dynamic: "dynamic"
      }, "object", "secondary"),
      useDecimal: new RendererOptions_1.EnumOption("number-type", "Type to use for numbers", {
        double: false,
        decimal: true
      }, "double", "secondary"),
      features: new RendererOptions_1.EnumOption("features", "Output features", {
        complete: {
          namespaces: true,
          helpers: true,
          attributes: true
        },
        "attributes-only": {
          namespaces: true,
          helpers: false,
          attributes: true
        },
        "just-types-and-namespace": {
          namespaces: true,
          helpers: false,
          attributes: false
        },
        "just-types": {
          namespaces: true,
          helpers: false,
          attributes: false
        }
      }, "complete"),
      baseclass: new RendererOptions_1.EnumOption("base-class", "Base class", {
        EntityData: "EntityData",
        Object: void 0
      }, "Object", "secondary"),
      checkRequired: new RendererOptions_1.BooleanOption("check-required", "Fail if required properties are missing", false),
      keepPropertyName: new RendererOptions_1.BooleanOption("keep-property-name", "Keep original field name generate", false)
    };
    exports.newtonsoftCSharpOptions = Object.assign({}, exports.cSharpOptions, {});
    exports.systemTextJsonCSharpOptions = Object.assign({}, exports.cSharpOptions, {});
    exports.cSharpLanguageConfig = {
      displayName: "C#",
      names: [
        "cs",
        "csharp"
      ],
      extension: "cs"
    };
    var CSharpTargetLanguage = class extends TargetLanguage_1.TargetLanguage {
      constructor() {
        super(exports.cSharpLanguageConfig);
      }
      getOptions() {
        return exports.cSharpOptions;
      }
      get stringTypeMapping() {
        const mapping = /* @__PURE__ */ new Map();
        mapping.set("date", "date-time");
        mapping.set("time", "date-time");
        mapping.set("date-time", "date-time");
        mapping.set("uuid", "uuid");
        mapping.set("uri", "uri");
        mapping.set("integer-string", "integer-string");
        mapping.set("bool-string", "bool-string");
        return mapping;
      }
      get supportsUnionsWithBothNumberTypes() {
        return true;
      }
      get supportsOptionalClassProperties() {
        return true;
      }
      needsTransformerForType(t) {
        const need = (0, utils_1.needTransformerForType)(t);
        return need !== "none" && need !== "nullable";
      }
      makeRenderer(renderContext, untypedOptionValues) {
        const options = (0, RendererOptions_1.getOptionValues)(exports.cSharpOptions, untypedOptionValues);
        switch (options.framework) {
          case "NewtonSoft":
            return new NewtonSoftCSharpRenderer_1.NewtonsoftCSharpRenderer(this, renderContext, (0, RendererOptions_1.getOptionValues)(exports.newtonsoftCSharpOptions, untypedOptionValues));
          case "SystemTextJson":
            return new SystemTextJsonCSharpRenderer_1.SystemTextJsonCSharpRenderer(this, renderContext, (0, RendererOptions_1.getOptionValues)(exports.systemTextJsonCSharpOptions, untypedOptionValues));
          default:
            return (0, Support_1.assertNever)(options.framework);
        }
      }
    };
    exports.CSharpTargetLanguage = CSharpTargetLanguage;
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/CSharp/index.js
var require_CSharp = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/CSharp/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.SystemTextJsonCSharpRenderer = exports.NewtonsoftCSharpRenderer = exports.CSharpRenderer = exports.systemTextJsonCSharpOptions = exports.newtonsoftCSharpOptions = exports.cSharpOptions = exports.CSharpTargetLanguage = void 0;
    var language_1 = require_language4();
    Object.defineProperty(exports, "CSharpTargetLanguage", {
      enumerable: true,
      get: function() {
        return language_1.CSharpTargetLanguage;
      }
    });
    Object.defineProperty(exports, "cSharpOptions", {
      enumerable: true,
      get: function() {
        return language_1.cSharpOptions;
      }
    });
    Object.defineProperty(exports, "newtonsoftCSharpOptions", {
      enumerable: true,
      get: function() {
        return language_1.newtonsoftCSharpOptions;
      }
    });
    Object.defineProperty(exports, "systemTextJsonCSharpOptions", {
      enumerable: true,
      get: function() {
        return language_1.systemTextJsonCSharpOptions;
      }
    });
    var CSharpRenderer_1 = require_CSharpRenderer();
    Object.defineProperty(exports, "CSharpRenderer", {
      enumerable: true,
      get: function() {
        return CSharpRenderer_1.CSharpRenderer;
      }
    });
    var NewtonSoftCSharpRenderer_1 = require_NewtonSoftCSharpRenderer();
    Object.defineProperty(exports, "NewtonsoftCSharpRenderer", {
      enumerable: true,
      get: function() {
        return NewtonSoftCSharpRenderer_1.NewtonsoftCSharpRenderer;
      }
    });
    var SystemTextJsonCSharpRenderer_1 = require_SystemTextJsonCSharpRenderer();
    Object.defineProperty(exports, "SystemTextJsonCSharpRenderer", {
      enumerable: true,
      get: function() {
        return SystemTextJsonCSharpRenderer_1.SystemTextJsonCSharpRenderer;
      }
    });
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Dart/constants.js
var require_constants6 = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Dart/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.keywords = void 0;
    exports.keywords = [
      "abstract",
      "do",
      "import",
      "super",
      "as",
      "dynamic",
      "in",
      "switch",
      "assert",
      "else",
      "interface",
      "sync*",
      "async",
      "enum",
      "is",
      "this",
      "async*",
      "export",
      "library",
      "throw",
      "await",
      "external",
      "mixin",
      "true",
      "break",
      "extends",
      "new",
      "try",
      "case",
      "factory",
      "null",
      "typedef",
      "catch",
      "false",
      "operator",
      "var",
      "class",
      "final",
      "part",
      "void",
      "const",
      "finally",
      "rethrow",
      "while",
      "continue",
      "for",
      "return",
      "with",
      "covariant",
      "get",
      "set",
      "yield",
      "default",
      "if",
      "static",
      "yield*",
      "deferred",
      "implements",
      "int",
      "double",
      "bool",
      "Map",
      "List",
      "String",
      "File",
      "fromJson",
      "toJson",
      "fromMap",
      "toMap"
    ];
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Dart/utils.js
var require_utils5 = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Dart/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.stringEscape = exports.enumCaseNamingFunction = exports.propertyNamingFunction = exports.typeNamingFunction = void 0;
    exports.dartNameStyle = dartNameStyle;
    var Naming_1 = require_Naming();
    var Strings_1 = require_Strings();
    exports.typeNamingFunction = (0, Naming_1.funPrefixNamer)("types", (n) => dartNameStyle(true, false, n));
    exports.propertyNamingFunction = (0, Naming_1.funPrefixNamer)("properties", (n) => dartNameStyle(false, false, n));
    exports.enumCaseNamingFunction = (0, Naming_1.funPrefixNamer)("enum-cases", (n) => dartNameStyle(true, true, n));
    exports.stringEscape = (0, Strings_1.utf16ConcatMap)((0, Strings_1.escapeNonPrintableMapper)((cp) => (0, Strings_1.isPrintable)(cp) && cp !== 36, Strings_1.standardUnicodeHexEscape));
    function isStartCharacter(codePoint) {
      if (codePoint === 95) return false;
      return (0, Strings_1.isAscii)(codePoint) && (0, Strings_1.isLetter)(codePoint);
    }
    function isPartCharacter(codePoint) {
      return isStartCharacter(codePoint) || (0, Strings_1.isAscii)(codePoint) && (0, Strings_1.isDigit)(codePoint);
    }
    var legalizeName = (0, Strings_1.utf16LegalizeCharacters)(isPartCharacter);
    function dartNameStyle(startWithUpper, upperUnderscore, original) {
      const words = (0, Strings_1.splitIntoWords)(original);
      const firstWordStyle = upperUnderscore ? Strings_1.allUpperWordStyle : startWithUpper ? Strings_1.firstUpperWordStyle : Strings_1.allLowerWordStyle;
      const restWordStyle = upperUnderscore ? Strings_1.allUpperWordStyle : Strings_1.firstUpperWordStyle;
      return (0, Strings_1.combineWords)(words, legalizeName, firstWordStyle, restWordStyle, firstWordStyle, restWordStyle, upperUnderscore ? "_" : "", isStartCharacter);
    }
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Dart/DartRenderer.js
var require_DartRenderer = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Dart/DartRenderer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.DartRenderer = void 0;
    var Annotation_1 = require_Annotation();
    var ConvenienceRenderer_1 = require_ConvenienceRenderer();
    var Naming_1 = require_Naming();
    var Source_1 = require_Source();
    var Strings_1 = require_Strings();
    var Support_1 = require_Support();
    var Type_1 = require_Type2();
    var TypeUtils_1 = require_TypeUtils();
    var constants_1 = require_constants6();
    var utils_1 = require_utils5();
    var DartRenderer = class extends ConvenienceRenderer_1.ConvenienceRenderer {
      constructor(targetLanguage, renderContext, _options) {
        super(targetLanguage, renderContext);
        this._options = _options;
        this._gettersAndSettersForPropertyName = /* @__PURE__ */ new Map();
        this._needEnumValues = false;
        this.classCounter = 0;
        this.classPropertyCounter = 0;
        this._topLevelDependents = /* @__PURE__ */ new Map();
        this._enumValues = /* @__PURE__ */ new Map();
      }
      forbiddenNamesForGlobalNamespace() {
        return constants_1.keywords;
      }
      forbiddenForObjectProperties(_c, _className) {
        return {
          names: [],
          includeGlobalForbidden: true
        };
      }
      makeNamedTypeNamer() {
        return utils_1.typeNamingFunction;
      }
      namerForObjectProperty() {
        return utils_1.propertyNamingFunction;
      }
      makeUnionMemberNamer() {
        return utils_1.propertyNamingFunction;
      }
      makeEnumCaseNamer() {
        return utils_1.enumCaseNamingFunction;
      }
      unionNeedsName(u) {
        return (0, TypeUtils_1.nullableFromUnion)(u) === null;
      }
      namedTypeToNameForTopLevel(type) {
        return (0, TypeUtils_1.directlyReachableSingleNamedType)(type);
      }
      get toJson() {
        return `to${this._options.methodNamesWithMap ? "Map" : "Json"}`;
      }
      get fromJson() {
        return `from${this._options.methodNamesWithMap ? "Map" : "Json"}`;
      }
      makeTopLevelDependencyNames(_t, name) {
        const encoder = new Naming_1.DependencyName(utils_1.propertyNamingFunction, name.order, (lookup) => `${lookup(name)}_${this.toJson}`);
        const decoder = new Naming_1.DependencyName(utils_1.propertyNamingFunction, name.order, (lookup) => `${lookup(name)}_${this.fromJson}`);
        this._topLevelDependents.set(name, {
          encoder,
          decoder
        });
        return [
          encoder,
          decoder
        ];
      }
      makeNamesForPropertyGetterAndSetter(_c, _className, _p, _jsonName, name) {
        const getterName = new Naming_1.DependencyName(utils_1.propertyNamingFunction, name.order, (lookup) => `get_${lookup(name)}`);
        const setterName = new Naming_1.DependencyName(utils_1.propertyNamingFunction, name.order, (lookup) => `set_${lookup(name)}`);
        return [
          getterName,
          setterName
        ];
      }
      makePropertyDependencyNames(c, className, p, jsonName, name) {
        const getterAndSetterNames = this.makeNamesForPropertyGetterAndSetter(c, className, p, jsonName, name);
        this._gettersAndSettersForPropertyName.set(name, getterAndSetterNames);
        return getterAndSetterNames;
      }
      makeNamedTypeDependencyNames(t, name) {
        if (!(t instanceof Type_1.EnumType)) return [];
        const enumValue = new Naming_1.DependencyName(utils_1.propertyNamingFunction, name.order, (lookup) => `${lookup(name)}_values`);
        this._enumValues.set(t, enumValue);
        return [
          enumValue
        ];
      }
      emitFileHeader() {
        if (this.leadingComments !== void 0) {
          this.emitComments(this.leadingComments);
        }
        if (this._options.justTypes) return;
        if (!this._options.codersInClass) {
          this.emitLine("// To parse this JSON data, do");
          this.emitLine("//");
          this.forEachTopLevel("none", (_t, name) => {
            const { decoder } = (0, Support_1.defined)(this._topLevelDependents.get(name));
            this.emitLine("//     final ", (0, Source_1.modifySource)(Strings_1.decapitalize, name), " = ", decoder, "(jsonString);");
          });
        }
        this.ensureBlankLine();
        if (this._options.requiredProperties) {
          this.emitLine("import 'package:meta/meta.dart';");
        }
        if (this._options.useFreezed) {
          this.emitLine("import 'package:freezed_annotation/freezed_annotation.dart';");
        }
        if (this._options.useHive) {
          this.emitLine("import 'package:hive/hive.dart';");
        }
        if (this._options.useJsonAnnotation && !this._options.useFreezed) {
          this.emitLine("import 'package:json_annotation/json_annotation.dart';");
        }
        this.emitLine("import 'dart:convert';");
        if (this._options.useFreezed || this._options.useHive || this._options.useJsonAnnotation) {
          this.ensureBlankLine();
          const optionNameIsEmpty = this._options.partName.length === 0;
          const name = (0, Source_1.modifySource)(Strings_1.snakeCase, optionNameIsEmpty ? [
            ...this.topLevels.keys()
          ][0] : this._options.partName);
          if (this._options.useFreezed) {
            this.emitLine("part '", name, ".freezed.dart';");
          }
          if (!this._options.justTypes) {
            this.emitLine("part '", name, ".g.dart';");
          }
        }
      }
      emitDescriptionBlock(lines) {
        this.emitCommentLines(lines, {
          lineStart: "///",
          beforeComment: ""
        });
      }
      emitBlock(line, f) {
        this.emitLine(line, " {");
        this.indent(f);
        this.emitLine("}");
      }
      dartType(t, withIssues = false, forceNullable = false) {
        const nullable = forceNullable || this._options.nullSafety && t.isNullable && !this._options.requiredProperties;
        const withNullable = (s) => nullable ? [
          s,
          "?"
        ] : s;
        return (0, TypeUtils_1.matchType)(t, (_anyType) => (0, Source_1.maybeAnnotated)(withIssues, Annotation_1.anyTypeIssueAnnotation, "dynamic"), (_nullType) => (0, Source_1.maybeAnnotated)(withIssues, Annotation_1.nullTypeIssueAnnotation, "dynamic"), (_boolType) => withNullable("bool"), (_integerType) => withNullable("int"), (_doubleType) => withNullable("double"), (_stringType) => withNullable("String"), (arrayType) => withNullable([
          "List<",
          this.dartType(arrayType.items, withIssues),
          ">"
        ]), (classType) => withNullable(this.nameForNamedType(classType)), (mapType) => withNullable([
          "Map<String, ",
          this.dartType(mapType.values, withIssues),
          ">"
        ]), (enumType) => withNullable(this.nameForNamedType(enumType)), (unionType) => {
          const maybeNullable = (0, TypeUtils_1.nullableFromUnion)(unionType);
          if (maybeNullable === null) {
            return "dynamic";
          }
          return withNullable(this.dartType(maybeNullable, withIssues));
        }, (transformedStringType) => {
          switch (transformedStringType.kind) {
            case "date-time":
            case "date":
              return withNullable("DateTime");
            default:
              return withNullable("String");
          }
        });
      }
      mapList(isNullable, itemType, list, mapper) {
        if (this._options.nullSafety && isNullable && !this._options.requiredProperties) {
          return [
            list,
            " == null ? [] : ",
            "List<",
            itemType,
            ">.from(",
            list,
            "!.map((x) => ",
            mapper,
            "))"
          ];
        }
        return [
          "List<",
          itemType,
          ">.from(",
          list,
          ".map((x) => ",
          mapper,
          "))"
        ];
      }
      mapMap(isNullable, valueType, map, valueMapper) {
        if (this._options.nullSafety && isNullable && !this._options.requiredProperties) {
          return [
            "Map.from(",
            map,
            "!).map((k, v) => MapEntry<String, ",
            valueType,
            ">(k, ",
            valueMapper,
            "))"
          ];
        }
        return [
          "Map.from(",
          map,
          ").map((k, v) => MapEntry<String, ",
          valueType,
          ">(k, ",
          valueMapper,
          "))"
        ];
      }
      mapClass(isNullable, classType, dynamic) {
        if (this._options.nullSafety && isNullable && !this._options.requiredProperties) {
          return [
            dynamic,
            " == null ? null : ",
            this.nameForNamedType(classType),
            ".",
            this.fromJson,
            "(",
            dynamic,
            ")"
          ];
        }
        return [
          this.nameForNamedType(classType),
          ".",
          this.fromJson,
          "(",
          dynamic,
          ")"
        ];
      }
      // FIXME: refactor this
      // If the first time is the unionType type, after nullableFromUnion conversion,
      // the isNullable property will become false, which is obviously wrong,
      // so add isNullable property
      // eslint-disable-next-line @typescript-eslint/default-param-last
      fromDynamicExpression(isNullable = false, t, ...dynamic) {
        return (0, TypeUtils_1.matchType)(t, (_anyType) => dynamic, (_nullType) => dynamic, (_boolType) => dynamic, (_integerType) => dynamic, (_doubleType) => [
          dynamic,
          this._options.nullSafety ? "?.toDouble()" : ".toDouble()"
        ], (_stringType) => dynamic, (arrayType) => this.mapList(isNullable || arrayType.isNullable, this.dartType(arrayType.items), dynamic, this.fromDynamicExpression(arrayType.items.isNullable, arrayType.items, "x")), (classType) => this.mapClass(isNullable || classType.isNullable, classType, dynamic), (mapType) => this.mapMap(mapType.isNullable || isNullable, this.dartType(mapType.values), dynamic, this.fromDynamicExpression(mapType.values.isNullable, mapType.values, "v")), (enumType) => {
          return [
            (0, Support_1.defined)(this._enumValues.get(enumType)),
            ".map[",
            dynamic,
            this._options.nullSafety ? "]!" : "]"
          ];
        }, (unionType) => {
          const maybeNullable = (0, TypeUtils_1.nullableFromUnion)(unionType);
          if (maybeNullable === null) {
            return dynamic;
          }
          return this.fromDynamicExpression(unionType.isNullable, maybeNullable, dynamic);
        }, (transformedStringType) => {
          switch (transformedStringType.kind) {
            case "date-time":
            case "date":
              if ((transformedStringType.isNullable || isNullable) && !this._options.requiredProperties && this._options.nullSafety) {
                return [
                  dynamic,
                  " == null ? null : ",
                  "DateTime.parse(",
                  dynamic,
                  ")"
                ];
              }
              return [
                "DateTime.parse(",
                dynamic,
                ")"
              ];
            default:
              return dynamic;
          }
        });
      }
      // FIXME: refactor this
      // If the first time is the unionType type, after nullableFromUnion conversion,
      // the isNullable property will become false, which is obviously wrong,
      // so add isNullable property
      // eslint-disable-next-line @typescript-eslint/default-param-last
      toDynamicExpression(isNullable = false, t, ...dynamic) {
        return (0, TypeUtils_1.matchType)(t, (_anyType) => dynamic, (_nullType) => dynamic, (_boolType) => dynamic, (_integerType) => dynamic, (_doubleType) => dynamic, (_stringType) => dynamic, (arrayType) => this.mapList(arrayType.isNullable || isNullable, "dynamic", dynamic, this.toDynamicExpression(arrayType.items.isNullable, arrayType.items, "x")), (_classType) => {
          if (this._options.nullSafety && (_classType.isNullable || isNullable) && !this._options.requiredProperties) {
            return [
              dynamic,
              "?.",
              this.toJson,
              "()"
            ];
          }
          return [
            dynamic,
            ".",
            this.toJson,
            "()"
          ];
        }, (mapType) => this.mapMap(mapType.isNullable || isNullable, "dynamic", dynamic, this.toDynamicExpression(mapType.values.isNullable, mapType.values, "v")), (enumType) => {
          return [
            (0, Support_1.defined)(this._enumValues.get(enumType)),
            ".reverse[",
            dynamic,
            "]"
          ];
        }, (unionType) => {
          const maybeNullable = (0, TypeUtils_1.nullableFromUnion)(unionType);
          if (maybeNullable === null) {
            return dynamic;
          }
          return this.toDynamicExpression(unionType.isNullable, maybeNullable, dynamic);
        }, (transformedStringType) => {
          switch (transformedStringType.kind) {
            case "date-time":
              if (this._options.nullSafety && !this._options.requiredProperties && (transformedStringType.isNullable || isNullable)) {
                return [
                  dynamic,
                  "?.toIso8601String()"
                ];
              }
              return [
                dynamic,
                ".toIso8601String()"
              ];
            case "date":
              if (this._options.nullSafety && !this._options.requiredProperties && (transformedStringType.isNullable || isNullable)) {
                return [
                  '"${',
                  dynamic,
                  "!.year.toString().padLeft(4, '0')",
                  "}-${",
                  dynamic,
                  "!.month.toString().padLeft(2, '0')}-${",
                  dynamic,
                  `!.day.toString().padLeft(2, '0')}"`
                ];
              }
              return [
                '"${',
                dynamic,
                ".year.toString().padLeft(4, '0')",
                "}-${",
                dynamic,
                ".month.toString().padLeft(2, '0')}-${",
                dynamic,
                `.day.toString().padLeft(2, '0')}"`
              ];
            default:
              return dynamic;
          }
        });
      }
      _emitEmptyConstructor(className) {
        this.emitLine(className, "();");
      }
      _emitConstructor(c, className) {
        this.emitLine(className, "({");
        this.indent(() => {
          this.forEachClassProperty(c, "none", (name, _, prop) => {
            const required = this._options.requiredProperties || this._options.nullSafety && (!prop.type.isNullable || !prop.isOptional);
            this.emitLine(required ? "required " : "", "this.", name, ",");
          });
        });
        this.emitLine("});");
        this.ensureBlankLine();
      }
      _emitVariables(c) {
        this.forEachClassProperty(c, "none", (name, jsonName, p) => {
          const description = this.descriptionForClassProperty(c, jsonName);
          if (description !== void 0) {
            this.emitDescription(description);
          }
          if (this._options.useHive) {
            this.classPropertyCounter++;
            this.emitLine(`@HiveField(${this.classPropertyCounter})`);
          }
          if (this._options.useJsonAnnotation) {
            this.classPropertyCounter++;
            this.emitLine(`@JsonKey(name: "${jsonName}")`);
          }
          this.emitLine(this._options.finalProperties ? "final " : "", this.dartType(p.type, true), " ", name, ";");
        });
      }
      _emitCopyConstructor(c, className) {
        this.ensureBlankLine();
        this.emitLine(className, " copyWith({");
        this.indent(() => {
          this.forEachClassProperty(c, "none", (name, _, _p) => {
            this.emitLine(this.dartType(_p.type, true, true), " ", name, ",");
          });
        });
        this.emitLine("}) => ");
        this.indent(() => {
          this.emitLine(className, "(");
          this.indent(() => {
            this.forEachClassProperty(c, "none", (name, _, _p) => {
              this.emitLine(name, ": ", name, " ?? ", "this.", name, ",");
            });
          });
          this.emitLine(");");
        });
      }
      _emitStringJsonEncoderDecoder(className) {
        this.ensureBlankLine();
        this.emitLine("factory ", className, ".from", this._options.methodNamesWithMap ? "Json" : "RawJson", "(String str) => ", className, ".", this.fromJson, "(json.decode(str));");
        this.ensureBlankLine();
        this.emitLine("String ", this._options.methodNamesWithMap ? "toJson() => " : "toRawJson() => ", "json.encode(", this.toJson, "());");
      }
      _emitMapEncoderDecoder(c, className) {
        this.ensureBlankLine();
        this.emitLine("factory ", className, ".", this.fromJson, "(Map<String, dynamic> json) => ", className, "(");
        this.indent(() => {
          this.forEachClassProperty(c, "none", (name, jsonName, property) => {
            this.emitLine(name, ": ", this.fromDynamicExpression(property.type.isNullable, property.type, 'json["', (0, utils_1.stringEscape)(jsonName), '"]'), ",");
          });
        });
        this.emitLine(");");
        this.ensureBlankLine();
        this.emitLine("Map<String, dynamic> ", this.toJson, "() => {");
        this.indent(() => {
          this.forEachClassProperty(c, "none", (name, jsonName, property) => {
            this.emitLine('"', (0, utils_1.stringEscape)(jsonName), '": ', this.toDynamicExpression(property.type.isNullable, property.type, name), ",");
          });
        });
        this.emitLine("};");
      }
      emitClassDefinition(c, className) {
        this.emitDescription(this.descriptionForType(c));
        if (this._options.useHive) {
          this.classCounter++;
          this.emitLine(`@HiveType(typeId: ${this.classCounter})`);
          this.classPropertyCounter = 0;
        }
        if (this._options.useJsonAnnotation) {
          this.emitLine("@JsonSerializable()");
        }
        this.emitBlock([
          "class ",
          className
        ], () => {
          if (c.getProperties().size === 0) {
            this._emitEmptyConstructor(className);
          } else {
            this._emitVariables(c);
            this.ensureBlankLine();
            this._emitConstructor(c, className);
          }
          if (this._options.generateCopyWith) {
            this._emitCopyConstructor(c, className);
          }
          if (this._options.useJsonAnnotation) {
            this.ensureBlankLine();
            this.emitLine(
              // factory PublicAnswer.fromJson(Map<String, dynamic> json) => _$PublicAnswerFromJson(json);
              "factory ",
              className,
              ".fromJson(Map<String, dynamic> json) => ",
              "_$",
              className,
              "FromJson(json);"
            );
            this.ensureBlankLine();
            this.emitLine(
              // Map<String, dynamic> toJson() => _$PublicAnswerToJson(this);
              "Map<String, dynamic> toJson() => ",
              "_$",
              className,
              "ToJson(this);"
            );
          } else {
            if (this._options.justTypes) return;
            if (this._options.codersInClass) {
              this._emitStringJsonEncoderDecoder(className);
            }
            this._emitMapEncoderDecoder(c, className);
          }
        });
      }
      emitFreezedClassDefinition(c, className) {
        this.emitDescription(this.descriptionForType(c));
        this.emitLine("@freezed");
        this.emitBlock([
          "class ",
          className,
          " with _$",
          className
        ], () => {
          if (c.getProperties().size === 0) {
            this.emitLine("const factory ", className, "() = _", className, ";");
          } else {
            this.emitLine("const factory ", className, "({");
            this.indent(() => {
              this.forEachClassProperty(c, "none", (name, jsonName, prop) => {
                const description = this.descriptionForClassProperty(c, jsonName);
                if (description !== void 0) {
                  this.emitDescription(description);
                }
                const required = this._options.requiredProperties || this._options.nullSafety && (!prop.type.isNullable || !prop.isOptional);
                if (this._options.useJsonAnnotation) {
                  this.classPropertyCounter++;
                  this.emitLine(`@JsonKey(name: "${jsonName}")`);
                }
                this.emitLine(required ? "required " : "", this.dartType(prop.type, true), " ", name, ",");
              });
            });
            this.emitLine("}) = _", className, ";");
          }
          if (this._options.justTypes) return;
          this.ensureBlankLine();
          this.emitLine(
            // factory PublicAnswer.fromJson(Map<String, dynamic> json) => _$PublicAnswerFromJson(json);
            "factory ",
            className,
            ".fromJson(Map<String, dynamic> json) => ",
            "_$",
            className,
            "FromJson(json);"
          );
        });
      }
      emitEnumDefinition(e, enumName) {
        this.emitDescription(this.descriptionForType(e));
        this.emitLine("enum ", enumName, " {");
        this.indent(() => {
          this.forEachEnumCase(e, "none", (name, jsonName, pos) => {
            const comma = pos === "first" || pos === "middle" ? "," : [];
            if (this._options.useJsonAnnotation) {
              this.emitLine('@JsonValue("', (0, utils_1.stringEscape)(jsonName), '")');
            }
            this.emitLine(name, comma);
          });
        });
        this.emitLine("}");
        if (this._options.justTypes) return;
        this.ensureBlankLine();
        this.emitLine("final ", (0, Support_1.defined)(this._enumValues.get(e)), " = EnumValues({");
        this.indent(() => {
          this.forEachEnumCase(e, "none", (name, jsonName, pos) => {
            const comma = pos === "first" || pos === "middle" ? "," : [];
            this.emitLine('"', (0, utils_1.stringEscape)(jsonName), '": ', enumName, ".", name, comma);
          });
        });
        this.emitLine("});");
        this._needEnumValues = true;
      }
      emitEnumValues() {
        this.ensureBlankLine();
        this.emitMultiline(`class EnumValues<T> {
	Map<String, T> map;
	late Map<T, String> reverseMap;

	EnumValues(this.map);

	Map<T, String> get reverse {
			reverseMap = map.map((k, v) => MapEntry(v, k));
			return reverseMap;
	}
}`);
      }
      _emitTopLvlEncoderDecoder() {
        this.forEachTopLevel("leading-and-interposing", (t, name) => {
          const { encoder, decoder } = (0, Support_1.defined)(this._topLevelDependents.get(name));
          this.emitLine(this.dartType(t), " ", decoder, "(String str) => ", this.fromDynamicExpression(t.isNullable, t, "json.decode(str)"), ";");
          this.ensureBlankLine();
          this.emitLine("String ", encoder, "(", this.dartType(t), " data) => json.encode(", this.toDynamicExpression(t.isNullable, t, "data"), ");");
        });
      }
      emitSourceStructure() {
        this.emitFileHeader();
        if (!this._options.justTypes && !this._options.codersInClass) {
          this._emitTopLvlEncoderDecoder();
        }
        this.forEachNamedType("leading-and-interposing", (c, n) => this._options.useFreezed ? this.emitFreezedClassDefinition(c, n) : this.emitClassDefinition(c, n), (e, n) => this.emitEnumDefinition(e, n), (_e, _n) => {
        });
        if (this._needEnumValues) {
          this.emitEnumValues();
        }
      }
    };
    exports.DartRenderer = DartRenderer;
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Dart/language.js
var require_language5 = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Dart/language.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.DartTargetLanguage = exports.dartLanguageConfig = exports.dartOptions = void 0;
    var RendererOptions_1 = require_RendererOptions();
    var TargetLanguage_1 = require_TargetLanguage();
    var DartRenderer_1 = require_DartRenderer();
    exports.dartOptions = {
      nullSafety: new RendererOptions_1.BooleanOption("null-safety", "Null Safety", true),
      justTypes: new RendererOptions_1.BooleanOption("just-types", "Types only", false),
      codersInClass: new RendererOptions_1.BooleanOption("coders-in-class", "Put encoder & decoder in Class", false),
      methodNamesWithMap: new RendererOptions_1.BooleanOption("from-map", "Use method names fromMap() & toMap()", false, "secondary"),
      requiredProperties: new RendererOptions_1.BooleanOption("required-props", "Make all properties required", false),
      finalProperties: new RendererOptions_1.BooleanOption("final-props", "Make all properties final", false),
      generateCopyWith: new RendererOptions_1.BooleanOption("copy-with", "Generate CopyWith method", false),
      useFreezed: new RendererOptions_1.BooleanOption("use-freezed", "Generate class definitions with @freezed compatibility", false, "secondary"),
      useHive: new RendererOptions_1.BooleanOption("use-hive", "Generate annotations for Hive type adapters", false, "secondary"),
      useJsonAnnotation: new RendererOptions_1.BooleanOption("use-json-annotation", "Generate annotations for json_serializable", false, "secondary"),
      partName: new RendererOptions_1.StringOption("part-name", "Use this name in `part` directive", "NAME", "", "secondary")
    };
    exports.dartLanguageConfig = {
      displayName: "Dart",
      names: [
        "dart"
      ],
      extension: "dart"
    };
    var DartTargetLanguage = class extends TargetLanguage_1.TargetLanguage {
      constructor() {
        super(exports.dartLanguageConfig);
      }
      getOptions() {
        return exports.dartOptions;
      }
      get supportsUnionsWithBothNumberTypes() {
        return true;
      }
      get stringTypeMapping() {
        const mapping = /* @__PURE__ */ new Map();
        mapping.set("date", "date");
        mapping.set("date-time", "date-time");
        return mapping;
      }
      makeRenderer(renderContext, untypedOptionValues) {
        const options = (0, RendererOptions_1.getOptionValues)(exports.dartOptions, untypedOptionValues);
        return new DartRenderer_1.DartRenderer(this, renderContext, options);
      }
    };
    exports.DartTargetLanguage = DartTargetLanguage;
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Dart/index.js
var require_Dart = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Dart/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.DartRenderer = exports.dartOptions = exports.DartTargetLanguage = void 0;
    var language_1 = require_language5();
    Object.defineProperty(exports, "DartTargetLanguage", {
      enumerable: true,
      get: function() {
        return language_1.DartTargetLanguage;
      }
    });
    Object.defineProperty(exports, "dartOptions", {
      enumerable: true,
      get: function() {
        return language_1.dartOptions;
      }
    });
    var DartRenderer_1 = require_DartRenderer();
    Object.defineProperty(exports, "DartRenderer", {
      enumerable: true,
      get: function() {
        return DartRenderer_1.DartRenderer;
      }
    });
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Elixir/constants.js
var require_constants7 = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Elixir/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.reservedWords = exports.forbiddenModuleNames = void 0;
    exports.forbiddenModuleNames = [
      "Access",
      "Agent",
      "Any",
      "Application",
      "ArgumentError",
      "ArithmeticError",
      "Atom",
      "BadArityError",
      "BadBooleanError",
      "BadFunctionError",
      "BadMapError",
      "BadStructError",
      "Base",
      "Behaviour",
      "Bitwise",
      "Calendar",
      "CaseClauseError",
      "Code",
      "Collectable",
      "CondClauseError",
      "Config",
      "Date",
      "DateTime",
      "Dict",
      "DynamicSupervisor",
      "Enum",
      "ErlangError",
      "Exception",
      "File",
      "Float",
      "Function",
      "FunctionClauseError",
      "GenEvent",
      "GenServer",
      "HashDict",
      "HashSet",
      "IO",
      "Inspect",
      "Integer",
      "Kernel",
      "KeyError",
      "Keyword",
      "List",
      "Macro",
      "Map",
      "MapSet",
      "MatchError",
      "Module",
      "Node",
      "OptionParser",
      "Path",
      "Port",
      "Process",
      "Protocol",
      "Range",
      "Record",
      "Regex",
      "Registry",
      "RuntimeError",
      "Set",
      "Stream",
      "String",
      "StringIO",
      "Supervisor",
      "SyntaxError",
      "System",
      "SystemLimitError",
      "Task",
      "Time",
      "TokenMissingError",
      "Tuple",
      "URI",
      "UndefinedFunctionError",
      "UnicodeConversionError",
      "Version",
      "WithClauseError"
    ];
    exports.reservedWords = [
      "def",
      "defmodule",
      "use",
      "import",
      "alias",
      "true",
      "false",
      "nil",
      "when",
      "and",
      "or",
      "not",
      "in",
      "fn",
      "do",
      "end",
      "catch",
      "rescue",
      "after",
      "else"
    ];
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Elixir/utils.js
var require_utils6 = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Elixir/utils.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : {
        "default": mod
      };
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.stringEscape = void 0;
    exports.capitalizeFirstLetter = capitalizeFirstLetter;
    exports.escapeDoubleQuotes = escapeDoubleQuotes;
    exports.escapeNewLines = escapeNewLines;
    exports.simpleNameStyle = simpleNameStyle;
    exports.memberNameStyle = memberNameStyle;
    var unicode_properties_1 = __importDefault(require_main());
    var Strings_1 = require_Strings();
    function unicodeEscape(codePoint) {
      return `\\u{${(0, Strings_1.intToHex)(codePoint, 0)}}`;
    }
    function capitalizeFirstLetter(str) {
      return str.charAt(0).toUpperCase() + str.slice(1);
    }
    exports.stringEscape = (0, Strings_1.utf32ConcatMap)((0, Strings_1.escapeNonPrintableMapper)(Strings_1.isPrintable, unicodeEscape));
    function escapeDoubleQuotes(str) {
      return str.replace(/"/g, '\\"');
    }
    function escapeNewLines(str) {
      return str.replace(/\n/g, "\\n");
    }
    var isStartCharacter = Strings_1.isLetterOrUnderscore;
    function isPartCharacter(utf16Unit) {
      const category = unicode_properties_1.default.getCategory(utf16Unit);
      return [
        "Nd",
        "Pc",
        "Mn",
        "Mc"
      ].includes(category) || isStartCharacter(utf16Unit);
    }
    var legalizeName = (0, Strings_1.legalizeCharacters)(isPartCharacter);
    function simpleNameStyle(original, uppercase) {
      if (/^[0-9]+$/.test(original)) {
        original = `${original}N`;
      }
      const words = (0, Strings_1.splitIntoWords)(original);
      return (0, Strings_1.combineWords)(words, legalizeName, uppercase ? Strings_1.firstUpperWordStyle : Strings_1.allLowerWordStyle, uppercase ? Strings_1.firstUpperWordStyle : Strings_1.allLowerWordStyle, Strings_1.allUpperWordStyle, Strings_1.allUpperWordStyle, "", isStartCharacter);
    }
    function memberNameStyle(original) {
      const words = (0, Strings_1.splitIntoWords)(original);
      return (0, Strings_1.combineWords)(words, legalizeName, Strings_1.allLowerWordStyle, Strings_1.allLowerWordStyle, Strings_1.allLowerWordStyle, Strings_1.allLowerWordStyle, "_", isStartCharacter);
    }
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Elixir/ElixirRenderer.js
var require_ElixirRenderer = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Elixir/ElixirRenderer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.ElixirRenderer = void 0;
    var ConvenienceRenderer_1 = require_ConvenienceRenderer();
    var Naming_1 = require_Naming();
    var Type_1 = require_Type2();
    var TypeUtils_1 = require_TypeUtils();
    var constants_1 = require_constants7();
    var utils_1 = require_utils6();
    var ElixirRenderer = class extends ConvenienceRenderer_1.ConvenienceRenderer {
      constructor(targetLanguage, renderContext, _options) {
        super(targetLanguage, renderContext);
        this._options = _options;
      }
      get commentLineStart() {
        return "# ";
      }
      get needsTypeDeclarationBeforeUse() {
        return true;
      }
      canBeForwardDeclared(t) {
        return "class" === t.kind;
      }
      forbiddenNamesForGlobalNamespace() {
        return [
          ...constants_1.forbiddenModuleNames,
          ...constants_1.reservedWords.map((word) => (0, utils_1.capitalizeFirstLetter)(word))
        ];
      }
      forbiddenForObjectProperties(_c, _classNamed) {
        return {
          names: constants_1.reservedWords,
          includeGlobalForbidden: true
        };
      }
      makeNamedTypeNamer() {
        return new Naming_1.Namer("types", (n) => (0, utils_1.simpleNameStyle)(n, true), []);
      }
      namerForObjectProperty() {
        return new Naming_1.Namer("properties", utils_1.memberNameStyle, []);
      }
      makeUnionMemberNamer() {
        return new Naming_1.Namer("properties", utils_1.memberNameStyle, []);
      }
      makeEnumCaseNamer() {
        return new Naming_1.Namer("enum-cases", (n) => (0, utils_1.simpleNameStyle)(n, true), []);
      }
      nameForNamedTypeWithNamespace(t) {
        if (this._options.namespace) {
          return [
            this._options.namespace,
            ".",
            this.nameForNamedType(t)
          ];
        }
        return [
          this.nameForNamedType(t)
        ];
      }
      nameWithNamespace(n) {
        if (this._options.namespace) {
          return [
            this._options.namespace,
            ".",
            n
          ];
        }
        return [
          n
        ];
      }
      elixirType(t, isOptional = false) {
        const optional = isOptional ? " | nil" : "";
        return (0, TypeUtils_1.matchType)(t, (_anyType) => [
          "any()",
          optional
        ], (_nullType) => [
          "nil"
        ], (_boolType) => [
          "boolean()",
          optional
        ], (_integerType) => [
          "integer()",
          optional
        ], (_doubleType) => [
          "float()",
          optional
        ], (_stringType) => [
          "String.t()",
          optional
        ], (arrayType) => [
          "[",
          this.elixirType(arrayType.items),
          "]",
          optional
        ], (classType) => [
          this.nameForNamedTypeWithNamespace(classType),
          ".t()",
          optional
        ], (mapType) => [
          "%{String.t() => ",
          this.elixirType(mapType.values),
          "}",
          optional
        ], (enumType) => [
          this.nameForNamedTypeWithNamespace(enumType),
          ".t()",
          optional
        ], (unionType) => {
          const children = [
            ...unionType.getChildren()
          ].map((ut) => this.elixirType(ut));
          return [
            children.flatMap((element, index) => index === children.length - 1 ? element : [
              element,
              " | "
            ]),
            optional
          ];
        });
      }
      patternMatchClauseDecode(t, attributeName, suffix = "") {
        return (0, TypeUtils_1.matchType)(t, (_anyType) => [], (_nullType) => [
          "def decode_",
          attributeName,
          suffix,
          "(value) when is_nil(value), do: value"
        ], (_boolType) => [
          "def decode_",
          attributeName,
          suffix,
          "(value) when is_boolean(value), do: value"
        ], (_integerType) => [
          "def decode_",
          attributeName,
          suffix,
          "(value) when is_integer(value), do: value"
        ], (_doubleType) => [
          "def decode_",
          attributeName,
          suffix,
          "(value) when is_float(value), do: value\n",
          "def decode_",
          attributeName,
          suffix,
          "(value) when is_integer(value), do: value"
        ], (_stringType) => [
          "def decode_",
          attributeName,
          suffix,
          "(value) when is_binary(value), do: value"
        ], (_arrayType) => [
          "def decode_",
          attributeName,
          suffix,
          "(value) when is_list(value), do: value"
        ], (classType) => {
          const requiredAttributeArgs = [];
          this.forEachClassProperty(classType, "none", (_name, jsonName, p) => {
            if (!p.isOptional) {
              requiredAttributeArgs.push([
                '"',
                jsonName,
                '" => _,'
              ]);
            }
          });
          return [
            "def decode_",
            attributeName,
            suffix,
            "(%{",
            requiredAttributeArgs,
            "} = value), do: ",
            this.nameForNamedTypeWithNamespace(classType),
            ".from_map(value)"
          ];
        }, (_mapType) => [
          "def decode_",
          attributeName,
          suffix,
          "(value) when is_map(value), do: value"
        ], (enumType) => [
          "def decode_",
          attributeName,
          suffix,
          "(value) when is_binary(value)",
          ", do: ",
          this.nameForNamedTypeWithNamespace(enumType),
          ".decode(value)"
        ], (_unionType) => []);
      }
      patternMatchClauseEncode(t, attributeName, suffix = "") {
        return (0, TypeUtils_1.matchType)(t, (_anyType) => [], (_nullType) => [
          "def encode_",
          attributeName,
          suffix,
          "(value) when is_nil(value), do: value"
        ], (_boolType) => [
          "def encode_",
          attributeName,
          suffix,
          "(value) when is_boolean(value), do: value"
        ], (_integerType) => [
          "def encode_",
          attributeName,
          suffix,
          "(value) when is_integer(value), do: value"
        ], (_doubleType) => [
          "def encode_",
          attributeName,
          suffix,
          "(value) when is_float(value), do: value\n",
          "def encode_",
          attributeName,
          suffix,
          "(value) when is_integer(value), do: value"
        ], (_stringType) => [
          "def encode_",
          attributeName,
          suffix,
          "(value) when is_binary(value), do: value"
        ], (_arrayType) => [
          "def encode_",
          attributeName,
          suffix,
          "(value) when is_list(value), do: value"
        ], (classType) => {
          const requiredAttributeArgs = [];
          this.forEachClassProperty(classType, "none", (_name, jsonName, p) => {
            if (!p.isOptional) {
              requiredAttributeArgs.push([
                '"',
                jsonName,
                '" => _,'
              ]);
            }
          });
          return [
            "def encode_",
            attributeName,
            suffix,
            "(%",
            this.nameForNamedTypeWithNamespace(classType),
            "{} = value), do: ",
            this.nameForNamedTypeWithNamespace(classType),
            ".to_map(value)"
          ];
        }, (_mapType) => [
          "def encode_",
          attributeName,
          suffix,
          "(value) when is_map(value), do: value"
        ], (enumType) => [
          "def encode_",
          attributeName,
          suffix,
          "(value) when is_atom(value)",
          ", do: ",
          this.nameForNamedTypeWithNamespace(enumType),
          ".encode(value)"
        ], (_unionType) => []);
      }
      sortAndFilterPatternMatchTypes(types) {
        return types.filter((type) => !(type instanceof Type_1.UnionType)).sort((a, b) => {
          if (a instanceof Type_1.ClassType && !(b instanceof Type_1.ClassType)) {
            return -1;
          }
          if (b instanceof Type_1.ClassType && !(a instanceof Type_1.ClassType)) {
            return 1;
          }
          if (a.kind === "bool" && b.kind !== "bool") {
            return -1;
          }
          if (b.kind === "bool" && a.kind !== "bool") {
            return 1;
          }
          if (a instanceof Type_1.EnumType && !(b instanceof Type_1.EnumType)) {
            return -1;
          }
          if (b instanceof Type_1.EnumType && !(a instanceof Type_1.EnumType)) {
            return 1;
          }
          if (a.isPrimitive() && !b.isPrimitive()) {
            return -1;
          }
          if (b.isPrimitive() && !a.isPrimitive()) {
            return 1;
          }
          return 0;
        });
      }
      emitPatternMatches(types, name, parentName, suffix = "", optional = false) {
        this.ensureBlankLine();
        let typesToMatch = this.sortAndFilterPatternMatchTypes(types);
        if (typesToMatch.length < 2) {
          return;
        }
        if (typesToMatch.find((type) => type.kind === "double")) {
          typesToMatch = typesToMatch.filter((type) => type.kind !== "integer");
        }
        typesToMatch.forEach((type) => {
          this.emitLine(this.patternMatchClauseDecode(type, name, suffix));
        });
        if (optional && !typesToMatch.find((type) => type.kind === "null")) {
          this.emitLine("def decode_", name, suffix, "(value) when is_nil(value), do: value");
        }
        this.emitLine("def decode_", name, suffix, '(_), do: {:error, "Unexpected type when decoding ', parentName, ".", name, '"}');
        this.ensureBlankLine();
        typesToMatch.forEach((type) => {
          this.emitLine(this.patternMatchClauseEncode(type, name, suffix));
        });
        if (optional && !typesToMatch.find((type) => type.kind === "null")) {
          this.emitLine("def encode_", name, suffix, "(value) when is_nil(value), do: value");
        }
        this.emitLine("def encode_", name, suffix, '(_), do: {:error, "Unexpected type when encoding ', parentName, ".", name, '"}');
        this.ensureBlankLine();
      }
      nameOfTransformFunction(t, name, encode = false, prefix = "") {
        let mode = "decode";
        if (encode) {
          mode = "encode";
        }
        return (0, TypeUtils_1.matchType)(t, (_anyType) => [], (_nullType) => [], (_boolType) => [], (_integerType) => [], (_doubleType) => [], (_stringType) => [], (_arrayType) => [], (classType) => [
          this.nameForNamedTypeWithNamespace(classType),
          `.${encode ? "to" : "from"}_map`
        ], (_mapType) => [], (enumType) => {
          return [
            this.nameForNamedTypeWithNamespace(enumType),
            `.${mode}`
          ];
        }, (_unionType) => {
          return [
            `${mode}_`,
            name,
            prefix
          ];
        });
      }
      fromDynamic(t, jsonName, name, optional = false) {
        const primitive = [
          'm["',
          jsonName,
          '"]'
        ];
        return (0, TypeUtils_1.matchType)(t, (_anyType) => primitive, (_nullType) => primitive, (_boolType) => primitive, (_integerType) => primitive, (_doubleType) => primitive, (_stringType) => primitive, (arrayType) => {
          const arrayElement = arrayType.items;
          if (arrayElement instanceof Type_1.ArrayType) {
            return primitive;
          }
          if (arrayElement.isPrimitive()) {
            return primitive;
          }
          if (arrayElement instanceof Type_1.MapType) {
            return primitive;
          }
          if (optional) {
            return [
              "m",
              '["',
              jsonName,
              '"] && Enum.map(m["',
              jsonName,
              '"], &',
              this.nameOfTransformFunction(arrayElement, name, false, "_element"),
              "/1)"
            ];
          }
          return [
            'Enum.map(m["',
            jsonName,
            '"], &',
            this.nameOfTransformFunction(arrayElement, name, false, "_element"),
            "/1)"
          ];
        }, (classType) => [
          optional ? [
            primitive,
            " && "
          ] : "",
          this.nameForNamedTypeWithNamespace(classType),
          ".from_map(",
          primitive,
          ")"
        ], (mapType) => {
          const mapValueTypes = [
            ...mapType.values.getChildren()
          ];
          const mapValueTypesNotPrimitive = mapValueTypes.filter((type) => !(type instanceof Type_1.PrimitiveType));
          if (mapValueTypesNotPrimitive.length === 0) {
            return [
              primitive
            ];
          }
          if (mapType.values.kind === "union") {
            return [
              'm["',
              jsonName,
              '"]\n|> Map.new(fn {key, value} -> {key, ',
              this.nameOfTransformFunction(mapType.values, jsonName, false),
              "_value(value)} end)"
            ];
          }
          if (mapType.values instanceof Type_1.EnumType || mapType.values instanceof Type_1.ClassType) {
            return [
              'm["',
              jsonName,
              '"]\n|> Map.new(fn {key, value} -> {key, ',
              this.nameOfTransformFunction(mapType.values, jsonName, false),
              "(value)} end)"
            ];
          }
          return [
            primitive
          ];
        }, (enumType) => {
          return [
            optional ? [
              primitive,
              " && "
            ] : "",
            this.nameOfTransformFunction(enumType, name),
            "(",
            primitive,
            ")"
          ];
        }, (unionType) => {
          const unionTypes = [
            ...unionType.getChildren()
          ];
          const unionPrimitiveTypes = unionTypes.filter((type) => type.isPrimitive());
          if (unionTypes.length === unionPrimitiveTypes.length) {
            return [
              'm["',
              jsonName,
              '"]'
            ];
          }
          const nullable = (0, TypeUtils_1.nullableFromUnion)(unionType);
          if (nullable !== null) {
            if (nullable instanceof Type_1.ClassType) {
              return this.fromDynamic(nullable, jsonName, name, true);
            }
            const nullableTypes = [
              ...nullable.getChildren()
            ];
            if (nullableTypes.length < 2) {
              return this.fromDynamic(nullable, jsonName, name, true);
            }
            return [
              'm["',
              jsonName,
              '"] && decode_',
              name,
              '(m["',
              jsonName,
              '"])'
            ];
          }
          return [
            "decode_",
            name,
            '(m["',
            jsonName,
            '"])'
          ];
        });
      }
      toDynamic(t, e, optional = false) {
        const expression = [
          "struct.",
          e
        ];
        return (0, TypeUtils_1.matchType)(t, (_anyType) => expression, (_nullType) => expression, (_boolType) => expression, (_integerType) => expression, (_doubleType) => expression, (_stringType) => expression, (arrayType) => {
          const arrayElement = arrayType.items;
          if (arrayElement instanceof Type_1.ArrayType) {
            return expression;
          }
          if (arrayElement.isPrimitive()) {
            return expression;
          }
          if (arrayElement instanceof Type_1.MapType) {
            return expression;
          }
          if (arrayElement.kind === "array") {
            return expression;
          }
          if (optional) {
            return [
              "struct.",
              e,
              " && Enum.map(struct.",
              e,
              ", &",
              this.nameOfTransformFunction(arrayElement, e, true, "_element"),
              "/1)"
            ];
          }
          return [
            "struct.",
            e,
            " && Enum.map(struct.",
            e,
            ", &",
            this.nameOfTransformFunction(arrayElement, e, true, "_element"),
            "/1)"
          ];
        }, (classType) => [
          optional ? [
            "struct.",
            e,
            " && "
          ] : "",
          this.nameForNamedTypeWithNamespace(classType),
          ".to_map(",
          "struct.",
          e,
          ")"
        ], (mapType) => {
          const mapValueTypes = [
            ...mapType.values.getChildren()
          ];
          const mapValueTypesNotPrimitive = mapValueTypes.filter((type) => !(type instanceof Type_1.PrimitiveType));
          if (mapValueTypesNotPrimitive.length === 0) {
            return [
              expression
            ];
          }
          if (mapType.values.kind === "union") {
            return [
              "struct.",
              e,
              "\n|> Map.new(fn {key, value} -> {key, ",
              this.nameOfTransformFunction(mapType.values, e, true),
              "_value(value)} end)"
            ];
          }
          if (mapType.values instanceof Type_1.EnumType || mapType.values instanceof Type_1.ClassType) {
            return [
              "struct.",
              e,
              "\n|> Map.new(fn {key, value} -> {key, ",
              this.nameOfTransformFunction(mapType.values, e, true),
              "(value)} end)"
            ];
          }
          return [
            expression
          ];
        }, (enumType) => {
          return [
            optional ? [
              "struct.",
              e,
              " && "
            ] : "",
            this.nameForNamedTypeWithNamespace(enumType),
            ".encode(struct.",
            e,
            ")"
          ];
        }, (unionType) => {
          const unionTypes = [
            ...unionType.getChildren()
          ];
          const unionPrimitiveTypes = unionTypes.filter((type) => type.isPrimitive());
          if (unionTypes.length === unionPrimitiveTypes.length) {
            return [
              "struct.",
              e
            ];
          }
          const nullable = (0, TypeUtils_1.nullableFromUnion)(unionType);
          if (nullable !== null) {
            if (nullable instanceof Type_1.ClassType) {
              return this.toDynamic(nullable, e, true);
            }
            const nullableTypes = [
              ...nullable.getChildren()
            ];
            if (nullableTypes.length < 2) {
              return this.toDynamic(nullable, e, true);
            }
            return [
              "struct.",
              e,
              " && encode_",
              e,
              "(struct.",
              e,
              ")"
            ];
          }
          return [
            "encode_",
            e,
            "(struct.",
            e,
            ")"
          ];
        });
      }
      emitBlock(source, emit) {
        this.emitLine(source);
        this.indent(emit);
        this.emitLine("end");
      }
      emitDescriptionBlock(lines) {
        this.emitCommentLines(lines, {
          firstLineStart: '@moduledoc """\n',
          lineStart: "",
          afterComment: '"""'
        });
      }
      emitModule(c, moduleName) {
        this.emitBlock([
          "defmodule ",
          this.nameWithNamespace(moduleName),
          " do"
        ], () => {
          var _a;
          const structDescription = (_a = this.descriptionForType(c)) !== null && _a !== void 0 ? _a : [];
          const attributeDescriptions = [];
          this.forEachClassProperty(c, "none", (name, jsonName, _p) => {
            const attributeDescription = this.descriptionForClassProperty(c, jsonName);
            if (attributeDescription) {
              attributeDescriptions.push([
                "- `:",
                name,
                "` - ",
                attributeDescription
              ]);
            }
          });
          if (structDescription.length || attributeDescriptions.length) {
            this.emitDescription([
              ...structDescription,
              ...attributeDescriptions
            ]);
            this.ensureBlankLine();
          }
          const requiredAttributes = [];
          this.forEachClassProperty(c, "none", (name, _jsonName, p) => {
            if (!p.isOptional) {
              if (requiredAttributes.length === 0) {
                requiredAttributes.push([
                  ":",
                  name
                ]);
              } else {
                requiredAttributes.push([
                  ", :",
                  name
                ]);
              }
            }
          });
          if (requiredAttributes.length) {
            this.emitLine([
              "@enforce_keys [",
              requiredAttributes,
              "]"
            ]);
          }
          const attributeNames = [];
          this.forEachClassProperty(c, "none", (name, _jsonName, _p) => {
            if (attributeNames.length === 0) {
              attributeNames.push([
                ":",
                name
              ]);
            } else {
              attributeNames.push([
                ", :",
                name
              ]);
            }
          });
          this.emitLine([
            "defstruct [",
            attributeNames,
            "]"
          ]);
          this.ensureBlankLine();
          const typeDefinitionTable = [
            [
              [
                "@type "
              ],
              [
                "t :: %__MODULE__{"
              ]
            ]
          ];
          let count = c.getProperties().size;
          this.forEachClassProperty(c, "none", (name, _jsonName, p) => {
            const last = --count === 0;
            const attributeRow = [
              [],
              [
                "  ",
                name,
                ": ",
                this.elixirType(p.type),
                p.isOptional ? " | nil" : "",
                last ? "" : ","
              ]
            ];
            typeDefinitionTable.push(attributeRow);
          });
          typeDefinitionTable.push([
            [],
            [
              "}"
            ]
          ]);
          this.emitTable(typeDefinitionTable);
          if (this._options.justTypes) {
            return;
          }
          this.forEachClassProperty(c, "none", (name, _jsonName, p) => {
            if (p.type.kind === "union") {
              const unionTypes = [
                ...p.type.getChildren()
              ];
              const unionPrimitiveTypes = unionTypes.filter((type) => type.isPrimitive());
              if (unionTypes.length === unionPrimitiveTypes.length) {
                return;
              }
              const unionTypesNonNull = unionTypes.filter((type) => type.kind !== "null");
              if (unionTypesNonNull.length === 1) {
                let suffix = "";
                let itemTypes = [];
                if (unionTypesNonNull[0] instanceof Type_1.ArrayType) {
                  suffix = "_element";
                  itemTypes = [
                    ...unionTypesNonNull[0].getChildren()
                  ];
                } else if (unionTypesNonNull[0] instanceof Type_1.MapType) {
                  suffix = "_value";
                  itemTypes = [
                    ...unionTypesNonNull[0].getChildren()
                  ];
                }
                if (itemTypes.length === 1 && itemTypes[0] instanceof Type_1.UnionType) {
                  itemTypes = [
                    ...itemTypes[0].getChildren()
                  ];
                }
                this.emitPatternMatches(itemTypes, name, this.nameForNamedTypeWithNamespace(c), suffix, p.isOptional);
              } else {
                this.emitPatternMatches(unionTypes, name, this.nameForNamedTypeWithNamespace(c), "", p.isOptional);
              }
            } else if (p.type.kind === "array") {
              const arrayType = p.type;
              if (arrayType.items instanceof Type_1.UnionType) {
                const unionType = arrayType.items;
                const typesInUnion = [
                  ...unionType.getChildren()
                ];
                this.emitPatternMatches(typesInUnion, name, this.nameForNamedTypeWithNamespace(c), "_element");
              }
            } else if (p.type.kind === "map") {
              const mapType = p.type;
              if (mapType.values instanceof Type_1.UnionType) {
                const unionType = mapType.values;
                const typesInUnion = [
                  ...unionType.getChildren()
                ];
                this.emitPatternMatches(typesInUnion, name, this.nameForNamedTypeWithNamespace(c), "_value");
              }
            }
          });
          let propCount = 0;
          this.forEachClassProperty(c, "none", (_name, _jsonName, _p) => {
            propCount++;
          });
          const isEmpty = propCount ? false : true;
          this.ensureBlankLine();
          this.emitBlock([
            `def from_map(${isEmpty ? "_" : ""}m) do`
          ], () => {
            this.emitLine("%", this.nameWithNamespace(moduleName), "{");
            this.indent(() => {
              this.forEachClassProperty(c, "none", (name, jsonName, p) => {
                jsonName = (0, utils_1.escapeDoubleQuotes)(jsonName);
                jsonName = (0, utils_1.escapeNewLines)(jsonName);
                const expression = this.fromDynamic(p.type, jsonName, name, p.isOptional);
                this.emitLine(name, ": ", expression, ",");
              });
            });
            this.emitLine("}");
          });
          this.ensureBlankLine();
          this.emitBlock("def from_json(json) do", () => {
            this.emitMultiline(`json
			|> Jason.decode!()
			|> from_map()`);
          });
          this.ensureBlankLine();
          this.emitBlock([
            `def to_map(${isEmpty ? "_" : ""}struct) do`
          ], () => {
            this.emitLine("%{");
            this.indent(() => {
              this.forEachClassProperty(c, "none", (name, jsonName, p) => {
                const expression = this.toDynamic(p.type, name, p.isOptional);
                this.emitLine([
                  [
                    `"${(0, utils_1.stringEscape)(jsonName)}"`
                  ],
                  [
                    " => ",
                    expression,
                    ","
                  ]
                ]);
              });
            });
            this.emitLine("}");
          });
          this.ensureBlankLine();
          this.emitBlock("def to_json(struct) do", () => {
            this.emitMultiline(`struct
			|> to_map()
			|> Jason.encode!()`);
          });
        });
      }
      isValidAtom(str) {
        function isLetter(char2) {
          return /^[A-Za-z_]$/.test(char2);
        }
        function isLetterOrDigit(char2) {
          return /^[A-Za-z0-9_]$/.test(char2);
        }
        if (str.length === 0) {
          return false;
        }
        const firstChar = str[0];
        if (!isLetter(firstChar)) {
          return false;
        }
        for (let i2 = 1; i2 < str.length; i2++) {
          const char2 = str[i2];
          if (!isLetterOrDigit(char2) && char2 !== "@" && !(i2 === str.length - 1 && (char2 === "!" || char2 === "?"))) {
            return false;
          }
        }
        return true;
      }
      emitEnum(e, enumName) {
        this.emitBlock([
          "defmodule ",
          this.nameWithNamespace(enumName),
          " do"
        ], () => {
          this.emitDescription(this.descriptionForType(e));
          this.emitLine("@valid_enum_members [");
          this.indent(() => {
            this.forEachEnumCase(e, "none", (_name, json) => {
              if (this.isValidAtom(json)) {
                this.emitLine(":", json, ",");
              } else {
                this.emitLine(":", `"${json}"`, ",");
              }
            });
          });
          this.emitLine("]");
          this.ensureBlankLine();
          this.emitMultiline(`def valid_atom?(value), do: value in @valid_enum_members

def valid_atom_string?(value) do
	try do
			atom = String.to_existing_atom(value)
			atom in @valid_enum_members
	rescue
			ArgumentError -> false
	end
end

def encode(value) do
	if valid_atom?(value) do
			Atom.to_string(value)
	else
			{:error, "Unexpected value when encoding atom: #{inspect(value)}"}
	end
end

def decode(value) do
	if valid_atom_string?(value) do
			String.to_existing_atom(value)
	else
			{:error, "Unexpected value when decoding atom: #{inspect(value)}"}
	end
end

def from_json(json) do
	json
	|> Jason.decode!()
	|> decode()
end

def to_json(data) do
	data
	|> encode()
	|> Jason.encode!()
end`);
        });
      }
      emitUnion(_u, _unionName) {
        return;
      }
      emitSourceStructure() {
        if (this.leadingComments !== void 0) {
          this.emitComments(this.leadingComments);
        } else if (!this._options.justTypes) {
          this.emitMultiline(`# This file was autogenerated using quicktype https://github.com/quicktype/quicktype
#
# Add Jason to your mix.exs`);
          this.forEachTopLevel("none", (_topLevel, name) => {
            this.emitLine("#");
            this.emitLine("# Decode a JSON string: ", this.nameWithNamespace(name), ".from_json(data)");
            this.emitLine("# Encode into a JSON string: ", this.nameWithNamespace(name), ".to_json(struct)");
          });
        }
        this.ensureBlankLine();
        this.forEachNamedType("leading-and-interposing", (c, n) => this.emitModule(c, n), (e, n) => this.emitEnum(e, n), (u, n) => this.emitUnion(u, n));
        if (!this._options.justTypes) {
          this.forEachTopLevel("leading-and-interposing", (topLevel, name) => {
            const isTopLevelArray = "array" === topLevel.kind;
            this.emitBlock([
              "defmodule ",
              this.nameWithNamespace(name),
              " do"
            ], () => {
              var _a;
              const description = (_a = this.descriptionForType(topLevel)) !== null && _a !== void 0 ? _a : [];
              if (description.length) {
                this.emitDescription([
                  ...description
                ]);
                this.ensureBlankLine();
              }
              if (isTopLevelArray) {
                const arrayElement = topLevel.items;
                let isUnion = false;
                if (arrayElement instanceof Type_1.UnionType) {
                  this.emitPatternMatches([
                    ...arrayElement.getChildren()
                  ], "element", name);
                  isUnion = true;
                }
                this.emitBlock("def from_json(json) do", () => {
                  this.emitLine("json");
                  this.emitLine("|> Jason.decode!()");
                  this.emitLine("|> Enum.map(&", isUnion ? [
                    "decode_element/1)"
                  ] : [
                    this.nameWithNamespace(name),
                    "Element.from_map/1)"
                  ]);
                });
                this.ensureBlankLine();
                this.emitBlock("def to_json(list) do", () => {
                  this.emitLine("Enum.map(list, &", isUnion ? [
                    "encode_element/1)"
                  ] : [
                    this.nameWithNamespace(name),
                    "Element.to_map/1)"
                  ]);
                  this.emitLine("|> Jason.encode!()");
                });
              } else {
                this.emitBlock("def from_json(json) do", () => {
                  this.emitLine("Jason.decode!(json)");
                });
                this.ensureBlankLine();
                this.emitBlock("def to_json(data) do", () => {
                  this.emitLine("Jason.encode!(data)");
                });
              }
            });
          }, (t) => this.namedTypeToNameForTopLevel(t) === void 0);
        }
      }
    };
    exports.ElixirRenderer = ElixirRenderer;
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Elixir/language.js
var require_language6 = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Elixir/language.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.ElixirTargetLanguage = exports.elixirLanguageConfig = exports.elixirOptions = void 0;
    var RendererOptions_1 = require_RendererOptions();
    var TargetLanguage_1 = require_TargetLanguage();
    var ElixirRenderer_1 = require_ElixirRenderer();
    exports.elixirOptions = {
      justTypes: new RendererOptions_1.BooleanOption("just-types", "Plain types only", false),
      namespace: new RendererOptions_1.StringOption("namespace", "Specify a module namespace", "NAME", "")
    };
    exports.elixirLanguageConfig = {
      displayName: "Elixir",
      names: [
        "elixir"
      ],
      extension: "ex"
    };
    var ElixirTargetLanguage = class extends TargetLanguage_1.TargetLanguage {
      constructor() {
        super(exports.elixirLanguageConfig);
      }
      getOptions() {
        return exports.elixirOptions;
      }
      get supportsOptionalClassProperties() {
        return true;
      }
      get defaultIndentation() {
        return "  ";
      }
      makeRenderer(renderContext, untypedOptionValues) {
        return new ElixirRenderer_1.ElixirRenderer(this, renderContext, (0, RendererOptions_1.getOptionValues)(exports.elixirOptions, untypedOptionValues));
      }
    };
    exports.ElixirTargetLanguage = ElixirTargetLanguage;
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Elixir/index.js
var require_Elixir = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Elixir/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.ElixirRenderer = exports.elixirOptions = exports.ElixirTargetLanguage = void 0;
    var language_1 = require_language6();
    Object.defineProperty(exports, "ElixirTargetLanguage", {
      enumerable: true,
      get: function() {
        return language_1.ElixirTargetLanguage;
      }
    });
    Object.defineProperty(exports, "elixirOptions", {
      enumerable: true,
      get: function() {
        return language_1.elixirOptions;
      }
    });
    var ElixirRenderer_1 = require_ElixirRenderer();
    Object.defineProperty(exports, "ElixirRenderer", {
      enumerable: true,
      get: function() {
        return ElixirRenderer_1.ElixirRenderer;
      }
    });
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Elm/constants.js
var require_constants8 = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Elm/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.forbiddenNames = void 0;
    exports.forbiddenNames = [
      "if",
      "then",
      "else",
      "case",
      "of",
      "let",
      "in",
      "infix",
      "type",
      "module",
      "where",
      "import",
      "exposing",
      "as",
      "port",
      "int",
      "float",
      "bool",
      "string",
      "Jenc",
      "Jdec",
      "Jpipe",
      "always",
      "identity",
      "Array",
      "List",
      "Dict",
      "Maybe",
      "map",
      "toList",
      "makeArrayEncoder",
      "makeDictEncoder",
      "makeNullableEncoder",
      "Int",
      "True",
      "False",
      "String",
      "Float"
    ];
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Elm/utils.js
var require_utils7 = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Elm/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.lowerNamingFunction = exports.upperNamingFunction = void 0;
    exports.requiredOrOptional = requiredOrOptional;
    var Naming_1 = require_Naming();
    var Strings_1 = require_Strings();
    var Type_1 = require_Type2();
    var TypeUtils_1 = require_TypeUtils();
    var legalizeName = (0, Strings_1.legalizeCharacters)((cp) => (0, Strings_1.isAscii)(cp) && (0, Strings_1.isLetterOrUnderscoreOrDigit)(cp));
    function elmNameStyle(original, upper) {
      const words = (0, Strings_1.splitIntoWords)(original);
      return (0, Strings_1.combineWords)(words, legalizeName, upper ? Strings_1.firstUpperWordStyle : Strings_1.allLowerWordStyle, Strings_1.firstUpperWordStyle, upper ? Strings_1.allUpperWordStyle : Strings_1.allLowerWordStyle, Strings_1.allUpperWordStyle, "", Strings_1.isLetterOrUnderscore);
    }
    exports.upperNamingFunction = (0, Naming_1.funPrefixNamer)("upper", (n) => elmNameStyle(n, true));
    exports.lowerNamingFunction = (0, Naming_1.funPrefixNamer)("lower", (n) => elmNameStyle(n, false));
    function requiredOrOptional(p) {
      function optional(fallback) {
        return {
          reqOrOpt: "Jpipe.optional",
          fallback
        };
      }
      const t = p.type;
      if (p.isOptional || t instanceof Type_1.UnionType && (0, TypeUtils_1.nullableFromUnion)(t) !== null) {
        return optional(" Nothing");
      }
      if (t.kind === "null") {
        return optional(" ()");
      }
      return {
        reqOrOpt: "Jpipe.required",
        fallback: ""
      };
    }
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Elm/ElmRenderer.js
var require_ElmRenderer = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Elm/ElmRenderer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.ElmRenderer = void 0;
    var collection_utils_1 = require_dist();
    var Annotation_1 = require_Annotation();
    var ConvenienceRenderer_1 = require_ConvenienceRenderer();
    var Naming_1 = require_Naming();
    var Source_1 = require_Source();
    var Strings_1 = require_Strings();
    var Support_1 = require_Support();
    var TypeUtils_1 = require_TypeUtils();
    var constants_1 = require_constants8();
    var utils_1 = require_utils7();
    var ElmRenderer = class extends ConvenienceRenderer_1.ConvenienceRenderer {
      constructor(targetLanguage, renderContext, _options) {
        super(targetLanguage, renderContext);
        this._options = _options;
        this._topLevelDependents = /* @__PURE__ */ new Map();
        this._namedTypeDependents = /* @__PURE__ */ new Map();
      }
      forbiddenNamesForGlobalNamespace() {
        return constants_1.forbiddenNames;
      }
      makeTopLevelDependencyNames(t, topLevelName) {
        const encoder = new Naming_1.DependencyName(utils_1.lowerNamingFunction, topLevelName.order, (lookup) => `${lookup(topLevelName)}_to_string`);
        let decoder = void 0;
        if (this.namedTypeToNameForTopLevel(t) === void 0) {
          decoder = new Naming_1.DependencyName(utils_1.lowerNamingFunction, topLevelName.order, (lookup) => lookup(topLevelName));
        }
        this._topLevelDependents.set(topLevelName, {
          encoder,
          decoder
        });
        if (decoder !== void 0) {
          return [
            encoder,
            decoder
          ];
        }
        return [
          encoder
        ];
      }
      makeNamedTypeNamer() {
        return utils_1.upperNamingFunction;
      }
      makeNamedTypeDependencyNames(_, typeName) {
        const encoder = new Naming_1.DependencyName(utils_1.lowerNamingFunction, typeName.order, (lookup) => `encode_${lookup(typeName)}`);
        const decoder = new Naming_1.DependencyName(utils_1.lowerNamingFunction, typeName.order, (lookup) => lookup(typeName));
        this._namedTypeDependents.set(typeName, {
          encoder,
          decoder
        });
        return [
          encoder,
          decoder
        ];
      }
      namerForObjectProperty() {
        return utils_1.lowerNamingFunction;
      }
      forbiddenForObjectProperties(_c, _className) {
        return {
          names: [],
          includeGlobalForbidden: true
        };
      }
      makeUnionMemberNamer() {
        return utils_1.upperNamingFunction;
      }
      get unionMembersInGlobalNamespace() {
        return true;
      }
      makeEnumCaseNamer() {
        return utils_1.upperNamingFunction;
      }
      get enumCasesInGlobalNamespace() {
        return true;
      }
      proposeUnionMemberName(u, unionName, fieldType, lookup) {
        const fieldName = super.proposeUnionMemberName(u, unionName, fieldType, lookup);
        return `${fieldName}_in_${lookup(unionName)}`;
      }
      get commentLineStart() {
        return "-- ";
      }
      emitDescriptionBlock(lines) {
        if (lines.length === 1) {
          this.emitComments([
            {
              customLines: lines,
              lineStart: "{-| ",
              lineEnd: " -}"
            }
          ]);
        } else {
          this.emitCommentLines(lines, {
            firstLineStart: "{-| ",
            lineStart: "",
            afterComment: "-}"
          });
        }
      }
      get arrayType() {
        return this._options.useList ? "List" : "Array";
      }
      elmType(t, noOptional = false) {
        return (0, TypeUtils_1.matchType)(t, (_anyType) => (0, Source_1.singleWord)((0, Source_1.annotated)(Annotation_1.anyTypeIssueAnnotation, "Jdec.Value")), (_nullType) => (0, Source_1.singleWord)((0, Source_1.annotated)(Annotation_1.nullTypeIssueAnnotation, "()")), (_boolType) => (0, Source_1.singleWord)("Bool"), (_integerType) => (0, Source_1.singleWord)("Int"), (_doubleType) => (0, Source_1.singleWord)("Float"), (_stringType) => (0, Source_1.singleWord)("String"), (arrayType) => (0, Source_1.multiWord)(" ", this.arrayType, (0, Source_1.parenIfNeeded)(this.elmType(arrayType.items))), (classType) => (0, Source_1.singleWord)(this.nameForNamedType(classType)), (mapType) => (0, Source_1.multiWord)(" ", "Dict String", (0, Source_1.parenIfNeeded)(this.elmType(mapType.values))), (enumType) => (0, Source_1.singleWord)(this.nameForNamedType(enumType)), (unionType) => {
          const nullable = (0, TypeUtils_1.nullableFromUnion)(unionType);
          if (nullable !== null) {
            const nullableType = this.elmType(nullable);
            if (noOptional) return nullableType;
            return (0, Source_1.multiWord)(" ", "Maybe", (0, Source_1.parenIfNeeded)(nullableType));
          }
          return (0, Source_1.singleWord)(this.nameForNamedType(unionType));
        });
      }
      elmProperty(p) {
        if (p.isOptional) {
          return (0, Source_1.multiWord)(" ", "Maybe", (0, Source_1.parenIfNeeded)(this.elmType(p.type, true))).source;
        }
        return this.elmType(p.type).source;
      }
      decoderNameForNamedType(t) {
        const name = this.nameForNamedType(t);
        return (0, Support_1.defined)(this._namedTypeDependents.get(name)).decoder;
      }
      decoderNameForType(t, noOptional = false) {
        return (0, TypeUtils_1.matchType)(t, (_anyType) => (0, Source_1.singleWord)("Jdec.value"), (_nullType) => (0, Source_1.multiWord)(" ", "Jdec.null", "()"), (_boolType) => (0, Source_1.singleWord)("Jdec.bool"), (_integerType) => (0, Source_1.singleWord)("Jdec.int"), (_doubleType) => (0, Source_1.singleWord)("Jdec.float"), (_stringType) => (0, Source_1.singleWord)("Jdec.string"), (arrayType) => (0, Source_1.multiWord)(" ", [
          "Jdec.",
          (0, Strings_1.decapitalize)(this.arrayType)
        ], (0, Source_1.parenIfNeeded)(this.decoderNameForType(arrayType.items))), (classType) => (0, Source_1.singleWord)(this.decoderNameForNamedType(classType)), (mapType) => (0, Source_1.multiWord)(" ", "Jdec.dict", (0, Source_1.parenIfNeeded)(this.decoderNameForType(mapType.values))), (enumType) => (0, Source_1.singleWord)(this.decoderNameForNamedType(enumType)), (unionType) => {
          const nullable = (0, TypeUtils_1.nullableFromUnion)(unionType);
          if (nullable !== null) {
            const nullableDecoder = this.decoderNameForType(nullable);
            if (noOptional) return nullableDecoder;
            return (0, Source_1.multiWord)(" ", "Jdec.nullable", (0, Source_1.parenIfNeeded)(nullableDecoder));
          }
          return (0, Source_1.singleWord)(this.decoderNameForNamedType(unionType));
        });
      }
      decoderNameForProperty(p) {
        if (p.isOptional) {
          return (0, Source_1.multiWord)(" ", "Jdec.nullable", (0, Source_1.parenIfNeeded)(this.decoderNameForType(p.type, true)));
        }
        return this.decoderNameForType(p.type);
      }
      encoderNameForNamedType(t) {
        const name = this.nameForNamedType(t);
        return (0, Support_1.defined)(this._namedTypeDependents.get(name)).encoder;
      }
      encoderNameForType(t, noOptional = false) {
        return (0, TypeUtils_1.matchType)(t, (_anyType) => (0, Source_1.singleWord)("identity"), (_nullType) => (0, Source_1.multiWord)(" ", "always", "Jenc.null"), (_boolType) => (0, Source_1.singleWord)("Jenc.bool"), (_integerType) => (0, Source_1.singleWord)("Jenc.int"), (_doubleType) => (0, Source_1.singleWord)("Jenc.float"), (_stringType) => (0, Source_1.singleWord)("Jenc.string"), (arrayType) => (0, Source_1.multiWord)(" ", [
          "make",
          this.arrayType,
          "Encoder"
        ], (0, Source_1.parenIfNeeded)(this.encoderNameForType(arrayType.items))), (classType) => (0, Source_1.singleWord)(this.encoderNameForNamedType(classType)), (mapType) => (0, Source_1.multiWord)(" ", "makeDictEncoder", (0, Source_1.parenIfNeeded)(this.encoderNameForType(mapType.values))), (enumType) => (0, Source_1.singleWord)(this.encoderNameForNamedType(enumType)), (unionType) => {
          const nullable = (0, TypeUtils_1.nullableFromUnion)(unionType);
          if (nullable !== null) {
            const nullableEncoder = this.encoderNameForType(nullable);
            if (noOptional) return nullableEncoder;
            return (0, Source_1.multiWord)(" ", "makeNullableEncoder", (0, Source_1.parenIfNeeded)(nullableEncoder));
          }
          return (0, Source_1.singleWord)(this.encoderNameForNamedType(unionType));
        });
      }
      encoderNameForProperty(p) {
        if (p.isOptional) {
          return (0, Source_1.multiWord)(" ", "makeNullableEncoder", (0, Source_1.parenIfNeeded)(this.encoderNameForType(p.type, true)));
        }
        return this.encoderNameForType(p.type);
      }
      emitTopLevelDefinition(t, topLevelName) {
        this.emitLine("type alias ", topLevelName, " = ", this.elmType(t).source);
      }
      emitClassDefinition(c, className) {
        let description = this.descriptionForType(c);
        this.forEachClassProperty(c, "none", (name, jsonName) => {
          const propertyDescription = this.descriptionForClassProperty(c, jsonName);
          if (propertyDescription === void 0) return;
          if (description === void 0) {
            description = [];
          } else {
            description.push("");
          }
          description.push(`${this.sourcelikeToString(name)}:`);
          description.push(...propertyDescription);
        });
        this.emitDescription(description);
        this.emitLine("type alias ", className, " =");
        this.indent(() => {
          let onFirst = true;
          this.forEachClassProperty(c, "none", (name, _jsonName, p) => {
            this.emitLine(onFirst ? "{" : ",", " ", name, " : ", this.elmProperty(p));
            onFirst = false;
          });
          if (onFirst) {
            this.emitLine("{");
          }
          this.emitLine("}");
        });
      }
      emitEnumDefinition(e, enumName) {
        this.emitDescription(this.descriptionForType(e));
        this.emitLine("type ", enumName);
        this.indent(() => {
          let onFirst = true;
          this.forEachEnumCase(e, "none", (name) => {
            const equalsOrPipe = onFirst ? "=" : "|";
            this.emitLine(equalsOrPipe, " ", name);
            onFirst = false;
          });
        });
      }
      emitUnionDefinition(u, unionName) {
        this.emitDescription(this.descriptionForType(u));
        this.emitLine("type ", unionName);
        this.indent(() => {
          let onFirst = true;
          this.forEachUnionMember(u, null, "none", null, (name, t) => {
            const equalsOrPipe = onFirst ? "=" : "|";
            if (t.kind === "null") {
              this.emitLine(equalsOrPipe, " ", name);
            } else {
              this.emitLine(equalsOrPipe, " ", name, " ", (0, Source_1.parenIfNeeded)(this.elmType(t)));
            }
            onFirst = false;
          });
        });
      }
      emitTopLevelFunctions(t, topLevelName) {
        const { encoder, decoder } = (0, Support_1.defined)(this._topLevelDependents.get(topLevelName));
        if (this.namedTypeToNameForTopLevel(t) === void 0) {
          this.emitLine((0, Support_1.defined)(decoder), " : Jdec.Decoder ", topLevelName);
          this.emitLine((0, Support_1.defined)(decoder), " = ", this.decoderNameForType(t).source);
          this.ensureBlankLine();
        }
        this.emitLine(encoder, " : ", topLevelName, " -> String");
        this.emitLine(encoder, " r = Jenc.encode 0 (", this.encoderNameForType(t).source, " r)");
      }
      emitClassFunctions(c, className) {
        const decoderName = this.decoderNameForNamedType(c);
        this.emitLine(decoderName, " : Jdec.Decoder ", className);
        this.emitLine(decoderName, " =");
        this.indent(() => {
          this.emitLine("Jpipe.decode ", className);
          this.indent(() => {
            this.forEachClassProperty(c, "none", (_, jsonName, p) => {
              const propDecoder = (0, Source_1.parenIfNeeded)(this.decoderNameForProperty(p));
              const { reqOrOpt, fallback } = (0, utils_1.requiredOrOptional)(p);
              this.emitLine("|> ", reqOrOpt, ' "', (0, Strings_1.stringEscape)(jsonName), '" ', propDecoder, fallback);
            });
          });
        });
        this.ensureBlankLine();
        const encoderName = this.encoderNameForNamedType(c);
        this.emitLine(encoderName, " : ", className, " -> Jenc.Value");
        this.emitLine(encoderName, " x =");
        this.indent(() => {
          this.emitLine("Jenc.object");
          this.indent(() => {
            let onFirst = true;
            this.forEachClassProperty(c, "none", (name, jsonName, p) => {
              const bracketOrComma = onFirst ? "[" : ",";
              const propEncoder = this.encoderNameForProperty(p).source;
              this.emitLine(bracketOrComma, ' ("', (0, Strings_1.stringEscape)(jsonName), '", ', propEncoder, " x.", name, ")");
              onFirst = false;
            });
            if (onFirst) {
              this.emitLine("[");
            }
            this.emitLine("]");
          });
        });
      }
      emitEnumFunctions(e, enumName) {
        const decoderName = this.decoderNameForNamedType(e);
        this.emitLine(decoderName, " : Jdec.Decoder ", enumName);
        this.emitLine(decoderName, " =");
        this.indent(() => {
          this.emitLine("Jdec.string");
          this.indent(() => {
            this.emitLine("|> Jdec.andThen (\\str ->");
            this.indent(() => {
              this.emitLine("case str of");
              this.indent(() => {
                this.forEachEnumCase(e, "none", (name, jsonName) => {
                  this.emitLine('"', (0, Strings_1.stringEscape)(jsonName), '" -> Jdec.succeed ', name);
                });
                this.emitLine('somethingElse -> Jdec.fail <| "Invalid ', enumName, ': " ++ somethingElse');
              });
            });
            this.emitLine(")");
          });
        });
        this.ensureBlankLine();
        const encoderName = this.encoderNameForNamedType(e);
        this.emitLine(encoderName, " : ", enumName, " -> Jenc.Value");
        this.emitLine(encoderName, " x = case x of");
        this.indent(() => {
          this.forEachEnumCase(e, "none", (name, jsonName) => {
            this.emitLine(name, ' -> Jenc.string "', (0, Strings_1.stringEscape)(jsonName), '"');
          });
        });
      }
      emitUnionFunctions(u, unionName) {
        function sortOrder(_, t) {
          if (t.kind === "array") {
            return "  array";
          }
          if (t.kind === "double") {
            return " xdouble";
          }
          if (t.isPrimitive()) {
            return " " + t.kind;
          }
          return t.kind;
        }
        const decoderName = this.decoderNameForNamedType(u);
        this.emitLine(decoderName, " : Jdec.Decoder ", unionName);
        this.emitLine(decoderName, " =");
        this.indent(() => {
          this.emitLine("Jdec.oneOf");
          this.indent(() => {
            let onFirst = true;
            this.forEachUnionMember(u, null, "none", sortOrder, (name, t) => {
              const bracketOrComma = onFirst ? "[" : ",";
              if (t.kind === "null") {
                this.emitLine(bracketOrComma, " Jdec.null ", name);
              } else {
                const decoder = (0, Source_1.parenIfNeeded)(this.decoderNameForType(t));
                this.emitLine(bracketOrComma, " Jdec.map ", name, " ", decoder);
              }
              onFirst = false;
            });
            this.emitLine("]");
          });
        });
        this.ensureBlankLine();
        const encoderName = this.encoderNameForNamedType(u);
        this.emitLine(encoderName, " : ", unionName, " -> Jenc.Value");
        this.emitLine(encoderName, " x = case x of");
        this.indent(() => {
          this.forEachUnionMember(u, null, "none", sortOrder, (name, t) => {
            if (t.kind === "null") {
              this.emitLine(name, " -> Jenc.null");
            } else {
              const encoder = this.encoderNameForType(t).source;
              this.emitLine(name, " y -> ", encoder, " y");
            }
          });
        });
      }
      emitSourceStructure() {
        const exports2 = [];
        const topLevelDecoders = [];
        this.forEachTopLevel("none", (_, name) => {
          let { encoder, decoder } = (0, Support_1.defined)(this._topLevelDependents.get(name));
          if (decoder === void 0) {
            decoder = (0, Support_1.defined)(this._namedTypeDependents.get(name)).decoder;
          }
          topLevelDecoders.push(decoder);
          exports2.push(name, encoder, decoder);
        });
        this.forEachObject("none", (t, name) => {
          if (!(0, collection_utils_1.mapContains)(this.topLevels, t)) exports2.push(name);
        });
        this.forEachEnum("none", (t, name) => {
          if (!(0, collection_utils_1.mapContains)(this.topLevels, t)) exports2.push([
            name,
            "(..)"
          ]);
        });
        this.forEachUnion("none", (t, name) => {
          if (!(0, collection_utils_1.mapContains)(this.topLevels, t)) exports2.push([
            name,
            "(..)"
          ]);
        });
        if (this.leadingComments !== void 0) {
          this.emitComments(this.leadingComments);
        } else if (!this._options.justTypes) {
          this.emitCommentLines([
            "To decode the JSON data, add this file to your project, run",
            "",
            "    elm-package install NoRedInk/elm-decode-pipeline",
            "",
            "add these imports",
            "",
            "    import Json.Decode exposing (decodeString)`);"
          ]);
          this.emitLine("--     import ", this._options.moduleName, " exposing (", (0, collection_utils_1.arrayIntercalate)(", ", topLevelDecoders), ")");
          this.emitMultiline(`--
-- and you're off to the races with
--`);
          this.forEachTopLevel("none", (_, name) => {
            let { decoder } = (0, Support_1.defined)(this._topLevelDependents.get(name));
            if (decoder === void 0) {
              decoder = (0, Support_1.defined)(this._namedTypeDependents.get(name)).decoder;
            }
            this.emitLine("--     decodeString ", decoder, " myJsonString");
          });
        }
        if (!this._options.justTypes) {
          this.ensureBlankLine();
          this.emitLine("module ", this._options.moduleName, " exposing");
          this.indent(() => {
            for (let i2 = 0; i2 < exports2.length; i2++) {
              this.emitLine(i2 === 0 ? "(" : ",", " ", exports2[i2]);
            }
            this.emitLine(")");
          });
          this.ensureBlankLine();
          this.emitMultiline(`import Json.Decode as Jdec
import Json.Decode.Pipeline as Jpipe
import Json.Encode as Jenc
import Dict exposing (Dict, map, toList)`);
          if (this._options.useList) {
            this.emitLine("import List exposing (map)");
          } else {
            this.emitLine("import Array exposing (Array, map)");
          }
        }
        this.forEachTopLevel("leading-and-interposing", (t, topLevelName) => this.emitTopLevelDefinition(t, topLevelName), (t) => this.namedTypeToNameForTopLevel(t) === void 0);
        this.forEachNamedType("leading-and-interposing", (c, className) => this.emitClassDefinition(c, className), (e, enumName) => this.emitEnumDefinition(e, enumName), (u, unionName) => this.emitUnionDefinition(u, unionName));
        if (this._options.justTypes) return;
        this.ensureBlankLine();
        this.emitLine("-- decoders and encoders");
        this.forEachTopLevel("leading-and-interposing", (t, topLevelName) => this.emitTopLevelFunctions(t, topLevelName));
        this.forEachNamedType("leading-and-interposing", (c, className) => this.emitClassFunctions(c, className), (e, enumName) => this.emitEnumFunctions(e, enumName), (u, unionName) => this.emitUnionFunctions(u, unionName));
        this.ensureBlankLine();
        this.emitLine("--- encoder helpers");
        this.ensureBlankLine();
        this.emitLine("make", this.arrayType, "Encoder : (a -> Jenc.Value) -> ", this.arrayType, " a -> Jenc.Value");
        this.emitLine("make", this.arrayType, "Encoder f arr =");
        this.indent(() => {
          this.emitLine("Jenc.", (0, Strings_1.decapitalize)(this.arrayType), " (", this.arrayType, ".map f arr)");
        });
        this.ensureBlankLine();
        this.emitMultiline(`makeDictEncoder : (a -> Jenc.Value) -> Dict String a -> Jenc.Value
makeDictEncoder f dict =
	Jenc.object (toList (Dict.map (\\k -> f) dict))

makeNullableEncoder : (a -> Jenc.Value) -> Maybe a -> Jenc.Value
makeNullableEncoder f m =
	case m of
	Just x -> f x
	Nothing -> Jenc.null`);
      }
    };
    exports.ElmRenderer = ElmRenderer;
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Elm/language.js
var require_language7 = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Elm/language.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.ElmTargetLanguage = exports.elmLanguageConfig = exports.elmOptions = void 0;
    var RendererOptions_1 = require_RendererOptions();
    var TargetLanguage_1 = require_TargetLanguage();
    var ElmRenderer_1 = require_ElmRenderer();
    exports.elmOptions = {
      justTypes: new RendererOptions_1.BooleanOption("just-types", "Plain types only", false),
      useList: new RendererOptions_1.EnumOption("array-type", "Use Array or List", {
        array: false,
        list: true
      }, "array"),
      // FIXME: Do this via a configurable named eventually.
      moduleName: new RendererOptions_1.StringOption("module", "Generated module name", "NAME", "QuickType")
    };
    exports.elmLanguageConfig = {
      displayName: "Elm",
      names: [
        "elm"
      ],
      extension: "elm"
    };
    var ElmTargetLanguage = class extends TargetLanguage_1.TargetLanguage {
      constructor() {
        super(exports.elmLanguageConfig);
      }
      getOptions() {
        return exports.elmOptions;
      }
      get supportsOptionalClassProperties() {
        return true;
      }
      get supportsUnionsWithBothNumberTypes() {
        return true;
      }
      makeRenderer(renderContext, untypedOptionValues) {
        return new ElmRenderer_1.ElmRenderer(this, renderContext, (0, RendererOptions_1.getOptionValues)(exports.elmOptions, untypedOptionValues));
      }
    };
    exports.ElmTargetLanguage = ElmTargetLanguage;
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Elm/index.js
var require_Elm = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Elm/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.ElmRenderer = exports.elmOptions = exports.ElmTargetLanguage = void 0;
    var language_1 = require_language7();
    Object.defineProperty(exports, "ElmTargetLanguage", {
      enumerable: true,
      get: function() {
        return language_1.ElmTargetLanguage;
      }
    });
    Object.defineProperty(exports, "elmOptions", {
      enumerable: true,
      get: function() {
        return language_1.elmOptions;
      }
    });
    var ElmRenderer_1 = require_ElmRenderer();
    Object.defineProperty(exports, "ElmRenderer", {
      enumerable: true,
      get: function() {
        return ElmRenderer_1.ElmRenderer;
      }
    });
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Golang/utils.js
var require_utils8 = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Golang/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.compoundTypeKinds = exports.primitiveValueTypeKinds = exports.namingFunction = void 0;
    exports.isValueType = isValueType;
    exports.canOmitEmpty = canOmitEmpty;
    var Naming_1 = require_Naming();
    var Strings_1 = require_Strings();
    exports.namingFunction = (0, Naming_1.funPrefixNamer)("namer", goNameStyle);
    var legalizeName = (0, Strings_1.legalizeCharacters)(Strings_1.isLetterOrUnderscoreOrDigit);
    function goNameStyle(original) {
      const words = (0, Strings_1.splitIntoWords)(original);
      return (0, Strings_1.combineWords)(words, legalizeName, Strings_1.firstUpperWordStyle, Strings_1.firstUpperWordStyle, Strings_1.allUpperWordStyle, Strings_1.allUpperWordStyle, "", Strings_1.isLetterOrUnderscore);
    }
    exports.primitiveValueTypeKinds = [
      "integer",
      "double",
      "bool",
      "string"
    ];
    exports.compoundTypeKinds = [
      "array",
      "class",
      "map",
      "enum"
    ];
    function isValueType(t) {
      const kind = t.kind;
      return exports.primitiveValueTypeKinds.includes(kind) || kind === "class" || kind === "enum" || kind === "date-time";
    }
    function canOmitEmpty(cp, omitEmptyOption) {
      if (!cp.isOptional) return false;
      if (omitEmptyOption) return true;
      const t = cp.type;
      return ![
        "union",
        "null",
        "any"
      ].includes(t.kind);
    }
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Golang/GolangRenderer.js
var require_GolangRenderer = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Golang/GolangRenderer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.GoRenderer = void 0;
    var Annotation_1 = require_Annotation();
    var ConvenienceRenderer_1 = require_ConvenienceRenderer();
    var Naming_1 = require_Naming();
    var Source_1 = require_Source();
    var Strings_1 = require_Strings();
    var Support_1 = require_Support();
    var Type_1 = require_Type2();
    var TypeUtils_1 = require_TypeUtils();
    var utils_1 = require_utils8();
    var GoRenderer = class extends ConvenienceRenderer_1.ConvenienceRenderer {
      constructor(targetLanguage, renderContext, _options) {
        super(targetLanguage, renderContext);
        this._options = _options;
        this._topLevelUnmarshalNames = /* @__PURE__ */ new Map();
      }
      makeNamedTypeNamer() {
        return utils_1.namingFunction;
      }
      namerForObjectProperty() {
        return utils_1.namingFunction;
      }
      makeUnionMemberNamer() {
        return utils_1.namingFunction;
      }
      makeEnumCaseNamer() {
        return utils_1.namingFunction;
      }
      get enumCasesInGlobalNamespace() {
        return true;
      }
      makeTopLevelDependencyNames(_, topLevelName) {
        const unmarshalName = new Naming_1.DependencyName(utils_1.namingFunction, topLevelName.order, (lookup) => `unmarshal_${lookup(topLevelName)}`);
        this._topLevelUnmarshalNames.set(topLevelName, unmarshalName);
        return [
          unmarshalName
        ];
      }
      /// startFile takes a file name, lowercases it, appends ".go" to it, and sets it as the current filename.
      startFile(basename) {
        if (this._options.multiFileOutput === false) {
          return;
        }
        (0, Support_1.assert)(this._currentFilename === void 0, `Previous file wasn't finished: ${this._currentFilename}`);
        this._currentFilename = `${this.sourcelikeToString(basename)}.go`;
        this.initializeEmitContextForFilename(this._currentFilename);
      }
      /// endFile pushes the current file name onto the collection of finished files and then resets the current file name. These finished files are used in index.ts to write the output.
      endFile() {
        if (this._options.multiFileOutput === false) {
          return;
        }
        this.finishFile((0, Support_1.defined)(this._currentFilename));
        this._currentFilename = void 0;
      }
      emitBlock(line, f) {
        this.emitLine(line, " {");
        this.indent(f);
        this.emitLine("}");
      }
      emitFunc(decl, f) {
        this.emitBlock([
          "func ",
          decl
        ], f);
      }
      emitStruct(name, table) {
        this.emitBlock([
          "type ",
          name,
          " struct"
        ], () => this.emitTable(table));
      }
      nullableGoType(t, withIssues) {
        const goType = this.goType(t, withIssues);
        if ((0, utils_1.isValueType)(t)) {
          return [
            "*",
            goType
          ];
        }
        return goType;
      }
      propertyGoType(cp) {
        const t = cp.type;
        if (t instanceof Type_1.UnionType && (0, TypeUtils_1.nullableFromUnion)(t) === null) {
          return [
            "*",
            this.goType(t, true)
          ];
        }
        if (cp.isOptional) {
          return this.nullableGoType(t, true);
        }
        return this.goType(t, true);
      }
      goType(t, withIssues = false) {
        return (0, TypeUtils_1.matchType)(t, (_anyType) => (0, Source_1.maybeAnnotated)(withIssues, Annotation_1.anyTypeIssueAnnotation, "interface{}"), (_nullType) => (0, Source_1.maybeAnnotated)(withIssues, Annotation_1.nullTypeIssueAnnotation, "interface{}"), (_boolType) => "bool", (_integerType) => "int64", (_doubleType) => "float64", (_stringType) => "string", (arrayType) => [
          "[]",
          this.goType(arrayType.items, withIssues)
        ], (classType) => this.nameForNamedType(classType), (mapType) => {
          let valueSource;
          const v = mapType.values;
          if (v instanceof Type_1.UnionType && (0, TypeUtils_1.nullableFromUnion)(v) === null) {
            valueSource = [
              "*",
              this.nameForNamedType(v)
            ];
          } else {
            valueSource = this.goType(v, withIssues);
          }
          return [
            "map[string]",
            valueSource
          ];
        }, (enumType) => this.nameForNamedType(enumType), (unionType) => {
          const nullable = (0, TypeUtils_1.nullableFromUnion)(unionType);
          if (nullable !== null) return this.nullableGoType(nullable, withIssues);
          return this.nameForNamedType(unionType);
        }, (transformedStringType) => {
          if (transformedStringType.kind === "date-time") {
            return "time.Time";
          }
          return "string";
        });
      }
      emitTopLevel(t, name) {
        this.startFile(name);
        if (this._options.multiFileOutput && this._options.justTypes === false && this._options.justTypesAndPackage === false && this.leadingComments === void 0) {
          this.emitLineOnce("// Code generated from JSON Schema using quicktype. DO NOT EDIT.");
          this.emitLineOnce("// To parse and unparse this JSON data, add this code to your project and do:");
          this.emitLineOnce("//");
          const ref = (0, Source_1.modifySource)(Strings_1.camelCase, name);
          this.emitLineOnce("//    ", ref, ", err := ", (0, Support_1.defined)(this._topLevelUnmarshalNames.get(name)), "(bytes)");
          this.emitLineOnce("//    bytes, err = ", ref, ".Marshal()");
        }
        this.emitPackageDefinitons(true);
        const unmarshalName = (0, Support_1.defined)(this._topLevelUnmarshalNames.get(name));
        if (this.namedTypeToNameForTopLevel(t) === void 0) {
          this.emitLine("type ", name, " ", this.goType(t));
        }
        if (this._options.justTypes || this._options.justTypesAndPackage) return;
        this.ensureBlankLine();
        this.emitFunc([
          unmarshalName,
          "(data []byte) (",
          name,
          ", error)"
        ], () => {
          this.emitLine("var r ", name);
          this.emitLine("err := json.Unmarshal(data, &r)");
          this.emitLine("return r, err");
        });
        this.ensureBlankLine();
        this.emitFunc([
          "(r *",
          name,
          ") Marshal() ([]byte, error)"
        ], () => {
          this.emitLine("return json.Marshal(r)");
        });
        this.endFile();
      }
      emitClass(c, className) {
        this.startFile(className);
        const columns = [];
        const usedTypes = /* @__PURE__ */ new Set();
        this.forEachClassProperty(c, "none", (name, jsonName, p) => {
          const description = this.descriptionForClassProperty(c, jsonName);
          const docStrings = description !== void 0 && description.length > 0 ? description.map((d) => "// " + d) : [];
          const goType = this.propertyGoType(p);
          const omitEmpty = (0, utils_1.canOmitEmpty)(p, this._options.omitEmpty) ? ",omitempty" : [];
          docStrings.forEach((doc) => columns.push([
            doc
          ]));
          const tags = this._options.fieldTags.split(",").map((tag) => `${tag}:"${(0, Strings_1.stringEscape)(jsonName)}${omitEmpty}"`).join(" ");
          columns.push([
            [
              name,
              " "
            ],
            [
              goType,
              " "
            ],
            [
              "`",
              tags,
              "`"
            ]
          ]);
          usedTypes.add(goType.toString());
        });
        this.emitPackageDefinitons(false, usedTypes.has("time.Time") || usedTypes.has("*,time.Time") || usedTypes.has("[],time.Time") ? /* @__PURE__ */ new Set([
          "time"
        ]) : void 0);
        this.emitDescription(this.descriptionForType(c));
        this.emitStruct(className, columns);
        this.endFile();
      }
      emitEnum(e, enumName) {
        this.startFile(enumName);
        this.emitPackageDefinitons(false);
        this.emitDescription(this.descriptionForType(e));
        this.emitLine("type ", enumName, " string");
        this.ensureBlankLine();
        this.emitLine("const (");
        const columns = [];
        this.forEachEnumCase(e, "none", (name, jsonName) => {
          columns.push([
            [
              name,
              " "
            ],
            [
              enumName,
              ' = "',
              (0, Strings_1.stringEscape)(jsonName),
              '"'
            ]
          ]);
        });
        this.indent(() => this.emitTable(columns));
        this.emitLine(")");
        this.endFile();
      }
      emitUnion(u, unionName) {
        this.startFile(unionName);
        this.emitPackageDefinitons(false);
        const [hasNull, nonNulls] = (0, TypeUtils_1.removeNullFromUnion)(u);
        const isNullableArg = hasNull !== null ? "true" : "false";
        const ifMember = (kind, ifNotMember, f) => {
          const maybeType = u.findMember(kind);
          if (maybeType === void 0) return ifNotMember;
          return f(maybeType, this.nameForUnionMember(u, maybeType), this.goType(maybeType));
        };
        const maybeAssignNil = (kind) => {
          ifMember(kind, void 0, (_1, fieldName, _2) => {
            this.emitLine("x.", fieldName, " = nil");
          });
        };
        const makeArgs = (primitiveArg, compoundArg) => {
          const args = [];
          for (const kind of utils_1.primitiveValueTypeKinds) {
            args.push(ifMember(kind, "nil", (_1, fieldName, _2) => primitiveArg(fieldName)), ", ");
          }
          for (const kind of utils_1.compoundTypeKinds) {
            args.push(ifMember(kind, "false, nil", (t, fieldName, _) => compoundArg(t.kind === "class", fieldName)), ", ");
          }
          args.push(isNullableArg);
          return args;
        };
        const columns = [];
        this.forEachUnionMember(u, nonNulls, "none", null, (fieldName, t) => {
          const goType = this.nullableGoType(t, true);
          columns.push([
            [
              fieldName,
              " "
            ],
            goType
          ]);
        });
        this.emitDescription(this.descriptionForType(u));
        this.emitStruct(unionName, columns);
        if (this._options.justTypes || this._options.justTypesAndPackage) return;
        this.ensureBlankLine();
        this.emitFunc([
          "(x *",
          unionName,
          ") UnmarshalJSON(data []byte) error"
        ], () => {
          for (const kind of utils_1.compoundTypeKinds) {
            maybeAssignNil(kind);
          }
          ifMember("class", void 0, (_1, _2, goType) => {
            this.emitLine("var c ", goType);
          });
          const args = makeArgs((fn) => [
            "&x.",
            fn
          ], (isClass, fn) => isClass ? "true, &c" : [
            "true, &x.",
            fn
          ]);
          this.emitLine("object, err := unmarshalUnion(data, ", args, ")");
          this.emitBlock("if err != nil", () => {
            this.emitLine("return err");
          });
          this.emitBlock("if object", () => {
            ifMember("class", void 0, (_1, fieldName, _2) => {
              this.emitLine("x.", fieldName, " = &c");
            });
          });
          this.emitLine("return nil");
        });
        this.ensureBlankLine();
        this.emitFunc([
          "(x *",
          unionName,
          ") MarshalJSON() ([]byte, error)"
        ], () => {
          const args = makeArgs((fn) => [
            "x.",
            fn
          ], (_, fn) => [
            "x.",
            fn,
            " != nil, x.",
            fn
          ]);
          this.emitLine("return marshalUnion(", args, ")");
        });
        this.endFile();
      }
      emitSingleFileHeaderComments() {
        this.emitLineOnce("// Code generated from JSON Schema using quicktype. DO NOT EDIT.");
        this.emitLineOnce("// To parse and unparse this JSON data, add this code to your project and do:");
        this.forEachTopLevel("none", (_, name) => {
          this.emitLine("//");
          const ref = (0, Source_1.modifySource)(Strings_1.camelCase, name);
          this.emitLine("//    ", ref, ", err := ", (0, Support_1.defined)(this._topLevelUnmarshalNames.get(name)), "(bytes)");
          this.emitLine("//    bytes, err = ", ref, ".Marshal()");
        });
      }
      emitPackageDefinitons(includeJSONEncodingImport, imports = /* @__PURE__ */ new Set()) {
        if (!this._options.justTypes || this._options.justTypesAndPackage) {
          this.ensureBlankLine();
          const packageDeclaration = `package ${this._options.packageName}`;
          this.emitLineOnce(packageDeclaration);
          this.ensureBlankLine();
        }
        if (!this._options.justTypes && !this._options.justTypesAndPackage) {
          if (this.haveNamedUnions && this._options.multiFileOutput === false) {
            imports.add("bytes");
            imports.add("errors");
          }
          if (includeJSONEncodingImport) {
            imports.add("encoding/json");
          }
        }
        this.emitImports(imports);
      }
      emitImports(imports) {
        const sortedImports = Array.from(imports).sort((a, b) => a.localeCompare(b));
        if (sortedImports.length === 0) {
          return;
        }
        sortedImports.forEach((packageName) => {
          this.emitLineOnce(`import "${packageName}"`);
        });
        this.ensureBlankLine();
      }
      emitHelperFunctions() {
        if (this.haveNamedUnions) {
          this.startFile("JSONSchemaSupport");
          const imports = /* @__PURE__ */ new Set();
          if (this._options.multiFileOutput) {
            imports.add("bytes");
            imports.add("errors");
          }
          this.emitPackageDefinitons(true, imports);
          this.ensureBlankLine();
          this.emitMultiline(`func unmarshalUnion(data []byte, pi **int64, pf **float64, pb **bool, ps **string, haveArray bool, pa interface{}, haveObject bool, pc interface{}, haveMap bool, pm interface{}, haveEnum bool, pe interface{}, nullable bool) (bool, error) {
	if pi != nil {
			*pi = nil
	}
	if pf != nil {
			*pf = nil
	}
	if pb != nil {
			*pb = nil
	}
	if ps != nil {
			*ps = nil
	}

	dec := json.NewDecoder(bytes.NewReader(data))
	dec.UseNumber()
	tok, err := dec.Token()
	if err != nil {
			return false, err
	}

	switch v := tok.(type) {
	case json.Number:
			if pi != nil {
					i, err := v.Int64()
					if err == nil {
							*pi = &i
							return false, nil
					}
			}
			if pf != nil {
					f, err := v.Float64()
					if err == nil {
							*pf = &f
							return false, nil
					}
					return false, errors.New("Unparsable number")
			}
			return false, errors.New("Union does not contain number")
	case float64:
			return false, errors.New("Decoder should not return float64")
	case bool:
			if pb != nil {
					*pb = &v
					return false, nil
			}
			return false, errors.New("Union does not contain bool")
	case string:
			if haveEnum {
					return false, json.Unmarshal(data, pe)
			}
			if ps != nil {
					*ps = &v
					return false, nil
			}
			return false, errors.New("Union does not contain string")
	case nil:
			if nullable {
					return false, nil
			}
			return false, errors.New("Union does not contain null")
	case json.Delim:
			if v == '{' {
					if haveObject {
							return true, json.Unmarshal(data, pc)
					}
					if haveMap {
							return false, json.Unmarshal(data, pm)
					}
					return false, errors.New("Union does not contain object")
			}
			if v == '[' {
					if haveArray {
							return false, json.Unmarshal(data, pa)
					}
					return false, errors.New("Union does not contain array")
			}
			return false, errors.New("Cannot handle delimiter")
	}
	return false, errors.New("Cannot unmarshal union")
}

func marshalUnion(pi *int64, pf *float64, pb *bool, ps *string, haveArray bool, pa interface{}, haveObject bool, pc interface{}, haveMap bool, pm interface{}, haveEnum bool, pe interface{}, nullable bool) ([]byte, error) {
	if pi != nil {
			return json.Marshal(*pi)
	}
	if pf != nil {
			return json.Marshal(*pf)
	}
	if pb != nil {
			return json.Marshal(*pb)
	}
	if ps != nil {
			return json.Marshal(*ps)
	}
	if haveArray {
			return json.Marshal(pa)
	}
	if haveObject {
			return json.Marshal(pc)
	}
	if haveMap {
			return json.Marshal(pm)
	}
	if haveEnum {
			return json.Marshal(pe)
	}
	if nullable {
			return json.Marshal(nil)
	}
	return nil, errors.New("Union must not be null")
}`);
          this.endFile();
        }
      }
      emitSourceStructure() {
        if (this._options.multiFileOutput === false && this._options.justTypes === false && this._options.justTypesAndPackage === false && this.leadingComments === void 0) {
          this.emitSingleFileHeaderComments();
          this.emitPackageDefinitons(false, this.collectAllImports());
        }
        this.forEachTopLevel("leading-and-interposing", (t, name) => this.emitTopLevel(t, name), (t) => !(this._options.justTypes || this._options.justTypesAndPackage) || this.namedTypeToNameForTopLevel(t) === void 0);
        this.forEachObject("leading-and-interposing", (c, className) => this.emitClass(c, className));
        this.forEachEnum("leading-and-interposing", (u, enumName) => this.emitEnum(u, enumName));
        this.forEachUnion("leading-and-interposing", (u, unionName) => this.emitUnion(u, unionName));
        if (this._options.justTypes || this._options.justTypesAndPackage) {
          return;
        }
        this.emitHelperFunctions();
      }
      collectAllImports() {
        let imports = /* @__PURE__ */ new Set();
        this.forEachObject("leading-and-interposing", (c, _className) => {
          const classImports = this.collectClassImports(c);
          imports = /* @__PURE__ */ new Set([
            ...imports,
            ...classImports
          ]);
        });
        this.forEachUnion("leading-and-interposing", (u, _unionName) => {
          const unionImports = this.collectUnionImports(u);
          imports = /* @__PURE__ */ new Set([
            ...imports,
            ...unionImports
          ]);
        });
        return imports;
      }
      collectClassImports(c) {
        const usedTypes = /* @__PURE__ */ new Set();
        const mapping = /* @__PURE__ */ new Map();
        mapping.set("time.Time", "time");
        mapping.set("*,time.Time", "time");
        mapping.set("[],time.Time", "time");
        this.forEachClassProperty(c, "none", (_name, _jsonName, p) => {
          const goType = this.propertyGoType(p);
          usedTypes.add(goType.toString());
        });
        const imports = /* @__PURE__ */ new Set();
        usedTypes.forEach((k) => {
          const typeImport = mapping.get(k);
          if (typeImport) {
            imports.add(typeImport);
          }
        });
        return imports;
      }
      collectUnionImports(u) {
        const usedTypes = /* @__PURE__ */ new Set();
        const mapping = /* @__PURE__ */ new Map();
        mapping.set("time.Time", "time");
        mapping.set("*,time.Time", "time");
        this.forEachUnionMember(u, null, "none", null, (_fieldName, t) => {
          const goType = this.nullableGoType(t, true);
          usedTypes.add(goType.toString());
        });
        const imports = /* @__PURE__ */ new Set();
        for (const k of usedTypes) {
          const typeImport = mapping.get(k);
          if (!typeImport) {
            continue;
          }
          imports.add(typeImport);
        }
        return imports;
      }
    };
    exports.GoRenderer = GoRenderer;
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Golang/language.js
var require_language8 = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Golang/language.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.GoTargetLanguage = exports.goOptions = void 0;
    var RendererOptions_1 = require_RendererOptions();
    var TargetLanguage_1 = require_TargetLanguage();
    var GolangRenderer_1 = require_GolangRenderer();
    exports.goOptions = {
      justTypes: new RendererOptions_1.BooleanOption("just-types", "Plain types only", false),
      justTypesAndPackage: new RendererOptions_1.BooleanOption("just-types-and-package", "Plain types with package only", false),
      packageName: new RendererOptions_1.StringOption("package", "Generated package name", "NAME", "main"),
      multiFileOutput: new RendererOptions_1.BooleanOption("multi-file-output", "Renders each top-level object in its own Go file", false),
      fieldTags: new RendererOptions_1.StringOption("field-tags", "list of tags which should be generated for fields", "TAGS", "json"),
      omitEmpty: new RendererOptions_1.BooleanOption("omit-empty", 'If set, all non-required objects will be tagged with ",omitempty"', false)
    };
    var golangLanguageConfig = {
      displayName: "Go",
      names: [
        "go",
        "golang"
      ],
      extension: "go"
    };
    var GoTargetLanguage = class extends TargetLanguage_1.TargetLanguage {
      constructor() {
        super(golangLanguageConfig);
      }
      getOptions() {
        return exports.goOptions;
      }
      get supportsUnionsWithBothNumberTypes() {
        return true;
      }
      get stringTypeMapping() {
        const mapping = /* @__PURE__ */ new Map();
        mapping.set("date-time", "date-time");
        return mapping;
      }
      get supportsOptionalClassProperties() {
        return true;
      }
      makeRenderer(renderContext, untypedOptionValues) {
        return new GolangRenderer_1.GoRenderer(this, renderContext, (0, RendererOptions_1.getOptionValues)(exports.goOptions, untypedOptionValues));
      }
      get defaultIndentation() {
        return "	";
      }
    };
    exports.GoTargetLanguage = GoTargetLanguage;
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Golang/index.js
var require_Golang = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Golang/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.GoRenderer = exports.goOptions = exports.GoTargetLanguage = void 0;
    var language_1 = require_language8();
    Object.defineProperty(exports, "GoTargetLanguage", {
      enumerable: true,
      get: function() {
        return language_1.GoTargetLanguage;
      }
    });
    Object.defineProperty(exports, "goOptions", {
      enumerable: true,
      get: function() {
        return language_1.goOptions;
      }
    });
    var GolangRenderer_1 = require_GolangRenderer();
    Object.defineProperty(exports, "GoRenderer", {
      enumerable: true,
      get: function() {
        return GolangRenderer_1.GoRenderer;
      }
    });
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Haskell/constants.js
var require_constants9 = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Haskell/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.forbiddenNames = void 0;
    exports.forbiddenNames = [
      // reserved keywords
      "as",
      "case",
      "class",
      "data",
      "default",
      "deriving",
      "do",
      "else",
      "family",
      "forall",
      "foreign",
      "hiding",
      "if",
      "import",
      "in",
      "infix",
      "infixl",
      "infixr",
      "instance",
      "let",
      "of",
      "mdo",
      "module",
      "newtype",
      "proc",
      "qualified",
      "rec",
      "then",
      "type",
      "where",
      // in Prelude keywords ...
      "id",
      "Array",
      "HashMap",
      "Map",
      "Maybe",
      "Bool",
      "Int",
      "True",
      "False",
      "Enum",
      // Aeson types
      "encode",
      "decode",
      "text",
      "Text",
      "Value",
      "Object",
      "Result",
      "Series",
      "Error"
    ];
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Haskell/utils.js
var require_utils9 = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Haskell/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.lowerNamingFunction = exports.upperNamingFunction = void 0;
    var Naming_1 = require_Naming();
    var Strings_1 = require_Strings();
    var legalizeName = (0, Strings_1.legalizeCharacters)((cp) => (0, Strings_1.isAscii)(cp) && (0, Strings_1.isLetterOrUnderscoreOrDigit)(cp));
    function haskellNameStyle(original, upper) {
      const words = (0, Strings_1.splitIntoWords)(original);
      return (0, Strings_1.combineWords)(words, legalizeName, upper ? Strings_1.firstUpperWordStyle : Strings_1.allLowerWordStyle, Strings_1.firstUpperWordStyle, upper ? Strings_1.allUpperWordStyle : Strings_1.allLowerWordStyle, Strings_1.allUpperWordStyle, "", Strings_1.isLetterOrUnderscore);
    }
    exports.upperNamingFunction = (0, Naming_1.funPrefixNamer)("upper", (n) => haskellNameStyle(n, true));
    exports.lowerNamingFunction = (0, Naming_1.funPrefixNamer)("lower", (n) => haskellNameStyle(n, false));
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Haskell/HaskellRenderer.js
var require_HaskellRenderer = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Haskell/HaskellRenderer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.HaskellRenderer = void 0;
    var collection_utils_1 = require_dist();
    var ConvenienceRenderer_1 = require_ConvenienceRenderer();
    var Source_1 = require_Source();
    var Strings_1 = require_Strings();
    var TypeUtils_1 = require_TypeUtils();
    var constants_1 = require_constants9();
    var utils_1 = require_utils9();
    var HaskellRenderer = class extends ConvenienceRenderer_1.ConvenienceRenderer {
      constructor(targetLanguage, renderContext, _options) {
        super(targetLanguage, renderContext);
        this._options = _options;
      }
      forbiddenNamesForGlobalNamespace() {
        return constants_1.forbiddenNames;
      }
      makeNamedTypeNamer() {
        return utils_1.upperNamingFunction;
      }
      namerForObjectProperty() {
        return utils_1.lowerNamingFunction;
      }
      forbiddenForObjectProperties(_c, _className) {
        return {
          names: [],
          includeGlobalForbidden: true
        };
      }
      makeUnionMemberNamer() {
        return utils_1.upperNamingFunction;
      }
      get unionMembersInGlobalNamespace() {
        return true;
      }
      makeEnumCaseNamer() {
        return utils_1.upperNamingFunction;
      }
      get enumCasesInGlobalNamespace() {
        return true;
      }
      proposeUnionMemberName(u, unionName, fieldType, lookup) {
        const fieldName = super.proposeUnionMemberName(u, unionName, fieldType, lookup);
        return `${fieldName}_in_${lookup(unionName)}`;
      }
      get commentLineStart() {
        return "-- ";
      }
      emitDescriptionBlock(lines) {
        if (lines.length === 1) {
          this.emitComments([
            {
              customLines: lines,
              lineStart: "{-| ",
              lineEnd: " -}"
            }
          ]);
        } else {
          this.emitCommentLines(lines, {
            firstLineStart: "{-| ",
            lineStart: "",
            afterComment: "-}"
          });
        }
      }
      haskellType(t, noOptional = false) {
        return (0, TypeUtils_1.matchType)(t, (_anyType) => (0, Source_1.multiWord)(" ", "Maybe", "Text"), (_nullType) => (0, Source_1.multiWord)(" ", "Maybe", "Text"), (_boolType) => (0, Source_1.singleWord)("Bool"), (_integerType) => (0, Source_1.singleWord)("Int"), (_doubleType) => (0, Source_1.singleWord)("Float"), (_stringType) => (0, Source_1.singleWord)("Text"), (arrayType) => {
          if (this._options.useList) {
            return (0, Source_1.multiWord)("", "[", (0, Source_1.parenIfNeeded)(this.haskellType(arrayType.items)), "]");
          }
          return (0, Source_1.multiWord)(" ", "Vector", (0, Source_1.parenIfNeeded)(this.haskellType(arrayType.items)));
        }, (classType) => (0, Source_1.singleWord)(this.nameForNamedType(classType)), (mapType) => (0, Source_1.multiWord)(" ", "HashMap Text", (0, Source_1.parenIfNeeded)(this.haskellType(mapType.values))), (enumType) => (0, Source_1.singleWord)(this.nameForNamedType(enumType)), (unionType) => {
          const nullable = (0, TypeUtils_1.nullableFromUnion)(unionType);
          if (nullable !== null) {
            const nullableType = this.haskellType(nullable);
            if (noOptional) return nullableType;
            return (0, Source_1.multiWord)(" ", "Maybe", (0, Source_1.parenIfNeeded)(nullableType));
          }
          return (0, Source_1.singleWord)(this.nameForNamedType(unionType));
        });
      }
      haskellProperty(p) {
        if (p.isOptional) {
          return (0, Source_1.multiWord)(" ", "Maybe", (0, Source_1.parenIfNeeded)(this.haskellType(p.type, true))).source;
        }
        return this.haskellType(p.type).source;
      }
      encoderNameForType(t) {
        return (0, TypeUtils_1.matchType)(t, (_anyType) => (0, Source_1.singleWord)("String"), (_nullType) => (0, Source_1.singleWord)("Null"), (_boolType) => (0, Source_1.singleWord)("Bool"), (_integerType) => (0, Source_1.singleWord)("Number"), (_doubleType) => (0, Source_1.singleWord)("Number"), (_stringType) => (0, Source_1.singleWord)("String"), (_arrayType) => (0, Source_1.singleWord)("Array"), (_classType) => (0, Source_1.singleWord)("Object"), (_mapType) => (0, Source_1.singleWord)("Object"), (_enumType) => (0, Source_1.singleWord)("Object"), (_unionType) => (0, Source_1.singleWord)("Object"));
      }
      emitTopLevelDefinition(t, topLevelName) {
        this.emitLine("type ", topLevelName, " = ", this.haskellType(t).source);
      }
      emitClassDefinition(c, className) {
        let description = this.descriptionForType(c);
        this.forEachClassProperty(c, "none", (name, jsonName) => {
          const propertyDescription = this.descriptionForClassProperty(c, jsonName);
          if (propertyDescription === void 0) return;
          if (description === void 0) {
            description = [];
          } else {
            description.push("");
          }
          description.push(`${this.sourcelikeToString(name)}:`);
          description.push(...propertyDescription);
        });
        this.emitDescription(description);
        this.emitLine("data ", className, " = ", className);
        this.indent(() => {
          let onFirst = true;
          this.forEachClassProperty(c, "none", (name, _jsonName, p) => {
            this.emitLine(onFirst ? "{ " : ", ", name, className, " :: ", this.haskellProperty(p));
            onFirst = false;
          });
          if (onFirst) {
            this.emitLine("{");
          }
          this.emitLine("} deriving (Show)");
        });
      }
      emitEnumDefinition(e, enumName) {
        this.emitDescription(this.descriptionForType(e));
        this.emitLine("data ", enumName);
        this.indent(() => {
          let onFirst = true;
          this.forEachEnumCase(e, "none", (name) => {
            const equalsOrPipe = onFirst ? "=" : "|";
            this.emitLine(equalsOrPipe, " ", name, enumName);
            onFirst = false;
          });
          this.emitLine("deriving (Show)");
        });
      }
      emitUnionDefinition(u, unionName) {
        this.emitDescription(this.descriptionForType(u));
        this.emitLine("data ", unionName);
        this.indent(() => {
          let onFirst = true;
          this.forEachUnionMember(u, null, "none", null, (name, t) => {
            const equalsOrPipe = onFirst ? "=" : "|";
            if (t.kind === "null") {
              this.emitLine(equalsOrPipe, " ", name);
            } else {
              this.emitLine(equalsOrPipe, " ", name, " ", (0, Source_1.parenIfNeeded)(this.haskellType(t)));
            }
            onFirst = false;
          });
          this.emitLine("deriving (Show)");
        });
      }
      emitTopLevelFunctions(topLevelName) {
        this.emitLine("decodeTopLevel :: ByteString -> Maybe ", topLevelName);
        this.emitLine("decodeTopLevel = decode");
      }
      classPropertyLength(c) {
        let counter = 0;
        this.forEachClassProperty(c, "none", () => {
          counter += 1;
        });
        return counter;
      }
      emitClassEncoderInstance(c, className) {
        const classProperties = [];
        this.forEachClassProperty(c, "none", (name) => {
          classProperties.push(" ");
          classProperties.push(name);
          classProperties.push(className);
        });
        this.emitLine("instance ToJSON ", className, " where");
        this.indent(() => {
          if (classProperties.length === 0) {
            this.emitLine("toJSON = \\_ -> emptyObject");
          } else {
            this.emitLine("toJSON (", className, ...classProperties, ") =");
            this.indent(() => {
              this.emitLine("object");
              let onFirst = true;
              this.forEachClassProperty(c, "none", (name, jsonName) => {
                this.emitLine(onFirst ? "[ " : ", ", '"', (0, Strings_1.stringEscape)(jsonName), '" .= ', name, className);
                onFirst = false;
              });
              if (onFirst) {
                this.emitLine("[");
              }
              this.emitLine("]");
            });
          }
        });
      }
      emitClassDecoderInstance(c, className) {
        this.emitLine("instance FromJSON ", className, " where");
        this.indent(() => {
          if (this.classPropertyLength(c) === 0) {
            this.emitLine("parseJSON emptyObject = return ", className);
          } else {
            this.emitLine("parseJSON (Object v) = ", className);
            this.indent(() => {
              let onFirst = true;
              this.forEachClassProperty(c, "none", (_, jsonName, p) => {
                const operator = p.isOptional ? ".:?" : ".:";
                this.emitLine(onFirst ? "<$> " : "<*> ", "v ", operator, ' "', (0, Strings_1.stringEscape)(jsonName), '"');
                onFirst = false;
              });
            });
          }
        });
      }
      emitClassFunctions(c, className) {
        this.emitClassEncoderInstance(c, className);
        this.ensureBlankLine();
        this.emitClassDecoderInstance(c, className);
      }
      emitEnumEncoderInstance(e, enumName) {
        this.emitLine("instance ToJSON ", enumName, " where");
        this.indent(() => {
          this.forEachEnumCase(e, "none", (name, jsonName) => {
            this.emitLine("toJSON ", name, enumName, ' = "', (0, Strings_1.stringEscape)(jsonName), '"');
          });
        });
      }
      emitEnumDecoderInstance(e, enumName) {
        this.emitLine("instance FromJSON ", enumName, " where");
        this.indent(() => {
          this.emitLine('parseJSON = withText "', enumName, '" parseText');
          this.indent(() => {
            this.emitLine("where");
            this.indent(() => {
              this.forEachEnumCase(e, "none", (name, jsonName) => {
                this.emitLine('parseText "', (0, Strings_1.stringEscape)(jsonName), '" = return ', name, enumName);
              });
            });
          });
        });
      }
      emitEnumFunctions(e, enumName) {
        this.emitEnumEncoderInstance(e, enumName);
        this.ensureBlankLine();
        this.emitEnumDecoderInstance(e, enumName);
      }
      emitUnionEncoderInstance(u, unionName) {
        this.emitLine("instance ToJSON ", unionName, " where");
        this.indent(() => {
          this.forEachUnionMember(u, null, "none", null, (name, t) => {
            if (t.kind === "null") {
              this.emitLine("toJSON ", name, " = Null");
            } else {
              this.emitLine("toJSON (", name, " x) = toJSON x");
            }
          });
        });
      }
      emitUnionDecoderInstance(u, unionName) {
        this.emitLine("instance FromJSON ", unionName, " where");
        this.indent(() => {
          this.forEachUnionMember(u, null, "none", null, (name, t) => {
            if (t.kind === "null") {
              this.emitLine("parseJSON Null = return ", name);
            } else {
              this.emitLine("parseJSON xs@(", this.encoderNameForType(t).source, " _) = (fmap ", name, " . parseJSON) xs");
            }
          });
        });
      }
      emitUnionFunctions(u, unionName) {
        this.emitUnionEncoderInstance(u, unionName);
        this.ensureBlankLine();
        this.emitUnionDecoderInstance(u, unionName);
      }
      emitLanguageExtensions(ext) {
        this.emitLine(`{-# LANGUAGE ${ext} #-}`);
      }
      emitSourceStructure() {
        const exports2 = [];
        this.forEachTopLevel("none", (_, name) => {
          exports2.push([
            name,
            " (..)"
          ]);
        });
        this.forEachObject("none", (t, name) => {
          if (!(0, collection_utils_1.mapContains)(this.topLevels, t)) exports2.push([
            name,
            " (..)"
          ]);
        });
        this.forEachEnum("none", (t, name) => {
          if (!(0, collection_utils_1.mapContains)(this.topLevels, t)) exports2.push([
            name,
            " (..)"
          ]);
        });
        this.forEachUnion("none", (t, name) => {
          if (!(0, collection_utils_1.mapContains)(this.topLevels, t)) exports2.push([
            name,
            " (..)"
          ]);
        });
        this.emitLanguageExtensions("StrictData");
        this.emitLanguageExtensions("OverloadedStrings");
        if (!this._options.justTypes) {
          this.ensureBlankLine();
          this.emitLine("module ", this._options.moduleName);
          this.indent(() => {
            for (let i2 = 0; i2 < exports2.length; i2++) {
              this.emitLine(i2 === 0 ? "(" : ",", " ", exports2[i2]);
            }
            this.emitLine(", decodeTopLevel");
            this.emitLine(") where");
          });
          this.ensureBlankLine();
          this.emitMultiline(`import Data.Aeson
import Data.Aeson.Types (emptyObject)
import Data.ByteString.Lazy (ByteString)
import Data.HashMap.Strict (HashMap)
import Data.Text (Text)`);
          if (this._options.useList) {
          } else {
            this.emitLine("import Data.Vector (Vector)");
          }
        }
        this.forEachTopLevel("leading-and-interposing", (t, topLevelName) => this.emitTopLevelDefinition(t, topLevelName), (t) => this.namedTypeToNameForTopLevel(t) === void 0);
        this.forEachNamedType("leading-and-interposing", (c, className) => this.emitClassDefinition(c, className), (e, enumName) => this.emitEnumDefinition(e, enumName), (u, unionName) => this.emitUnionDefinition(u, unionName));
        this.forEachTopLevel("leading-and-interposing", (_, topLevelName) => this.emitTopLevelFunctions(topLevelName));
        this.forEachNamedType("leading-and-interposing", (c, className) => this.emitClassFunctions(c, className), (e, enumName) => this.emitEnumFunctions(e, enumName), (u, unionName) => this.emitUnionFunctions(u, unionName));
        if (this._options.justTypes) return;
        this.ensureBlankLine();
      }
    };
    exports.HaskellRenderer = HaskellRenderer;
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Haskell/language.js
var require_language9 = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Haskell/language.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.HaskellTargetLanguage = exports.haskellLanguageConfig = exports.haskellOptions = void 0;
    var RendererOptions_1 = require_RendererOptions();
    var TargetLanguage_1 = require_TargetLanguage();
    var HaskellRenderer_1 = require_HaskellRenderer();
    exports.haskellOptions = {
      justTypes: new RendererOptions_1.BooleanOption("just-types", "Plain types only", false),
      useList: new RendererOptions_1.EnumOption("array-type", "Use Array or List", {
        array: false,
        list: true
      }, "array"),
      moduleName: new RendererOptions_1.StringOption("module", "Generated module name", "NAME", "QuickType")
    };
    exports.haskellLanguageConfig = {
      displayName: "Haskell",
      names: [
        "haskell"
      ],
      extension: "haskell"
    };
    var HaskellTargetLanguage = class extends TargetLanguage_1.TargetLanguage {
      constructor() {
        super(exports.haskellLanguageConfig);
      }
      getOptions() {
        return exports.haskellOptions;
      }
      get supportsOptionalClassProperties() {
        return true;
      }
      get supportsUnionsWithBothNumberTypes() {
        return true;
      }
      makeRenderer(renderContext, untypedOptionValues) {
        return new HaskellRenderer_1.HaskellRenderer(this, renderContext, (0, RendererOptions_1.getOptionValues)(exports.haskellOptions, untypedOptionValues));
      }
    };
    exports.HaskellTargetLanguage = HaskellTargetLanguage;
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Haskell/index.js
var require_Haskell = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Haskell/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.HaskellRenderer = exports.haskellOptions = exports.HaskellTargetLanguage = void 0;
    var language_1 = require_language9();
    Object.defineProperty(exports, "HaskellTargetLanguage", {
      enumerable: true,
      get: function() {
        return language_1.HaskellTargetLanguage;
      }
    });
    Object.defineProperty(exports, "haskellOptions", {
      enumerable: true,
      get: function() {
        return language_1.haskellOptions;
      }
    });
    var HaskellRenderer_1 = require_HaskellRenderer();
    Object.defineProperty(exports, "HaskellRenderer", {
      enumerable: true,
      get: function() {
        return HaskellRenderer_1.HaskellRenderer;
      }
    });
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/support/Acronyms.js
var require_Acronyms = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/support/Acronyms.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.acronymOption = exports.AcronymStyleOptions = void 0;
    exports.acronymStyle = acronymStyle;
    var RendererOptions_1 = require_RendererOptions();
    var Strings_1 = require_Strings();
    var AcronymStyleOptions;
    (function(AcronymStyleOptions2) {
      AcronymStyleOptions2["Camel"] = "camel";
      AcronymStyleOptions2["Lower"] = "lowerCase";
      AcronymStyleOptions2["Original"] = "original";
      AcronymStyleOptions2["Pascal"] = "pascal";
    })(AcronymStyleOptions || (exports.AcronymStyleOptions = AcronymStyleOptions = {}));
    var acronymOption = (defaultOption) => new RendererOptions_1.EnumOption("acronym-style", "Acronym naming style", {
      [AcronymStyleOptions.Original]: AcronymStyleOptions.Original,
      [AcronymStyleOptions.Pascal]: AcronymStyleOptions.Pascal,
      [AcronymStyleOptions.Camel]: AcronymStyleOptions.Camel,
      [AcronymStyleOptions.Lower]: AcronymStyleOptions.Lower
    }, defaultOption, "secondary");
    exports.acronymOption = acronymOption;
    var options = {
      [AcronymStyleOptions.Pascal]: Strings_1.allUpperWordStyle,
      [AcronymStyleOptions.Camel]: Strings_1.firstUpperWordStyle,
      [AcronymStyleOptions.Original]: Strings_1.originalWord,
      [AcronymStyleOptions.Lower]: Strings_1.allLowerWordStyle
    };
    function acronymStyle(style) {
      return options[style];
    }
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Java/constants.js
var require_constants10 = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Java/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.javaKeywords = void 0;
    exports.javaKeywords = [
      "_",
      "Object",
      "Class",
      "System",
      "Long",
      "Double",
      "Boolean",
      "String",
      "List",
      "Map",
      "UUID",
      "Exception",
      "IOException",
      "Override",
      "abstract",
      "continue",
      "for",
      "new",
      "switch",
      "assert",
      "default",
      "goto",
      "package",
      "synchronized",
      "boolean",
      "do",
      "if",
      "private",
      "this",
      "break",
      "double",
      "implements",
      "protected",
      "throw",
      "byte",
      "else",
      "import",
      "public",
      "throws",
      "case",
      "enum",
      "instanceof",
      "return",
      "transient",
      "catch",
      "extends",
      "int",
      "short",
      "try",
      "char",
      "final",
      "interface",
      "static",
      "void",
      "class",
      "finally",
      "long",
      "strictfp",
      "volatile",
      "const",
      "float",
      "native",
      "super",
      "while",
      "null",
      "false",
      "true"
    ];
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Java/DateTimeProvider.js
var require_DateTimeProvider = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Java/DateTimeProvider.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.JavaLegacyDateTimeProvider = exports.Java8DateTimeProvider = exports.JavaDateTimeProvider = void 0;
    var JavaDateTimeProvider = class {
      constructor(_renderer, _className) {
        this._renderer = _renderer;
        this._className = _className;
        this.shouldEmitDateTimeConverter = true;
        this.shouldEmitTimeConverter = true;
        this.shouldEmitDateConverter = true;
      }
    };
    exports.JavaDateTimeProvider = JavaDateTimeProvider;
    var Java8DateTimeProvider = class extends JavaDateTimeProvider {
      constructor() {
        super(...arguments);
        this.keywords = [
          "LocalDate",
          "OffsetDateTime",
          "OffsetTime",
          "ZoneOffset",
          "ZonedDateTime",
          "DateTimeFormatter",
          "DateTimeFormatterBuilder",
          "ChronoField"
        ];
        this.dateTimeImports = [
          "java.time.OffsetDateTime"
        ];
        this.dateImports = [
          "java.time.LocalDate"
        ];
        this.timeImports = [
          "java.time.OffsetTime"
        ];
        this.converterImports = [
          "java.time.LocalDate",
          "java.time.OffsetDateTime",
          "java.time.OffsetTime",
          "java.time.ZoneOffset",
          "java.time.ZonedDateTime",
          "java.time.format.DateTimeFormatter",
          "java.time.format.DateTimeFormatterBuilder",
          "java.time.temporal.ChronoField"
        ];
        this.dateTimeType = "OffsetDateTime";
        this.dateType = "LocalDate";
        this.timeType = "OffsetTime";
        this.dateTimeJacksonAnnotations = [];
        this.dateJacksonAnnotations = [];
        this.timeJacksonAnnotations = [];
      }
      emitDateTimeConverters() {
        this._renderer.ensureBlankLine();
        this._renderer.emitLine("private static final DateTimeFormatter DATE_TIME_FORMATTER = new DateTimeFormatterBuilder()");
        this._renderer.indent(() => this._renderer.indent(() => {
          this._renderer.emitLine(".appendOptional(DateTimeFormatter.ISO_DATE_TIME)");
          this._renderer.emitLine(".appendOptional(DateTimeFormatter.ISO_OFFSET_DATE_TIME)");
          this._renderer.emitLine(".appendOptional(DateTimeFormatter.ISO_INSTANT)");
          this._renderer.emitLine('.appendOptional(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss.SX"))');
          this._renderer.emitLine('.appendOptional(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ssX"))');
          this._renderer.emitLine('.appendOptional(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss"))');
          this._renderer.emitLine(".toFormatter()");
          this._renderer.emitLine(".withZone(ZoneOffset.UTC);");
        }));
        this._renderer.ensureBlankLine();
        this._renderer.emitBlock("public static OffsetDateTime parseDateTimeString(String str)", () => {
          this._renderer.emitLine("return ZonedDateTime.from(Converter.DATE_TIME_FORMATTER.parse(str)).toOffsetDateTime();");
        });
        this._renderer.ensureBlankLine();
        this._renderer.emitLine("private static final DateTimeFormatter TIME_FORMATTER = new DateTimeFormatterBuilder()");
        this._renderer.indent(() => this._renderer.indent(() => {
          this._renderer.emitLine(".appendOptional(DateTimeFormatter.ISO_TIME)");
          this._renderer.emitLine(".appendOptional(DateTimeFormatter.ISO_OFFSET_TIME)");
          this._renderer.emitLine(".parseDefaulting(ChronoField.YEAR, 2020)");
          this._renderer.emitLine(".parseDefaulting(ChronoField.MONTH_OF_YEAR, 1)");
          this._renderer.emitLine(".parseDefaulting(ChronoField.DAY_OF_MONTH, 1)");
          this._renderer.emitLine(".toFormatter()");
          this._renderer.emitLine(".withZone(ZoneOffset.UTC);");
        }));
        this._renderer.ensureBlankLine();
        this._renderer.emitBlock("public static OffsetTime parseTimeString(String str)", () => {
          this._renderer.emitLine("return ZonedDateTime.from(Converter.TIME_FORMATTER.parse(str)).toOffsetDateTime().toOffsetTime();");
        });
      }
      convertStringToDateTime(variable) {
        return [
          this._className,
          ".parseDateTimeString(",
          variable,
          ")"
        ];
      }
      convertStringToTime(variable) {
        return [
          this._className,
          ".parseTimeString(",
          variable,
          ")"
        ];
      }
      convertStringToDate(variable) {
        return [
          "LocalDate.parse(",
          variable,
          ")"
        ];
      }
      convertDateTimeToString(variable) {
        return [
          variable,
          ".format(java.time.format.DateTimeFormatter.ISO_OFFSET_DATE_TIME)"
        ];
      }
      convertTimeToString(variable) {
        return [
          variable,
          ".format(java.time.format.DateTimeFormatter.ISO_OFFSET_TIME)"
        ];
      }
      convertDateToString(variable) {
        return [
          variable,
          ".format(java.time.format.DateTimeFormatter.ISO_DATE)"
        ];
      }
    };
    exports.Java8DateTimeProvider = Java8DateTimeProvider;
    var JavaLegacyDateTimeProvider = class extends JavaDateTimeProvider {
      constructor() {
        super(...arguments);
        this.keywords = [
          "SimpleDateFormat",
          "Date"
        ];
        this.dateTimeImports = [
          "java.util.Date"
        ];
        this.dateImports = [
          "java.util.Date"
        ];
        this.timeImports = [
          "java.util.Date"
        ];
        this.converterImports = [
          "java.util.Date",
          "java.text.SimpleDateFormat"
        ];
        this.dateTimeType = "Date";
        this.dateType = "Date";
        this.timeType = "Date";
        this.dateTimeJacksonAnnotations = [
          `@JsonFormat(pattern = "yyyy-MM-dd'T'HH:mm:ssX", timezone = "UTC")`
        ];
        this.dateJacksonAnnotations = [
          '@JsonFormat(pattern = "yyyy-MM-dd")'
        ];
        this.timeJacksonAnnotations = [
          '@JsonFormat(pattern = "HH:mm:ssX", timezone = "UTC")'
        ];
        this.shouldEmitTimeConverter = false;
        this.shouldEmitDateConverter = false;
      }
      emitDateTimeConverters() {
        this._renderer.ensureBlankLine();
        this._renderer.emitLine("private static final String[] DATE_TIME_FORMATS = {");
        this._renderer.indent(() => this._renderer.indent(() => {
          this._renderer.emitLine(`"yyyy-MM-dd'T'HH:mm:ss.SX",`);
          this._renderer.emitLine(`"yyyy-MM-dd'T'HH:mm:ss.S",`);
          this._renderer.emitLine(`"yyyy-MM-dd'T'HH:mm:ssX",`);
          this._renderer.emitLine(`"yyyy-MM-dd'T'HH:mm:ss",`);
          this._renderer.emitLine('"yyyy-MM-dd HH:mm:ss.SX",');
          this._renderer.emitLine('"yyyy-MM-dd HH:mm:ss.S",');
          this._renderer.emitLine('"yyyy-MM-dd HH:mm:ssX",');
          this._renderer.emitLine('"yyyy-MM-dd HH:mm:ss",');
          this._renderer.emitLine('"HH:mm:ss.SZ",');
          this._renderer.emitLine('"HH:mm:ss.S",');
          this._renderer.emitLine('"HH:mm:ssZ",');
          this._renderer.emitLine('"HH:mm:ss",');
          this._renderer.emitLine('"yyyy-MM-dd",');
        }));
        this._renderer.emitLine("};");
        this._renderer.ensureBlankLine();
        this._renderer.emitBlock("public static Date parseAllDateTimeString(String str)", () => {
          this._renderer.emitBlock("for (String format : DATE_TIME_FORMATS)", () => {
            this._renderer.emitIgnoredTryCatchBlock(() => {
              this._renderer.emitLine("return new SimpleDateFormat(format).parse(str);");
            });
          });
          this._renderer.emitLine("return null;");
        });
        this._renderer.ensureBlankLine();
        this._renderer.emitBlock("public static String serializeDateTime(Date datetime)", () => {
          this._renderer.emitLine(`return new SimpleDateFormat("yyyy-MM-dd'T'hh:mm:ssZ").format(datetime);`);
        });
        this._renderer.ensureBlankLine();
        this._renderer.emitBlock("public static String serializeDate(Date datetime)", () => {
          this._renderer.emitLine('return new SimpleDateFormat("yyyy-MM-dd").format(datetime);');
        });
        this._renderer.ensureBlankLine();
        this._renderer.emitBlock("public static String serializeTime(Date datetime)", () => {
          this._renderer.emitLine('return new SimpleDateFormat("hh:mm:ssZ").format(datetime);');
        });
      }
      convertStringToDateTime(variable) {
        return [
          this._className,
          ".parseAllDateTimeString(",
          variable,
          ")"
        ];
      }
      convertStringToTime(variable) {
        return [
          this._className,
          ".parseAllDateTimeString(",
          variable,
          ")"
        ];
      }
      convertStringToDate(variable) {
        return [
          this._className,
          ".parseAllDateTimeString(",
          variable,
          ")"
        ];
      }
      convertDateTimeToString(variable) {
        return [
          this._className,
          ".serializeDateTime(",
          variable,
          ")"
        ];
      }
      convertTimeToString(variable) {
        return [
          this._className,
          ".serializeTime(",
          variable,
          ")"
        ];
      }
      convertDateToString(variable) {
        return [
          this._className,
          ".serializeDate(",
          variable,
          ")"
        ];
      }
    };
    exports.JavaLegacyDateTimeProvider = JavaLegacyDateTimeProvider;
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Java/utils.js
var require_utils10 = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Java/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.stringEscape = void 0;
    exports.javaNameStyle = javaNameStyle;
    var Strings_1 = require_Strings();
    exports.stringEscape = (0, Strings_1.utf16ConcatMap)((0, Strings_1.escapeNonPrintableMapper)(Strings_1.isAscii, Strings_1.standardUnicodeHexEscape));
    function isStartCharacter(codePoint) {
      if (codePoint === 95) return true;
      return (0, Strings_1.isAscii)(codePoint) && (0, Strings_1.isLetter)(codePoint);
    }
    function isPartCharacter(codePoint) {
      return isStartCharacter(codePoint) || (0, Strings_1.isAscii)(codePoint) && (0, Strings_1.isDigit)(codePoint);
    }
    var legalizeName = (0, Strings_1.utf16LegalizeCharacters)(isPartCharacter);
    function javaNameStyle(startWithUpper, upperUnderscore, original, acronymsStyle = Strings_1.allUpperWordStyle) {
      const words = (0, Strings_1.splitIntoWords)(original);
      return (0, Strings_1.combineWords)(words, legalizeName, upperUnderscore ? Strings_1.allUpperWordStyle : startWithUpper ? Strings_1.firstUpperWordStyle : Strings_1.allLowerWordStyle, upperUnderscore ? Strings_1.allUpperWordStyle : Strings_1.firstUpperWordStyle, upperUnderscore || startWithUpper ? Strings_1.allUpperWordStyle : Strings_1.allLowerWordStyle, acronymsStyle, upperUnderscore ? "_" : "", isStartCharacter);
    }
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Java/JavaRenderer.js
var require_JavaRenderer = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Java/JavaRenderer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.JavaRenderer = void 0;
    var Annotation_1 = require_Annotation();
    var ConvenienceRenderer_1 = require_ConvenienceRenderer();
    var Naming_1 = require_Naming();
    var Source_1 = require_Source();
    var Acronyms_1 = require_Acronyms();
    var Strings_1 = require_Strings();
    var Support_1 = require_Support();
    var Type_1 = require_Type2();
    var TypeUtils_1 = require_TypeUtils();
    var constants_1 = require_constants10();
    var DateTimeProvider_1 = require_DateTimeProvider();
    var utils_1 = require_utils10();
    var JavaRenderer = class extends ConvenienceRenderer_1.ConvenienceRenderer {
      constructor(targetLanguage, renderContext, _options) {
        super(targetLanguage, renderContext);
        this._options = _options;
        this._gettersAndSettersForPropertyName = /* @__PURE__ */ new Map();
        this._haveEmittedLeadingComments = false;
        this._converterClassname = "Converter";
        this._converterKeywords = [];
        switch (_options.dateTimeProvider) {
          case "legacy":
            this._dateTimeProvider = new DateTimeProvider_1.JavaLegacyDateTimeProvider(this, this._converterClassname);
            break;
          case "java8":
          default:
            this._dateTimeProvider = new DateTimeProvider_1.Java8DateTimeProvider(this, this._converterClassname);
            break;
        }
      }
      forbiddenNamesForGlobalNamespace() {
        const keywords = [
          ...constants_1.javaKeywords,
          ...this._converterKeywords,
          this._converterClassname,
          ...this._dateTimeProvider.keywords
        ];
        return keywords;
      }
      forbiddenForObjectProperties(_c, _className) {
        return {
          names: [],
          includeGlobalForbidden: true
        };
      }
      makeNamedTypeNamer() {
        return this.getNameStyling("typeNamingFunction");
      }
      namerForObjectProperty() {
        return this.getNameStyling("propertyNamingFunction");
      }
      makeUnionMemberNamer() {
        return this.getNameStyling("propertyNamingFunction");
      }
      makeEnumCaseNamer() {
        return this.getNameStyling("enumCaseNamingFunction");
      }
      unionNeedsName(u) {
        return (0, TypeUtils_1.nullableFromUnion)(u) === null;
      }
      namedTypeToNameForTopLevel(type) {
        return (0, TypeUtils_1.directlyReachableSingleNamedType)(type);
      }
      makeNamesForPropertyGetterAndSetter(_c, _className, _p, _jsonName, name) {
        const getterName = new Naming_1.DependencyName(this.getNameStyling("propertyNamingFunction"), name.order, (lookup) => `get_${lookup(name)}`);
        const setterName = new Naming_1.DependencyName(this.getNameStyling("propertyNamingFunction"), name.order, (lookup) => `set_${lookup(name)}`);
        return [
          getterName,
          setterName
        ];
      }
      makePropertyDependencyNames(c, className, p, jsonName, name) {
        const getterAndSetterNames = this.makeNamesForPropertyGetterAndSetter(c, className, p, jsonName, name);
        this._gettersAndSettersForPropertyName.set(name, getterAndSetterNames);
        return getterAndSetterNames;
      }
      getNameStyling(convention) {
        const styling = {
          typeNamingFunction: (0, Naming_1.funPrefixNamer)("types", (n) => (0, utils_1.javaNameStyle)(true, false, n, (0, Acronyms_1.acronymStyle)(this._options.acronymStyle))),
          propertyNamingFunction: (0, Naming_1.funPrefixNamer)("properties", (n) => (0, utils_1.javaNameStyle)(false, false, n, (0, Acronyms_1.acronymStyle)(this._options.acronymStyle))),
          enumCaseNamingFunction: (0, Naming_1.funPrefixNamer)("enum-cases", (n) => (0, utils_1.javaNameStyle)(true, true, n, (0, Acronyms_1.acronymStyle)(this._options.acronymStyle)))
        };
        return styling[convention];
      }
      fieldOrMethodName(methodName, topLevelName) {
        if (this.topLevels.size === 1) {
          return methodName;
        }
        return [
          topLevelName,
          (0, Strings_1.capitalize)(methodName)
        ];
      }
      methodName(prefix, suffix, topLevelName) {
        if (this.topLevels.size === 1) {
          return [
            prefix,
            suffix
          ];
        }
        return [
          prefix,
          topLevelName,
          suffix
        ];
      }
      decoderName(topLevelName) {
        return this.fieldOrMethodName("fromJsonString", topLevelName);
      }
      encoderName(topLevelName) {
        return this.fieldOrMethodName("toJsonString", topLevelName);
      }
      readerGetterName(topLevelName) {
        return this.methodName("get", "ObjectReader", topLevelName);
      }
      writerGetterName(topLevelName) {
        return this.methodName("get", "ObjectWriter", topLevelName);
      }
      startFile(basename) {
        (0, Support_1.assert)(this._currentFilename === void 0, "Previous file wasn't finished");
        this._currentFilename = `${this.sourcelikeToString(basename)}.java`;
        this.ensureBlankLine();
        if (!this._haveEmittedLeadingComments && this.leadingComments !== void 0) {
          this.emitComments(this.leadingComments);
          this.ensureBlankLine();
          this._haveEmittedLeadingComments = true;
        }
      }
      finishFile() {
        super.finishFile((0, Support_1.defined)(this._currentFilename));
        this._currentFilename = void 0;
      }
      emitPackageAndImports(imports) {
        this.emitLine("package ", this._options.packageName, ";");
        this.ensureBlankLine();
        for (const pkg of imports) {
          this.emitLine("import ", pkg, ";");
        }
      }
      emitFileHeader(fileName, imports) {
        this.startFile(fileName);
        this.emitPackageAndImports(imports);
        this.ensureBlankLine();
      }
      emitDescriptionBlock(lines) {
        this.emitCommentLines(lines, {
          lineStart: " * ",
          beforeComment: "/**",
          afterComment: " */"
        });
      }
      emitBlock(line, f) {
        this.emitLine(line, " {");
        this.indent(f);
        this.emitLine("}");
      }
      emitTryCatch(main, handler, exception = "Exception") {
        this.emitLine("try {");
        this.indent(main);
        this.emitLine("} catch (", exception, " ex) {");
        this.indent(handler);
        this.emitLine("}");
      }
      emitIgnoredTryCatchBlock(f) {
        this.emitTryCatch(f, () => this.emitLine("// Ignored"));
      }
      javaType(reference, t, withIssues = false) {
        return (0, TypeUtils_1.matchType)(t, (_anyType) => (0, Source_1.maybeAnnotated)(withIssues, Annotation_1.anyTypeIssueAnnotation, "Object"), (_nullType) => (0, Source_1.maybeAnnotated)(withIssues, Annotation_1.nullTypeIssueAnnotation, "Object"), (_boolType) => reference ? "Boolean" : "boolean", (_integerType) => reference ? "Long" : "long", (_doubleType) => reference ? "Double" : "double", (_stringType) => "String", (arrayType) => {
          if (this._options.useList) {
            return [
              "List<",
              this.javaType(true, arrayType.items, withIssues),
              ">"
            ];
          }
          return [
            this.javaType(false, arrayType.items, withIssues),
            "[]"
          ];
        }, (classType) => this.nameForNamedType(classType), (mapType) => [
          "Map<String, ",
          this.javaType(true, mapType.values, withIssues),
          ">"
        ], (enumType) => this.nameForNamedType(enumType), (unionType) => {
          const nullable = (0, TypeUtils_1.nullableFromUnion)(unionType);
          if (nullable !== null) return this.javaType(true, nullable, withIssues);
          return this.nameForNamedType(unionType);
        }, (transformedStringType) => {
          if (transformedStringType.kind === "time") {
            return this._dateTimeProvider.timeType;
          }
          if (transformedStringType.kind === "date") {
            return this._dateTimeProvider.dateType;
          }
          if (transformedStringType.kind === "date-time") {
            return this._dateTimeProvider.dateTimeType;
          }
          if (transformedStringType.kind === "uuid") {
            return "UUID";
          }
          return "String";
        });
      }
      javaImport(t) {
        return (0, TypeUtils_1.matchType)(t, (_anyType) => [], (_nullType) => [], (_boolType) => [], (_integerType) => [], (_doubleType) => [], (_stringType) => [], (arrayType) => {
          if (this._options.useList) {
            return [
              ...this.javaImport(arrayType.items),
              "java.util.List"
            ];
          }
          return [
            ...this.javaImport(arrayType.items)
          ];
        }, (_classType) => [], (mapType) => [
          ...this.javaImport(mapType.values),
          "java.util.Map"
        ], (_enumType) => [], (unionType) => {
          const imports = [];
          unionType.members.forEach((type) => this.javaImport(type).forEach((imp) => imports.push(imp)));
          return imports;
        }, (transformedStringType) => {
          if (transformedStringType.kind === "time") {
            return this._dateTimeProvider.timeImports;
          }
          if (transformedStringType.kind === "date") {
            return this._dateTimeProvider.dateImports;
          }
          if (transformedStringType.kind === "date-time") {
            return this._dateTimeProvider.dateTimeImports;
          }
          if (transformedStringType.kind === "uuid") {
            return [
              "java.util.UUID"
            ];
          }
          return [];
        });
      }
      javaTypeWithoutGenerics(reference, t) {
        if (t instanceof Type_1.ArrayType) {
          if (this._options.useList) {
            return [
              "List"
            ];
          }
          return [
            this.javaTypeWithoutGenerics(false, t.items),
            "[]"
          ];
        }
        if (t instanceof Type_1.MapType) {
          return "Map";
        }
        if (t instanceof Type_1.UnionType) {
          const nullable = (0, TypeUtils_1.nullableFromUnion)(t);
          if (nullable !== null) return this.javaTypeWithoutGenerics(true, nullable);
          return this.nameForNamedType(t);
        }
        return this.javaType(reference, t);
      }
      emitClassAttributes(_c, _className) {
        if (this._options.lombok) {
          this.emitLine("@lombok.Data");
        }
      }
      annotationsForAccessor(_c, _className, _propertyName, _jsonName, _p, _isSetter) {
        return [];
      }
      importsForType(t) {
        if (t instanceof Type_1.ClassType) {
          return [];
        }
        if (t instanceof Type_1.UnionType) {
          return [
            "java.io.IOException"
          ];
        }
        if (t instanceof Type_1.EnumType) {
          return [
            "java.io.IOException"
          ];
        }
        return (0, Support_1.assertNever)(t);
      }
      importsForClass(c) {
        const imports = [];
        this.forEachClassProperty(c, "none", (_name, _jsonName, p) => {
          this.javaImport(p.type).forEach((imp) => imports.push(imp));
        });
        imports.sort();
        return [
          ...new Set(imports)
        ];
      }
      importsForUnionMembers(u) {
        const imports = [];
        const [, nonNulls] = (0, TypeUtils_1.removeNullFromUnion)(u);
        this.forEachUnionMember(u, nonNulls, "none", null, (_fieldName, t) => {
          this.javaImport(t).forEach((imp) => imports.push(imp));
        });
        imports.sort();
        return [
          ...new Set(imports)
        ];
      }
      emitClassDefinition(c, className) {
        const imports = [
          ...this.importsForType(c),
          ...this.importsForClass(c)
        ];
        this.emitFileHeader(className, imports);
        this.emitDescription(this.descriptionForType(c));
        this.emitClassAttributes(c, className);
        this.emitBlock([
          "public class ",
          className
        ], () => {
          this.forEachClassProperty(c, "none", (name, jsonName, p) => {
            if (this._options.lombok && this._options.lombokCopyAnnotations) {
              const getter = this.annotationsForAccessor(c, className, name, jsonName, p, false);
              const setter = this.annotationsForAccessor(c, className, name, jsonName, p, true);
              if (getter.length !== 0) {
                this.emitLine(`@lombok.Getter(onMethod_ = {${getter.join(", ")}})`);
              }
              if (setter.length !== 0) {
                this.emitLine(`@lombok.Setter(onMethod_ = {${setter.join(", ")}})`);
              }
            }
            this.emitLine("private ", this.javaType(false, p.type, true), " ", name, ";");
          });
          if (!this._options.lombok) {
            this.forEachClassProperty(c, "leading-and-interposing", (name, jsonName, p) => {
              this.emitDescription(this.descriptionForClassProperty(c, jsonName));
              const [getterName, setterName] = (0, Support_1.defined)(this._gettersAndSettersForPropertyName.get(name));
              const rendered = this.javaType(false, p.type);
              this.annotationsForAccessor(c, className, name, jsonName, p, false).forEach((annotation) => this.emitLine(annotation));
              this.emitLine("public ", rendered, " ", getterName, "() { return ", name, "; }");
              this.annotationsForAccessor(c, className, name, jsonName, p, true).forEach((annotation) => this.emitLine(annotation));
              this.emitLine("public void ", setterName, "(", rendered, " value) { this.", name, " = value; }");
            });
          }
        });
        this.finishFile();
      }
      unionField(u, t, withIssues = false) {
        const fieldType = this.javaType(true, t, withIssues);
        const fieldName = [
          this.nameForUnionMember(u, t),
          "Value"
        ];
        return {
          fieldType,
          fieldName
        };
      }
      emitUnionAttributes(_u, _unionName) {
      }
      emitUnionSerializer(_u, _unionName) {
      }
      emitUnionDefinition(u, unionName) {
        const imports = [
          ...this.importsForType(u),
          ...this.importsForUnionMembers(u)
        ];
        this.emitFileHeader(unionName, imports);
        this.emitDescription(this.descriptionForType(u));
        const [, nonNulls] = (0, TypeUtils_1.removeNullFromUnion)(u);
        this.emitUnionAttributes(u, unionName);
        this.emitBlock([
          "public class ",
          unionName
        ], () => {
          for (const t of nonNulls) {
            const { fieldType, fieldName } = this.unionField(u, t, true);
            this.emitLine("public ", fieldType, " ", fieldName, ";");
          }
          this.emitUnionSerializer(u, unionName);
        });
        this.finishFile();
      }
      emitEnumSerializationAttributes(_e) {
      }
      emitEnumDeserializationAttributes(_e) {
      }
      emitEnumDefinition(e, enumName) {
        this.emitFileHeader(enumName, this.importsForType(e));
        this.emitDescription(this.descriptionForType(e));
        const caseNames = [];
        this.forEachEnumCase(e, "none", (name) => {
          if (caseNames.length > 0) caseNames.push(", ");
          caseNames.push(name);
        });
        caseNames.push(";");
        this.emitBlock([
          "public enum ",
          enumName
        ], () => {
          this.emitLine(caseNames);
          this.ensureBlankLine();
          this.emitEnumSerializationAttributes(e);
          this.emitBlock("public String toValue()", () => {
            this.emitLine("switch (this) {");
            this.indent(() => {
              this.forEachEnumCase(e, "none", (name, jsonName) => {
                this.emitLine("case ", name, ': return "', (0, utils_1.stringEscape)(jsonName), '";');
              });
            });
            this.emitLine("}");
            this.emitLine("return null;");
          });
          this.ensureBlankLine();
          this.emitEnumDeserializationAttributes(e);
          this.emitBlock([
            "public static ",
            enumName,
            " forValue(String value) throws IOException"
          ], () => {
            this.forEachEnumCase(e, "none", (name, jsonName) => {
              this.emitLine('if (value.equals("', (0, utils_1.stringEscape)(jsonName), '")) return ', name, ";");
            });
            this.emitLine('throw new IOException("Cannot deserialize ', enumName, '");');
          });
        });
        this.finishFile();
      }
      emitSourceStructure() {
        this.forEachNamedType("leading-and-interposing", (c, n) => this.emitClassDefinition(c, n), (e, n) => this.emitEnumDefinition(e, n), (u, n) => this.emitUnionDefinition(u, n));
      }
    };
    exports.JavaRenderer = JavaRenderer;
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Java/JavaJacksonRenderer.js
var require_JavaJacksonRenderer = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Java/JavaJacksonRenderer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.JacksonRenderer = void 0;
    var Support_1 = require_Support();
    var Type_1 = require_Type2();
    var TypeUtils_1 = require_TypeUtils();
    var JavaRenderer_1 = require_JavaRenderer();
    var utils_1 = require_utils10();
    var JacksonRenderer = class extends JavaRenderer_1.JavaRenderer {
      constructor(targetLanguage, renderContext, options) {
        super(targetLanguage, renderContext, options);
        this._converterKeywords = [
          "JsonProperty",
          "JsonDeserialize",
          "JsonDeserializer",
          "JsonSerialize",
          "JsonSerializer",
          "JsonParser",
          "JsonProcessingException",
          "DeserializationContext",
          "SerializerProvider"
        ];
      }
      emitClassAttributes(c, _className) {
        if (c.getProperties().size === 0) this.emitLine("@JsonAutoDetect(fieldVisibility=JsonAutoDetect.Visibility.NONE)");
        super.emitClassAttributes(c, _className);
      }
      annotationsForAccessor(_c, _className, _propertyName, jsonName, p, _isSetter) {
        const superAnnotations = super.annotationsForAccessor(_c, _className, _propertyName, jsonName, p, _isSetter);
        const annotations = [
          `@JsonProperty("${(0, utils_1.stringEscape)(jsonName)}")`
        ];
        switch (p.type.kind) {
          case "date-time":
            this._dateTimeProvider.dateTimeJacksonAnnotations.forEach((annotation) => annotations.push(annotation));
            break;
          case "date":
            this._dateTimeProvider.dateJacksonAnnotations.forEach((annotation) => annotations.push(annotation));
            break;
          case "time":
            this._dateTimeProvider.timeJacksonAnnotations.forEach((annotation) => annotations.push(annotation));
            break;
          default:
            break;
        }
        return [
          ...superAnnotations,
          ...annotations
        ];
      }
      importsForType(t) {
        if (t instanceof Type_1.ClassType) {
          const imports = super.importsForType(t);
          imports.push("com.fasterxml.jackson.annotation.*");
          return imports;
        }
        if (t instanceof Type_1.UnionType) {
          const imports = super.importsForType(t);
          imports.push("java.io.IOException", "com.fasterxml.jackson.core.*", "com.fasterxml.jackson.databind.*", "com.fasterxml.jackson.databind.annotation.*");
          if (this._options.useList) {
            imports.push("com.fasterxml.jackson.core.type.*");
          }
          return imports;
        }
        if (t instanceof Type_1.EnumType) {
          const imports = super.importsForType(t);
          imports.push("com.fasterxml.jackson.annotation.*");
          return imports;
        }
        return (0, Support_1.assertNever)(t);
      }
      emitUnionAttributes(_u, unionName) {
        this.emitLine("@JsonDeserialize(using = ", unionName, ".Deserializer.class)");
        this.emitLine("@JsonSerialize(using = ", unionName, ".Serializer.class)");
      }
      emitUnionSerializer(u, unionName) {
        const stringBasedObjects = [
          "uuid",
          "time",
          "date",
          "date-time"
        ];
        const tokenCase = (tokenType) => {
          this.emitLine("case ", tokenType, ":");
        };
        const emitNullDeserializer = () => {
          this.indent(() => {
            tokenCase("VALUE_NULL");
            this.indent(() => this.emitLine("break;"));
          });
        };
        const emitDeserializerCodeForStringObjects = (fieldName, kind, parseFrom) => {
          switch (kind) {
            case "date":
              this.emitLine("value.", fieldName, " = ", this._dateTimeProvider.convertStringToDate(parseFrom), ";");
              break;
            case "time":
              this.emitLine("value.", fieldName, " = ", this._dateTimeProvider.convertStringToTime(parseFrom), ";");
              break;
            case "date-time":
              this.emitLine("value.", fieldName, " = ", this._dateTimeProvider.convertStringToDateTime(parseFrom), ";");
              break;
            case "uuid":
              this.emitLine("value.", fieldName, " = UUID.fromString(", parseFrom, ");");
              break;
            default:
              (0, Support_1.panic)("Requested type isnt an object!");
          }
        };
        const emitDeserializeType = (t, variableFieldName = "") => {
          const { fieldName } = this.unionField(u, t);
          const rendered = this.javaTypeWithoutGenerics(true, t);
          if (this._options.useList && t instanceof Type_1.ArrayType) {
            this.emitLine("value.", fieldName, " = jsonParser.readValueAs(new TypeReference<", rendered, ">() {});");
          } else if (stringBasedObjects.some((stringBasedTypeKind) => t.kind === stringBasedTypeKind)) {
            emitDeserializerCodeForStringObjects(fieldName, t.kind, variableFieldName);
          } else if (t.kind === "string") {
            this.emitLine("value.", fieldName, " = ", variableFieldName, ";");
          } else if (t.kind === "enum") {
            const { fieldType } = this.unionField(u, t, true);
            this.emitLine("value.", fieldName, " = ", fieldType, ".forValue(", variableFieldName, ");");
          } else {
            this.emitLine("value.", fieldName, " = jsonParser.readValueAs(", rendered, ".class);");
          }
        };
        const emitDeserializer = (tokenTypes, kind) => {
          const t = u.findMember(kind);
          if (t === void 0) return;
          this.indent(() => {
            for (const tokenType of tokenTypes) {
              tokenCase(tokenType);
            }
            this.indent(() => {
              emitDeserializeType(t);
              this.emitLine("break;");
            });
          });
        };
        const emitStringDeserializer = () => {
          const enumType = u.findMember("enum");
          const stringType = u.findMember("string");
          if (stringBasedObjects.every((kind) => u.findMember(kind) === void 0) && stringType === void 0 && enumType === void 0) return;
          this.indent(() => {
            tokenCase("VALUE_STRING");
            this.indent(() => {
              const fromVariable = "string";
              this.emitLine(`String ${fromVariable} = jsonParser.readValueAs(String.class);`);
              stringBasedObjects.forEach((kind) => {
                const type = u.findMember(kind);
                if (type !== void 0) {
                  this.emitIgnoredTryCatchBlock(() => {
                    emitDeserializeType(type, fromVariable);
                  });
                }
              });
              if (enumType !== void 0) {
                this.emitIgnoredTryCatchBlock(() => {
                  emitDeserializeType(enumType, fromVariable);
                });
              }
              if (stringType !== void 0) {
                emitDeserializeType(stringType, fromVariable);
              }
              this.emitLine("break;");
            });
          });
        };
        const emitNumberDeserializer = () => {
          const integerType = u.findMember("integer");
          const doubleType = u.findMember("double");
          if (doubleType === void 0 && integerType === void 0) return;
          this.indent(() => {
            tokenCase("VALUE_NUMBER_INT");
            if (integerType !== void 0) {
              this.indent(() => {
                emitDeserializeType(integerType);
                this.emitLine("break;");
              });
            }
            if (doubleType !== void 0) {
              tokenCase("VALUE_NUMBER_FLOAT");
              this.indent(() => {
                emitDeserializeType(doubleType);
                this.emitLine("break;");
              });
            }
          });
        };
        const customObjectSerializer = [
          "time",
          "date",
          "date-time"
        ];
        const serializerCodeForType = (type, fieldName) => {
          switch (type.kind) {
            case "date":
              return this._dateTimeProvider.convertDateToString(fieldName);
            case "time":
              return this._dateTimeProvider.convertTimeToString(fieldName);
            case "date-time":
              return this._dateTimeProvider.convertDateTimeToString(fieldName);
            default:
              return (0, Support_1.panic)("Requested type doesn't have custom serializer code!");
          }
        };
        const emitSerializeType = (t) => {
          const { fieldName } = this.unionField(u, t, true);
          this.emitBlock([
            "if (obj.",
            fieldName,
            " != null)"
          ], () => {
            if (customObjectSerializer.some((customSerializerType) => t.kind === customSerializerType)) {
              this.emitLine("jsonGenerator.writeObject(", serializerCodeForType(t, [
                "obj.",
                fieldName
              ]), ");");
            } else {
              this.emitLine("jsonGenerator.writeObject(obj.", fieldName, ");");
            }
            this.emitLine("return;");
          });
        };
        const [maybeNull, nonNulls] = (0, TypeUtils_1.removeNullFromUnion)(u);
        this.ensureBlankLine();
        this.emitBlock([
          "static class Deserializer extends JsonDeserializer<",
          unionName,
          ">"
        ], () => {
          this.emitLine("@Override");
          this.emitBlock([
            "public ",
            unionName,
            " deserialize(JsonParser jsonParser, DeserializationContext deserializationContext) throws IOException, JsonProcessingException"
          ], () => {
            this.emitLine(unionName, " value = new ", unionName, "();");
            this.emitLine("switch (jsonParser.currentToken()) {");
            if (maybeNull !== null) emitNullDeserializer();
            emitNumberDeserializer();
            emitDeserializer([
              "VALUE_TRUE",
              "VALUE_FALSE"
            ], "bool");
            emitStringDeserializer();
            emitDeserializer([
              "START_ARRAY"
            ], "array");
            emitDeserializer([
              "START_OBJECT"
            ], "class");
            emitDeserializer([
              "START_OBJECT"
            ], "map");
            this.indent(() => this.emitLine('default: throw new IOException("Cannot deserialize ', unionName, '");'));
            this.emitLine("}");
            this.emitLine("return value;");
          });
        });
        this.ensureBlankLine();
        this.emitBlock([
          "static class Serializer extends JsonSerializer<",
          unionName,
          ">"
        ], () => {
          this.emitLine("@Override");
          this.emitBlock([
            "public void serialize(",
            unionName,
            " obj, JsonGenerator jsonGenerator, SerializerProvider serializerProvider) throws IOException"
          ], () => {
            for (const t of nonNulls) {
              emitSerializeType(t);
            }
            if (maybeNull !== null) {
              this.emitLine("jsonGenerator.writeNull();");
            } else {
              this.emitLine('throw new IOException("', unionName, ' must not be null");');
            }
          });
        });
      }
      emitEnumSerializationAttributes(_e) {
        this.emitLine("@JsonValue");
      }
      emitEnumDeserializationAttributes(_e) {
        this.emitLine("@JsonCreator");
      }
      emitOffsetDateTimeConverterModule() {
        this.emitLine("SimpleModule module = new SimpleModule();");
        if (this._dateTimeProvider.shouldEmitDateTimeConverter) {
          this.emitLine("module.addDeserializer(", this._dateTimeProvider.dateTimeType, ".class, new JsonDeserializer<", this._dateTimeProvider.dateTimeType, ">() {");
          this.indent(() => {
            this.emitLine("@Override");
            this.emitBlock([
              "public ",
              this._dateTimeProvider.dateTimeType,
              " deserialize(JsonParser jsonParser, DeserializationContext deserializationContext) ",
              "throws IOException, JsonProcessingException"
            ], () => {
              this.emitLine("String value = jsonParser.getText();");
              this.emitLine("return ", this._dateTimeProvider.convertStringToDateTime("value"), ";");
            });
          });
          this.emitLine("});");
        }
        if (!this._dateTimeProvider.shouldEmitTimeConverter) {
          this.emitLine("module.addDeserializer(", this._dateTimeProvider.timeType, ".class, new JsonDeserializer<", this._dateTimeProvider.timeType, ">() {");
          this.indent(() => {
            this.emitLine("@Override");
            this.emitBlock([
              "public ",
              this._dateTimeProvider.timeType,
              " deserialize(JsonParser jsonParser, DeserializationContext deserializationContext) ",
              "throws IOException, JsonProcessingException"
            ], () => {
              this.emitLine("String value = jsonParser.getText();");
              this.emitLine("return ", this._dateTimeProvider.convertStringToTime("value"), ";");
            });
          });
          this.emitLine("});");
        }
        if (!this._dateTimeProvider.shouldEmitDateConverter) {
          this.emitLine("module.addDeserializer(", this._dateTimeProvider.dateType, ".class, new JsonDeserializer<", this._dateTimeProvider.dateType, ">() {");
          this.indent(() => {
            this.emitLine("@Override");
            this.emitBlock([
              "public ",
              this._dateTimeProvider.dateType,
              " deserialize(JsonParser jsonParser, DeserializationContext deserializationContext) ",
              "throws IOException, JsonProcessingException"
            ], () => {
              this.emitLine("String value = jsonParser.getText();");
              this.emitLine("return ", this._dateTimeProvider.convertStringToDate("value"), ";");
            });
          });
          this.emitLine("});");
        }
        this.emitLine("mapper.registerModule(module);");
      }
      emitConverterClass() {
        this.startFile(this._converterClassname);
        this.emitCommentLines([
          "To use this code, add the following Maven dependency to your project:",
          "",
          this._options.lombok ? "    org.projectlombok : lombok : 1.18.2" : "",
          "    com.fasterxml.jackson.core     : jackson-databind          : 2.9.0",
          this._options.dateTimeProvider === "java8" ? "    com.fasterxml.jackson.datatype : jackson-datatype-jsr310   : 2.9.0" : "",
          "",
          "Import this package:",
          ""
        ]);
        this.emitLine("//     import ", this._options.packageName, ".Converter;");
        this.emitMultiline(`//
// Then you can deserialize a JSON string with
//`);
        this.forEachTopLevel("none", (t, name) => {
          this.emitLine("//     ", this.javaType(false, t), " data = Converter.", this.decoderName(name), "(jsonString);");
        });
        this.ensureBlankLine();
        const imports = [
          "java.io.IOException",
          "com.fasterxml.jackson.databind.*",
          "com.fasterxml.jackson.databind.module.SimpleModule",
          "com.fasterxml.jackson.core.JsonParser",
          "com.fasterxml.jackson.core.JsonProcessingException",
          "java.util.*"
        ].concat(this._dateTimeProvider.converterImports);
        this.emitPackageAndImports(imports);
        this.ensureBlankLine();
        this.emitBlock([
          "public class Converter"
        ], () => {
          this.emitLine("// Date-time helpers");
          this._dateTimeProvider.emitDateTimeConverters();
          this.emitLine("// Serialize/deserialize helpers");
          this.forEachTopLevel("leading-and-interposing", (topLevelType, topLevelName) => {
            const topLevelTypeRendered = this.javaType(false, topLevelType);
            this.emitBlock([
              "public static ",
              topLevelTypeRendered,
              " ",
              this.decoderName(topLevelName),
              "(String json) throws IOException"
            ], () => {
              this.emitLine("return ", this.readerGetterName(topLevelName), "().readValue(json);");
            });
            this.ensureBlankLine();
            this.emitBlock([
              "public static String ",
              this.encoderName(topLevelName),
              "(",
              topLevelTypeRendered,
              " obj) throws JsonProcessingException"
            ], () => {
              this.emitLine("return ", this.writerGetterName(topLevelName), "().writeValueAsString(obj);");
            });
          });
          this.forEachTopLevel("leading-and-interposing", (topLevelType, topLevelName) => {
            const readerName = this.fieldOrMethodName("reader", topLevelName);
            const writerName = this.fieldOrMethodName("writer", topLevelName);
            this.emitLine("private static ObjectReader ", readerName, ";");
            this.emitLine("private static ObjectWriter ", writerName, ";");
            this.ensureBlankLine();
            this.emitBlock([
              "private static void ",
              this.methodName("instantiate", "Mapper", topLevelName),
              "()"
            ], () => {
              const renderedForClass = this.javaTypeWithoutGenerics(false, topLevelType);
              this.emitLine("ObjectMapper mapper = new ObjectMapper();");
              this.emitLine("mapper.findAndRegisterModules();");
              this.emitLine("mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);");
              this.emitLine("mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false);");
              this.emitOffsetDateTimeConverterModule();
              this.emitLine(readerName, " = mapper.readerFor(", renderedForClass, ".class);");
              this.emitLine(writerName, " = mapper.writerFor(", renderedForClass, ".class);");
            });
            this.ensureBlankLine();
            this.emitBlock([
              "private static ObjectReader ",
              this.readerGetterName(topLevelName),
              "()"
            ], () => {
              this.emitLine("if (", readerName, " == null) ", this.methodName("instantiate", "Mapper", topLevelName), "();");
              this.emitLine("return ", readerName, ";");
            });
            this.ensureBlankLine();
            this.emitBlock([
              "private static ObjectWriter ",
              this.writerGetterName(topLevelName),
              "()"
            ], () => {
              this.emitLine("if (", writerName, " == null) ", this.methodName("instantiate", "Mapper", topLevelName), "();");
              this.emitLine("return ", writerName, ";");
            });
          });
        });
        this.finishFile();
      }
      emitSourceStructure() {
        this.emitConverterClass();
        super.emitSourceStructure();
      }
    };
    exports.JacksonRenderer = JacksonRenderer;
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Java/language.js
var require_language10 = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Java/language.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.JavaTargetLanguage = exports.javaLanguageConfig = exports.javaOptions = void 0;
    var RendererOptions_1 = require_RendererOptions();
    var Acronyms_1 = require_Acronyms();
    var TargetLanguage_1 = require_TargetLanguage();
    var JavaJacksonRenderer_1 = require_JavaJacksonRenderer();
    var JavaRenderer_1 = require_JavaRenderer();
    exports.javaOptions = {
      useList: new RendererOptions_1.EnumOption("array-type", "Use T[] or List<T>", {
        array: false,
        list: true
      }, "array"),
      justTypes: new RendererOptions_1.BooleanOption("just-types", "Plain types only", false),
      dateTimeProvider: new RendererOptions_1.EnumOption("datetime-provider", "Date time provider type", {
        java8: "java8",
        legacy: "legacy"
      }, "java8"),
      acronymStyle: (0, Acronyms_1.acronymOption)(Acronyms_1.AcronymStyleOptions.Pascal),
      // FIXME: Do this via a configurable named eventually.
      packageName: new RendererOptions_1.StringOption("package", "Generated package name", "NAME", "io.quicktype"),
      lombok: new RendererOptions_1.BooleanOption("lombok", "Use lombok", false, "primary"),
      lombokCopyAnnotations: new RendererOptions_1.BooleanOption("lombok-copy-annotations", "Copy accessor annotations", true, "secondary")
    };
    exports.javaLanguageConfig = {
      displayName: "Java",
      names: [
        "java"
      ],
      extension: "java"
    };
    var JavaTargetLanguage = class extends TargetLanguage_1.TargetLanguage {
      constructor() {
        super(exports.javaLanguageConfig);
      }
      getOptions() {
        return exports.javaOptions;
      }
      get supportsUnionsWithBothNumberTypes() {
        return true;
      }
      makeRenderer(renderContext, untypedOptionValues) {
        const options = (0, RendererOptions_1.getOptionValues)(exports.javaOptions, untypedOptionValues);
        if (options.justTypes) {
          return new JavaRenderer_1.JavaRenderer(this, renderContext, options);
        }
        return new JavaJacksonRenderer_1.JacksonRenderer(this, renderContext, options);
      }
      get stringTypeMapping() {
        const mapping = /* @__PURE__ */ new Map();
        mapping.set("date", "date");
        mapping.set("time", "time");
        mapping.set("date-time", "date-time");
        mapping.set("uuid", "uuid");
        return mapping;
      }
    };
    exports.JavaTargetLanguage = JavaTargetLanguage;
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Java/index.js
var require_Java = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Java/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.JacksonRenderer = exports.JavaRenderer = exports.javaOptions = exports.JavaTargetLanguage = void 0;
    var language_1 = require_language10();
    Object.defineProperty(exports, "JavaTargetLanguage", {
      enumerable: true,
      get: function() {
        return language_1.JavaTargetLanguage;
      }
    });
    Object.defineProperty(exports, "javaOptions", {
      enumerable: true,
      get: function() {
        return language_1.javaOptions;
      }
    });
    var JavaRenderer_1 = require_JavaRenderer();
    Object.defineProperty(exports, "JavaRenderer", {
      enumerable: true,
      get: function() {
        return JavaRenderer_1.JavaRenderer;
      }
    });
    var JavaJacksonRenderer_1 = require_JavaJacksonRenderer();
    Object.defineProperty(exports, "JacksonRenderer", {
      enumerable: true,
      get: function() {
        return JavaJacksonRenderer_1.JacksonRenderer;
      }
    });
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/support/Converters.js
var require_Converters = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/support/Converters.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.ConvertersOptions = void 0;
    exports.convertersOption = convertersOption;
    var RendererOptions_1 = require_RendererOptions();
    var ConvertersOptions;
    (function(ConvertersOptions2) {
      ConvertersOptions2["AllObjects"] = "all-objects";
      ConvertersOptions2["TopLevel"] = "top-level";
    })(ConvertersOptions || (exports.ConvertersOptions = ConvertersOptions = {}));
    function convertersOption() {
      return new RendererOptions_1.EnumOption("converters", "Which converters to generate (top-level by default)", {
        [ConvertersOptions.TopLevel]: ConvertersOptions.TopLevel,
        [ConvertersOptions.AllObjects]: ConvertersOptions.AllObjects
      }, ConvertersOptions.TopLevel, "secondary");
    }
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/JavaScript/unicodeMaps.js
var require_unicodeMaps = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/JavaScript/unicodeMaps.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.isES3IdentifierStart = isES3IdentifierStart;
    exports.isES3IdentifierPart = isES3IdentifierPart;
    function lookupInUnicodeMap(code, map) {
      if (code < map[0]) {
        return false;
      }
      let lo = 0;
      let hi = map.length;
      let mid;
      while (lo + 1 < hi) {
        mid = lo + (hi - lo) / 2;
        mid -= mid % 2;
        if (map[mid] <= code && code <= map[mid + 1]) {
          return true;
        }
        if (code < map[mid]) {
          hi = mid;
        } else {
          lo = mid + 2;
        }
      }
      return false;
    }
    var CharacterCodes;
    (function(CharacterCodes2) {
      CharacterCodes2[CharacterCodes2["maxAsciiCharacter"] = 127] = "maxAsciiCharacter";
      CharacterCodes2[CharacterCodes2["_"] = 95] = "_";
      CharacterCodes2[CharacterCodes2["$"] = 36] = "$";
      CharacterCodes2[CharacterCodes2["_0"] = 48] = "_0";
      CharacterCodes2[CharacterCodes2["_9"] = 57] = "_9";
      CharacterCodes2[CharacterCodes2["a"] = 97] = "a";
      CharacterCodes2[CharacterCodes2["z"] = 122] = "z";
      CharacterCodes2[CharacterCodes2["A"] = 65] = "A";
      CharacterCodes2[CharacterCodes2["Z"] = 90] = "Z";
    })(CharacterCodes || (CharacterCodes = {}));
    function isES3IdentifierStart(ch) {
      return ch >= CharacterCodes.A && ch <= CharacterCodes.Z || ch >= CharacterCodes.a && ch <= CharacterCodes.z || ch === CharacterCodes.$ || ch === CharacterCodes._ || ch > CharacterCodes.maxAsciiCharacter && lookupInUnicodeMap(ch, unicodeES3IdentifierStart);
    }
    function isES3IdentifierPart(ch) {
      return ch >= CharacterCodes.A && ch <= CharacterCodes.Z || ch >= CharacterCodes.a && ch <= CharacterCodes.z || ch >= CharacterCodes._0 && ch <= CharacterCodes._9 || ch === CharacterCodes.$ || ch === CharacterCodes._ || ch > CharacterCodes.maxAsciiCharacter && lookupInUnicodeMap(ch, unicodeES3IdentifierPart);
    }
    var unicodeES3IdentifierStart = [
      170,
      170,
      181,
      181,
      186,
      186,
      192,
      214,
      216,
      246,
      248,
      543,
      546,
      563,
      592,
      685,
      688,
      696,
      699,
      705,
      720,
      721,
      736,
      740,
      750,
      750,
      890,
      890,
      902,
      902,
      904,
      906,
      908,
      908,
      910,
      929,
      931,
      974,
      976,
      983,
      986,
      1011,
      1024,
      1153,
      1164,
      1220,
      1223,
      1224,
      1227,
      1228,
      1232,
      1269,
      1272,
      1273,
      1329,
      1366,
      1369,
      1369,
      1377,
      1415,
      1488,
      1514,
      1520,
      1522,
      1569,
      1594,
      1600,
      1610,
      1649,
      1747,
      1749,
      1749,
      1765,
      1766,
      1786,
      1788,
      1808,
      1808,
      1810,
      1836,
      1920,
      1957,
      2309,
      2361,
      2365,
      2365,
      2384,
      2384,
      2392,
      2401,
      2437,
      2444,
      2447,
      2448,
      2451,
      2472,
      2474,
      2480,
      2482,
      2482,
      2486,
      2489,
      2524,
      2525,
      2527,
      2529,
      2544,
      2545,
      2565,
      2570,
      2575,
      2576,
      2579,
      2600,
      2602,
      2608,
      2610,
      2611,
      2613,
      2614,
      2616,
      2617,
      2649,
      2652,
      2654,
      2654,
      2674,
      2676,
      2693,
      2699,
      2701,
      2701,
      2703,
      2705,
      2707,
      2728,
      2730,
      2736,
      2738,
      2739,
      2741,
      2745,
      2749,
      2749,
      2768,
      2768,
      2784,
      2784,
      2821,
      2828,
      2831,
      2832,
      2835,
      2856,
      2858,
      2864,
      2866,
      2867,
      2870,
      2873,
      2877,
      2877,
      2908,
      2909,
      2911,
      2913,
      2949,
      2954,
      2958,
      2960,
      2962,
      2965,
      2969,
      2970,
      2972,
      2972,
      2974,
      2975,
      2979,
      2980,
      2984,
      2986,
      2990,
      2997,
      2999,
      3001,
      3077,
      3084,
      3086,
      3088,
      3090,
      3112,
      3114,
      3123,
      3125,
      3129,
      3168,
      3169,
      3205,
      3212,
      3214,
      3216,
      3218,
      3240,
      3242,
      3251,
      3253,
      3257,
      3294,
      3294,
      3296,
      3297,
      3333,
      3340,
      3342,
      3344,
      3346,
      3368,
      3370,
      3385,
      3424,
      3425,
      3461,
      3478,
      3482,
      3505,
      3507,
      3515,
      3517,
      3517,
      3520,
      3526,
      3585,
      3632,
      3634,
      3635,
      3648,
      3654,
      3713,
      3714,
      3716,
      3716,
      3719,
      3720,
      3722,
      3722,
      3725,
      3725,
      3732,
      3735,
      3737,
      3743,
      3745,
      3747,
      3749,
      3749,
      3751,
      3751,
      3754,
      3755,
      3757,
      3760,
      3762,
      3763,
      3773,
      3773,
      3776,
      3780,
      3782,
      3782,
      3804,
      3805,
      3840,
      3840,
      3904,
      3911,
      3913,
      3946,
      3976,
      3979,
      4096,
      4129,
      4131,
      4135,
      4137,
      4138,
      4176,
      4181,
      4256,
      4293,
      4304,
      4342,
      4352,
      4441,
      4447,
      4514,
      4520,
      4601,
      4608,
      4614,
      4616,
      4678,
      4680,
      4680,
      4682,
      4685,
      4688,
      4694,
      4696,
      4696,
      4698,
      4701,
      4704,
      4742,
      4744,
      4744,
      4746,
      4749,
      4752,
      4782,
      4784,
      4784,
      4786,
      4789,
      4792,
      4798,
      4800,
      4800,
      4802,
      4805,
      4808,
      4814,
      4816,
      4822,
      4824,
      4846,
      4848,
      4878,
      4880,
      4880,
      4882,
      4885,
      4888,
      4894,
      4896,
      4934,
      4936,
      4954,
      5024,
      5108,
      5121,
      5740,
      5743,
      5750,
      5761,
      5786,
      5792,
      5866,
      6016,
      6067,
      6176,
      6263,
      6272,
      6312,
      7680,
      7835,
      7840,
      7929,
      7936,
      7957,
      7960,
      7965,
      7968,
      8005,
      8008,
      8013,
      8016,
      8023,
      8025,
      8025,
      8027,
      8027,
      8029,
      8029,
      8031,
      8061,
      8064,
      8116,
      8118,
      8124,
      8126,
      8126,
      8130,
      8132,
      8134,
      8140,
      8144,
      8147,
      8150,
      8155,
      8160,
      8172,
      8178,
      8180,
      8182,
      8188,
      8319,
      8319,
      8450,
      8450,
      8455,
      8455,
      8458,
      8467,
      8469,
      8469,
      8473,
      8477,
      8484,
      8484,
      8486,
      8486,
      8488,
      8488,
      8490,
      8493,
      8495,
      8497,
      8499,
      8505,
      8544,
      8579,
      12293,
      12295,
      12321,
      12329,
      12337,
      12341,
      12344,
      12346,
      12353,
      12436,
      12445,
      12446,
      12449,
      12538,
      12540,
      12542,
      12549,
      12588,
      12593,
      12686,
      12704,
      12727,
      13312,
      19893,
      19968,
      40869,
      40960,
      42124,
      44032,
      55203,
      63744,
      64045,
      64256,
      64262,
      64275,
      64279,
      64285,
      64285,
      64287,
      64296,
      64298,
      64310,
      64312,
      64316,
      64318,
      64318,
      64320,
      64321,
      64323,
      64324,
      64326,
      64433,
      64467,
      64829,
      64848,
      64911,
      64914,
      64967,
      65008,
      65019,
      65136,
      65138,
      65140,
      65140,
      65142,
      65276,
      65313,
      65338,
      65345,
      65370,
      65382,
      65470,
      65474,
      65479,
      65482,
      65487,
      65490,
      65495,
      65498,
      65500
    ];
    var unicodeES3IdentifierPart = [
      170,
      170,
      181,
      181,
      186,
      186,
      192,
      214,
      216,
      246,
      248,
      543,
      546,
      563,
      592,
      685,
      688,
      696,
      699,
      705,
      720,
      721,
      736,
      740,
      750,
      750,
      768,
      846,
      864,
      866,
      890,
      890,
      902,
      902,
      904,
      906,
      908,
      908,
      910,
      929,
      931,
      974,
      976,
      983,
      986,
      1011,
      1024,
      1153,
      1155,
      1158,
      1164,
      1220,
      1223,
      1224,
      1227,
      1228,
      1232,
      1269,
      1272,
      1273,
      1329,
      1366,
      1369,
      1369,
      1377,
      1415,
      1425,
      1441,
      1443,
      1465,
      1467,
      1469,
      1471,
      1471,
      1473,
      1474,
      1476,
      1476,
      1488,
      1514,
      1520,
      1522,
      1569,
      1594,
      1600,
      1621,
      1632,
      1641,
      1648,
      1747,
      1749,
      1756,
      1759,
      1768,
      1770,
      1773,
      1776,
      1788,
      1808,
      1836,
      1840,
      1866,
      1920,
      1968,
      2305,
      2307,
      2309,
      2361,
      2364,
      2381,
      2384,
      2388,
      2392,
      2403,
      2406,
      2415,
      2433,
      2435,
      2437,
      2444,
      2447,
      2448,
      2451,
      2472,
      2474,
      2480,
      2482,
      2482,
      2486,
      2489,
      2492,
      2492,
      2494,
      2500,
      2503,
      2504,
      2507,
      2509,
      2519,
      2519,
      2524,
      2525,
      2527,
      2531,
      2534,
      2545,
      2562,
      2562,
      2565,
      2570,
      2575,
      2576,
      2579,
      2600,
      2602,
      2608,
      2610,
      2611,
      2613,
      2614,
      2616,
      2617,
      2620,
      2620,
      2622,
      2626,
      2631,
      2632,
      2635,
      2637,
      2649,
      2652,
      2654,
      2654,
      2662,
      2676,
      2689,
      2691,
      2693,
      2699,
      2701,
      2701,
      2703,
      2705,
      2707,
      2728,
      2730,
      2736,
      2738,
      2739,
      2741,
      2745,
      2748,
      2757,
      2759,
      2761,
      2763,
      2765,
      2768,
      2768,
      2784,
      2784,
      2790,
      2799,
      2817,
      2819,
      2821,
      2828,
      2831,
      2832,
      2835,
      2856,
      2858,
      2864,
      2866,
      2867,
      2870,
      2873,
      2876,
      2883,
      2887,
      2888,
      2891,
      2893,
      2902,
      2903,
      2908,
      2909,
      2911,
      2913,
      2918,
      2927,
      2946,
      2947,
      2949,
      2954,
      2958,
      2960,
      2962,
      2965,
      2969,
      2970,
      2972,
      2972,
      2974,
      2975,
      2979,
      2980,
      2984,
      2986,
      2990,
      2997,
      2999,
      3001,
      3006,
      3010,
      3014,
      3016,
      3018,
      3021,
      3031,
      3031,
      3047,
      3055,
      3073,
      3075,
      3077,
      3084,
      3086,
      3088,
      3090,
      3112,
      3114,
      3123,
      3125,
      3129,
      3134,
      3140,
      3142,
      3144,
      3146,
      3149,
      3157,
      3158,
      3168,
      3169,
      3174,
      3183,
      3202,
      3203,
      3205,
      3212,
      3214,
      3216,
      3218,
      3240,
      3242,
      3251,
      3253,
      3257,
      3262,
      3268,
      3270,
      3272,
      3274,
      3277,
      3285,
      3286,
      3294,
      3294,
      3296,
      3297,
      3302,
      3311,
      3330,
      3331,
      3333,
      3340,
      3342,
      3344,
      3346,
      3368,
      3370,
      3385,
      3390,
      3395,
      3398,
      3400,
      3402,
      3405,
      3415,
      3415,
      3424,
      3425,
      3430,
      3439,
      3458,
      3459,
      3461,
      3478,
      3482,
      3505,
      3507,
      3515,
      3517,
      3517,
      3520,
      3526,
      3530,
      3530,
      3535,
      3540,
      3542,
      3542,
      3544,
      3551,
      3570,
      3571,
      3585,
      3642,
      3648,
      3662,
      3664,
      3673,
      3713,
      3714,
      3716,
      3716,
      3719,
      3720,
      3722,
      3722,
      3725,
      3725,
      3732,
      3735,
      3737,
      3743,
      3745,
      3747,
      3749,
      3749,
      3751,
      3751,
      3754,
      3755,
      3757,
      3769,
      3771,
      3773,
      3776,
      3780,
      3782,
      3782,
      3784,
      3789,
      3792,
      3801,
      3804,
      3805,
      3840,
      3840,
      3864,
      3865,
      3872,
      3881,
      3893,
      3893,
      3895,
      3895,
      3897,
      3897,
      3902,
      3911,
      3913,
      3946,
      3953,
      3972,
      3974,
      3979,
      3984,
      3991,
      3993,
      4028,
      4038,
      4038,
      4096,
      4129,
      4131,
      4135,
      4137,
      4138,
      4140,
      4146,
      4150,
      4153,
      4160,
      4169,
      4176,
      4185,
      4256,
      4293,
      4304,
      4342,
      4352,
      4441,
      4447,
      4514,
      4520,
      4601,
      4608,
      4614,
      4616,
      4678,
      4680,
      4680,
      4682,
      4685,
      4688,
      4694,
      4696,
      4696,
      4698,
      4701,
      4704,
      4742,
      4744,
      4744,
      4746,
      4749,
      4752,
      4782,
      4784,
      4784,
      4786,
      4789,
      4792,
      4798,
      4800,
      4800,
      4802,
      4805,
      4808,
      4814,
      4816,
      4822,
      4824,
      4846,
      4848,
      4878,
      4880,
      4880,
      4882,
      4885,
      4888,
      4894,
      4896,
      4934,
      4936,
      4954,
      4969,
      4977,
      5024,
      5108,
      5121,
      5740,
      5743,
      5750,
      5761,
      5786,
      5792,
      5866,
      6016,
      6099,
      6112,
      6121,
      6160,
      6169,
      6176,
      6263,
      6272,
      6313,
      7680,
      7835,
      7840,
      7929,
      7936,
      7957,
      7960,
      7965,
      7968,
      8005,
      8008,
      8013,
      8016,
      8023,
      8025,
      8025,
      8027,
      8027,
      8029,
      8029,
      8031,
      8061,
      8064,
      8116,
      8118,
      8124,
      8126,
      8126,
      8130,
      8132,
      8134,
      8140,
      8144,
      8147,
      8150,
      8155,
      8160,
      8172,
      8178,
      8180,
      8182,
      8188,
      8255,
      8256,
      8319,
      8319,
      8400,
      8412,
      8417,
      8417,
      8450,
      8450,
      8455,
      8455,
      8458,
      8467,
      8469,
      8469,
      8473,
      8477,
      8484,
      8484,
      8486,
      8486,
      8488,
      8488,
      8490,
      8493,
      8495,
      8497,
      8499,
      8505,
      8544,
      8579,
      12293,
      12295,
      12321,
      12335,
      12337,
      12341,
      12344,
      12346,
      12353,
      12436,
      12441,
      12442,
      12445,
      12446,
      12449,
      12542,
      12549,
      12588,
      12593,
      12686,
      12704,
      12727,
      13312,
      19893,
      19968,
      40869,
      40960,
      42124,
      44032,
      55203,
      63744,
      64045,
      64256,
      64262,
      64275,
      64279,
      64285,
      64296,
      64298,
      64310,
      64312,
      64316,
      64318,
      64318,
      64320,
      64321,
      64323,
      64324,
      64326,
      64433,
      64467,
      64829,
      64848,
      64911,
      64914,
      64967,
      65008,
      65019,
      65056,
      65059,
      65075,
      65076,
      65101,
      65103,
      65136,
      65138,
      65140,
      65140,
      65142,
      65276,
      65296,
      65305,
      65313,
      65338,
      65343,
      65343,
      65345,
      65370,
      65381,
      65470,
      65474,
      65479,
      65482,
      65487,
      65490,
      65495,
      65498,
      65500
    ];
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/JavaScript/utils.js
var require_utils11 = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/JavaScript/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.legalizeName = void 0;
    var Strings_1 = require_Strings();
    var unicodeMaps_1 = require_unicodeMaps();
    exports.legalizeName = (0, Strings_1.utf16LegalizeCharacters)(unicodeMaps_1.isES3IdentifierPart);
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/JavaScript/JavaScriptRenderer.js
var require_JavaScriptRenderer = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/JavaScript/JavaScriptRenderer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.JavaScriptRenderer = void 0;
    var collection_utils_1 = require_dist();
    var ConvenienceRenderer_1 = require_ConvenienceRenderer();
    var Naming_1 = require_Naming();
    var Source_1 = require_Source();
    var Acronyms_1 = require_Acronyms();
    var Converters_1 = require_Converters();
    var Strings_1 = require_Strings();
    var Support_1 = require_Support();
    var TypeUtils_1 = require_TypeUtils();
    var unicodeMaps_1 = require_unicodeMaps();
    var utils_1 = require_utils11();
    var identityNamingFunction = (0, Naming_1.funPrefixNamer)("properties", (s) => s);
    var JavaScriptRenderer = class extends ConvenienceRenderer_1.ConvenienceRenderer {
      constructor(targetLanguage, renderContext, _jsOptions) {
        super(targetLanguage, renderContext);
        this._jsOptions = _jsOptions;
      }
      nameStyle(original, upper) {
        const acronyms = (0, Acronyms_1.acronymStyle)(this._jsOptions.acronymStyle);
        const words = (0, Strings_1.splitIntoWords)(original);
        return (0, Strings_1.combineWords)(words, utils_1.legalizeName, upper ? Strings_1.firstUpperWordStyle : Strings_1.allLowerWordStyle, Strings_1.firstUpperWordStyle, upper ? (s) => (0, Strings_1.capitalize)(acronyms(s)) : Strings_1.allLowerWordStyle, acronyms, "", unicodeMaps_1.isES3IdentifierStart);
      }
      makeNamedTypeNamer() {
        return (0, Naming_1.funPrefixNamer)("types", (s) => this.nameStyle(s, true));
      }
      namerForObjectProperty() {
        return identityNamingFunction;
      }
      makeUnionMemberNamer() {
        return null;
      }
      makeEnumCaseNamer() {
        return (0, Naming_1.funPrefixNamer)("enum-cases", (s) => this.nameStyle(s, true));
      }
      namedTypeToNameForTopLevel(type) {
        return (0, TypeUtils_1.directlyReachableSingleNamedType)(type);
      }
      makeNameForProperty(c, className, p, jsonName, _assignedName) {
        return super.makeNameForProperty(c, className, p, jsonName, void 0);
      }
      emitDescriptionBlock(lines) {
        this.emitCommentLines(lines, {
          lineStart: " * ",
          beforeComment: "/**",
          afterComment: " */"
        });
      }
      typeMapTypeFor(t) {
        if ([
          "class",
          "object",
          "enum"
        ].includes(t.kind)) {
          return [
            'r("',
            this.nameForNamedType(t),
            '")'
          ];
        }
        return (0, TypeUtils_1.matchType)(t, (_anyType) => '"any"', (_nullType) => "null", (_boolType) => "true", (_integerType) => "0", (_doubleType) => "3.14", (_stringType) => '""', (arrayType) => [
          "a(",
          this.typeMapTypeFor(arrayType.items),
          ")"
        ], (_classType) => (0, Support_1.panic)("We handled this above"), (mapType) => [
          "m(",
          this.typeMapTypeFor(mapType.values),
          ")"
        ], (_enumType) => (0, Support_1.panic)("We handled this above"), (unionType) => {
          const children = Array.from(unionType.getChildren()).map((type) => this.typeMapTypeFor(type));
          return [
            "u(",
            ...(0, collection_utils_1.arrayIntercalate)(", ", children),
            ")"
          ];
        }, (transformedStringType) => {
          if (transformedStringType.kind === "date-time") {
            return "Date";
          }
          return '""';
        });
      }
      typeMapTypeForProperty(p) {
        const typeMap = this.typeMapTypeFor(p.type);
        if (!p.isOptional) {
          return typeMap;
        }
        return [
          "u(undefined, ",
          typeMap,
          ")"
        ];
      }
      emitBlock(source, end, emit) {
        this.emitLine(source, "{");
        this.indent(emit);
        this.emitLine("}", end);
      }
      emitTypeMap() {
        const { any: anyAnnotation } = this.typeAnnotations;
        this.emitBlock(`const typeMap${anyAnnotation} = `, ";", () => {
          this.forEachObject("none", (t, name) => {
            const additionalProperties = t.getAdditionalProperties();
            const additional = additionalProperties !== void 0 ? this.typeMapTypeFor(additionalProperties) : "false";
            this.emitLine('"', name, '": o([');
            this.indent(() => {
              this.forEachClassProperty(t, "none", (propName, jsonName, property) => {
                this.emitLine('{ json: "', (0, Strings_1.utf16StringEscape)(jsonName), '", js: "', (0, Source_1.modifySource)(Strings_1.utf16StringEscape, propName), '", typ: ', this.typeMapTypeForProperty(property), " },");
              });
            });
            this.emitLine("], ", additional, "),");
          });
          this.forEachEnum("none", (e, name) => {
            this.emitLine('"', name, '": [');
            this.indent(() => {
              this.forEachEnumCase(e, "none", (_caseName, jsonName) => {
                this.emitLine(`"${(0, Strings_1.utf16StringEscape)(jsonName)}",`);
              });
            });
            this.emitLine("],");
          });
        });
      }
      deserializerFunctionName(name) {
        return [
          "to",
          name
        ];
      }
      deserializerFunctionLine(_t, name) {
        return [
          "function ",
          this.deserializerFunctionName(name),
          "(json)"
        ];
      }
      serializerFunctionName(name) {
        const camelCaseName = (0, Source_1.modifySource)(Strings_1.camelCase, name);
        return [
          camelCaseName,
          "ToJson"
        ];
      }
      serializerFunctionLine(_t, name) {
        return [
          "function ",
          this.serializerFunctionName(name),
          "(value)"
        ];
      }
      get moduleLine() {
        return void 0;
      }
      get castFunctionLines() {
        return [
          "function cast(val, typ)",
          "function uncast(val, typ)"
        ];
      }
      get typeAnnotations() {
        return {
          any: "",
          anyArray: "",
          anyMap: "",
          string: "",
          stringArray: "",
          boolean: "",
          never: ""
        };
      }
      emitConvertModuleBody() {
        const converter = (t, name) => {
          const typeMap = this.typeMapTypeFor(t);
          this.emitBlock([
            this.deserializerFunctionLine(t, name),
            " "
          ], "", () => {
            const parsedJson = this._jsOptions.rawType === "json" ? "JSON.parse(json)" : "json";
            if (!this._jsOptions.runtimeTypecheck) {
              this.emitLine("return ", parsedJson, ";");
            } else {
              this.emitLine("return cast(", parsedJson, ", ", typeMap, ");");
            }
          });
          this.ensureBlankLine();
          this.emitBlock([
            this.serializerFunctionLine(t, name),
            " "
          ], "", () => {
            if (this._jsOptions.rawType === "json") {
              if (!this._jsOptions.runtimeTypecheck) {
                this.emitLine("return JSON.stringify(value);");
              } else {
                this.emitLine("return JSON.stringify(uncast(value, ", typeMap, "), null, 2);");
              }
            } else {
              if (!this._jsOptions.runtimeTypecheck) {
                this.emitLine("return value;");
              } else {
                this.emitLine("return uncast(value, ", typeMap, ");");
              }
            }
          });
        };
        switch (this._jsOptions.converters) {
          case Converters_1.ConvertersOptions.AllObjects:
            this.forEachObject("interposing", converter);
            break;
          default:
            this.forEachTopLevel("interposing", converter);
            break;
        }
      }
      emitConvertModuleHelpers() {
        if (this._jsOptions.runtimeTypecheck) {
          const { any: anyAnnotation, anyArray: anyArrayAnnotation, anyMap: anyMapAnnotation, string: stringAnnotation, stringArray: stringArrayAnnotation, never: neverAnnotation } = this.typeAnnotations;
          this.ensureBlankLine();
          this.emitMultiline(`function invalidValue(typ${anyAnnotation}, val${anyAnnotation}, key${anyAnnotation}, parent${anyAnnotation} = '')${neverAnnotation} {
    const prettyTyp = prettyTypeName(typ);
    const parentText = parent ? \` on \${parent}\` : '';
    const keyText = key ? \` for key "\${key}"\` : '';
    throw Error(\`Invalid value\${keyText}\${parentText}. Expected \${prettyTyp} but got \${JSON.stringify(val)}\`);
}

function prettyTypeName(typ${anyAnnotation})${stringAnnotation} {
    if (Array.isArray(typ)) {
        if (typ.length === 2 && typ[0] === undefined) {
            return \`an optional \${prettyTypeName(typ[1])}\`;
        } else {
            return \`one of [\${typ.map(a => { return prettyTypeName(a); }).join(", ")}]\`;
        }
    } else if (typeof typ === "object" && typ.literal !== undefined) {
        return typ.literal;
    } else {
        return typeof typ;
    }
}

function jsonToJSProps(typ${anyAnnotation})${anyAnnotation} {
    if (typ.jsonToJS === undefined) {
        const map${anyAnnotation} = {};
        typ.props.forEach((p${anyAnnotation}) => map[p.json] = { key: p.js, typ: p.typ });
        typ.jsonToJS = map;
    }
    return typ.jsonToJS;
}

function jsToJSONProps(typ${anyAnnotation})${anyAnnotation} {
    if (typ.jsToJSON === undefined) {
        const map${anyAnnotation} = {};
        typ.props.forEach((p${anyAnnotation}) => map[p.js] = { key: p.json, typ: p.typ });
        typ.jsToJSON = map;
    }
    return typ.jsToJSON;
}

function transform(val${anyAnnotation}, typ${anyAnnotation}, getProps${anyAnnotation}, key${anyAnnotation} = '', parent${anyAnnotation} = '')${anyAnnotation} {
    function transformPrimitive(typ${stringAnnotation}, val${anyAnnotation})${anyAnnotation} {
        if (typeof typ === typeof val) return val;
        return invalidValue(typ, val, key, parent);
    }

    function transformUnion(typs${anyArrayAnnotation}, val${anyAnnotation})${anyAnnotation} {
        // val must validate against one typ in typs
        const l = typs.length;
        for (let i = 0; i < l; i++) {
            const typ = typs[i];
            try {
                return transform(val, typ, getProps);
            } catch (_) {}
        }
        return invalidValue(typs, val, key, parent);
    }

    function transformEnum(cases${stringArrayAnnotation}, val${anyAnnotation})${anyAnnotation} {
        if (cases.indexOf(val) !== -1) return val;
        return invalidValue(cases.map(a => { return l(a); }), val, key, parent);
    }

    function transformArray(typ${anyAnnotation}, val${anyAnnotation})${anyAnnotation} {
        // val must be an array with no invalid elements
        if (!Array.isArray(val)) return invalidValue(l("array"), val, key, parent);
        return val.map(el => transform(el, typ, getProps));
    }

    function transformDate(val${anyAnnotation})${anyAnnotation} {
        if (val === null) {
            return null;
        }
        const d = new Date(val);
        if (isNaN(d.valueOf())) {
            return invalidValue(l("Date"), val, key, parent);
        }
        return d;
    }

    function transformObject(props${anyMapAnnotation}, additional${anyAnnotation}, val${anyAnnotation})${anyAnnotation} {
        if (val === null || typeof val !== "object" || Array.isArray(val)) {
            return invalidValue(l(ref || "object"), val, key, parent);
        }
        const result${anyAnnotation} = {};
        Object.getOwnPropertyNames(props).forEach(key => {
            const prop = props[key];
            const v = Object.prototype.hasOwnProperty.call(val, key) ? val[key] : undefined;
            result[prop.key] = transform(v, prop.typ, getProps, key, ref);
        });
        Object.getOwnPropertyNames(val).forEach(key => {
            if (!Object.prototype.hasOwnProperty.call(props, key)) {
                result[key] = ${this._jsOptions.runtimeTypecheckIgnoreUnknownProperties ? "val[key]" : "transform(val[key], additional, getProps, key, ref)"};
            }
        });
        return result;
    }

    if (typ === "any") return val;
    if (typ === null) {
        if (val === null) return val;
        return invalidValue(typ, val, key, parent);
    }
    if (typ === false) return invalidValue(typ, val, key, parent);
    let ref${anyAnnotation} = undefined;
    while (typeof typ === "object" && typ.ref !== undefined) {
        ref = typ.ref;
        typ = typeMap[typ.ref];
    }
    if (Array.isArray(typ)) return transformEnum(typ, val);
    if (typeof typ === "object") {
        return typ.hasOwnProperty("unionMembers") ? transformUnion(typ.unionMembers, val)
            : typ.hasOwnProperty("arrayItems")    ? transformArray(typ.arrayItems, val)
            : typ.hasOwnProperty("props")         ? transformObject(getProps(typ), typ.additional, val)
            : invalidValue(typ, val, key, parent);
    }
    // Numbers can be parsed by Date but shouldn't be.
    if (typ === Date && typeof val !== "number") return transformDate(val);
    return transformPrimitive(typ, val);
}

${this.castFunctionLines[0]} {
    return transform(val, typ, jsonToJSProps);
}

${this.castFunctionLines[1]} {
    return transform(val, typ, jsToJSONProps);
}

function l(typ${anyAnnotation}) {
    return { literal: typ };
}

function a(typ${anyAnnotation}) {
    return { arrayItems: typ };
}

function u(...typs${anyArrayAnnotation}) {
    return { unionMembers: typs };
}

function o(props${anyArrayAnnotation}, additional${anyAnnotation}) {
    return { props, additional };
}

function m(additional${anyAnnotation}) {
    return { props: [], additional };
}

function r(name${stringAnnotation}) {
    return { ref: name };
}
`);
          this.emitTypeMap();
        }
      }
      emitConvertModule() {
        this.ensureBlankLine();
        this.emitMultiline(`// Converts JSON ${this._jsOptions.rawType === "json" ? "strings" : "types"} to/from your types`);
        if (this._jsOptions.runtimeTypecheck) {
          this.emitMultiline(`// and asserts the results${this._jsOptions.rawType === "json" ? " of JSON.parse" : ""} at runtime`);
        }
        const moduleLine = this.moduleLine;
        if (moduleLine === void 0) {
          this.emitConvertModuleBody();
        } else {
          this.emitBlock([
            moduleLine,
            " "
          ], "", () => this.emitConvertModuleBody());
        }
      }
      emitTypes() {
        return;
      }
      emitUsageImportComment() {
        this.emitLine('//   const Convert = require("./file");');
      }
      emitUsageComments() {
        this.emitMultiline(`// To parse this data:
//`);
        this.emitUsageImportComment();
        this.emitLine("//");
        this.forEachTopLevel("none", (_t, name) => {
          const camelCaseName = (0, Source_1.modifySource)(Strings_1.camelCase, name);
          this.emitLine("//   const ", camelCaseName, " = Convert.to", name, "(json);");
        });
        if (this._jsOptions.runtimeTypecheck) {
          this.emitLine("//");
          this.emitLine("// These functions will throw an error if the JSON doesn't");
          this.emitLine("// match the expected interface, even if the JSON is valid.");
        }
      }
      emitModuleExports() {
        this.ensureBlankLine();
        this.emitBlock("module.exports = ", ";", () => {
          this.forEachTopLevel("none", (_, name) => {
            const serializer = this.serializerFunctionName(name);
            const deserializer = this.deserializerFunctionName(name);
            this.emitLine('"', serializer, '": ', serializer, ",");
            this.emitLine('"', deserializer, '": ', deserializer, ",");
          });
        });
      }
      emitSourceStructure() {
        if (this.leadingComments !== void 0) {
          this.emitComments(this.leadingComments);
        } else {
          this.emitUsageComments();
        }
        this.emitTypes();
        this.emitConvertModule();
        this.emitConvertModuleHelpers();
        this.emitModuleExports();
      }
    };
    exports.JavaScriptRenderer = JavaScriptRenderer;
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/JavaScript/language.js
var require_language11 = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/JavaScript/language.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.JavaScriptTargetLanguage = exports.javaScriptLanguageConfig = exports.javaScriptOptions = void 0;
    var RendererOptions_1 = require_RendererOptions();
    var Acronyms_1 = require_Acronyms();
    var Converters_1 = require_Converters();
    var TargetLanguage_1 = require_TargetLanguage();
    var JavaScriptRenderer_1 = require_JavaScriptRenderer();
    exports.javaScriptOptions = {
      acronymStyle: (0, Acronyms_1.acronymOption)(Acronyms_1.AcronymStyleOptions.Pascal),
      runtimeTypecheck: new RendererOptions_1.BooleanOption("runtime-typecheck", "Verify JSON.parse results at runtime", true),
      runtimeTypecheckIgnoreUnknownProperties: new RendererOptions_1.BooleanOption("runtime-typecheck-ignore-unknown-properties", "Ignore unknown properties when verifying at runtime", false, "secondary"),
      converters: (0, Converters_1.convertersOption)(),
      rawType: new RendererOptions_1.EnumOption("raw-type", "Type of raw input (json by default)", {
        json: "json",
        any: "any"
      }, "json", "secondary")
    };
    exports.javaScriptLanguageConfig = {
      displayName: "JavaScript",
      names: [
        "javascript",
        "js",
        "jsx"
      ],
      extension: "js"
    };
    var JavaScriptTargetLanguage = class extends TargetLanguage_1.TargetLanguage {
      constructor() {
        super(exports.javaScriptLanguageConfig);
      }
      getOptions() {
        return exports.javaScriptOptions;
      }
      get stringTypeMapping() {
        const mapping = /* @__PURE__ */ new Map();
        const dateTimeType = "date-time";
        mapping.set("date", dateTimeType);
        mapping.set("date-time", dateTimeType);
        return mapping;
      }
      get supportsOptionalClassProperties() {
        return true;
      }
      get supportsFullObjectType() {
        return true;
      }
      makeRenderer(renderContext, untypedOptionValues) {
        return new JavaScriptRenderer_1.JavaScriptRenderer(this, renderContext, (0, RendererOptions_1.getOptionValues)(exports.javaScriptOptions, untypedOptionValues));
      }
    };
    exports.JavaScriptTargetLanguage = JavaScriptTargetLanguage;
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/JavaScript/index.js
var require_JavaScript = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/JavaScript/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.JavaScriptRenderer = exports.javaScriptOptions = exports.JavaScriptTargetLanguage = void 0;
    var language_1 = require_language11();
    Object.defineProperty(exports, "JavaScriptTargetLanguage", {
      enumerable: true,
      get: function() {
        return language_1.JavaScriptTargetLanguage;
      }
    });
    Object.defineProperty(exports, "javaScriptOptions", {
      enumerable: true,
      get: function() {
        return language_1.javaScriptOptions;
      }
    });
    var JavaScriptRenderer_1 = require_JavaScriptRenderer();
    Object.defineProperty(exports, "JavaScriptRenderer", {
      enumerable: true,
      get: function() {
        return JavaScriptRenderer_1.JavaScriptRenderer;
      }
    });
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/JavaScriptPropTypes/JavaScriptPropTypesRenderer.js
var require_JavaScriptPropTypesRenderer = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/JavaScriptPropTypes/JavaScriptPropTypesRenderer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.JavaScriptPropTypesRenderer = void 0;
    var collection_utils_1 = require_dist();
    var ConvenienceRenderer_1 = require_ConvenienceRenderer();
    var Naming_1 = require_Naming();
    var Acronyms_1 = require_Acronyms();
    var Strings_1 = require_Strings();
    var Support_1 = require_Support();
    var Type_1 = require_Type2();
    var TypeUtils_1 = require_TypeUtils();
    var unicodeMaps_1 = require_unicodeMaps();
    var utils_1 = require_utils11();
    var identityNamingFunction = (0, Naming_1.funPrefixNamer)("properties", (s) => s);
    var JavaScriptPropTypesRenderer = class extends ConvenienceRenderer_1.ConvenienceRenderer {
      constructor(targetLanguage, renderContext, _jsOptions) {
        super(targetLanguage, renderContext);
        this._jsOptions = _jsOptions;
      }
      nameStyle(original, upper) {
        const acronyms = (0, Acronyms_1.acronymStyle)(this._jsOptions.acronymStyle);
        const words = (0, Strings_1.splitIntoWords)(original);
        return (0, Strings_1.combineWords)(words, utils_1.legalizeName, upper ? Strings_1.firstUpperWordStyle : Strings_1.allLowerWordStyle, Strings_1.firstUpperWordStyle, upper ? (s) => (0, Strings_1.capitalize)(acronyms(s)) : Strings_1.allLowerWordStyle, acronyms, "", unicodeMaps_1.isES3IdentifierStart);
      }
      makeNamedTypeNamer() {
        return (0, Naming_1.funPrefixNamer)("types", (s) => this.nameStyle(s, true));
      }
      namerForObjectProperty() {
        return identityNamingFunction;
      }
      makeUnionMemberNamer() {
        return null;
      }
      makeEnumCaseNamer() {
        return (0, Naming_1.funPrefixNamer)("enum-cases", (s) => this.nameStyle(s, false));
      }
      namedTypeToNameForTopLevel(type) {
        return (0, TypeUtils_1.directlyReachableSingleNamedType)(type);
      }
      makeNameForProperty(c, className, p, jsonName, _assignedName) {
        return super.makeNameForProperty(c, className, p, jsonName, void 0);
      }
      typeMapTypeFor(t, required = true) {
        if ([
          "class",
          "object",
          "enum"
        ].includes(t.kind)) {
          return [
            "_",
            this.nameForNamedType(t)
          ];
        }
        const match2 = (0, TypeUtils_1.matchType)(t, (_anyType) => "PropTypes.any", (_nullType) => "PropTypes.any", (_boolType) => "PropTypes.bool", (_integerType) => "PropTypes.number", (_doubleType) => "PropTypes.number", (_stringType) => "PropTypes.string", (arrayType) => [
          "PropTypes.arrayOf(",
          this.typeMapTypeFor(arrayType.items, false),
          ")"
        ], (_classType) => (0, Support_1.panic)("Should already be handled."), (_mapType) => "PropTypes.object", (_enumType) => (0, Support_1.panic)("Should already be handled."), (unionType) => {
          const children = Array.from(unionType.getChildren()).map((type) => this.typeMapTypeFor(type, false));
          return [
            "PropTypes.oneOfType([",
            ...(0, collection_utils_1.arrayIntercalate)(", ", children),
            "])"
          ];
        }, (_transformedStringType) => {
          return "PropTypes.string";
        });
        if (required) {
          return [
            match2
          ];
        }
        return match2;
      }
      typeMapTypeForProperty(p) {
        return this.typeMapTypeFor(p.type);
      }
      importStatement(lhs, moduleName) {
        if (this._jsOptions.moduleSystem) {
          return [
            "import ",
            lhs,
            " from ",
            moduleName,
            ";"
          ];
        }
        return [
          "const ",
          lhs,
          " = require(",
          moduleName,
          ");"
        ];
      }
      emitUsageComments() {
        this.emitCommentLines([
          "Example usage:",
          "",
          this.importStatement("{ MyShape }", "./myShape.js"),
          "",
          "class MyComponent extends React.Component {",
          "  //",
          "}",
          "",
          "MyComponent.propTypes = {",
          "  input: MyShape",
          "};"
        ], {
          lineStart: "// "
        });
      }
      emitBlock(source, end, emit) {
        this.emitLine(source, "{");
        this.indent(emit);
        this.emitLine("}", end);
      }
      emitImports() {
        this.ensureBlankLine();
        this.emitLine(this.importStatement("PropTypes", '"prop-types"'));
      }
      emitExport(name, value) {
        if (this._jsOptions.moduleSystem) {
          this.emitLine("export const ", name, " = ", value, ";");
        } else {
          this.emitLine("module.exports = exports = { ", name, ": ", value, " };");
        }
      }
      emitTypes() {
        this.ensureBlankLine();
        this.forEachObject("none", (_type, name) => {
          this.emitLine("let _", name, ";");
        });
        this.forEachEnum("none", (enumType, enumName) => {
          const options = [];
          this.forEachEnumCase(enumType, "none", (name, _jsonName, _position) => {
            options.push("'");
            options.push(name);
            options.push("'");
            options.push(", ");
          });
          options.pop();
          this.emitLine([
            "const _",
            enumName,
            " = PropTypes.oneOfType([",
            ...options,
            "]);"
          ]);
        });
        const order = [];
        const mapKey = [];
        const mapValue = [];
        this.forEachObject("none", (type, name) => {
          mapKey.push(name);
          mapValue.push(this.gatherSource(() => this.emitObject(name, type)));
        });
        mapKey.forEach((_, index) => {
          let ordinal = 0;
          const source = mapValue[index];
          const names = source.filter((value) => value);
          names.forEach((name) => {
            const depName = name;
            order.forEach((orderItem) => {
              const depIndex = orderItem;
              if (mapKey[depIndex] === depName) {
                ordinal = Math.max(ordinal, depIndex + 1);
              }
            });
          });
          order.splice(ordinal, 0, index);
        });
        order.forEach((i2) => this.emitGatheredSource(mapValue[i2]));
        this.forEachTopLevel("none", (type, name) => {
          if (type instanceof Type_1.PrimitiveType) {
            this.ensureBlankLine();
            this.emitExport(name, this.typeMapTypeFor(type));
          } else {
            if (type.kind === "array") {
              this.ensureBlankLine();
              this.emitExport(name, [
                "PropTypes.arrayOf(",
                this.typeMapTypeFor(type.items),
                ")"
              ]);
            } else {
              this.ensureBlankLine();
              this.emitExport(name, [
                "_",
                name
              ]);
            }
          }
        });
      }
      emitObject(name, t) {
        this.ensureBlankLine();
        this.emitLine("_", name, " = PropTypes.shape({");
        this.indent(() => {
          this.forEachClassProperty(t, "none", (_, jsonName, property) => {
            this.emitLine(`"${(0, Strings_1.utf16StringEscape)(jsonName)}"`, ": ", this.typeMapTypeForProperty(property), ",");
          });
        });
        this.emitLine("});");
      }
      emitSourceStructure() {
        if (this.leadingComments !== void 0) {
          this.emitComments(this.leadingComments);
        } else {
          this.emitUsageComments();
        }
        this.emitImports();
        this.emitTypes();
      }
    };
    exports.JavaScriptPropTypesRenderer = JavaScriptPropTypesRenderer;
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/JavaScriptPropTypes/language.js
var require_language12 = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/JavaScriptPropTypes/language.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.JavaScriptPropTypesTargetLanguage = exports.javaScriptPropTypesLanguageConfig = exports.javaScriptPropTypesOptions = void 0;
    var RendererOptions_1 = require_RendererOptions();
    var Acronyms_1 = require_Acronyms();
    var Converters_1 = require_Converters();
    var TargetLanguage_1 = require_TargetLanguage();
    var JavaScriptPropTypesRenderer_1 = require_JavaScriptPropTypesRenderer();
    exports.javaScriptPropTypesOptions = {
      acronymStyle: (0, Acronyms_1.acronymOption)(Acronyms_1.AcronymStyleOptions.Pascal),
      converters: (0, Converters_1.convertersOption)(),
      moduleSystem: new RendererOptions_1.EnumOption("module-system", "Which module system to use", {
        "common-js": false,
        es6: true
      }, "es6")
    };
    exports.javaScriptPropTypesLanguageConfig = {
      displayName: "JavaScript PropTypes",
      names: [
        "javascript-prop-types"
      ],
      extension: "js"
    };
    var JavaScriptPropTypesTargetLanguage = class extends TargetLanguage_1.TargetLanguage {
      constructor() {
        super(exports.javaScriptPropTypesLanguageConfig);
      }
      getOptions() {
        return exports.javaScriptPropTypesOptions;
      }
      makeRenderer(renderContext, untypedOptionValues) {
        return new JavaScriptPropTypesRenderer_1.JavaScriptPropTypesRenderer(this, renderContext, (0, RendererOptions_1.getOptionValues)(exports.javaScriptPropTypesOptions, untypedOptionValues));
      }
    };
    exports.JavaScriptPropTypesTargetLanguage = JavaScriptPropTypesTargetLanguage;
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/JavaScriptPropTypes/index.js
var require_JavaScriptPropTypes = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/JavaScriptPropTypes/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.JavaScriptPropTypesRenderer = exports.javaScriptPropTypesOptions = exports.JavaScriptPropTypesTargetLanguage = void 0;
    var language_1 = require_language12();
    Object.defineProperty(exports, "JavaScriptPropTypesTargetLanguage", {
      enumerable: true,
      get: function() {
        return language_1.JavaScriptPropTypesTargetLanguage;
      }
    });
    Object.defineProperty(exports, "javaScriptPropTypesOptions", {
      enumerable: true,
      get: function() {
        return language_1.javaScriptPropTypesOptions;
      }
    });
    var JavaScriptPropTypesRenderer_1 = require_JavaScriptPropTypesRenderer();
    Object.defineProperty(exports, "JavaScriptPropTypesRenderer", {
      enumerable: true,
      get: function() {
        return JavaScriptPropTypesRenderer_1.JavaScriptPropTypesRenderer;
      }
    });
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/JSONSchema/utils.js
var require_utils12 = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/JSONSchema/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.namingFunction = void 0;
    var Naming_1 = require_Naming();
    var Strings_1 = require_Strings();
    exports.namingFunction = (0, Naming_1.funPrefixNamer)("namer", jsonNameStyle);
    var legalizeName = (0, Strings_1.legalizeCharacters)(
      (cp) => cp >= 32 && cp < 128 && cp !== 47
      /* slash */
    );
    function jsonNameStyle(original) {
      const words = (0, Strings_1.splitIntoWords)(original);
      return (0, Strings_1.combineWords)(words, legalizeName, Strings_1.firstUpperWordStyle, Strings_1.firstUpperWordStyle, Strings_1.allUpperWordStyle, Strings_1.allUpperWordStyle, "", (_) => true);
    }
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/JSONSchema/JSONSchemaRenderer.js
var require_JSONSchemaRenderer = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/JSONSchema/JSONSchemaRenderer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.JSONSchemaRenderer = void 0;
    var collection_utils_1 = require_dist();
    var Description_1 = require_Description();
    var ConvenienceRenderer_1 = require_ConvenienceRenderer();
    var Support_1 = require_Support();
    var Type_1 = require_Type2();
    var TypeUtils_1 = require_TypeUtils();
    var utils_1 = require_utils12();
    var JSONSchemaRenderer = class extends ConvenienceRenderer_1.ConvenienceRenderer {
      makeNamedTypeNamer() {
        return utils_1.namingFunction;
      }
      namerForObjectProperty() {
        return null;
      }
      makeUnionMemberNamer() {
        return null;
      }
      makeEnumCaseNamer() {
        return null;
      }
      nameForType(t) {
        return (0, Support_1.defined)(this.names.get(this.nameForNamedType(t)));
      }
      makeOneOf(types) {
        const first = (0, collection_utils_1.iterableFirst)(types);
        if (first === void 0) {
          return (0, Support_1.panic)("Must have at least one type for oneOf");
        }
        if (types.size === 1) {
          return this.schemaForType(first);
        }
        return {
          anyOf: Array.from(types).map((t) => this.schemaForType(t))
        };
      }
      makeRef(t) {
        return {
          $ref: `#/definitions/${this.nameForType(t)}`
        };
      }
      addAttributesToSchema(t, schema) {
        const attributes = this.typeGraph.attributeStore.attributesForType(t);
        for (const [kind, attr] of attributes) {
          kind.addToSchema(schema, t, attr);
        }
      }
      schemaForType(t) {
        const schema = (0, TypeUtils_1.matchTypeExhaustive)(t, (_noneType) => {
          return (0, Support_1.panic)("none type should have been replaced");
        }, (_anyType) => ({}), (_nullType) => ({
          type: "null"
        }), (_boolType) => ({
          type: "boolean"
        }), (_integerType) => ({
          type: "integer"
        }), (_doubleType) => ({
          type: "number"
        }), (_stringType) => ({
          type: "string"
        }), (arrayType) => ({
          type: "array",
          items: this.schemaForType(arrayType.items)
        }), (classType) => this.makeRef(classType), (mapType) => this.definitionForObject(mapType, void 0), (objectType) => this.makeRef(objectType), (enumType) => this.makeRef(enumType), (unionType) => {
          if (this.unionNeedsName(unionType)) {
            return this.makeRef(unionType);
          }
          return this.definitionForUnion(unionType);
        }, (transformedStringType) => {
          const target = Type_1.transformedStringTypeTargetTypeKindsMap.get(transformedStringType.kind);
          if (target === void 0) {
            return (0, Support_1.panic)(`Unknown transformed string type ${transformedStringType.kind}`);
          }
          return {
            type: "string",
            format: target.jsonSchema
          };
        });
        if (schema.$ref === void 0) {
          this.addAttributesToSchema(t, schema);
        }
        return schema;
      }
      definitionForObject(o, title) {
        let properties;
        let required;
        if (o.getProperties().size === 0) {
          properties = void 0;
          required = void 0;
        } else {
          const props = {};
          const req = [];
          for (const [name, p] of o.getProperties()) {
            const prop = this.schemaForType(p.type);
            if (prop.description === void 0) {
              (0, Description_1.addDescriptionToSchema)(prop, this.descriptionForClassProperty(o, name));
            }
            props[name] = prop;
            if (!p.isOptional) {
              req.push(name);
            }
          }
          properties = props;
          required = req.sort();
        }
        const additional = o.getAdditionalProperties();
        const additionalProperties = additional !== void 0 ? this.schemaForType(additional) : false;
        const schema = {
          type: "object",
          additionalProperties,
          properties,
          required,
          title
        };
        this.addAttributesToSchema(o, schema);
        return schema;
      }
      definitionForUnion(u, title) {
        const oneOf = this.makeOneOf(u.sortedMembers);
        if (title !== void 0) {
          oneOf.title = title;
        }
        this.addAttributesToSchema(u, oneOf);
        return oneOf;
      }
      definitionForEnum(e, title) {
        const schema = {
          type: "string",
          enum: Array.from(e.cases),
          title
        };
        this.addAttributesToSchema(e, schema);
        return schema;
      }
      emitSourceStructure() {
        const topLevelType = this.topLevels.size === 1 ? this.schemaForType((0, Support_1.defined)((0, collection_utils_1.mapFirst)(this.topLevels))) : {};
        const schema = Object.assign({
          $schema: "http://json-schema.org/draft-06/schema#"
        }, topLevelType);
        const definitions = {};
        this.forEachObject("none", (o, name) => {
          const title = (0, Support_1.defined)(this.names.get(name));
          definitions[title] = this.definitionForObject(o, title);
        });
        this.forEachUnion("none", (u, name) => {
          if (!this.unionNeedsName(u)) return;
          const title = (0, Support_1.defined)(this.names.get(name));
          definitions[title] = this.definitionForUnion(u, title);
        });
        this.forEachEnum("none", (e, name) => {
          const title = (0, Support_1.defined)(this.names.get(name));
          definitions[title] = this.definitionForEnum(e, title);
        });
        schema.definitions = definitions;
        this.emitMultiline(JSON.stringify(schema, void 0, "    "));
      }
    };
    exports.JSONSchemaRenderer = JSONSchemaRenderer;
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/JSONSchema/language.js
var require_language13 = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/JSONSchema/language.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.JSONSchemaTargetLanguage = exports.JSONSchemaLanguageConfig = void 0;
    var TargetLanguage_1 = require_TargetLanguage();
    var TypeBuilderUtils_1 = require_TypeBuilderUtils();
    var JSONSchemaRenderer_1 = require_JSONSchemaRenderer();
    exports.JSONSchemaLanguageConfig = {
      displayName: "JSON Schema",
      names: [
        "schema",
        "json-schema"
      ],
      extension: "schema"
    };
    var JSONSchemaTargetLanguage = class extends TargetLanguage_1.TargetLanguage {
      constructor() {
        super(exports.JSONSchemaLanguageConfig);
      }
      getOptions() {
        return {};
      }
      get stringTypeMapping() {
        return (0, TypeBuilderUtils_1.getNoStringTypeMapping)();
      }
      get supportsOptionalClassProperties() {
        return true;
      }
      get supportsFullObjectType() {
        return true;
      }
      makeRenderer(renderContext, _untypedOptionValues) {
        return new JSONSchemaRenderer_1.JSONSchemaRenderer(this, renderContext);
      }
    };
    exports.JSONSchemaTargetLanguage = JSONSchemaTargetLanguage;
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/JSONSchema/index.js
var require_JSONSchema = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/JSONSchema/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.JSONSchemaRenderer = exports.JSONSchemaTargetLanguage = void 0;
    var language_1 = require_language13();
    Object.defineProperty(exports, "JSONSchemaTargetLanguage", {
      enumerable: true,
      get: function() {
        return language_1.JSONSchemaTargetLanguage;
      }
    });
    var JSONSchemaRenderer_1 = require_JSONSchemaRenderer();
    Object.defineProperty(exports, "JSONSchemaRenderer", {
      enumerable: true,
      get: function() {
        return JSONSchemaRenderer_1.JSONSchemaRenderer;
      }
    });
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Kotlin/constants.js
var require_constants11 = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Kotlin/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.keywords = void 0;
    exports.keywords = [
      "package",
      "as",
      "typealias",
      "class",
      "this",
      "super",
      "val",
      "var",
      "fun",
      "for",
      "null",
      "true",
      "false",
      "is",
      "in",
      "throw",
      "return",
      "break",
      "continue",
      "object",
      "if",
      "try",
      "else",
      "while",
      "do",
      "when",
      "interface",
      "typeof",
      "klaxon",
      "toJson",
      "Any",
      "Boolean",
      "Double",
      "Float",
      "Long",
      "Int",
      "Short",
      "System",
      "Byte",
      "String",
      "Array",
      "List",
      "Map",
      "Enum",
      "Class",
      "JsonObject",
      "JsonValue",
      "Converter",
      "Klaxon"
    ];
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Kotlin/utils.js
var require_utils13 = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Kotlin/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.kotlinNameStyle = kotlinNameStyle;
    exports.stringEscape = stringEscape;
    var Strings_1 = require_Strings();
    function isPartCharacter(codePoint) {
      return (0, Strings_1.isLetterOrUnderscore)(codePoint) || (0, Strings_1.isNumeric)(codePoint);
    }
    function isStartCharacter(codePoint) {
      return isPartCharacter(codePoint) && !(0, Strings_1.isDigit)(codePoint);
    }
    var legalizeName = (0, Strings_1.legalizeCharacters)(isPartCharacter);
    function kotlinNameStyle(isUpper, original, acronymsStyle = Strings_1.allUpperWordStyle) {
      const words = (0, Strings_1.splitIntoWords)(original);
      return (0, Strings_1.combineWords)(words, legalizeName, isUpper ? Strings_1.firstUpperWordStyle : Strings_1.allLowerWordStyle, Strings_1.firstUpperWordStyle, isUpper ? Strings_1.allUpperWordStyle : Strings_1.allLowerWordStyle, acronymsStyle, "", isStartCharacter);
    }
    function unicodeEscape(codePoint) {
      return "\\u" + (0, Strings_1.intToHex)(codePoint, 4);
    }
    var _stringEscape = (0, Strings_1.utf32ConcatMap)((0, Strings_1.escapeNonPrintableMapper)(Strings_1.isPrintable, unicodeEscape));
    function stringEscape(s) {
      return _stringEscape(s).replace(/\$/g, "\\$");
    }
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Kotlin/KotlinRenderer.js
var require_KotlinRenderer = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Kotlin/KotlinRenderer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.KotlinRenderer = void 0;
    var Annotation_1 = require_Annotation();
    var ConvenienceRenderer_1 = require_ConvenienceRenderer();
    var Naming_1 = require_Naming();
    var Source_1 = require_Source();
    var Acronyms_1 = require_Acronyms();
    var Type_1 = require_Type2();
    var TypeUtils_1 = require_TypeUtils();
    var constants_1 = require_constants11();
    var utils_1 = require_utils13();
    var KotlinRenderer = class extends ConvenienceRenderer_1.ConvenienceRenderer {
      constructor(targetLanguage, renderContext, _kotlinOptions) {
        super(targetLanguage, renderContext);
        this._kotlinOptions = _kotlinOptions;
      }
      forbiddenNamesForGlobalNamespace() {
        return constants_1.keywords;
      }
      forbiddenForObjectProperties(_o, _classNamed) {
        return {
          names: [],
          includeGlobalForbidden: true
        };
      }
      forbiddenForEnumCases(_e, _enumName) {
        return {
          names: [],
          includeGlobalForbidden: true
        };
      }
      forbiddenForUnionMembers(_u, _unionName) {
        return {
          names: [],
          includeGlobalForbidden: false
        };
      }
      topLevelNameStyle(rawName) {
        return (0, utils_1.kotlinNameStyle)(true, rawName);
      }
      makeNamedTypeNamer() {
        return (0, Naming_1.funPrefixNamer)("upper", (s) => (0, utils_1.kotlinNameStyle)(true, s, (0, Acronyms_1.acronymStyle)(this._kotlinOptions.acronymStyle)));
      }
      namerForObjectProperty() {
        return (0, Naming_1.funPrefixNamer)("lower", (s) => (0, utils_1.kotlinNameStyle)(false, s, (0, Acronyms_1.acronymStyle)(this._kotlinOptions.acronymStyle)));
      }
      makeUnionMemberNamer() {
        return (0, Naming_1.funPrefixNamer)("upper", (s) => `${(0, utils_1.kotlinNameStyle)(true, s)}Value`);
      }
      makeEnumCaseNamer() {
        return (0, Naming_1.funPrefixNamer)("upper", (s) => (0, utils_1.kotlinNameStyle)(true, s, (0, Acronyms_1.acronymStyle)(this._kotlinOptions.acronymStyle)));
      }
      emitDescriptionBlock(lines) {
        this.emitCommentLines(lines, {
          lineStart: " * ",
          beforeComment: "/**",
          afterComment: " */"
        });
      }
      emitBlock(line, f, delimiter = "curly") {
        const [open, close] = delimiter === "curly" ? [
          "{",
          "}"
        ] : delimiter === "paren" ? [
          "(",
          ")"
        ] : [
          "{",
          "})"
        ];
        this.emitLine(line, " ", open);
        this.indent(f);
        this.emitLine(close);
      }
      anySourceType(optional) {
        return [
          "Any",
          optional
        ];
      }
      // (asarazan): I've broken out the following two functions
      // because some renderers, such as kotlinx, can cope with `any`, while some get mad.
      arrayType(arrayType, withIssues = false, _noOptional = false) {
        return [
          "List<",
          this.kotlinType(arrayType.items, withIssues),
          ">"
        ];
      }
      mapType(mapType, withIssues = false, _noOptional = false) {
        return [
          "Map<String, ",
          this.kotlinType(mapType.values, withIssues),
          ">"
        ];
      }
      kotlinType(t, withIssues = false, noOptional = false) {
        const optional = noOptional ? "" : "?";
        return (0, TypeUtils_1.matchType)(t, (_anyType) => {
          return (0, Source_1.maybeAnnotated)(withIssues, Annotation_1.anyTypeIssueAnnotation, this.anySourceType(optional));
        }, (_nullType) => {
          return (0, Source_1.maybeAnnotated)(withIssues, Annotation_1.nullTypeIssueAnnotation, this.anySourceType(optional));
        }, (_boolType) => "Boolean", (_integerType) => "Long", (_doubleType) => "Double", (_stringType) => "String", (arrayType) => this.arrayType(arrayType, withIssues), (classType) => this.nameForNamedType(classType), (mapType) => this.mapType(mapType, withIssues), (enumType) => this.nameForNamedType(enumType), (unionType) => {
          const nullable = (0, TypeUtils_1.nullableFromUnion)(unionType);
          if (nullable !== null) return [
            this.kotlinType(nullable, withIssues),
            optional
          ];
          return this.nameForNamedType(unionType);
        });
      }
      emitUsageHeader() {
      }
      emitHeader() {
        if (this.leadingComments !== void 0) {
          this.emitComments(this.leadingComments);
        } else {
          this.emitUsageHeader();
        }
        this.ensureBlankLine();
        this.emitLine("package ", this._kotlinOptions.packageName);
        this.ensureBlankLine();
      }
      emitTopLevelPrimitive(t, name) {
        const elementType = this.kotlinType(t);
        this.emitLine([
          "typealias ",
          name,
          " = ",
          elementType,
          ""
        ]);
      }
      emitTopLevelArray(t, name) {
        const elementType = this.kotlinType(t.items);
        this.emitLine([
          "typealias ",
          name,
          " = ArrayList<",
          elementType,
          ">"
        ]);
      }
      emitTopLevelMap(t, name) {
        const elementType = this.kotlinType(t.values);
        this.emitLine([
          "typealias ",
          name,
          " = HashMap<String, ",
          elementType,
          ">"
        ]);
      }
      emitEmptyClassDefinition(c, className) {
        this.emitDescription(this.descriptionForType(c));
        this.emitClassAnnotations(c, className);
        this.emitLine("class ", className, "()");
      }
      emitClassDefinition(c, className) {
        if (c.getProperties().size === 0) {
          this.emitEmptyClassDefinition(c, className);
          return;
        }
        const kotlinType = (p) => {
          if (p.isOptional) {
            return [
              this.kotlinType(p.type, true, true),
              "?"
            ];
          }
          return this.kotlinType(p.type, true);
        };
        this.emitDescription(this.descriptionForType(c));
        this.emitClassAnnotations(c, className);
        this.emitLine("data class ", className, " (");
        this.indent(() => {
          let count = c.getProperties().size;
          let first = true;
          this.forEachClassProperty(c, "none", (name, jsonName, p) => {
            const nullable = p.type.kind === "union" && (0, TypeUtils_1.nullableFromUnion)(p.type) !== null;
            const nullableOrOptional = p.isOptional || p.type.kind === "null" || nullable;
            const last = --count === 0;
            const meta = [];
            const description = this.descriptionForClassProperty(c, jsonName);
            if (description !== void 0) {
              meta.push(() => this.emitDescription(description));
            }
            this.renameAttribute(name, jsonName, !nullableOrOptional, meta);
            if (meta.length > 0 && !first) {
              this.ensureBlankLine();
            }
            for (const emit of meta) {
              emit();
            }
            this.emitLine("val ", name, ": ", kotlinType(p), nullableOrOptional ? " = null" : "", last ? "" : ",");
            if (meta.length > 0 && !last) {
              this.ensureBlankLine();
            }
            first = false;
          });
        });
        this.emitClassDefinitionMethods(c, className);
      }
      emitClassDefinitionMethods(_c, _className) {
        this.emitLine(")");
      }
      emitClassAnnotations(_c, _className) {
      }
      renameAttribute(_name, _jsonName, _required, _meta) {
      }
      emitEnumDefinition(e, enumName) {
        this.emitDescription(this.descriptionForType(e));
        this.emitBlock([
          "enum class ",
          enumName
        ], () => {
          let count = e.cases.size;
          this.forEachEnumCase(e, "none", (name) => {
            this.emitLine(name, --count === 0 ? "" : ",");
          });
        });
      }
      emitUnionDefinition(u, unionName) {
        function sortBy(t) {
          const kind = t.kind;
          if (kind === "class") return kind;
          return `_${kind}`;
        }
        this.emitDescription(this.descriptionForType(u));
        const [maybeNull, nonNulls] = (0, TypeUtils_1.removeNullFromUnion)(u, sortBy);
        this.emitClassAnnotations(u, unionName);
        this.emitBlock([
          "sealed class ",
          unionName
        ], () => {
          {
            const table = [];
            this.forEachUnionMember(u, nonNulls, "none", null, (name, t) => {
              table.push([
                [
                  "class ",
                  name,
                  "(val value: ",
                  this.kotlinType(t),
                  ")"
                ],
                [
                  " : ",
                  unionName,
                  "()"
                ]
              ]);
            });
            if (maybeNull !== null) {
              table.push([
                [
                  "class ",
                  this.nameForUnionMember(u, maybeNull),
                  "()"
                ],
                [
                  " : ",
                  unionName,
                  "()"
                ]
              ]);
            }
            this.emitTable(table);
          }
          this.emitUnionDefinitionMethods(u, nonNulls, maybeNull, unionName);
        });
      }
      emitUnionDefinitionMethods(_u, _nonNulls, _maybeNull, _unionName) {
      }
      emitSourceStructure() {
        this.emitHeader();
        this.forEachTopLevel("leading", (t, name) => {
          if (t instanceof Type_1.ArrayType) {
            this.emitTopLevelArray(t, name);
          } else if (t instanceof Type_1.MapType) {
            this.emitTopLevelMap(t, name);
          } else if (t.isPrimitive()) {
            this.emitTopLevelPrimitive(t, name);
          }
        });
        this.forEachNamedType("leading-and-interposing", (c, n) => this.emitClassDefinition(c, n), (e, n) => this.emitEnumDefinition(e, n), (u, n) => this.emitUnionDefinition(u, n));
      }
    };
    exports.KotlinRenderer = KotlinRenderer;
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Kotlin/KotlinJacksonRenderer.js
var require_KotlinJacksonRenderer = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Kotlin/KotlinJacksonRenderer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.KotlinJacksonRenderer = void 0;
    var collection_utils_1 = require_dist();
    var Source_1 = require_Source();
    var Strings_1 = require_Strings();
    var Support_1 = require_Support();
    var Type_1 = require_Type2();
    var TypeUtils_1 = require_TypeUtils();
    var KotlinRenderer_1 = require_KotlinRenderer();
    var utils_1 = require_utils13();
    var KotlinJacksonRenderer = class extends KotlinRenderer_1.KotlinRenderer {
      constructor(targetLanguage, renderContext, _kotlinOptions) {
        super(targetLanguage, renderContext, _kotlinOptions);
      }
      unionMemberJsonValueGuard(t, _e) {
        return (0, TypeUtils_1.matchType)(
          t,
          (_anyType) => "is Any",
          (_nullType) => "null",
          (_boolType) => "is BooleanNode",
          (_integerType) => "is IntNode, is LongNode",
          (_doubleType) => "is DoubleNode",
          (_stringType) => "is TextNode",
          (_arrayType) => "is ArrayNode",
          // These could be stricter, but for now we don't allow maps
          // and objects in the same union
          (_classType) => "is ObjectNode",
          (_mapType) => "is ObjectNode",
          // This could be stricter, but for now we don't allow strings
          // and enums in the same union
          (_enumType) => "is TextNode",
          (_unionType) => (0, Support_1.mustNotHappen)()
        );
      }
      emitUsageHeader() {
        this.emitLine("// To parse the JSON, install jackson-module-kotlin and do:");
        this.emitLine("//");
        this.forEachTopLevel("none", (_, name) => {
          this.emitLine("//   val ", (0, Source_1.modifySource)(Strings_1.camelCase, name), " = ", name, ".fromJson(jsonString)");
        });
      }
      emitHeader() {
        super.emitHeader();
        this.emitMultiline(`import com.fasterxml.jackson.annotation.*
import com.fasterxml.jackson.core.*
import com.fasterxml.jackson.databind.*
import com.fasterxml.jackson.databind.deser.std.StdDeserializer
import com.fasterxml.jackson.databind.module.SimpleModule
import com.fasterxml.jackson.databind.node.*
import com.fasterxml.jackson.databind.ser.std.StdSerializer
import com.fasterxml.jackson.module.kotlin.*`);
        const hasUnions = (0, collection_utils_1.iterableSome)(this.typeGraph.allNamedTypes(), (t) => t instanceof Type_1.UnionType && (0, TypeUtils_1.nullableFromUnion)(t) === null);
        const hasEmptyObjects = (0, collection_utils_1.iterableSome)(this.typeGraph.allNamedTypes(), (c) => c instanceof Type_1.ClassType && c.getProperties().size === 0);
        if (hasUnions || this.haveEnums || hasEmptyObjects) {
          this.emitGenericConverter();
        }
        const converters = [];
        this.forEachEnum("none", (_, name) => {
          converters.push([
            [
              "convert(",
              name,
              "::class,"
            ],
            [
              " { ",
              name,
              ".fromValue(it.asText()) },"
            ],
            [
              ' { "\\"${it.value}\\"" })'
            ]
          ]);
        });
        this.forEachUnion("none", (_, name) => {
          converters.push([
            [
              "convert(",
              name,
              "::class,"
            ],
            [
              " { ",
              name,
              ".fromJson(it) },"
            ],
            [
              " { it.toJson() }, true)"
            ]
          ]);
        });
        this.ensureBlankLine();
        this.emitLine("val mapper = jacksonObjectMapper().apply {");
        this.indent(() => {
          this.emitLine("propertyNamingStrategy = PropertyNamingStrategy.LOWER_CAMEL_CASE");
          this.emitLine("setSerializationInclusion(JsonInclude.Include.NON_NULL)");
        });
        if (converters.length > 0) {
          this.indent(() => this.emitTable(converters));
        }
        this.emitLine("}");
      }
      emitTopLevelArray(t, name) {
        const elementType = this.kotlinType(t.items);
        this.emitBlock([
          "class ",
          name,
          "(elements: Collection<",
          elementType,
          ">) : ArrayList<",
          elementType,
          ">(elements)"
        ], () => {
          this.emitLine("fun toJson() = mapper.writeValueAsString(this)");
          this.ensureBlankLine();
          this.emitBlock("companion object", () => {
            this.emitLine("fun fromJson(json: String) = mapper.readValue<", name, ">(json)");
          });
        });
      }
      emitTopLevelMap(t, name) {
        const elementType = this.kotlinType(t.values);
        this.emitBlock([
          "class ",
          name,
          "(elements: Map<String, ",
          elementType,
          ">) : HashMap<String, ",
          elementType,
          ">(elements)"
        ], () => {
          this.emitLine("fun toJson() = mapper.writeValueAsString(this)");
          this.ensureBlankLine();
          this.emitBlock("companion object", () => {
            this.emitLine("fun fromJson(json: String) = mapper.readValue<", name, ">(json)");
          });
        });
      }
      jacksonRenameAttribute(propName, jsonName, required, ignore = false) {
        const escapedName = (0, utils_1.stringEscape)(jsonName);
        const namesDiffer = this.sourcelikeToString(propName) !== escapedName;
        const properties = [];
        const isPrefixBool = jsonName.startsWith("is");
        const propertyOpts = [];
        if (namesDiffer || isPrefixBool) {
          propertyOpts.push(`"${escapedName}"`);
        }
        if (required) {
          propertyOpts.push("required=true");
        }
        if (propertyOpts.length > 0) {
          properties.push([
            "@get:JsonProperty(",
            (0, collection_utils_1.arrayIntercalate)(", ", propertyOpts),
            ")"
          ]);
          properties.push([
            "@field:JsonProperty(",
            (0, collection_utils_1.arrayIntercalate)(", ", propertyOpts),
            ")"
          ]);
        }
        if (ignore) {
          properties.push("@get:JsonIgnore");
          properties.push("@field:JsonIgnore");
        }
        return properties.length === 0 ? void 0 : properties;
      }
      emitEmptyClassDefinition(c, className) {
        this.emitDescription(this.descriptionForType(c));
        this.emitLine("typealias ", className, " = JsonNode");
      }
      emitClassDefinitionMethods(c, className) {
        const isTopLevel = (0, collection_utils_1.iterableSome)(this.topLevels, ([_, top]) => top === c);
        if (isTopLevel) {
          this.emitBlock(")", () => {
            this.emitLine("fun toJson() = mapper.writeValueAsString(this)");
            this.ensureBlankLine();
            this.emitBlock("companion object", () => {
              this.emitLine("fun fromJson(json: String) = mapper.readValue<", className, ">(json)");
            });
          });
        } else {
          this.emitLine(")");
        }
      }
      renameAttribute(name, jsonName, required, meta) {
        const rename = this.jacksonRenameAttribute(name, jsonName, required);
        if (rename !== void 0) {
          meta.push(() => this.emitLine(rename));
        }
      }
      emitEnumDefinition(e, enumName) {
        this.emitDescription(this.descriptionForType(e));
        this.emitBlock([
          "enum class ",
          enumName,
          "(val value: String)"
        ], () => {
          let count = e.cases.size;
          this.forEachEnumCase(e, "none", (name, json) => {
            this.emitLine(name, `("${(0, utils_1.stringEscape)(json)}")`, --count === 0 ? ";" : ",");
          });
          this.ensureBlankLine();
          this.emitBlock("companion object", () => {
            this.emitBlock([
              "fun fromValue(value: String): ",
              enumName,
              " = when (value)"
            ], () => {
              const table = [];
              this.forEachEnumCase(e, "none", (name, json) => {
                table.push([
                  [
                    `"${(0, utils_1.stringEscape)(json)}"`
                  ],
                  [
                    " -> ",
                    name
                  ]
                ]);
              });
              table.push([
                [
                  "else"
                ],
                [
                  " -> throw IllegalArgumentException()"
                ]
              ]);
              this.emitTable(table);
            });
          });
        });
      }
      emitGenericConverter() {
        this.ensureBlankLine();
        this.emitMultiline(`
@Suppress("UNCHECKED_CAST")
private fun <T> ObjectMapper.convert(k: kotlin.reflect.KClass<*>, fromJson: (JsonNode) -> T, toJson: (T) -> String, isUnion: Boolean = false) = registerModule(SimpleModule().apply {
	addSerializer(k.java as Class<T>, object : StdSerializer<T>(k.java as Class<T>) {
			override fun serialize(value: T, gen: JsonGenerator, provider: SerializerProvider) = gen.writeRawValue(toJson(value))
	})
	addDeserializer(k.java as Class<T>, object : StdDeserializer<T>(k.java as Class<T>) {
			override fun deserialize(p: JsonParser, ctxt: DeserializationContext) = fromJson(p.readValueAsTree())
	})
})`);
      }
      emitUnionDefinitionMethods(u, nonNulls, maybeNull, unionName) {
        this.ensureBlankLine();
        this.emitLine("fun toJson(): String = mapper.writeValueAsString(when (this) {");
        this.indent(() => {
          const toJsonTable = [];
          this.forEachUnionMember(u, nonNulls, "none", null, (name) => {
            toJsonTable.push([
              [
                "is ",
                name
              ],
              [
                " -> this.value"
              ]
            ]);
          });
          if (maybeNull !== null) {
            const name = this.nameForUnionMember(u, maybeNull);
            toJsonTable.push([
              [
                "is ",
                name
              ],
              [
                ' -> "null"'
              ]
            ]);
          }
          this.emitTable(toJsonTable);
        });
        this.emitLine("})");
        this.ensureBlankLine();
        this.emitBlock("companion object", () => {
          this.emitLine("fun fromJson(jn: JsonNode): ", unionName, " = when (jn) {");
          this.indent(() => {
            const table = [];
            this.forEachUnionMember(u, nonNulls, "none", null, (name, t) => {
              table.push([
                [
                  this.unionMemberJsonValueGuard(t, "jn")
                ],
                [
                  " -> ",
                  name,
                  "(mapper.treeToValue(jn))"
                ]
              ]);
            });
            if (maybeNull !== null) {
              const name = this.nameForUnionMember(u, maybeNull);
              table.push([
                [
                  this.unionMemberJsonValueGuard(maybeNull, "jn")
                ],
                [
                  " -> ",
                  name,
                  "()"
                ]
              ]);
            }
            table.push([
              [
                "else"
              ],
              [
                " -> throw IllegalArgumentException()"
              ]
            ]);
            this.emitTable(table);
          });
          this.emitLine("}");
        });
      }
    };
    exports.KotlinJacksonRenderer = KotlinJacksonRenderer;
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Kotlin/KotlinKlaxonRenderer.js
var require_KotlinKlaxonRenderer = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Kotlin/KotlinKlaxonRenderer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.KotlinKlaxonRenderer = void 0;
    var collection_utils_1 = require_dist();
    var Source_1 = require_Source();
    var Strings_1 = require_Strings();
    var Support_1 = require_Support();
    var Type_1 = require_Type2();
    var TypeUtils_1 = require_TypeUtils();
    var KotlinRenderer_1 = require_KotlinRenderer();
    var utils_1 = require_utils13();
    var KotlinKlaxonRenderer = class extends KotlinRenderer_1.KotlinRenderer {
      constructor(targetLanguage, renderContext, _kotlinOptions) {
        super(targetLanguage, renderContext, _kotlinOptions);
      }
      unionMemberFromJsonValue(t, e) {
        return (0, TypeUtils_1.matchType)(t, (_anyType) => [
          e,
          ".inside"
        ], (_nullType) => "null", (_boolType) => [
          e,
          ".boolean"
        ], (_integerType) => [
          "(",
          e,
          ".int?.toLong() ?: ",
          e,
          ".longValue)"
        ], (_doubleType) => [
          e,
          ".double"
        ], (_stringType) => [
          e,
          ".string"
        ], (arrayType) => [
          e,
          ".array?.let { klaxon.parseFromJsonArray<",
          this.kotlinType(arrayType.items),
          ">(it) }"
        ], (_classType) => [
          e,
          ".obj?.let { klaxon.parseFromJsonObject<",
          this.kotlinType(t),
          ">(it) }"
        ], (_mapType) => [
          e,
          ".obj?.let { klaxon.parseFromJsonObject<",
          this.kotlinType(t),
          ">(it) }"
        ], (enumType) => [
          e,
          ".string?.let { ",
          this.kotlinType(enumType),
          ".fromValue(it) }"
        ], (_unionType) => (0, Support_1.mustNotHappen)());
      }
      unionMemberJsonValueGuard(t, _e) {
        return (0, TypeUtils_1.matchType)(
          t,
          (_anyType) => "is Any",
          (_nullType) => "null",
          (_boolType) => "is Boolean",
          (_integerType) => "is Int, is Long",
          (_doubleType) => "is Double",
          (_stringType) => "is String",
          (_arrayType) => "is JsonArray<*>",
          // These could be stricter, but for now we don't allow maps
          // and objects in the same union
          (_classType) => "is JsonObject",
          (_mapType) => "is JsonObject",
          // This could be stricter, but for now we don't allow strings
          // and enums in the same union
          (_enumType) => "is String",
          (_unionType) => (0, Support_1.mustNotHappen)()
        );
      }
      emitUsageHeader() {
        this.emitLine("// To parse the JSON, install Klaxon and do:");
        this.emitLine("//");
        this.forEachTopLevel("none", (_, name) => {
          this.emitLine("//   val ", (0, Source_1.modifySource)(Strings_1.camelCase, name), " = ", name, ".fromJson(jsonString)");
        });
      }
      emitHeader() {
        super.emitHeader();
        this.emitLine("import com.beust.klaxon.*");
        const hasUnions = (0, collection_utils_1.iterableSome)(this.typeGraph.allNamedTypes(), (t) => t instanceof Type_1.UnionType && (0, TypeUtils_1.nullableFromUnion)(t) === null);
        const hasEmptyObjects = (0, collection_utils_1.iterableSome)(this.typeGraph.allNamedTypes(), (c) => c instanceof Type_1.ClassType && c.getProperties().size === 0);
        if (hasUnions || this.haveEnums || hasEmptyObjects) {
          this.emitGenericConverter();
        }
        const converters = [];
        if (hasEmptyObjects) {
          converters.push([
            [
              ".convert(JsonObject::class,"
            ],
            [
              " { it.obj!! },"
            ],
            [
              " { it.toJsonString() })"
            ]
          ]);
        }
        this.forEachEnum("none", (_, name) => {
          converters.push([
            [
              ".convert(",
              name,
              "::class,"
            ],
            [
              " { ",
              name,
              ".fromValue(it.string!!) },"
            ],
            [
              ' { "\\"${it.value}\\"" })'
            ]
          ]);
        });
        this.forEachUnion("none", (_, name) => {
          converters.push([
            [
              ".convert(",
              name,
              "::class,"
            ],
            [
              " { ",
              name,
              ".fromJson(it) },"
            ],
            [
              " { it.toJson() }, true)"
            ]
          ]);
        });
        this.ensureBlankLine();
        this.emitLine("private val klaxon = Klaxon()");
        if (converters.length > 0) {
          this.indent(() => this.emitTable(converters));
        }
      }
      emitTopLevelArray(t, name) {
        const elementType = this.kotlinType(t.items);
        this.emitBlock([
          "class ",
          name,
          "(elements: Collection<",
          elementType,
          ">) : ArrayList<",
          elementType,
          ">(elements)"
        ], () => {
          this.emitLine("public fun toJson() = klaxon.toJsonString(this)");
          this.ensureBlankLine();
          this.emitBlock("companion object", () => {
            this.emitLine("public fun fromJson(json: String) = ", name, "(klaxon.parseArray<", elementType, ">(json)!!)");
          });
        });
      }
      emitTopLevelMap(t, name) {
        const elementType = this.kotlinType(t.values);
        this.emitBlock([
          "class ",
          name,
          "(elements: Map<String, ",
          elementType,
          ">) : HashMap<String, ",
          elementType,
          ">(elements)"
        ], () => {
          this.emitLine("public fun toJson() = klaxon.toJsonString(this)");
          this.ensureBlankLine();
          this.emitBlock("companion object", () => {
            this.emitBlock([
              "public fun fromJson(json: String) = ",
              name
            ], () => {
              this.emitLine("klaxon.parseJsonObject(java.io.StringReader(json)) as Map<String, ", elementType, ">");
            }, "paren");
          });
        });
      }
      klaxonRenameAttribute(propName, jsonName, ignore = false) {
        const escapedName = (0, utils_1.stringEscape)(jsonName);
        const namesDiffer = this.sourcelikeToString(propName) !== escapedName;
        const properties = [];
        if (namesDiffer) {
          properties.push([
            'name = "',
            escapedName,
            '"'
          ]);
        }
        if (ignore) {
          properties.push("ignored = true");
        }
        return properties.length === 0 ? void 0 : [
          "@Json(",
          (0, collection_utils_1.arrayIntercalate)(", ", properties),
          ")"
        ];
      }
      emitEmptyClassDefinition(c, className) {
        this.emitDescription(this.descriptionForType(c));
        this.emitLine("typealias ", className, " = JsonObject");
      }
      emitClassDefinitionMethods(c, className) {
        const isTopLevel = (0, collection_utils_1.iterableSome)(this.topLevels, ([_, top]) => top === c);
        if (isTopLevel) {
          this.emitBlock(")", () => {
            this.emitLine("public fun toJson() = klaxon.toJsonString(this)");
            this.ensureBlankLine();
            this.emitBlock("companion object", () => {
              this.emitLine("public fun fromJson(json: String) = klaxon.parse<", className, ">(json)");
            });
          });
        } else {
          this.emitLine(")");
        }
      }
      renameAttribute(name, jsonName, _required, meta) {
        const rename = this.klaxonRenameAttribute(name, jsonName);
        if (rename !== void 0) {
          meta.push(() => this.emitLine(rename));
        }
      }
      emitEnumDefinition(e, enumName) {
        this.emitDescription(this.descriptionForType(e));
        this.emitBlock([
          "enum class ",
          enumName,
          "(val value: String)"
        ], () => {
          let count = e.cases.size;
          this.forEachEnumCase(e, "none", (name, json) => {
            this.emitLine(name, `("${(0, utils_1.stringEscape)(json)}")`, --count === 0 ? ";" : ",");
          });
          this.ensureBlankLine();
          this.emitBlock("companion object", () => {
            this.emitBlock([
              "public fun fromValue(value: String): ",
              enumName,
              " = when (value)"
            ], () => {
              const table = [];
              this.forEachEnumCase(e, "none", (name, json) => {
                table.push([
                  [
                    `"${(0, utils_1.stringEscape)(json)}"`
                  ],
                  [
                    " -> ",
                    name
                  ]
                ]);
              });
              table.push([
                [
                  "else"
                ],
                [
                  " -> throw IllegalArgumentException()"
                ]
              ]);
              this.emitTable(table);
            });
          });
        });
      }
      emitGenericConverter() {
        this.ensureBlankLine();
        this.emitLine("private fun <T> Klaxon.convert(k: kotlin.reflect.KClass<*>, fromJson: (JsonValue) -> T, toJson: (T) -> String, isUnion: Boolean = false) =");
        this.indent(() => {
          this.emitLine("this.converter(object: Converter {");
          this.indent(() => {
            this.emitLine('@Suppress("UNCHECKED_CAST")');
            this.emitTable([
              [
                "override fun toJson(value: Any)",
                " = toJson(value as T)"
              ],
              [
                "override fun fromJson(jv: JsonValue)",
                " = fromJson(jv) as Any"
              ],
              [
                "override fun canConvert(cls: Class<*>)",
                " = cls == k.java || (isUnion && cls.superclass == k.java)"
              ]
            ]);
          });
          this.emitLine("})");
        });
      }
      emitUnionDefinitionMethods(u, nonNulls, maybeNull, unionName) {
        this.ensureBlankLine();
        this.emitLine("public fun toJson(): String = klaxon.toJsonString(when (this) {");
        this.indent(() => {
          const toJsonTable = [];
          this.forEachUnionMember(u, nonNulls, "none", null, (name) => {
            toJsonTable.push([
              [
                "is ",
                name
              ],
              [
                " -> this.value"
              ]
            ]);
          });
          if (maybeNull !== null) {
            const name = this.nameForUnionMember(u, maybeNull);
            toJsonTable.push([
              [
                "is ",
                name
              ],
              [
                ' -> "null"'
              ]
            ]);
          }
          this.emitTable(toJsonTable);
        });
        this.emitLine("})");
        this.ensureBlankLine();
        this.emitBlock("companion object", () => {
          this.emitLine("public fun fromJson(jv: JsonValue): ", unionName, " = when (jv.inside) {");
          this.indent(() => {
            const table = [];
            this.forEachUnionMember(u, nonNulls, "none", null, (name, t) => {
              table.push([
                [
                  this.unionMemberJsonValueGuard(t, "jv.inside")
                ],
                [
                  " -> ",
                  name,
                  "(",
                  this.unionMemberFromJsonValue(t, "jv"),
                  "!!)"
                ]
              ]);
            });
            if (maybeNull !== null) {
              const name = this.nameForUnionMember(u, maybeNull);
              table.push([
                [
                  this.unionMemberJsonValueGuard(maybeNull, "jv.inside")
                ],
                [
                  " -> ",
                  name,
                  "()"
                ]
              ]);
            }
            table.push([
              [
                "else"
              ],
              [
                " -> throw IllegalArgumentException()"
              ]
            ]);
            this.emitTable(table);
          });
          this.emitLine("}");
        });
      }
    };
    exports.KotlinKlaxonRenderer = KotlinKlaxonRenderer;
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Kotlin/KotlinXRenderer.js
var require_KotlinXRenderer = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Kotlin/KotlinXRenderer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.KotlinXRenderer = void 0;
    var Source_1 = require_Source();
    var Strings_1 = require_Strings();
    var KotlinRenderer_1 = require_KotlinRenderer();
    var utils_1 = require_utils13();
    var KotlinXRenderer = class extends KotlinRenderer_1.KotlinRenderer {
      constructor(targetLanguage, renderContext, _kotlinOptions) {
        super(targetLanguage, renderContext, _kotlinOptions);
      }
      anySourceType(optional) {
        return [
          "JsonElement",
          optional
        ];
      }
      arrayType(arrayType, withIssues = false, noOptional = false) {
        const valType = this.kotlinType(arrayType.items, withIssues, true);
        const name = this.sourcelikeToString(valType);
        if (name === "JsonObject" || name === "JsonElement") {
          return "JsonArray";
        }
        return super.arrayType(arrayType, withIssues, noOptional);
      }
      mapType(mapType, withIssues = false, noOptional = false) {
        const valType = this.kotlinType(mapType.values, withIssues, true);
        const name = this.sourcelikeToString(valType);
        if (name === "JsonObject" || name === "JsonElement") {
          return "JsonObject";
        }
        return super.mapType(mapType, withIssues, noOptional);
      }
      emitTopLevelMap(t, name) {
        const elementType = this.kotlinType(t.values);
        if (elementType === "JsonObject") {
          this.emitLine([
            "typealias ",
            name,
            " = JsonObject"
          ]);
        } else {
          super.emitTopLevelMap(t, name);
        }
      }
      emitTopLevelArray(t, name) {
        const elementType = this.kotlinType(t.items);
        this.emitLine([
          "typealias ",
          name,
          " = JsonArray<",
          elementType,
          ">"
        ]);
      }
      emitUsageHeader() {
        this.emitLine("// To parse the JSON, install kotlin's serialization plugin and do:");
        this.emitLine("//");
        const table = [];
        table.push([
          "// val ",
          "json",
          " = Json { allowStructuredMapKeys = true }"
        ]);
        this.forEachTopLevel("none", (_, name) => {
          table.push([
            "// val ",
            (0, Source_1.modifySource)(Strings_1.camelCase, name),
            ` = json.parse(${this.sourcelikeToString(name)}.serializer(), jsonString)`
          ]);
        });
        this.emitTable(table);
      }
      emitHeader() {
        super.emitHeader();
        this.emitLine("import kotlinx.serialization.*");
        this.emitLine("import kotlinx.serialization.json.*");
        this.emitLine("import kotlinx.serialization.descriptors.*");
        this.emitLine("import kotlinx.serialization.encoding.*");
      }
      emitClassAnnotations(_c, _className) {
        this.emitLine("@Serializable");
      }
      renameAttribute(name, jsonName, _required, meta) {
        const rename = this._rename(name, jsonName);
        if (rename !== void 0) {
          meta.push(() => this.emitLine(rename));
        }
      }
      _rename(propName, jsonName) {
        const escapedName = (0, utils_1.stringEscape)(jsonName);
        const namesDiffer = this.sourcelikeToString(propName) !== escapedName;
        if (namesDiffer) {
          return [
            '@SerialName("',
            escapedName,
            '")'
          ];
        }
        return void 0;
      }
      emitEnumDefinition(e, enumName) {
        this.emitDescription(this.descriptionForType(e));
        this.emitLine([
          "@Serializable"
        ]);
        this.emitBlock([
          "enum class ",
          enumName,
          "(val value: String)"
        ], () => {
          let count = e.cases.size;
          this.forEachEnumCase(e, "none", (name, json) => {
            const jsonEnum = (0, utils_1.stringEscape)(json);
            this.emitLine(`@SerialName("${jsonEnum}") `, name, `("${jsonEnum}")`, --count === 0 ? ";" : ",");
          });
        });
      }
    };
    exports.KotlinXRenderer = KotlinXRenderer;
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Kotlin/language.js
var require_language14 = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Kotlin/language.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.KotlinTargetLanguage = exports.kotlinLanguageConfig = exports.kotlinOptions = void 0;
    var RendererOptions_1 = require_RendererOptions();
    var Acronyms_1 = require_Acronyms();
    var Support_1 = require_Support();
    var TargetLanguage_1 = require_TargetLanguage();
    var KotlinJacksonRenderer_1 = require_KotlinJacksonRenderer();
    var KotlinKlaxonRenderer_1 = require_KotlinKlaxonRenderer();
    var KotlinRenderer_1 = require_KotlinRenderer();
    var KotlinXRenderer_1 = require_KotlinXRenderer();
    exports.kotlinOptions = {
      framework: new RendererOptions_1.EnumOption("framework", "Serialization framework", {
        "just-types": "None",
        jackson: "Jackson",
        klaxon: "Klaxon",
        kotlinx: "KotlinX"
      }, "klaxon"),
      acronymStyle: (0, Acronyms_1.acronymOption)(Acronyms_1.AcronymStyleOptions.Pascal),
      packageName: new RendererOptions_1.StringOption("package", "Package", "PACKAGE", "quicktype")
    };
    exports.kotlinLanguageConfig = {
      displayName: "Kotlin",
      names: [
        "kotlin"
      ],
      extension: "kt"
    };
    var KotlinTargetLanguage = class extends TargetLanguage_1.TargetLanguage {
      constructor() {
        super(exports.kotlinLanguageConfig);
      }
      getOptions() {
        return exports.kotlinOptions;
      }
      get supportsOptionalClassProperties() {
        return true;
      }
      get supportsUnionsWithBothNumberTypes() {
        return true;
      }
      makeRenderer(renderContext, untypedOptionValues) {
        const options = (0, RendererOptions_1.getOptionValues)(exports.kotlinOptions, untypedOptionValues);
        switch (options.framework) {
          case "None":
            return new KotlinRenderer_1.KotlinRenderer(this, renderContext, options);
          case "Jackson":
            return new KotlinJacksonRenderer_1.KotlinJacksonRenderer(this, renderContext, options);
          case "Klaxon":
            return new KotlinKlaxonRenderer_1.KotlinKlaxonRenderer(this, renderContext, options);
          case "KotlinX":
            return new KotlinXRenderer_1.KotlinXRenderer(this, renderContext, options);
          default:
            return (0, Support_1.assertNever)(options.framework);
        }
      }
    };
    exports.KotlinTargetLanguage = KotlinTargetLanguage;
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Kotlin/index.js
var require_Kotlin = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Kotlin/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.KotlinXRenderer = exports.KotlinKlaxonRenderer = exports.KotlinJacksonRenderer = exports.KotlinRenderer = exports.kotlinOptions = exports.KotlinTargetLanguage = void 0;
    var language_1 = require_language14();
    Object.defineProperty(exports, "KotlinTargetLanguage", {
      enumerable: true,
      get: function() {
        return language_1.KotlinTargetLanguage;
      }
    });
    Object.defineProperty(exports, "kotlinOptions", {
      enumerable: true,
      get: function() {
        return language_1.kotlinOptions;
      }
    });
    var KotlinRenderer_1 = require_KotlinRenderer();
    Object.defineProperty(exports, "KotlinRenderer", {
      enumerable: true,
      get: function() {
        return KotlinRenderer_1.KotlinRenderer;
      }
    });
    var KotlinJacksonRenderer_1 = require_KotlinJacksonRenderer();
    Object.defineProperty(exports, "KotlinJacksonRenderer", {
      enumerable: true,
      get: function() {
        return KotlinJacksonRenderer_1.KotlinJacksonRenderer;
      }
    });
    var KotlinKlaxonRenderer_1 = require_KotlinKlaxonRenderer();
    Object.defineProperty(exports, "KotlinKlaxonRenderer", {
      enumerable: true,
      get: function() {
        return KotlinKlaxonRenderer_1.KotlinKlaxonRenderer;
      }
    });
    var KotlinXRenderer_1 = require_KotlinXRenderer();
    Object.defineProperty(exports, "KotlinXRenderer", {
      enumerable: true,
      get: function() {
        return KotlinXRenderer_1.KotlinXRenderer;
      }
    });
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Objective-C/constants.js
var require_constants12 = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Objective-C/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.booleanPrefixes = exports.forbiddenPropertyNames = exports.keywords = void 0;
    exports.keywords = [
      /*
        "_Bool",
        "_Complex",
        "_Imaginary",
        */
      "asm",
      "atomic",
      "auto",
      "bool",
      "break",
      "case",
      "char",
      "const",
      "continue",
      "default",
      "do",
      "double",
      "else",
      "enum",
      "extern",
      "false",
      "float",
      "for",
      "goto",
      "if",
      "inline",
      "int",
      "long",
      "nil",
      "nonatomic",
      "register",
      "restrict",
      "retain",
      "return",
      "short",
      "signed",
      "sizeof",
      "static",
      "struct",
      "switch",
      "typedef",
      "typeof",
      "true",
      "union",
      "unsigned",
      "void",
      "volatile",
      "while"
    ];
    exports.forbiddenPropertyNames = [
      "id",
      "hash",
      "description",
      "init",
      "copy",
      "mutableCopy",
      "superclass",
      "debugDescription",
      "new"
    ];
    exports.booleanPrefixes = [
      "is",
      "are",
      "were",
      "was",
      "will",
      "all",
      "some",
      "many",
      "has",
      "have",
      "had",
      "does",
      "do",
      "requires",
      "require",
      "needs",
      "need"
    ];
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Objective-C/utils.js
var require_utils14 = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Objective-C/utils.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : {
        "default": mod
      };
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.forbiddenForEnumCases = exports.staticEnumValuesIdentifier = exports.DEFAULT_CLASS_PREFIX = void 0;
    exports.typeNameStyle = typeNameStyle;
    exports.propertyNameStyle = propertyNameStyle;
    exports.splitExtension = splitExtension;
    var unicode_properties_1 = __importDefault(require_main());
    var Strings_1 = require_Strings();
    var constants_1 = require_constants12();
    exports.DEFAULT_CLASS_PREFIX = "QT";
    function typeNameStyle(prefix, original) {
      const words = (0, Strings_1.splitIntoWords)(original);
      const result = (0, Strings_1.combineWords)(words, legalizeName, Strings_1.firstUpperWordStyle, Strings_1.firstUpperWordStyle, Strings_1.allUpperWordStyle, Strings_1.allUpperWordStyle, "", isStartCharacter);
      return (0, Strings_1.addPrefixIfNecessary)(prefix, result);
    }
    function propertyNameStyle(original, isBool = false) {
      if (original === "id") {
        original = "identifier";
      }
      let words = (0, Strings_1.splitIntoWords)(original);
      if (isBool) {
        if (words.length === 0) {
          words = [
            {
              word: "flag",
              isAcronym: false
            }
          ];
        } else if (!words[0].isAcronym && // @ts-expect-error needs strict type
        !constants_1.booleanPrefixes.includes(words[0].word)) {
          words = [
            {
              word: "is",
              isAcronym: false
            },
            ...words
          ];
        }
      }
      if (words.length > 0 && constants_1.forbiddenPropertyNames.includes(words[0].word)) {
        words = [
          {
            word: "the",
            isAcronym: false
          },
          ...words
        ];
      }
      return (0, Strings_1.combineWords)(words, legalizeName, Strings_1.allLowerWordStyle, Strings_1.firstUpperWordStyle, Strings_1.allLowerWordStyle, Strings_1.allUpperWordStyle, "", isStartCharacter);
    }
    function isStartCharacter(utf16Unit) {
      return unicode_properties_1.default.isAlphabetic(utf16Unit) || utf16Unit === 95;
    }
    function isPartCharacter(utf16Unit) {
      const category = unicode_properties_1.default.getCategory(utf16Unit);
      return [
        "Nd",
        "Pc",
        "Mn",
        "Mc"
      ].includes(category) || isStartCharacter(utf16Unit);
    }
    var legalizeName = (0, Strings_1.utf16LegalizeCharacters)(isPartCharacter);
    exports.staticEnumValuesIdentifier = "values";
    exports.forbiddenForEnumCases = [
      "new",
      exports.staticEnumValuesIdentifier
    ];
    function splitExtension(filename) {
      const i2 = filename.lastIndexOf(".");
      const extension = i2 !== -1 ? filename.split(".").pop() : "m";
      filename = i2 !== -1 ? filename.slice(0, i2) : filename;
      return [
        filename,
        extension !== null && extension !== void 0 ? extension : "m"
      ];
    }
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Objective-C/ObjectiveCRenderer.js
var require_ObjectiveCRenderer = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Objective-C/ObjectiveCRenderer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.ObjectiveCRenderer = void 0;
    var collection_utils_1 = require_dist();
    var ConvenienceRenderer_1 = require_ConvenienceRenderer();
    var Naming_1 = require_Naming();
    var Source_1 = require_Source();
    var Strings_1 = require_Strings();
    var Support_1 = require_Support();
    var Type_1 = require_Type2();
    var TypeUtils_1 = require_TypeUtils();
    var constants_1 = require_constants12();
    var utils_1 = require_utils14();
    var DEBUG = false;
    var ObjectiveCRenderer = class extends ConvenienceRenderer_1.ConvenienceRenderer {
      constructor(targetLanguage, renderContext, _options) {
        super(targetLanguage, renderContext);
        this._options = _options;
        if (_options.classPrefix === utils_1.DEFAULT_CLASS_PREFIX) {
          const aTopLevel = (0, Support_1.defined)((0, collection_utils_1.iterableFirst)(this.topLevels.keys()));
          this._classPrefix = this.inferClassPrefix(aTopLevel);
        } else {
          this._classPrefix = _options.classPrefix;
        }
      }
      inferClassPrefix(name) {
        const l = name.length;
        let firstNonUpper = 0;
        while (firstNonUpper < l && (0, Strings_1.fastIsUpperCase)(name.charCodeAt(firstNonUpper))) {
          firstNonUpper += 1;
        }
        if (firstNonUpper < 2) return utils_1.DEFAULT_CLASS_PREFIX;
        return name.slice(0, firstNonUpper - 1);
      }
      forbiddenNamesForGlobalNamespace() {
        return constants_1.keywords;
      }
      forbiddenForObjectProperties(_c, _className) {
        return {
          names: constants_1.forbiddenPropertyNames,
          includeGlobalForbidden: true
        };
      }
      forbiddenForEnumCases(_e, _enumName) {
        return {
          names: utils_1.forbiddenForEnumCases,
          includeGlobalForbidden: true
        };
      }
      makeNamedTypeNamer() {
        return (0, Naming_1.funPrefixNamer)("types", (rawName) => (0, utils_1.typeNameStyle)(this._classPrefix, rawName));
      }
      namerForObjectProperty(_, p) {
        return new Naming_1.Namer("properties", (s) => (0, utils_1.propertyNameStyle)(s, p.type.kind === "bool"), [
          "_",
          "the",
          "one",
          "some",
          "another"
        ]);
      }
      makeUnionMemberNamer() {
        return null;
      }
      makeEnumCaseNamer() {
        return new Naming_1.Namer("enum-cases", utils_1.propertyNameStyle, []);
      }
      namedTypeToNameForTopLevel(type) {
        return type;
      }
      emitDescriptionBlock(lines) {
        this.emitCommentLines(lines, {
          lineStart: "/// "
        });
      }
      emitBlock(line, f) {
        this.emitLine(line, " {");
        this.indent(f);
        this.emitLine("}");
      }
      emitMethod(declaration, f) {
        this.emitLine(declaration);
        this.emitLine("{");
        this.indent(f);
        this.emitLine("}");
      }
      emitExtraComments(...comments) {
        if (!this._options.extraComments) return;
        for (const comment of comments) {
          this.emitLine("// ", comment);
        }
      }
      startFile(basename, extension) {
        (0, Support_1.assert)(this._currentFilename === void 0, "Previous file wasn't finished");
        this._currentFilename = `${this.sourcelikeToString(basename)}.${extension}`;
      }
      finishFile() {
        super.finishFile((0, Support_1.defined)(this._currentFilename));
        this._currentFilename = void 0;
      }
      memoryAttribute(t, isNullable) {
        return (0, TypeUtils_1.matchType)(t, (_anyType) => "copy", (_nullType) => "copy", (_boolType) => isNullable ? "strong" : "assign", (_integerType) => isNullable ? "strong" : "assign", (_doubleType) => isNullable ? "strong" : "assign", (_stringType) => "copy", (_arrayType) => "copy", (_classType) => "strong", (_mapType) => "copy", (_enumType) => "assign", (unionType) => {
          const nullable = (0, TypeUtils_1.nullableFromUnion)(unionType);
          return nullable !== null ? this.memoryAttribute(nullable, true) : "copy";
        });
      }
      objcType(t, nullableOrBoxed = false) {
        return (0, TypeUtils_1.matchType)(
          t,
          (_anyType) => [
            "id",
            ""
          ],
          // For now, we're treating nulls just like any
          (_nullType) => [
            "id",
            ""
          ],
          (_boolType) => nullableOrBoxed ? [
            "NSNumber",
            " *"
          ] : [
            "BOOL",
            ""
          ],
          (_integerType) => nullableOrBoxed ? [
            "NSNumber",
            " *"
          ] : [
            "NSInteger",
            ""
          ],
          (_doubleType) => nullableOrBoxed ? [
            "NSNumber",
            " *"
          ] : [
            "double",
            ""
          ],
          (_stringType) => [
            "NSString",
            " *"
          ],
          (arrayType) => {
            const itemType = arrayType.items;
            const itemTypeName = this.objcType(itemType, true);
            if ((0, TypeUtils_1.isAnyOrNull)(itemType)) {
              return [
                "NSArray",
                " *"
              ];
            }
            return [
              [
                "NSArray<",
                itemTypeName,
                ">"
              ],
              " *"
            ];
          },
          (classType) => [
            this.nameForNamedType(classType),
            " *"
          ],
          (mapType) => [
            [
              "NSDictionary<NSString *, ",
              this.objcType(mapType.values, true),
              ">"
            ],
            " *"
          ],
          (enumType) => [
            this.nameForNamedType(enumType),
            " *"
          ],
          (unionType) => {
            const nullable = (0, TypeUtils_1.nullableFromUnion)(unionType);
            return nullable !== null ? this.objcType(nullable, true) : [
              "id",
              ""
            ];
          }
        );
      }
      jsonType(t) {
        return (0, TypeUtils_1.matchType)(
          t,
          (_anyType) => [
            "id",
            ""
          ],
          // For now, we're treating nulls just like any
          (_nullType) => [
            "id",
            ""
          ],
          (_boolType) => [
            "NSNumber",
            " *"
          ],
          (_integerType) => [
            "NSNumber",
            " *"
          ],
          (_doubleType) => [
            "NSNumber",
            " *"
          ],
          (_stringType) => [
            "NSString",
            " *"
          ],
          (_arrayType) => [
            "NSArray",
            " *"
          ],
          (_classType) => [
            "NSDictionary<NSString *, id>",
            " *"
          ],
          (mapType) => [
            [
              "NSDictionary<NSString *, ",
              this.jsonType(mapType.values),
              ">"
            ],
            " *"
          ],
          (_enumType) => [
            "NSString",
            " *"
          ],
          (unionType) => {
            const nullable = (0, TypeUtils_1.nullableFromUnion)(unionType);
            return nullable !== null ? this.jsonType(nullable) : [
              "id",
              ""
            ];
          }
        );
      }
      fromDynamicExpression(t, ...dynamic) {
        return (0, TypeUtils_1.matchType)(t, (_anyType) => dynamic, (_nullType) => dynamic, (_boolType) => dynamic, (_integerType) => dynamic, (_doubleType) => dynamic, (_stringType) => dynamic, (arrayType) => [
          "map(",
          dynamic,
          ", \u03BB(id x, ",
          this.fromDynamicExpression(arrayType.items, "x"),
          "))"
        ], (classType) => [
          "[",
          this.nameForNamedType(classType),
          " fromJSONDictionary:",
          dynamic,
          "]"
        ], (mapType) => [
          "map(",
          dynamic,
          ", \u03BB(id x, ",
          this.fromDynamicExpression(mapType.values, "x"),
          "))"
        ], (enumType) => [
          "[",
          this.nameForNamedType(enumType),
          " withValue:",
          dynamic,
          "]"
        ], (unionType) => {
          const nullable = (0, TypeUtils_1.nullableFromUnion)(unionType);
          return nullable !== null ? this.fromDynamicExpression(nullable, dynamic) : dynamic;
        });
      }
      toDynamicExpression(t, typed) {
        return (0, TypeUtils_1.matchType)(
          t,
          (_anyType) => [
            "NSNullify(",
            typed,
            ")"
          ],
          (_nullType) => [
            "NSNullify(",
            typed,
            ")"
          ],
          // Sadly, KVC
          (_boolType) => [
            typed,
            " ? @YES : @NO"
          ],
          (_integerType) => typed,
          (_doubleType) => typed,
          (_stringType) => typed,
          (arrayType) => {
            if (this.implicitlyConvertsFromJSON(arrayType)) {
              return typed;
            }
            return [
              "map(",
              typed,
              ", \u03BB(id x, ",
              this.toDynamicExpression(arrayType.items, "x"),
              "))"
            ];
          },
          (_classType) => [
            "[",
            typed,
            " JSONDictionary]"
          ],
          (mapType) => {
            if (this.implicitlyConvertsFromJSON(mapType)) {
              return typed;
            }
            return [
              "map(",
              typed,
              ", \u03BB(id x, ",
              this.toDynamicExpression(mapType.values, "x"),
              "))"
            ];
          },
          (_enumType) => [
            "[",
            typed,
            " value]"
          ],
          (unionType) => {
            const nullable = (0, TypeUtils_1.nullableFromUnion)(unionType);
            if (nullable !== null) {
              if (this.implicitlyConvertsFromJSON(nullable)) {
                return [
                  "NSNullify(",
                  typed,
                  ")"
                ];
              }
              return [
                "NSNullify(",
                this.toDynamicExpression(nullable, typed),
                ")"
              ];
            }
            return typed;
          }
        );
      }
      implicitlyConvertsFromJSON(t) {
        if (t instanceof Type_1.ClassType) {
          return false;
        }
        if (t instanceof Type_1.EnumType) {
          return false;
        }
        if (t instanceof Type_1.ArrayType) {
          return this.implicitlyConvertsFromJSON(t.items);
        }
        if (t instanceof Type_1.MapType) {
          return this.implicitlyConvertsFromJSON(t.values);
        }
        if (t.isPrimitive()) {
          return true;
        }
        if (t instanceof Type_1.UnionType) {
          const nullable = (0, TypeUtils_1.nullableFromUnion)(t);
          if (nullable !== null) {
            return this.implicitlyConvertsFromJSON(nullable);
          }
          return true;
        }
        return false;
      }
      implicitlyConvertsToJSON(t) {
        return this.implicitlyConvertsFromJSON(t) && "bool" !== t.kind;
      }
      emitPropertyAssignment(propertyName, jsonName, propertyType) {
        const name = [
          "_",
          propertyName
        ];
        (0, TypeUtils_1.matchType)(propertyType, (anyType) => this.emitLine(name, " = ", this.fromDynamicExpression(anyType, name), ";"), (nullType) => this.emitLine(name, " = ", this.fromDynamicExpression(nullType, name), ";"), (boolType) => this.emitLine(name, " = ", this.fromDynamicExpression(boolType, name), ";"), (integerType) => this.emitLine(name, " = ", this.fromDynamicExpression(integerType, name), ";"), (doubleType) => this.emitLine(name, " = ", this.fromDynamicExpression(doubleType, name), ";"), (stringType) => this.emitLine(name, " = ", this.fromDynamicExpression(stringType, name), ";"), (arrayType) => this.emitLine(name, " = ", this.fromDynamicExpression(arrayType, name), ";"), (classType) => this.emitLine(name, " = ", this.fromDynamicExpression(classType, [
          "(id)",
          name
        ]), ";"), (mapType) => {
          const itemType = mapType.values;
          this.emitLine(name, " = map(", name, ", ", [
            "\u03BB(id x, ",
            this.fromDynamicExpression(itemType, "x"),
            ")"
          ], ");");
        }, (enumType) => this.emitLine(name, " = ", this.fromDynamicExpression(enumType, [
          "(id)",
          name
        ]), ";"), (unionType) => {
          const nullable = (0, TypeUtils_1.nullableFromUnion)(unionType);
          if (nullable !== null) {
            this.emitPropertyAssignment(propertyName, jsonName, nullable);
          } else {
            this.emitLine(name, " = ", this.fromDynamicExpression(unionType, name), ";");
          }
        });
      }
      emitPrivateClassInterface(_, name) {
        this.emitLine("@interface ", name, " (JSONConversion)");
        this.emitLine("+ (instancetype)fromJSONDictionary:(NSDictionary *)dict;");
        this.emitLine("- (NSDictionary *)JSONDictionary;");
        this.emitLine("@end");
      }
      pointerAwareTypeName(t) {
        const name = t instanceof Type_1.Type ? this.objcType(t) : t;
        const isPointer = name[1] !== "";
        return isPointer ? name : [
          name,
          " "
        ];
      }
      emitNonClassTopLevelTypedef(t, name) {
        const nonPointerTypeName = this.objcType(t)[0];
        this.emitLine("typedef ", nonPointerTypeName, " ", name, ";");
      }
      topLevelFromDataPrototype(name) {
        return [
          name,
          " *_Nullable ",
          name,
          "FromData(NSData *data, NSError **error)"
        ];
      }
      topLevelFromJSONPrototype(name) {
        return [
          name,
          " *_Nullable ",
          name,
          "FromJSON(NSString *json, NSStringEncoding encoding, NSError **error)"
        ];
      }
      topLevelToDataPrototype(name, pad = false) {
        const parameter = this.variableNameForTopLevel(name);
        const padding = pad ? (0, Strings_1.repeatString)(" ", this.sourcelikeToString(name).length - "NSData".length) : "";
        return [
          "NSData",
          padding,
          " *_Nullable ",
          name,
          "ToData(",
          name,
          " *",
          parameter,
          ", NSError **error)"
        ];
      }
      topLevelToJSONPrototype(name, pad = false) {
        const parameter = this.variableNameForTopLevel(name);
        const padding = pad ? (0, Strings_1.repeatString)(" ", this.sourcelikeToString(name).length - "NSString".length) : "";
        return [
          "NSString",
          padding,
          " *_Nullable ",
          name,
          "ToJSON(",
          name,
          " *",
          parameter,
          ", NSStringEncoding encoding, NSError **error)"
        ];
      }
      emitTopLevelFunctionDeclarations(_, name) {
        this.emitLine(this.topLevelFromDataPrototype(name), ";");
        this.emitLine(this.topLevelFromJSONPrototype(name), ";");
        this.emitLine(this.topLevelToDataPrototype(name, true), ";");
        this.emitLine(this.topLevelToJSONPrototype(name, true), ";");
      }
      emitTryCatchAsError(inTry, inCatch) {
        this.emitLine("@try {");
        this.indent(inTry);
        this.emitLine("} @catch (NSException *exception) {");
        this.indent(() => {
          this.emitLine('*error = [NSError errorWithDomain:@"JSONSerialization" code:-1 userInfo:@{ @"exception": exception }];');
          inCatch();
        });
        this.emitLine("}");
      }
      emitTopLevelFunctions(t, name) {
        const parameter = this.variableNameForTopLevel(name);
        this.ensureBlankLine();
        this.emitMethod(this.topLevelFromDataPrototype(name), () => {
          this.emitTryCatchAsError(() => {
            this.emitLine("id json = [NSJSONSerialization JSONObjectWithData:data options:NSJSONReadingAllowFragments error:error];");
            this.emitLine("return *error ? nil : ", this.fromDynamicExpression(t, "json"), ";");
          }, () => this.emitLine("return nil;"));
        });
        this.ensureBlankLine();
        this.emitMethod(this.topLevelFromJSONPrototype(name), () => {
          this.emitLine("return ", name, "FromData([json dataUsingEncoding:encoding], error);");
        });
        this.ensureBlankLine();
        this.emitMethod(this.topLevelToDataPrototype(name), () => {
          this.emitTryCatchAsError(() => {
            this.emitLine("id json = ", this.toDynamicExpression(t, parameter), ";");
            this.emitLine("NSData *data = [NSJSONSerialization dataWithJSONObject:json options:kNilOptions error:error];");
            this.emitLine("return *error ? nil : data;");
          }, () => this.emitLine("return nil;"));
        });
        this.ensureBlankLine();
        this.emitMethod(this.topLevelToJSONPrototype(name), () => {
          this.emitLine("NSData *data = ", name, "ToData(", parameter, ", error);");
          this.emitLine("return data ? [[NSString alloc] initWithData:data encoding:encoding] : nil;");
        });
      }
      emitClassInterface(t, className) {
        const isTopLevel = (0, collection_utils_1.mapContains)(this.topLevels, t);
        this.emitDescription(this.descriptionForType(t));
        this.emitLine("@interface ", className, " : NSObject");
        if (DEBUG) this.emitLine("@property NSDictionary<NSString *, id> *_json;");
        this.emitPropertyTable(t, (name, _json, property) => {
          const attributes = [
            "nonatomic"
          ];
          if (property.type.isNullable) {
            attributes.push("nullable");
          }
          attributes.push(this.memoryAttribute(property.type, property.type.isNullable));
          return [
            [
              "@property ",
              [
                "(",
                attributes.join(", "),
                ")"
              ],
              " "
            ],
            [
              this.pointerAwareTypeName(property.type),
              name,
              ";"
            ]
          ];
        });
        if (!this._options.justTypes && isTopLevel) {
          if (t.getProperties().size > 0) this.ensureBlankLine();
          this.emitLine("+ (_Nullable instancetype)fromJSON:(NSString *)json encoding:(NSStringEncoding)encoding error:(NSError *_Nullable *)error;");
          this.emitLine("+ (_Nullable instancetype)fromData:(NSData *)data error:(NSError *_Nullable *)error;");
          this.emitLine("- (NSString *_Nullable)toJSON:(NSStringEncoding)encoding error:(NSError *_Nullable *)error;");
          this.emitLine("- (NSData *_Nullable)toData:(NSError *_Nullable *)error;");
        }
        this.emitLine("@end");
      }
      hasIrregularProperties(t) {
        let irregular = false;
        this.forEachClassProperty(t, "none", (name, jsonName) => {
          irregular = irregular || (0, Strings_1.stringEscape)(jsonName) !== this.sourcelikeToString(name);
        });
        return irregular;
      }
      hasUnsafeProperties(t) {
        let unsafe = false;
        this.forEachClassProperty(t, "none", (_, __, property) => {
          unsafe = unsafe || !this.implicitlyConvertsToJSON(property.type);
        });
        return unsafe;
      }
      // TODO Implement NSCopying
      emitClassImplementation(t, className) {
        const isTopLevel = (0, collection_utils_1.mapContains)(this.topLevels, t);
        const hasIrregularProperties = this.hasIrregularProperties(t);
        const hasUnsafeProperties = this.hasUnsafeProperties(t);
        this.emitLine("@implementation ", className);
        if (!this._options.justTypes) {
          this.emitMethod("+ (NSDictionary<NSString *, NSString *> *)properties", () => {
            this.emitLine("static NSDictionary<NSString *, NSString *> *properties;");
            this.emitLine("return properties = properties ? properties : @{");
            this.indent(() => {
              this.forEachClassProperty(t, "none", (name, jsonName) => this.emitLine(`@"${(0, Strings_1.stringEscape)(jsonName)}": @"`, name, '",'));
            });
            this.emitLine("};");
          });
          this.ensureBlankLine();
          if (isTopLevel) {
            this.emitMethod("+ (_Nullable instancetype)fromData:(NSData *)data error:(NSError *_Nullable *)error", () => {
              this.emitLine("return ", className, "FromData(data, error);");
            });
            this.ensureBlankLine();
            this.emitMethod("+ (_Nullable instancetype)fromJSON:(NSString *)json encoding:(NSStringEncoding)encoding error:(NSError *_Nullable *)error", () => {
              this.emitLine("return ", className, "FromJSON(json, encoding, error);");
            });
            this.ensureBlankLine();
          }
          this.emitMethod("+ (instancetype)fromJSONDictionary:(NSDictionary *)dict", () => {
            this.emitLine("return dict ? [[", className, " alloc] initWithJSONDictionary:dict] : nil;");
          });
          this.ensureBlankLine();
          this.emitMethod("- (instancetype)initWithJSONDictionary:(NSDictionary *)dict", () => {
            this.emitBlock("if (self = [super init])", () => {
              if (DEBUG) this.emitLine("__json = dict;");
              this.emitLine("[self setValuesForKeysWithDictionary:dict];");
              this.forEachClassProperty(t, "none", (name, jsonName, property) => {
                if (!this.implicitlyConvertsFromJSON(property.type)) {
                  this.emitPropertyAssignment(name, jsonName, property.type);
                }
              });
            });
            this.emitLine("return self;");
          });
          this.ensureBlankLine();
          this.emitMethod("- (void)setValue:(nullable id)value forKey:(NSString *)key", () => {
            this.emitLine("id resolved = ", className, ".properties[key];");
            this.emitLine("if (resolved) [super setValue:value forKey:resolved];");
          });
          this.ensureBlankLine();
          this.emitMethod("- (void)setNilValueForKey:(NSString *)key", () => {
            this.emitLine("id resolved = ", className, ".properties[key];");
            this.emitLine("if (resolved) [super setValue:@(0) forKey:resolved];");
          });
          this.ensureBlankLine();
          this.emitMethod("- (NSDictionary *)JSONDictionary", () => {
            if (!hasIrregularProperties && !hasUnsafeProperties) {
              this.emitLine("return [self dictionaryWithValuesForKeys:", className, ".properties.allValues];");
              return;
            }
            this.emitLine("id dict = [[self dictionaryWithValuesForKeys:", className, ".properties.allValues] mutableCopy];");
            this.ensureBlankLine();
            if (hasIrregularProperties) {
              this.emitExtraComments("Rewrite property names that differ in JSON");
              this.emitBlock([
                "for (id jsonName in ",
                className,
                ".properties)"
              ], () => {
                this.emitLine("id propertyName = ", className, ".properties[jsonName];");
                this.emitBlock("if (![jsonName isEqualToString:propertyName])", () => {
                  this.emitLine("dict[jsonName] = dict[propertyName];");
                  this.emitLine("[dict removeObjectForKey:propertyName];");
                });
              });
            }
            if (hasUnsafeProperties) {
              this.ensureBlankLine();
              this.emitExtraComments("Map values that need translation");
              this.emitLine("[dict addEntriesFromDictionary:@{");
              this.indent(() => {
                this.forEachClassProperty(t, "none", (propertyName, jsonKey, property) => {
                  if (!this.implicitlyConvertsToJSON(property.type)) {
                    const key = (0, Strings_1.stringEscape)(jsonKey);
                    const name = [
                      "_",
                      propertyName
                    ];
                    this.emitLine('@"', key, '": ', this.toDynamicExpression(property.type, name), ",");
                  }
                });
              });
              this.emitLine("}];");
            }
            this.ensureBlankLine();
            this.emitLine("return dict;");
          });
          if (isTopLevel) {
            this.ensureBlankLine();
            this.emitMethod("- (NSData *_Nullable)toData:(NSError *_Nullable *)error", () => {
              this.emitLine("return ", className, "ToData(self, error);");
            });
            this.ensureBlankLine();
            this.emitMethod("- (NSString *_Nullable)toJSON:(NSStringEncoding)encoding error:(NSError *_Nullable *)error", () => {
              this.emitLine("return ", className, "ToJSON(self, encoding, error);");
            });
          }
        }
        this.emitLine("@end");
      }
      emitMark(label) {
        this.ensureBlankLine();
        this.emitLine(`#pragma mark - ${label}`);
        this.ensureBlankLine();
      }
      variableNameForTopLevel(name) {
        const camelCaseName = (0, Source_1.modifySource)((serialized) => {
          serialized = serialized.slice(this._classPrefix.length);
          return (0, Strings_1.camelCase)(serialized);
        }, name);
        return camelCaseName;
      }
      emitPseudoEnumInterface(enumType, enumName) {
        this.emitDescription(this.descriptionForType(enumType));
        this.emitLine("@interface ", enumName, " : NSObject");
        this.emitLine("@property (nonatomic, readonly, copy) NSString *value;");
        this.emitLine("+ (instancetype _Nullable)withValue:(NSString *)value;");
        this.forEachEnumCase(enumType, "none", (name, _) => {
          this.emitLine("+ (", enumName, " *)", name, ";");
        });
        this.emitLine("@end");
      }
      emitPseudoEnumImplementation(enumType, enumName) {
        this.emitLine("@implementation ", enumName);
        const instances = [
          enumName,
          ".",
          utils_1.staticEnumValuesIdentifier
        ];
        this.emitMethod([
          "+ (NSDictionary<NSString *, ",
          enumName,
          " *> *)",
          utils_1.staticEnumValuesIdentifier
        ], () => {
          this.emitLine("static NSDictionary<NSString *, ", enumName, " *> *", utils_1.staticEnumValuesIdentifier, ";");
          this.emitLine("return ", utils_1.staticEnumValuesIdentifier, " = ", utils_1.staticEnumValuesIdentifier, " ? ", utils_1.staticEnumValuesIdentifier, " : @{");
          this.indent(() => {
            this.forEachEnumCase(enumType, "none", (_, jsonValue) => {
              const value = [
                '@"',
                (0, Strings_1.stringEscape)(jsonValue),
                '"'
              ];
              this.emitLine(value, ": [[", enumName, " alloc] initWithValue:", value, "],");
            });
          });
          this.emitLine("};");
        });
        this.ensureBlankLine();
        this.forEachEnumCase(enumType, "none", (name, jsonValue) => {
          this.emitLine("+ (", enumName, " *)", name, " { return ", instances, '[@"', (0, Strings_1.stringEscape)(jsonValue), '"]; }');
        });
        this.ensureBlankLine();
        this.emitMethod("+ (instancetype _Nullable)withValue:(NSString *)value", () => this.emitLine("return ", instances, "[value];"));
        this.ensureBlankLine();
        this.emitMethod("- (instancetype)initWithValue:(NSString *)value", () => {
          this.emitLine("if (self = [super init]) _value = value;");
          this.emitLine("return self;");
        });
        this.ensureBlankLine();
        this.emitLine("- (NSUInteger)hash { return _value.hash; }");
        this.emitLine("@end");
      }
      emitSourceStructure(proposedFilename) {
        const fileMode = proposedFilename !== "stdout";
        if (!fileMode) {
          const firstTopLevel = (0, Support_1.defined)((0, collection_utils_1.mapFirst)(this.topLevels));
          proposedFilename = this.sourcelikeToString(this.nameForNamedType(firstTopLevel)) + ".m";
        }
        const [filename, extension] = (0, utils_1.splitExtension)(proposedFilename);
        if (this._options.features.interface) {
          this.startFile(filename, "h");
          if (this.leadingComments !== void 0) {
            this.emitComments(this.leadingComments);
          } else if (!this._options.justTypes) {
            this.emitCommentLines([
              "To parse this JSON:",
              ""
            ]);
            this.emitLine("//   NSError *error;");
            this.forEachTopLevel("none", (t, topLevelName) => {
              const fromJsonExpression = t instanceof Type_1.ClassType ? [
                "[",
                topLevelName,
                " fromJSON:json encoding:NSUTF8Encoding error:&error];"
              ] : [
                topLevelName,
                "FromJSON(json, NSUTF8Encoding, &error);"
              ];
              this.emitLine("//   ", topLevelName, " *", this.variableNameForTopLevel(topLevelName), " = ", fromJsonExpression);
            });
          }
          this.ensureBlankLine();
          this.emitLine("#import <Foundation/Foundation.h>");
          this.ensureBlankLine();
          this.forEachNamedType("none", (_, className) => this.emitLine("@class ", className, ";"), (_, enumName) => this.emitLine("@class ", enumName, ";"), () => null);
          this.ensureBlankLine();
          this.ensureBlankLine();
          this.emitLine("NS_ASSUME_NONNULL_BEGIN");
          this.ensureBlankLine();
          if (this.haveEnums) {
            this.emitMark("Boxed enums");
            this.forEachEnum("leading-and-interposing", (t, n) => this.emitPseudoEnumInterface(t, n));
          }
          this.forEachTopLevel("leading-and-interposing", (t, n) => this.emitNonClassTopLevelTypedef(t, n), (t) => !(t instanceof Type_1.ClassType));
          const hasTopLevelNonClassTypes = (0, collection_utils_1.iterableSome)(this.topLevels, ([_, t]) => !(t instanceof Type_1.ClassType));
          if (!this._options.justTypes && (hasTopLevelNonClassTypes || this._options.marshallingFunctions)) {
            this.ensureBlankLine();
            this.emitMark("Top-level marshaling functions");
            this.forEachTopLevel(
              "leading-and-interposing",
              (t, n) => this.emitTopLevelFunctionDeclarations(t, n),
              // Objective-C developers get freaked out by C functions, so we don't
              // declare them for top-level object types (we always need them for non-object types)
              (t) => this._options.marshallingFunctions || !(t instanceof Type_1.ClassType)
            );
          }
          this.emitMark("Object interfaces");
          this.forEachNamedType("leading-and-interposing", (c, className) => this.emitClassInterface(c, className), () => null, () => null);
          this.ensureBlankLine();
          this.emitLine("NS_ASSUME_NONNULL_END");
          this.finishFile();
        }
        if (this._options.features.implementation) {
          this.startFile(filename, extension);
          this.emitLine(`#import "${filename}.h"`);
          this.ensureBlankLine();
          if (!this._options.justTypes) {
            this.ensureBlankLine();
            this.emitExtraComments("Shorthand for simple blocks");
            this.emitLine("#define \u03BB(decl, expr) (^(decl) { return (expr); })");
            this.ensureBlankLine();
            this.emitExtraComments("nil \u2192 NSNull conversion for JSON dictionaries");
            this.emitBlock("static id NSNullify(id _Nullable x)", () => this.emitLine("return (x == nil || x == NSNull.null) ? NSNull.null : x;"));
            this.ensureBlankLine();
            this.emitLine("NS_ASSUME_NONNULL_BEGIN");
            this.ensureBlankLine();
            if (this._options.extraComments) {
              this.emitMark("Private model interfaces");
            }
            this.forEachNamedType("leading-and-interposing", (c, className) => this.emitPrivateClassInterface(c, className), () => null, () => null);
            if (this.haveEnums) {
              if (this._options.extraComments) {
                this.ensureBlankLine();
                this.emitExtraComments("These enum-like reference types are needed so that enum", "values can be contained by NSArray and NSDictionary.");
                this.ensureBlankLine();
              }
              this.forEachEnum("leading-and-interposing", (t, n) => this.emitPseudoEnumImplementation(t, n));
            }
            this.ensureBlankLine();
            this.emitMapFunction();
            this.ensureBlankLine();
            this.emitMark("JSON serialization");
            this.forEachTopLevel("leading-and-interposing", (t, n) => this.emitTopLevelFunctions(t, n));
          }
          this.forEachNamedType("leading-and-interposing", (c, className) => this.emitClassImplementation(c, className), () => null, () => null);
          if (!this._options.justTypes) {
            this.ensureBlankLine();
            this.emitLine("NS_ASSUME_NONNULL_END");
          }
          this.finishFile();
        }
      }
      get needsMap() {
        function needsMap(t) {
          return t instanceof Type_1.MapType || t instanceof Type_1.ArrayType || t instanceof Type_1.ClassType && (0, collection_utils_1.mapSome)(t.getProperties(), (p) => needsMap(p.type));
        }
        return (0, collection_utils_1.iterableSome)(this.typeGraph.allTypesUnordered(), needsMap);
      }
      emitMapFunction() {
        if (this.needsMap) {
          this.emitMultiline(`static id map(id collection, id (^f)(id value)) {
	id result = nil;
	if ([collection isKindOfClass:NSArray.class]) {
			result = [NSMutableArray arrayWithCapacity:[collection count]];
			for (id x in collection) [result addObject:f(x)];
	} else if ([collection isKindOfClass:NSDictionary.class]) {
			result = [NSMutableDictionary dictionaryWithCapacity:[collection count]];
			for (id key in collection) [result setObject:f([collection objectForKey:key]) forKey:key];
	}
	return result;
}`);
        }
      }
    };
    exports.ObjectiveCRenderer = ObjectiveCRenderer;
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Objective-C/language.js
var require_language15 = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Objective-C/language.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.ObjectiveCTargetLanguage = exports.objectiveCLanguageConfig = exports.objectiveCOptions = void 0;
    var RendererOptions_1 = require_RendererOptions();
    var TargetLanguage_1 = require_TargetLanguage();
    var ObjectiveCRenderer_1 = require_ObjectiveCRenderer();
    var utils_1 = require_utils14();
    exports.objectiveCOptions = {
      features: new RendererOptions_1.EnumOption("features", "Interface and implementation", {
        all: {
          interface: true,
          implementation: true
        },
        interface: {
          interface: true,
          implementation: false
        },
        implementation: {
          interface: false,
          implementation: true
        }
      }, "all"),
      justTypes: new RendererOptions_1.BooleanOption("just-types", "Plain types only", false),
      marshallingFunctions: new RendererOptions_1.BooleanOption("functions", "C-style functions", false),
      classPrefix: new RendererOptions_1.StringOption("class-prefix", "Class prefix", "PREFIX", utils_1.DEFAULT_CLASS_PREFIX),
      extraComments: new RendererOptions_1.BooleanOption("extra-comments", "Extra comments", false)
    };
    exports.objectiveCLanguageConfig = {
      displayName: "Objective-C",
      names: [
        "objc",
        "objective-c",
        "objectivec"
      ],
      extension: "m"
    };
    var ObjectiveCTargetLanguage = class extends TargetLanguage_1.TargetLanguage {
      constructor() {
        super(exports.objectiveCLanguageConfig);
      }
      getOptions() {
        return exports.objectiveCOptions;
      }
      makeRenderer(renderContext, untypedOptionValues) {
        return new ObjectiveCRenderer_1.ObjectiveCRenderer(this, renderContext, (0, RendererOptions_1.getOptionValues)(exports.objectiveCOptions, untypedOptionValues));
      }
    };
    exports.ObjectiveCTargetLanguage = ObjectiveCTargetLanguage;
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Objective-C/index.js
var require_Objective_C = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Objective-C/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.ObjectiveCRenderer = exports.objectiveCOptions = exports.ObjectiveCTargetLanguage = void 0;
    var language_1 = require_language15();
    Object.defineProperty(exports, "ObjectiveCTargetLanguage", {
      enumerable: true,
      get: function() {
        return language_1.ObjectiveCTargetLanguage;
      }
    });
    Object.defineProperty(exports, "objectiveCOptions", {
      enumerable: true,
      get: function() {
        return language_1.objectiveCOptions;
      }
    });
    var ObjectiveCRenderer_1 = require_ObjectiveCRenderer();
    Object.defineProperty(exports, "ObjectiveCRenderer", {
      enumerable: true,
      get: function() {
        return ObjectiveCRenderer_1.ObjectiveCRenderer;
      }
    });
  }
});

// ../../../../../node_modules/.deno/lodash@4.17.21/node_modules/lodash/lodash.js
var require_lodash = __commonJS({
  "../../../../../node_modules/.deno/lodash@4.17.21/node_modules/lodash/lodash.js"(exports, module) {
    (function() {
      var undefined2;
      var VERSION = "4.17.21";
      var LARGE_ARRAY_SIZE = 200;
      var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT = "Expected a function", INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
      var HASH_UNDEFINED = "__lodash_hash_undefined__";
      var MAX_MEMOIZE_SIZE = 500;
      var PLACEHOLDER = "__lodash_placeholder__";
      var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
      var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
      var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
      var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
      var HOT_COUNT = 800, HOT_SPAN = 16;
      var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
      var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 17976931348623157e292, NAN = 0 / 0;
      var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
      var wrapFlags = [
        [
          "ary",
          WRAP_ARY_FLAG
        ],
        [
          "bind",
          WRAP_BIND_FLAG
        ],
        [
          "bindKey",
          WRAP_BIND_KEY_FLAG
        ],
        [
          "curry",
          WRAP_CURRY_FLAG
        ],
        [
          "curryRight",
          WRAP_CURRY_RIGHT_FLAG
        ],
        [
          "flip",
          WRAP_FLIP_FLAG
        ],
        [
          "partial",
          WRAP_PARTIAL_FLAG
        ],
        [
          "partialRight",
          WRAP_PARTIAL_RIGHT_FLAG
        ],
        [
          "rearg",
          WRAP_REARG_FLAG
        ]
      ];
      var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", domExcTag = "[object DOMException]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]", weakSetTag = "[object WeakSet]";
      var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
      var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
      var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
      var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
      var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
      var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
      var reTrimStart = /^\s+/;
      var reWhitespace = /\s/;
      var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
      var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
      var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
      var reEscapeChar = /\\(\\)?/g;
      var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
      var reFlags = /\w*$/;
      var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
      var reIsBinary = /^0b[01]+$/i;
      var reIsHostCtor = /^\[object .+?Constructor\]$/;
      var reIsOctal = /^0o[0-7]+$/i;
      var reIsUint = /^(?:0|[1-9]\d*)$/;
      var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
      var reNoMatch = /($^)/;
      var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
      var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
      var rsApos = "['\u2019]", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
      var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [
        rsNonAstral,
        rsRegional,
        rsSurrPair
      ].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [
        rsDingbat,
        rsRegional,
        rsSurrPair
      ].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [
        rsNonAstral + rsCombo + "?",
        rsCombo,
        rsRegional,
        rsSurrPair,
        rsAstral
      ].join("|") + ")";
      var reApos = RegExp(rsApos, "g");
      var reComboMark = RegExp(rsCombo, "g");
      var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
      var reUnicodeWord = RegExp([
        rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [
          rsBreak,
          rsUpper,
          "$"
        ].join("|") + ")",
        rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [
          rsBreak,
          rsUpper + rsMiscLower,
          "$"
        ].join("|") + ")",
        rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
        rsUpper + "+" + rsOptContrUpper,
        rsOrdUpper,
        rsOrdLower,
        rsDigits,
        rsEmoji
      ].join("|"), "g");
      var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
      var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
      var contextProps = [
        "Array",
        "Buffer",
        "DataView",
        "Date",
        "Error",
        "Float32Array",
        "Float64Array",
        "Function",
        "Int8Array",
        "Int16Array",
        "Int32Array",
        "Map",
        "Math",
        "Object",
        "Promise",
        "RegExp",
        "Set",
        "String",
        "Symbol",
        "TypeError",
        "Uint8Array",
        "Uint8ClampedArray",
        "Uint16Array",
        "Uint32Array",
        "WeakMap",
        "_",
        "clearTimeout",
        "isFinite",
        "parseInt",
        "setTimeout"
      ];
      var templateCounter = -1;
      var typedArrayTags = {};
      typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
      typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
      var cloneableTags = {};
      cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
      cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
      var deburredLetters = {
        // Latin-1 Supplement block.
        "\xC0": "A",
        "\xC1": "A",
        "\xC2": "A",
        "\xC3": "A",
        "\xC4": "A",
        "\xC5": "A",
        "\xE0": "a",
        "\xE1": "a",
        "\xE2": "a",
        "\xE3": "a",
        "\xE4": "a",
        "\xE5": "a",
        "\xC7": "C",
        "\xE7": "c",
        "\xD0": "D",
        "\xF0": "d",
        "\xC8": "E",
        "\xC9": "E",
        "\xCA": "E",
        "\xCB": "E",
        "\xE8": "e",
        "\xE9": "e",
        "\xEA": "e",
        "\xEB": "e",
        "\xCC": "I",
        "\xCD": "I",
        "\xCE": "I",
        "\xCF": "I",
        "\xEC": "i",
        "\xED": "i",
        "\xEE": "i",
        "\xEF": "i",
        "\xD1": "N",
        "\xF1": "n",
        "\xD2": "O",
        "\xD3": "O",
        "\xD4": "O",
        "\xD5": "O",
        "\xD6": "O",
        "\xD8": "O",
        "\xF2": "o",
        "\xF3": "o",
        "\xF4": "o",
        "\xF5": "o",
        "\xF6": "o",
        "\xF8": "o",
        "\xD9": "U",
        "\xDA": "U",
        "\xDB": "U",
        "\xDC": "U",
        "\xF9": "u",
        "\xFA": "u",
        "\xFB": "u",
        "\xFC": "u",
        "\xDD": "Y",
        "\xFD": "y",
        "\xFF": "y",
        "\xC6": "Ae",
        "\xE6": "ae",
        "\xDE": "Th",
        "\xFE": "th",
        "\xDF": "ss",
        // Latin Extended-A block.
        "\u0100": "A",
        "\u0102": "A",
        "\u0104": "A",
        "\u0101": "a",
        "\u0103": "a",
        "\u0105": "a",
        "\u0106": "C",
        "\u0108": "C",
        "\u010A": "C",
        "\u010C": "C",
        "\u0107": "c",
        "\u0109": "c",
        "\u010B": "c",
        "\u010D": "c",
        "\u010E": "D",
        "\u0110": "D",
        "\u010F": "d",
        "\u0111": "d",
        "\u0112": "E",
        "\u0114": "E",
        "\u0116": "E",
        "\u0118": "E",
        "\u011A": "E",
        "\u0113": "e",
        "\u0115": "e",
        "\u0117": "e",
        "\u0119": "e",
        "\u011B": "e",
        "\u011C": "G",
        "\u011E": "G",
        "\u0120": "G",
        "\u0122": "G",
        "\u011D": "g",
        "\u011F": "g",
        "\u0121": "g",
        "\u0123": "g",
        "\u0124": "H",
        "\u0126": "H",
        "\u0125": "h",
        "\u0127": "h",
        "\u0128": "I",
        "\u012A": "I",
        "\u012C": "I",
        "\u012E": "I",
        "\u0130": "I",
        "\u0129": "i",
        "\u012B": "i",
        "\u012D": "i",
        "\u012F": "i",
        "\u0131": "i",
        "\u0134": "J",
        "\u0135": "j",
        "\u0136": "K",
        "\u0137": "k",
        "\u0138": "k",
        "\u0139": "L",
        "\u013B": "L",
        "\u013D": "L",
        "\u013F": "L",
        "\u0141": "L",
        "\u013A": "l",
        "\u013C": "l",
        "\u013E": "l",
        "\u0140": "l",
        "\u0142": "l",
        "\u0143": "N",
        "\u0145": "N",
        "\u0147": "N",
        "\u014A": "N",
        "\u0144": "n",
        "\u0146": "n",
        "\u0148": "n",
        "\u014B": "n",
        "\u014C": "O",
        "\u014E": "O",
        "\u0150": "O",
        "\u014D": "o",
        "\u014F": "o",
        "\u0151": "o",
        "\u0154": "R",
        "\u0156": "R",
        "\u0158": "R",
        "\u0155": "r",
        "\u0157": "r",
        "\u0159": "r",
        "\u015A": "S",
        "\u015C": "S",
        "\u015E": "S",
        "\u0160": "S",
        "\u015B": "s",
        "\u015D": "s",
        "\u015F": "s",
        "\u0161": "s",
        "\u0162": "T",
        "\u0164": "T",
        "\u0166": "T",
        "\u0163": "t",
        "\u0165": "t",
        "\u0167": "t",
        "\u0168": "U",
        "\u016A": "U",
        "\u016C": "U",
        "\u016E": "U",
        "\u0170": "U",
        "\u0172": "U",
        "\u0169": "u",
        "\u016B": "u",
        "\u016D": "u",
        "\u016F": "u",
        "\u0171": "u",
        "\u0173": "u",
        "\u0174": "W",
        "\u0175": "w",
        "\u0176": "Y",
        "\u0177": "y",
        "\u0178": "Y",
        "\u0179": "Z",
        "\u017B": "Z",
        "\u017D": "Z",
        "\u017A": "z",
        "\u017C": "z",
        "\u017E": "z",
        "\u0132": "IJ",
        "\u0133": "ij",
        "\u0152": "Oe",
        "\u0153": "oe",
        "\u0149": "'n",
        "\u017F": "s"
      };
      var htmlEscapes = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;"
      };
      var htmlUnescapes = {
        "&amp;": "&",
        "&lt;": "<",
        "&gt;": ">",
        "&quot;": '"',
        "&#39;": "'"
      };
      var stringEscapes = {
        "\\": "\\",
        "'": "'",
        "\n": "n",
        "\r": "r",
        "\u2028": "u2028",
        "\u2029": "u2029"
      };
      var freeParseFloat = parseFloat, freeParseInt = parseInt;
      var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
      var freeSelf = typeof self == "object" && self && self.Object === Object && self;
      var root = freeGlobal || freeSelf || Function("return this")();
      var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
      var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
      var moduleExports = freeModule && freeModule.exports === freeExports;
      var freeProcess = moduleExports && freeGlobal.process;
      var nodeUtil = function() {
        try {
          var types = freeModule && freeModule.require && freeModule.require("util").types;
          if (types) {
            return types;
          }
          return freeProcess && freeProcess.binding && freeProcess.binding("util");
        } catch (e) {
        }
      }();
      var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
      function apply(func, thisArg, args) {
        switch (args.length) {
          case 0:
            return func.call(thisArg);
          case 1:
            return func.call(thisArg, args[0]);
          case 2:
            return func.call(thisArg, args[0], args[1]);
          case 3:
            return func.call(thisArg, args[0], args[1], args[2]);
        }
        return func.apply(thisArg, args);
      }
      function arrayAggregator(array, setter, iteratee, accumulator) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          var value = array[index];
          setter(accumulator, value, iteratee(value), array);
        }
        return accumulator;
      }
      function arrayEach(array, iteratee) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (iteratee(array[index], index, array) === false) {
            break;
          }
        }
        return array;
      }
      function arrayEachRight(array, iteratee) {
        var length = array == null ? 0 : array.length;
        while (length--) {
          if (iteratee(array[length], length, array) === false) {
            break;
          }
        }
        return array;
      }
      function arrayEvery(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (!predicate(array[index], index, array)) {
            return false;
          }
        }
        return true;
      }
      function arrayFilter(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
        while (++index < length) {
          var value = array[index];
          if (predicate(value, index, array)) {
            result[resIndex++] = value;
          }
        }
        return result;
      }
      function arrayIncludes(array, value) {
        var length = array == null ? 0 : array.length;
        return !!length && baseIndexOf(array, value, 0) > -1;
      }
      function arrayIncludesWith(array, value, comparator) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (comparator(value, array[index])) {
            return true;
          }
        }
        return false;
      }
      function arrayMap(array, iteratee) {
        var index = -1, length = array == null ? 0 : array.length, result = Array(length);
        while (++index < length) {
          result[index] = iteratee(array[index], index, array);
        }
        return result;
      }
      function arrayPush(array, values) {
        var index = -1, length = values.length, offset = array.length;
        while (++index < length) {
          array[offset + index] = values[index];
        }
        return array;
      }
      function arrayReduce(array, iteratee, accumulator, initAccum) {
        var index = -1, length = array == null ? 0 : array.length;
        if (initAccum && length) {
          accumulator = array[++index];
        }
        while (++index < length) {
          accumulator = iteratee(accumulator, array[index], index, array);
        }
        return accumulator;
      }
      function arrayReduceRight(array, iteratee, accumulator, initAccum) {
        var length = array == null ? 0 : array.length;
        if (initAccum && length) {
          accumulator = array[--length];
        }
        while (length--) {
          accumulator = iteratee(accumulator, array[length], length, array);
        }
        return accumulator;
      }
      function arraySome(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (predicate(array[index], index, array)) {
            return true;
          }
        }
        return false;
      }
      var asciiSize = baseProperty("length");
      function asciiToArray(string) {
        return string.split("");
      }
      function asciiWords(string) {
        return string.match(reAsciiWord) || [];
      }
      function baseFindKey(collection, predicate, eachFunc) {
        var result;
        eachFunc(collection, function(value, key, collection2) {
          if (predicate(value, key, collection2)) {
            result = key;
            return false;
          }
        });
        return result;
      }
      function baseFindIndex(array, predicate, fromIndex, fromRight) {
        var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
        while (fromRight ? index-- : ++index < length) {
          if (predicate(array[index], index, array)) {
            return index;
          }
        }
        return -1;
      }
      function baseIndexOf(array, value, fromIndex) {
        return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
      }
      function baseIndexOfWith(array, value, fromIndex, comparator) {
        var index = fromIndex - 1, length = array.length;
        while (++index < length) {
          if (comparator(array[index], value)) {
            return index;
          }
        }
        return -1;
      }
      function baseIsNaN(value) {
        return value !== value;
      }
      function baseMean(array, iteratee) {
        var length = array == null ? 0 : array.length;
        return length ? baseSum(array, iteratee) / length : NAN;
      }
      function baseProperty(key) {
        return function(object) {
          return object == null ? undefined2 : object[key];
        };
      }
      function basePropertyOf(object) {
        return function(key) {
          return object == null ? undefined2 : object[key];
        };
      }
      function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
        eachFunc(collection, function(value, index, collection2) {
          accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection2);
        });
        return accumulator;
      }
      function baseSortBy(array, comparer) {
        var length = array.length;
        array.sort(comparer);
        while (length--) {
          array[length] = array[length].value;
        }
        return array;
      }
      function baseSum(array, iteratee) {
        var result, index = -1, length = array.length;
        while (++index < length) {
          var current = iteratee(array[index]);
          if (current !== undefined2) {
            result = result === undefined2 ? current : result + current;
          }
        }
        return result;
      }
      function baseTimes(n, iteratee) {
        var index = -1, result = Array(n);
        while (++index < n) {
          result[index] = iteratee(index);
        }
        return result;
      }
      function baseToPairs(object, props) {
        return arrayMap(props, function(key) {
          return [
            key,
            object[key]
          ];
        });
      }
      function baseTrim(string) {
        return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
      }
      function baseUnary(func) {
        return function(value) {
          return func(value);
        };
      }
      function baseValues(object, props) {
        return arrayMap(props, function(key) {
          return object[key];
        });
      }
      function cacheHas(cache, key) {
        return cache.has(key);
      }
      function charsStartIndex(strSymbols, chrSymbols) {
        var index = -1, length = strSymbols.length;
        while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
        }
        return index;
      }
      function charsEndIndex(strSymbols, chrSymbols) {
        var index = strSymbols.length;
        while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
        }
        return index;
      }
      function countHolders(array, placeholder) {
        var length = array.length, result = 0;
        while (length--) {
          if (array[length] === placeholder) {
            ++result;
          }
        }
        return result;
      }
      var deburrLetter = basePropertyOf(deburredLetters);
      var escapeHtmlChar = basePropertyOf(htmlEscapes);
      function escapeStringChar(chr) {
        return "\\" + stringEscapes[chr];
      }
      function getValue(object, key) {
        return object == null ? undefined2 : object[key];
      }
      function hasUnicode(string) {
        return reHasUnicode.test(string);
      }
      function hasUnicodeWord(string) {
        return reHasUnicodeWord.test(string);
      }
      function iteratorToArray(iterator) {
        var data, result = [];
        while (!(data = iterator.next()).done) {
          result.push(data.value);
        }
        return result;
      }
      function mapToArray(map) {
        var index = -1, result = Array(map.size);
        map.forEach(function(value, key) {
          result[++index] = [
            key,
            value
          ];
        });
        return result;
      }
      function overArg(func, transform) {
        return function(arg) {
          return func(transform(arg));
        };
      }
      function replaceHolders(array, placeholder) {
        var index = -1, length = array.length, resIndex = 0, result = [];
        while (++index < length) {
          var value = array[index];
          if (value === placeholder || value === PLACEHOLDER) {
            array[index] = PLACEHOLDER;
            result[resIndex++] = index;
          }
        }
        return result;
      }
      function setToArray(set) {
        var index = -1, result = Array(set.size);
        set.forEach(function(value) {
          result[++index] = value;
        });
        return result;
      }
      function setToPairs(set) {
        var index = -1, result = Array(set.size);
        set.forEach(function(value) {
          result[++index] = [
            value,
            value
          ];
        });
        return result;
      }
      function strictIndexOf(array, value, fromIndex) {
        var index = fromIndex - 1, length = array.length;
        while (++index < length) {
          if (array[index] === value) {
            return index;
          }
        }
        return -1;
      }
      function strictLastIndexOf(array, value, fromIndex) {
        var index = fromIndex + 1;
        while (index--) {
          if (array[index] === value) {
            return index;
          }
        }
        return index;
      }
      function stringSize(string) {
        return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
      }
      function stringToArray(string) {
        return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
      }
      function trimmedEndIndex(string) {
        var index = string.length;
        while (index-- && reWhitespace.test(string.charAt(index))) {
        }
        return index;
      }
      var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
      function unicodeSize(string) {
        var result = reUnicode.lastIndex = 0;
        while (reUnicode.test(string)) {
          ++result;
        }
        return result;
      }
      function unicodeToArray(string) {
        return string.match(reUnicode) || [];
      }
      function unicodeWords(string) {
        return string.match(reUnicodeWord) || [];
      }
      var runInContext = function runInContext2(context) {
        context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));
        var Array2 = context.Array, Date2 = context.Date, Error2 = context.Error, Function2 = context.Function, Math2 = context.Math, Object2 = context.Object, RegExp2 = context.RegExp, String2 = context.String, TypeError2 = context.TypeError;
        var arrayProto = Array2.prototype, funcProto = Function2.prototype, objectProto = Object2.prototype;
        var coreJsData = context["__core-js_shared__"];
        var funcToString = funcProto.toString;
        var hasOwnProperty = objectProto.hasOwnProperty;
        var idCounter = 0;
        var maskSrcKey = function() {
          var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
          return uid ? "Symbol(src)_1." + uid : "";
        }();
        var nativeObjectToString = objectProto.toString;
        var objectCtorString = funcToString.call(Object2);
        var oldDash = root._;
        var reIsNative = RegExp2("^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
        var Buffer2 = moduleExports ? context.Buffer : undefined2, Symbol2 = context.Symbol, Uint8Array2 = context.Uint8Array, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : undefined2, getPrototype = overArg(Object2.getPrototypeOf, Object2), objectCreate = Object2.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : undefined2, symIterator = Symbol2 ? Symbol2.iterator : undefined2, symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined2;
        var defineProperty = function() {
          try {
            var func = getNative(Object2, "defineProperty");
            func({}, "", {});
            return func;
          } catch (e) {
          }
        }();
        var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout, ctxNow = Date2 && Date2.now !== root.Date.now && Date2.now, ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;
        var nativeCeil = Math2.ceil, nativeFloor = Math2.floor, nativeGetSymbols = Object2.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : undefined2, nativeIsFinite = context.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object2.keys, Object2), nativeMax = Math2.max, nativeMin = Math2.min, nativeNow = Date2.now, nativeParseInt = context.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto.reverse;
        var DataView2 = getNative(context, "DataView"), Map2 = getNative(context, "Map"), Promise2 = getNative(context, "Promise"), Set2 = getNative(context, "Set"), WeakMap2 = getNative(context, "WeakMap"), nativeCreate = getNative(Object2, "create");
        var metaMap = WeakMap2 && new WeakMap2();
        var realNames = {};
        var dataViewCtorString = toSource(DataView2), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
        var symbolProto = Symbol2 ? Symbol2.prototype : undefined2, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined2, symbolToString = symbolProto ? symbolProto.toString : undefined2;
        function lodash(value) {
          if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
            if (value instanceof LodashWrapper) {
              return value;
            }
            if (hasOwnProperty.call(value, "__wrapped__")) {
              return wrapperClone(value);
            }
          }
          return new LodashWrapper(value);
        }
        var baseCreate = /* @__PURE__ */ function() {
          function object() {
          }
          return function(proto) {
            if (!isObject(proto)) {
              return {};
            }
            if (objectCreate) {
              return objectCreate(proto);
            }
            object.prototype = proto;
            var result2 = new object();
            object.prototype = undefined2;
            return result2;
          };
        }();
        function baseLodash() {
        }
        function LodashWrapper(value, chainAll) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__chain__ = !!chainAll;
          this.__index__ = 0;
          this.__values__ = undefined2;
        }
        lodash.templateSettings = {
          /**
           * Used to detect `data` property values to be HTML-escaped.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          "escape": reEscape,
          /**
           * Used to detect code to be evaluated.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          "evaluate": reEvaluate,
          /**
           * Used to detect `data` property values to inject.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          "interpolate": reInterpolate,
          /**
           * Used to reference the data object in the template text.
           *
           * @memberOf _.templateSettings
           * @type {string}
           */
          "variable": "",
          /**
           * Used to import variables into the compiled template.
           *
           * @memberOf _.templateSettings
           * @type {Object}
           */
          "imports": {
            /**
             * A reference to the `lodash` function.
             *
             * @memberOf _.templateSettings.imports
             * @type {Function}
             */
            "_": lodash
          }
        };
        lodash.prototype = baseLodash.prototype;
        lodash.prototype.constructor = lodash;
        LodashWrapper.prototype = baseCreate(baseLodash.prototype);
        LodashWrapper.prototype.constructor = LodashWrapper;
        function LazyWrapper(value) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__dir__ = 1;
          this.__filtered__ = false;
          this.__iteratees__ = [];
          this.__takeCount__ = MAX_ARRAY_LENGTH;
          this.__views__ = [];
        }
        function lazyClone() {
          var result2 = new LazyWrapper(this.__wrapped__);
          result2.__actions__ = copyArray(this.__actions__);
          result2.__dir__ = this.__dir__;
          result2.__filtered__ = this.__filtered__;
          result2.__iteratees__ = copyArray(this.__iteratees__);
          result2.__takeCount__ = this.__takeCount__;
          result2.__views__ = copyArray(this.__views__);
          return result2;
        }
        function lazyReverse() {
          if (this.__filtered__) {
            var result2 = new LazyWrapper(this);
            result2.__dir__ = -1;
            result2.__filtered__ = true;
          } else {
            result2 = this.clone();
            result2.__dir__ *= -1;
          }
          return result2;
        }
        function lazyValue() {
          var array = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray(array), isRight = dir < 0, arrLength = isArr ? array.length : 0, view = getView(0, arrLength, this.__views__), start = view.start, end = view.end, length = end - start, index = isRight ? end : start - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length, this.__takeCount__);
          if (!isArr || !isRight && arrLength == length && takeCount == length) {
            return baseWrapperValue(array, this.__actions__);
          }
          var result2 = [];
          outer: while (length-- && resIndex < takeCount) {
            index += dir;
            var iterIndex = -1, value = array[index];
            while (++iterIndex < iterLength) {
              var data = iteratees[iterIndex], iteratee2 = data.iteratee, type = data.type, computed = iteratee2(value);
              if (type == LAZY_MAP_FLAG) {
                value = computed;
              } else if (!computed) {
                if (type == LAZY_FILTER_FLAG) {
                  continue outer;
                } else {
                  break outer;
                }
              }
            }
            result2[resIndex++] = value;
          }
          return result2;
        }
        LazyWrapper.prototype = baseCreate(baseLodash.prototype);
        LazyWrapper.prototype.constructor = LazyWrapper;
        function Hash(entries) {
          var index = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function hashClear() {
          this.__data__ = nativeCreate ? nativeCreate(null) : {};
          this.size = 0;
        }
        function hashDelete(key) {
          var result2 = this.has(key) && delete this.__data__[key];
          this.size -= result2 ? 1 : 0;
          return result2;
        }
        function hashGet(key) {
          var data = this.__data__;
          if (nativeCreate) {
            var result2 = data[key];
            return result2 === HASH_UNDEFINED ? undefined2 : result2;
          }
          return hasOwnProperty.call(data, key) ? data[key] : undefined2;
        }
        function hashHas(key) {
          var data = this.__data__;
          return nativeCreate ? data[key] !== undefined2 : hasOwnProperty.call(data, key);
        }
        function hashSet(key, value) {
          var data = this.__data__;
          this.size += this.has(key) ? 0 : 1;
          data[key] = nativeCreate && value === undefined2 ? HASH_UNDEFINED : value;
          return this;
        }
        Hash.prototype.clear = hashClear;
        Hash.prototype["delete"] = hashDelete;
        Hash.prototype.get = hashGet;
        Hash.prototype.has = hashHas;
        Hash.prototype.set = hashSet;
        function ListCache(entries) {
          var index = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function listCacheClear() {
          this.__data__ = [];
          this.size = 0;
        }
        function listCacheDelete(key) {
          var data = this.__data__, index = assocIndexOf(data, key);
          if (index < 0) {
            return false;
          }
          var lastIndex = data.length - 1;
          if (index == lastIndex) {
            data.pop();
          } else {
            splice.call(data, index, 1);
          }
          --this.size;
          return true;
        }
        function listCacheGet(key) {
          var data = this.__data__, index = assocIndexOf(data, key);
          return index < 0 ? undefined2 : data[index][1];
        }
        function listCacheHas(key) {
          return assocIndexOf(this.__data__, key) > -1;
        }
        function listCacheSet(key, value) {
          var data = this.__data__, index = assocIndexOf(data, key);
          if (index < 0) {
            ++this.size;
            data.push([
              key,
              value
            ]);
          } else {
            data[index][1] = value;
          }
          return this;
        }
        ListCache.prototype.clear = listCacheClear;
        ListCache.prototype["delete"] = listCacheDelete;
        ListCache.prototype.get = listCacheGet;
        ListCache.prototype.has = listCacheHas;
        ListCache.prototype.set = listCacheSet;
        function MapCache(entries) {
          var index = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function mapCacheClear() {
          this.size = 0;
          this.__data__ = {
            "hash": new Hash(),
            "map": new (Map2 || ListCache)(),
            "string": new Hash()
          };
        }
        function mapCacheDelete(key) {
          var result2 = getMapData(this, key)["delete"](key);
          this.size -= result2 ? 1 : 0;
          return result2;
        }
        function mapCacheGet(key) {
          return getMapData(this, key).get(key);
        }
        function mapCacheHas(key) {
          return getMapData(this, key).has(key);
        }
        function mapCacheSet(key, value) {
          var data = getMapData(this, key), size2 = data.size;
          data.set(key, value);
          this.size += data.size == size2 ? 0 : 1;
          return this;
        }
        MapCache.prototype.clear = mapCacheClear;
        MapCache.prototype["delete"] = mapCacheDelete;
        MapCache.prototype.get = mapCacheGet;
        MapCache.prototype.has = mapCacheHas;
        MapCache.prototype.set = mapCacheSet;
        function SetCache(values2) {
          var index = -1, length = values2 == null ? 0 : values2.length;
          this.__data__ = new MapCache();
          while (++index < length) {
            this.add(values2[index]);
          }
        }
        function setCacheAdd(value) {
          this.__data__.set(value, HASH_UNDEFINED);
          return this;
        }
        function setCacheHas(value) {
          return this.__data__.has(value);
        }
        SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
        SetCache.prototype.has = setCacheHas;
        function Stack(entries) {
          var data = this.__data__ = new ListCache(entries);
          this.size = data.size;
        }
        function stackClear() {
          this.__data__ = new ListCache();
          this.size = 0;
        }
        function stackDelete(key) {
          var data = this.__data__, result2 = data["delete"](key);
          this.size = data.size;
          return result2;
        }
        function stackGet(key) {
          return this.__data__.get(key);
        }
        function stackHas(key) {
          return this.__data__.has(key);
        }
        function stackSet(key, value) {
          var data = this.__data__;
          if (data instanceof ListCache) {
            var pairs = data.__data__;
            if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
              pairs.push([
                key,
                value
              ]);
              this.size = ++data.size;
              return this;
            }
            data = this.__data__ = new MapCache(pairs);
          }
          data.set(key, value);
          this.size = data.size;
          return this;
        }
        Stack.prototype.clear = stackClear;
        Stack.prototype["delete"] = stackDelete;
        Stack.prototype.get = stackGet;
        Stack.prototype.has = stackHas;
        Stack.prototype.set = stackSet;
        function arrayLikeKeys(value, inherited) {
          var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes(value.length, String2) : [], length = result2.length;
          for (var key in value) {
            if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
            (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
            isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
            isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
            isIndex(key, length)))) {
              result2.push(key);
            }
          }
          return result2;
        }
        function arraySample(array) {
          var length = array.length;
          return length ? array[baseRandom(0, length - 1)] : undefined2;
        }
        function arraySampleSize(array, n) {
          return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
        }
        function arrayShuffle(array) {
          return shuffleSelf(copyArray(array));
        }
        function assignMergeValue(object, key, value) {
          if (value !== undefined2 && !eq(object[key], value) || value === undefined2 && !(key in object)) {
            baseAssignValue(object, key, value);
          }
        }
        function assignValue(object, key, value) {
          var objValue = object[key];
          if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined2 && !(key in object)) {
            baseAssignValue(object, key, value);
          }
        }
        function assocIndexOf(array, key) {
          var length = array.length;
          while (length--) {
            if (eq(array[length][0], key)) {
              return length;
            }
          }
          return -1;
        }
        function baseAggregator(collection, setter, iteratee2, accumulator) {
          baseEach(collection, function(value, key, collection2) {
            setter(accumulator, value, iteratee2(value), collection2);
          });
          return accumulator;
        }
        function baseAssign(object, source) {
          return object && copyObject(source, keys(source), object);
        }
        function baseAssignIn(object, source) {
          return object && copyObject(source, keysIn(source), object);
        }
        function baseAssignValue(object, key, value) {
          if (key == "__proto__" && defineProperty) {
            defineProperty(object, key, {
              "configurable": true,
              "enumerable": true,
              "value": value,
              "writable": true
            });
          } else {
            object[key] = value;
          }
        }
        function baseAt(object, paths) {
          var index = -1, length = paths.length, result2 = Array2(length), skip = object == null;
          while (++index < length) {
            result2[index] = skip ? undefined2 : get(object, paths[index]);
          }
          return result2;
        }
        function baseClamp(number, lower, upper) {
          if (number === number) {
            if (upper !== undefined2) {
              number = number <= upper ? number : upper;
            }
            if (lower !== undefined2) {
              number = number >= lower ? number : lower;
            }
          }
          return number;
        }
        function baseClone(value, bitmask, customizer, key, object, stack) {
          var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
          if (customizer) {
            result2 = object ? customizer(value, key, object, stack) : customizer(value);
          }
          if (result2 !== undefined2) {
            return result2;
          }
          if (!isObject(value)) {
            return value;
          }
          var isArr = isArray(value);
          if (isArr) {
            result2 = initCloneArray(value);
            if (!isDeep) {
              return copyArray(value, result2);
            }
          } else {
            var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
            if (isBuffer(value)) {
              return cloneBuffer(value, isDeep);
            }
            if (tag == objectTag || tag == argsTag || isFunc && !object) {
              result2 = isFlat || isFunc ? {} : initCloneObject(value);
              if (!isDeep) {
                return isFlat ? copySymbolsIn(value, baseAssignIn(result2, value)) : copySymbols(value, baseAssign(result2, value));
              }
            } else {
              if (!cloneableTags[tag]) {
                return object ? value : {};
              }
              result2 = initCloneByTag(value, tag, isDeep);
            }
          }
          stack || (stack = new Stack());
          var stacked = stack.get(value);
          if (stacked) {
            return stacked;
          }
          stack.set(value, result2);
          if (isSet(value)) {
            value.forEach(function(subValue) {
              result2.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
            });
          } else if (isMap(value)) {
            value.forEach(function(subValue, key2) {
              result2.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
            });
          }
          var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
          var props = isArr ? undefined2 : keysFunc(value);
          arrayEach(props || value, function(subValue, key2) {
            if (props) {
              key2 = subValue;
              subValue = value[key2];
            }
            assignValue(result2, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
          });
          return result2;
        }
        function baseConforms(source) {
          var props = keys(source);
          return function(object) {
            return baseConformsTo(object, source, props);
          };
        }
        function baseConformsTo(object, source, props) {
          var length = props.length;
          if (object == null) {
            return !length;
          }
          object = Object2(object);
          while (length--) {
            var key = props[length], predicate = source[key], value = object[key];
            if (value === undefined2 && !(key in object) || !predicate(value)) {
              return false;
            }
          }
          return true;
        }
        function baseDelay(func, wait, args) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return setTimeout2(function() {
            func.apply(undefined2, args);
          }, wait);
        }
        function baseDifference(array, values2, iteratee2, comparator) {
          var index = -1, includes2 = arrayIncludes, isCommon = true, length = array.length, result2 = [], valuesLength = values2.length;
          if (!length) {
            return result2;
          }
          if (iteratee2) {
            values2 = arrayMap(values2, baseUnary(iteratee2));
          }
          if (comparator) {
            includes2 = arrayIncludesWith;
            isCommon = false;
          } else if (values2.length >= LARGE_ARRAY_SIZE) {
            includes2 = cacheHas;
            isCommon = false;
            values2 = new SetCache(values2);
          }
          outer: while (++index < length) {
            var value = array[index], computed = iteratee2 == null ? value : iteratee2(value);
            value = comparator || value !== 0 ? value : 0;
            if (isCommon && computed === computed) {
              var valuesIndex = valuesLength;
              while (valuesIndex--) {
                if (values2[valuesIndex] === computed) {
                  continue outer;
                }
              }
              result2.push(value);
            } else if (!includes2(values2, computed, comparator)) {
              result2.push(value);
            }
          }
          return result2;
        }
        var baseEach = createBaseEach(baseForOwn);
        var baseEachRight = createBaseEach(baseForOwnRight, true);
        function baseEvery(collection, predicate) {
          var result2 = true;
          baseEach(collection, function(value, index, collection2) {
            result2 = !!predicate(value, index, collection2);
            return result2;
          });
          return result2;
        }
        function baseExtremum(array, iteratee2, comparator) {
          var index = -1, length = array.length;
          while (++index < length) {
            var value = array[index], current = iteratee2(value);
            if (current != null && (computed === undefined2 ? current === current && !isSymbol(current) : comparator(current, computed))) {
              var computed = current, result2 = value;
            }
          }
          return result2;
        }
        function baseFill(array, value, start, end) {
          var length = array.length;
          start = toInteger(start);
          if (start < 0) {
            start = -start > length ? 0 : length + start;
          }
          end = end === undefined2 || end > length ? length : toInteger(end);
          if (end < 0) {
            end += length;
          }
          end = start > end ? 0 : toLength(end);
          while (start < end) {
            array[start++] = value;
          }
          return array;
        }
        function baseFilter(collection, predicate) {
          var result2 = [];
          baseEach(collection, function(value, index, collection2) {
            if (predicate(value, index, collection2)) {
              result2.push(value);
            }
          });
          return result2;
        }
        function baseFlatten(array, depth, predicate, isStrict, result2) {
          var index = -1, length = array.length;
          predicate || (predicate = isFlattenable);
          result2 || (result2 = []);
          while (++index < length) {
            var value = array[index];
            if (depth > 0 && predicate(value)) {
              if (depth > 1) {
                baseFlatten(value, depth - 1, predicate, isStrict, result2);
              } else {
                arrayPush(result2, value);
              }
            } else if (!isStrict) {
              result2[result2.length] = value;
            }
          }
          return result2;
        }
        var baseFor = createBaseFor();
        var baseForRight = createBaseFor(true);
        function baseForOwn(object, iteratee2) {
          return object && baseFor(object, iteratee2, keys);
        }
        function baseForOwnRight(object, iteratee2) {
          return object && baseForRight(object, iteratee2, keys);
        }
        function baseFunctions(object, props) {
          return arrayFilter(props, function(key) {
            return isFunction(object[key]);
          });
        }
        function baseGet(object, path2) {
          path2 = castPath(path2, object);
          var index = 0, length = path2.length;
          while (object != null && index < length) {
            object = object[toKey(path2[index++])];
          }
          return index && index == length ? object : undefined2;
        }
        function baseGetAllKeys(object, keysFunc, symbolsFunc) {
          var result2 = keysFunc(object);
          return isArray(object) ? result2 : arrayPush(result2, symbolsFunc(object));
        }
        function baseGetTag(value) {
          if (value == null) {
            return value === undefined2 ? undefinedTag : nullTag;
          }
          return symToStringTag && symToStringTag in Object2(value) ? getRawTag(value) : objectToString(value);
        }
        function baseGt(value, other) {
          return value > other;
        }
        function baseHas(object, key) {
          return object != null && hasOwnProperty.call(object, key);
        }
        function baseHasIn(object, key) {
          return object != null && key in Object2(object);
        }
        function baseInRange(number, start, end) {
          return number >= nativeMin(start, end) && number < nativeMax(start, end);
        }
        function baseIntersection(arrays, iteratee2, comparator) {
          var includes2 = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array2(othLength), maxLength = Infinity, result2 = [];
          while (othIndex--) {
            var array = arrays[othIndex];
            if (othIndex && iteratee2) {
              array = arrayMap(array, baseUnary(iteratee2));
            }
            maxLength = nativeMin(array.length, maxLength);
            caches[othIndex] = !comparator && (iteratee2 || length >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : undefined2;
          }
          array = arrays[0];
          var index = -1, seen = caches[0];
          outer: while (++index < length && result2.length < maxLength) {
            var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
            value = comparator || value !== 0 ? value : 0;
            if (!(seen ? cacheHas(seen, computed) : includes2(result2, computed, comparator))) {
              othIndex = othLength;
              while (--othIndex) {
                var cache = caches[othIndex];
                if (!(cache ? cacheHas(cache, computed) : includes2(arrays[othIndex], computed, comparator))) {
                  continue outer;
                }
              }
              if (seen) {
                seen.push(computed);
              }
              result2.push(value);
            }
          }
          return result2;
        }
        function baseInverter(object, setter, iteratee2, accumulator) {
          baseForOwn(object, function(value, key, object2) {
            setter(accumulator, iteratee2(value), key, object2);
          });
          return accumulator;
        }
        function baseInvoke(object, path2, args) {
          path2 = castPath(path2, object);
          object = parent(object, path2);
          var func = object == null ? object : object[toKey(last(path2))];
          return func == null ? undefined2 : apply(func, object, args);
        }
        function baseIsArguments(value) {
          return isObjectLike(value) && baseGetTag(value) == argsTag;
        }
        function baseIsArrayBuffer(value) {
          return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
        }
        function baseIsDate(value) {
          return isObjectLike(value) && baseGetTag(value) == dateTag;
        }
        function baseIsEqual(value, other, bitmask, customizer, stack) {
          if (value === other) {
            return true;
          }
          if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
            return value !== value && other !== other;
          }
          return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
        }
        function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
          var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
          objTag = objTag == argsTag ? objectTag : objTag;
          othTag = othTag == argsTag ? objectTag : othTag;
          var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
          if (isSameTag && isBuffer(object)) {
            if (!isBuffer(other)) {
              return false;
            }
            objIsArr = true;
            objIsObj = false;
          }
          if (isSameTag && !objIsObj) {
            stack || (stack = new Stack());
            return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
          }
          if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
            var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
            if (objIsWrapped || othIsWrapped) {
              var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
              stack || (stack = new Stack());
              return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
            }
          }
          if (!isSameTag) {
            return false;
          }
          stack || (stack = new Stack());
          return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
        }
        function baseIsMap(value) {
          return isObjectLike(value) && getTag(value) == mapTag;
        }
        function baseIsMatch(object, source, matchData, customizer) {
          var index = matchData.length, length = index, noCustomizer = !customizer;
          if (object == null) {
            return !length;
          }
          object = Object2(object);
          while (index--) {
            var data = matchData[index];
            if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
              return false;
            }
          }
          while (++index < length) {
            data = matchData[index];
            var key = data[0], objValue = object[key], srcValue = data[1];
            if (noCustomizer && data[2]) {
              if (objValue === undefined2 && !(key in object)) {
                return false;
              }
            } else {
              var stack = new Stack();
              if (customizer) {
                var result2 = customizer(objValue, srcValue, key, object, source, stack);
              }
              if (!(result2 === undefined2 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result2)) {
                return false;
              }
            }
          }
          return true;
        }
        function baseIsNative(value) {
          if (!isObject(value) || isMasked(value)) {
            return false;
          }
          var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
          return pattern.test(toSource(value));
        }
        function baseIsRegExp(value) {
          return isObjectLike(value) && baseGetTag(value) == regexpTag;
        }
        function baseIsSet(value) {
          return isObjectLike(value) && getTag(value) == setTag;
        }
        function baseIsTypedArray(value) {
          return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
        }
        function baseIteratee(value) {
          if (typeof value == "function") {
            return value;
          }
          if (value == null) {
            return identity;
          }
          if (typeof value == "object") {
            return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
          }
          return property(value);
        }
        function baseKeys(object) {
          if (!isPrototype(object)) {
            return nativeKeys(object);
          }
          var result2 = [];
          for (var key in Object2(object)) {
            if (hasOwnProperty.call(object, key) && key != "constructor") {
              result2.push(key);
            }
          }
          return result2;
        }
        function baseKeysIn(object) {
          if (!isObject(object)) {
            return nativeKeysIn(object);
          }
          var isProto = isPrototype(object), result2 = [];
          for (var key in object) {
            if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) {
              result2.push(key);
            }
          }
          return result2;
        }
        function baseLt(value, other) {
          return value < other;
        }
        function baseMap(collection, iteratee2) {
          var index = -1, result2 = isArrayLike(collection) ? Array2(collection.length) : [];
          baseEach(collection, function(value, key, collection2) {
            result2[++index] = iteratee2(value, key, collection2);
          });
          return result2;
        }
        function baseMatches(source) {
          var matchData = getMatchData(source);
          if (matchData.length == 1 && matchData[0][2]) {
            return matchesStrictComparable(matchData[0][0], matchData[0][1]);
          }
          return function(object) {
            return object === source || baseIsMatch(object, source, matchData);
          };
        }
        function baseMatchesProperty(path2, srcValue) {
          if (isKey(path2) && isStrictComparable(srcValue)) {
            return matchesStrictComparable(toKey(path2), srcValue);
          }
          return function(object) {
            var objValue = get(object, path2);
            return objValue === undefined2 && objValue === srcValue ? hasIn(object, path2) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
          };
        }
        function baseMerge(object, source, srcIndex, customizer, stack) {
          if (object === source) {
            return;
          }
          baseFor(source, function(srcValue, key) {
            stack || (stack = new Stack());
            if (isObject(srcValue)) {
              baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
            } else {
              var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : undefined2;
              if (newValue === undefined2) {
                newValue = srcValue;
              }
              assignMergeValue(object, key, newValue);
            }
          }, keysIn);
        }
        function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
          var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
          if (stacked) {
            assignMergeValue(object, key, stacked);
            return;
          }
          var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : undefined2;
          var isCommon = newValue === undefined2;
          if (isCommon) {
            var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
            newValue = srcValue;
            if (isArr || isBuff || isTyped) {
              if (isArray(objValue)) {
                newValue = objValue;
              } else if (isArrayLikeObject(objValue)) {
                newValue = copyArray(objValue);
              } else if (isBuff) {
                isCommon = false;
                newValue = cloneBuffer(srcValue, true);
              } else if (isTyped) {
                isCommon = false;
                newValue = cloneTypedArray(srcValue, true);
              } else {
                newValue = [];
              }
            } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
              newValue = objValue;
              if (isArguments(objValue)) {
                newValue = toPlainObject(objValue);
              } else if (!isObject(objValue) || isFunction(objValue)) {
                newValue = initCloneObject(srcValue);
              }
            } else {
              isCommon = false;
            }
          }
          if (isCommon) {
            stack.set(srcValue, newValue);
            mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
            stack["delete"](srcValue);
          }
          assignMergeValue(object, key, newValue);
        }
        function baseNth(array, n) {
          var length = array.length;
          if (!length) {
            return;
          }
          n += n < 0 ? length : 0;
          return isIndex(n, length) ? array[n] : undefined2;
        }
        function baseOrderBy(collection, iteratees, orders) {
          if (iteratees.length) {
            iteratees = arrayMap(iteratees, function(iteratee2) {
              if (isArray(iteratee2)) {
                return function(value) {
                  return baseGet(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
                };
              }
              return iteratee2;
            });
          } else {
            iteratees = [
              identity
            ];
          }
          var index = -1;
          iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
          var result2 = baseMap(collection, function(value, key, collection2) {
            var criteria = arrayMap(iteratees, function(iteratee2) {
              return iteratee2(value);
            });
            return {
              "criteria": criteria,
              "index": ++index,
              "value": value
            };
          });
          return baseSortBy(result2, function(object, other) {
            return compareMultiple(object, other, orders);
          });
        }
        function basePick(object, paths) {
          return basePickBy(object, paths, function(value, path2) {
            return hasIn(object, path2);
          });
        }
        function basePickBy(object, paths, predicate) {
          var index = -1, length = paths.length, result2 = {};
          while (++index < length) {
            var path2 = paths[index], value = baseGet(object, path2);
            if (predicate(value, path2)) {
              baseSet(result2, castPath(path2, object), value);
            }
          }
          return result2;
        }
        function basePropertyDeep(path2) {
          return function(object) {
            return baseGet(object, path2);
          };
        }
        function basePullAll(array, values2, iteratee2, comparator) {
          var indexOf2 = comparator ? baseIndexOfWith : baseIndexOf, index = -1, length = values2.length, seen = array;
          if (array === values2) {
            values2 = copyArray(values2);
          }
          if (iteratee2) {
            seen = arrayMap(array, baseUnary(iteratee2));
          }
          while (++index < length) {
            var fromIndex = 0, value = values2[index], computed = iteratee2 ? iteratee2(value) : value;
            while ((fromIndex = indexOf2(seen, computed, fromIndex, comparator)) > -1) {
              if (seen !== array) {
                splice.call(seen, fromIndex, 1);
              }
              splice.call(array, fromIndex, 1);
            }
          }
          return array;
        }
        function basePullAt(array, indexes) {
          var length = array ? indexes.length : 0, lastIndex = length - 1;
          while (length--) {
            var index = indexes[length];
            if (length == lastIndex || index !== previous) {
              var previous = index;
              if (isIndex(index)) {
                splice.call(array, index, 1);
              } else {
                baseUnset(array, index);
              }
            }
          }
          return array;
        }
        function baseRandom(lower, upper) {
          return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
        }
        function baseRange(start, end, step, fromRight) {
          var index = -1, length = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result2 = Array2(length);
          while (length--) {
            result2[fromRight ? length : ++index] = start;
            start += step;
          }
          return result2;
        }
        function baseRepeat(string, n) {
          var result2 = "";
          if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
            return result2;
          }
          do {
            if (n % 2) {
              result2 += string;
            }
            n = nativeFloor(n / 2);
            if (n) {
              string += string;
            }
          } while (n);
          return result2;
        }
        function baseRest(func, start) {
          return setToString(overRest(func, start, identity), func + "");
        }
        function baseSample(collection) {
          return arraySample(values(collection));
        }
        function baseSampleSize(collection, n) {
          var array = values(collection);
          return shuffleSelf(array, baseClamp(n, 0, array.length));
        }
        function baseSet(object, path2, value, customizer) {
          if (!isObject(object)) {
            return object;
          }
          path2 = castPath(path2, object);
          var index = -1, length = path2.length, lastIndex = length - 1, nested = object;
          while (nested != null && ++index < length) {
            var key = toKey(path2[index]), newValue = value;
            if (key === "__proto__" || key === "constructor" || key === "prototype") {
              return object;
            }
            if (index != lastIndex) {
              var objValue = nested[key];
              newValue = customizer ? customizer(objValue, key, nested) : undefined2;
              if (newValue === undefined2) {
                newValue = isObject(objValue) ? objValue : isIndex(path2[index + 1]) ? [] : {};
              }
            }
            assignValue(nested, key, newValue);
            nested = nested[key];
          }
          return object;
        }
        var baseSetData = !metaMap ? identity : function(func, data) {
          metaMap.set(func, data);
          return func;
        };
        var baseSetToString = !defineProperty ? identity : function(func, string) {
          return defineProperty(func, "toString", {
            "configurable": true,
            "enumerable": false,
            "value": constant(string),
            "writable": true
          });
        };
        function baseShuffle(collection) {
          return shuffleSelf(values(collection));
        }
        function baseSlice(array, start, end) {
          var index = -1, length = array.length;
          if (start < 0) {
            start = -start > length ? 0 : length + start;
          }
          end = end > length ? length : end;
          if (end < 0) {
            end += length;
          }
          length = start > end ? 0 : end - start >>> 0;
          start >>>= 0;
          var result2 = Array2(length);
          while (++index < length) {
            result2[index] = array[index + start];
          }
          return result2;
        }
        function baseSome(collection, predicate) {
          var result2;
          baseEach(collection, function(value, index, collection2) {
            result2 = predicate(value, index, collection2);
            return !result2;
          });
          return !!result2;
        }
        function baseSortedIndex(array, value, retHighest) {
          var low = 0, high = array == null ? low : array.length;
          if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
            while (low < high) {
              var mid = low + high >>> 1, computed = array[mid];
              if (computed !== null && !isSymbol(computed) && (retHighest ? computed <= value : computed < value)) {
                low = mid + 1;
              } else {
                high = mid;
              }
            }
            return high;
          }
          return baseSortedIndexBy(array, value, identity, retHighest);
        }
        function baseSortedIndexBy(array, value, iteratee2, retHighest) {
          var low = 0, high = array == null ? 0 : array.length;
          if (high === 0) {
            return 0;
          }
          value = iteratee2(value);
          var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol(value), valIsUndefined = value === undefined2;
          while (low < high) {
            var mid = nativeFloor((low + high) / 2), computed = iteratee2(array[mid]), othIsDefined = computed !== undefined2, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol(computed);
            if (valIsNaN) {
              var setLow = retHighest || othIsReflexive;
            } else if (valIsUndefined) {
              setLow = othIsReflexive && (retHighest || othIsDefined);
            } else if (valIsNull) {
              setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
            } else if (valIsSymbol) {
              setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
            } else if (othIsNull || othIsSymbol) {
              setLow = false;
            } else {
              setLow = retHighest ? computed <= value : computed < value;
            }
            if (setLow) {
              low = mid + 1;
            } else {
              high = mid;
            }
          }
          return nativeMin(high, MAX_ARRAY_INDEX);
        }
        function baseSortedUniq(array, iteratee2) {
          var index = -1, length = array.length, resIndex = 0, result2 = [];
          while (++index < length) {
            var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
            if (!index || !eq(computed, seen)) {
              var seen = computed;
              result2[resIndex++] = value === 0 ? 0 : value;
            }
          }
          return result2;
        }
        function baseToNumber(value) {
          if (typeof value == "number") {
            return value;
          }
          if (isSymbol(value)) {
            return NAN;
          }
          return +value;
        }
        function baseToString(value) {
          if (typeof value == "string") {
            return value;
          }
          if (isArray(value)) {
            return arrayMap(value, baseToString) + "";
          }
          if (isSymbol(value)) {
            return symbolToString ? symbolToString.call(value) : "";
          }
          var result2 = value + "";
          return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
        }
        function baseUniq(array, iteratee2, comparator) {
          var index = -1, includes2 = arrayIncludes, length = array.length, isCommon = true, result2 = [], seen = result2;
          if (comparator) {
            isCommon = false;
            includes2 = arrayIncludesWith;
          } else if (length >= LARGE_ARRAY_SIZE) {
            var set2 = iteratee2 ? null : createSet(array);
            if (set2) {
              return setToArray(set2);
            }
            isCommon = false;
            includes2 = cacheHas;
            seen = new SetCache();
          } else {
            seen = iteratee2 ? [] : result2;
          }
          outer: while (++index < length) {
            var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
            value = comparator || value !== 0 ? value : 0;
            if (isCommon && computed === computed) {
              var seenIndex = seen.length;
              while (seenIndex--) {
                if (seen[seenIndex] === computed) {
                  continue outer;
                }
              }
              if (iteratee2) {
                seen.push(computed);
              }
              result2.push(value);
            } else if (!includes2(seen, computed, comparator)) {
              if (seen !== result2) {
                seen.push(computed);
              }
              result2.push(value);
            }
          }
          return result2;
        }
        function baseUnset(object, path2) {
          path2 = castPath(path2, object);
          object = parent(object, path2);
          return object == null || delete object[toKey(last(path2))];
        }
        function baseUpdate(object, path2, updater, customizer) {
          return baseSet(object, path2, updater(baseGet(object, path2)), customizer);
        }
        function baseWhile(array, predicate, isDrop, fromRight) {
          var length = array.length, index = fromRight ? length : -1;
          while ((fromRight ? index-- : ++index < length) && predicate(array[index], index, array)) {
          }
          return isDrop ? baseSlice(array, fromRight ? 0 : index, fromRight ? index + 1 : length) : baseSlice(array, fromRight ? index + 1 : 0, fromRight ? length : index);
        }
        function baseWrapperValue(value, actions) {
          var result2 = value;
          if (result2 instanceof LazyWrapper) {
            result2 = result2.value();
          }
          return arrayReduce(actions, function(result3, action) {
            return action.func.apply(action.thisArg, arrayPush([
              result3
            ], action.args));
          }, result2);
        }
        function baseXor(arrays, iteratee2, comparator) {
          var length = arrays.length;
          if (length < 2) {
            return length ? baseUniq(arrays[0]) : [];
          }
          var index = -1, result2 = Array2(length);
          while (++index < length) {
            var array = arrays[index], othIndex = -1;
            while (++othIndex < length) {
              if (othIndex != index) {
                result2[index] = baseDifference(result2[index] || array, arrays[othIndex], iteratee2, comparator);
              }
            }
          }
          return baseUniq(baseFlatten(result2, 1), iteratee2, comparator);
        }
        function baseZipObject(props, values2, assignFunc) {
          var index = -1, length = props.length, valsLength = values2.length, result2 = {};
          while (++index < length) {
            var value = index < valsLength ? values2[index] : undefined2;
            assignFunc(result2, props[index], value);
          }
          return result2;
        }
        function castArrayLikeObject(value) {
          return isArrayLikeObject(value) ? value : [];
        }
        function castFunction(value) {
          return typeof value == "function" ? value : identity;
        }
        function castPath(value, object) {
          if (isArray(value)) {
            return value;
          }
          return isKey(value, object) ? [
            value
          ] : stringToPath(toString(value));
        }
        var castRest = baseRest;
        function castSlice(array, start, end) {
          var length = array.length;
          end = end === undefined2 ? length : end;
          return !start && end >= length ? array : baseSlice(array, start, end);
        }
        var clearTimeout2 = ctxClearTimeout || function(id) {
          return root.clearTimeout(id);
        };
        function cloneBuffer(buffer, isDeep) {
          if (isDeep) {
            return buffer.slice();
          }
          var length = buffer.length, result2 = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
          buffer.copy(result2);
          return result2;
        }
        function cloneArrayBuffer(arrayBuffer) {
          var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
          new Uint8Array2(result2).set(new Uint8Array2(arrayBuffer));
          return result2;
        }
        function cloneDataView(dataView, isDeep) {
          var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
          return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
        }
        function cloneRegExp(regexp) {
          var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
          result2.lastIndex = regexp.lastIndex;
          return result2;
        }
        function cloneSymbol(symbol) {
          return symbolValueOf ? Object2(symbolValueOf.call(symbol)) : {};
        }
        function cloneTypedArray(typedArray, isDeep) {
          var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
          return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
        }
        function compareAscending(value, other) {
          if (value !== other) {
            var valIsDefined = value !== undefined2, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
            var othIsDefined = other !== undefined2, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
            if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
              return 1;
            }
            if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
              return -1;
            }
          }
          return 0;
        }
        function compareMultiple(object, other, orders) {
          var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
          while (++index < length) {
            var result2 = compareAscending(objCriteria[index], othCriteria[index]);
            if (result2) {
              if (index >= ordersLength) {
                return result2;
              }
              var order = orders[index];
              return result2 * (order == "desc" ? -1 : 1);
            }
          }
          return object.index - other.index;
        }
        function composeArgs(args, partials, holders, isCurried) {
          var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(leftLength + rangeLength), isUncurried = !isCurried;
          while (++leftIndex < leftLength) {
            result2[leftIndex] = partials[leftIndex];
          }
          while (++argsIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result2[holders[argsIndex]] = args[argsIndex];
            }
          }
          while (rangeLength--) {
            result2[leftIndex++] = args[argsIndex++];
          }
          return result2;
        }
        function composeArgsRight(args, partials, holders, isCurried) {
          var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(rangeLength + rightLength), isUncurried = !isCurried;
          while (++argsIndex < rangeLength) {
            result2[argsIndex] = args[argsIndex];
          }
          var offset = argsIndex;
          while (++rightIndex < rightLength) {
            result2[offset + rightIndex] = partials[rightIndex];
          }
          while (++holdersIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result2[offset + holders[holdersIndex]] = args[argsIndex++];
            }
          }
          return result2;
        }
        function copyArray(source, array) {
          var index = -1, length = source.length;
          array || (array = Array2(length));
          while (++index < length) {
            array[index] = source[index];
          }
          return array;
        }
        function copyObject(source, props, object, customizer) {
          var isNew = !object;
          object || (object = {});
          var index = -1, length = props.length;
          while (++index < length) {
            var key = props[index];
            var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined2;
            if (newValue === undefined2) {
              newValue = source[key];
            }
            if (isNew) {
              baseAssignValue(object, key, newValue);
            } else {
              assignValue(object, key, newValue);
            }
          }
          return object;
        }
        function copySymbols(source, object) {
          return copyObject(source, getSymbols(source), object);
        }
        function copySymbolsIn(source, object) {
          return copyObject(source, getSymbolsIn(source), object);
        }
        function createAggregator(setter, initializer) {
          return function(collection, iteratee2) {
            var func = isArray(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
            return func(collection, setter, getIteratee(iteratee2, 2), accumulator);
          };
        }
        function createAssigner(assigner) {
          return baseRest(function(object, sources) {
            var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined2, guard = length > 2 ? sources[2] : undefined2;
            customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : undefined2;
            if (guard && isIterateeCall(sources[0], sources[1], guard)) {
              customizer = length < 3 ? undefined2 : customizer;
              length = 1;
            }
            object = Object2(object);
            while (++index < length) {
              var source = sources[index];
              if (source) {
                assigner(object, source, index, customizer);
              }
            }
            return object;
          });
        }
        function createBaseEach(eachFunc, fromRight) {
          return function(collection, iteratee2) {
            if (collection == null) {
              return collection;
            }
            if (!isArrayLike(collection)) {
              return eachFunc(collection, iteratee2);
            }
            var length = collection.length, index = fromRight ? length : -1, iterable = Object2(collection);
            while (fromRight ? index-- : ++index < length) {
              if (iteratee2(iterable[index], index, iterable) === false) {
                break;
              }
            }
            return collection;
          };
        }
        function createBaseFor(fromRight) {
          return function(object, iteratee2, keysFunc) {
            var index = -1, iterable = Object2(object), props = keysFunc(object), length = props.length;
            while (length--) {
              var key = props[fromRight ? length : ++index];
              if (iteratee2(iterable[key], key, iterable) === false) {
                break;
              }
            }
            return object;
          };
        }
        function createBind(func, bitmask, thisArg) {
          var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
          function wrapper() {
            var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
            return fn.apply(isBind ? thisArg : this, arguments);
          }
          return wrapper;
        }
        function createCaseFirst(methodName) {
          return function(string) {
            string = toString(string);
            var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined2;
            var chr = strSymbols ? strSymbols[0] : string.charAt(0);
            var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
            return chr[methodName]() + trailing;
          };
        }
        function createCompounder(callback) {
          return function(string) {
            return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
          };
        }
        function createCtor(Ctor) {
          return function() {
            var args = arguments;
            switch (args.length) {
              case 0:
                return new Ctor();
              case 1:
                return new Ctor(args[0]);
              case 2:
                return new Ctor(args[0], args[1]);
              case 3:
                return new Ctor(args[0], args[1], args[2]);
              case 4:
                return new Ctor(args[0], args[1], args[2], args[3]);
              case 5:
                return new Ctor(args[0], args[1], args[2], args[3], args[4]);
              case 6:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
              case 7:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
            }
            var thisBinding = baseCreate(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
            return isObject(result2) ? result2 : thisBinding;
          };
        }
        function createCurry(func, bitmask, arity) {
          var Ctor = createCtor(func);
          function wrapper() {
            var length = arguments.length, args = Array2(length), index = length, placeholder = getHolder(wrapper);
            while (index--) {
              args[index] = arguments[index];
            }
            var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
            length -= holders.length;
            if (length < arity) {
              return createRecurry(func, bitmask, createHybrid, wrapper.placeholder, undefined2, args, holders, undefined2, undefined2, arity - length);
            }
            var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
            return apply(fn, this, args);
          }
          return wrapper;
        }
        function createFind(findIndexFunc) {
          return function(collection, predicate, fromIndex) {
            var iterable = Object2(collection);
            if (!isArrayLike(collection)) {
              var iteratee2 = getIteratee(predicate, 3);
              collection = keys(collection);
              predicate = function(key) {
                return iteratee2(iterable[key], key, iterable);
              };
            }
            var index = findIndexFunc(collection, predicate, fromIndex);
            return index > -1 ? iterable[iteratee2 ? collection[index] : index] : undefined2;
          };
        }
        function createFlow(fromRight) {
          return flatRest(function(funcs) {
            var length = funcs.length, index = length, prereq = LodashWrapper.prototype.thru;
            if (fromRight) {
              funcs.reverse();
            }
            while (index--) {
              var func = funcs[index];
              if (typeof func != "function") {
                throw new TypeError2(FUNC_ERROR_TEXT);
              }
              if (prereq && !wrapper && getFuncName(func) == "wrapper") {
                var wrapper = new LodashWrapper([], true);
              }
            }
            index = wrapper ? index : length;
            while (++index < length) {
              func = funcs[index];
              var funcName = getFuncName(func), data = funcName == "wrapper" ? getData(func) : undefined2;
              if (data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && data[9] == 1) {
                wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
              } else {
                wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
              }
            }
            return function() {
              var args = arguments, value = args[0];
              if (wrapper && args.length == 1 && isArray(value)) {
                return wrapper.plant(value).value();
              }
              var index2 = 0, result2 = length ? funcs[index2].apply(this, args) : value;
              while (++index2 < length) {
                result2 = funcs[index2].call(this, result2);
              }
              return result2;
            };
          });
        }
        function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
          var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined2 : createCtor(func);
          function wrapper() {
            var length = arguments.length, args = Array2(length), index = length;
            while (index--) {
              args[index] = arguments[index];
            }
            if (isCurried) {
              var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
            }
            if (partials) {
              args = composeArgs(args, partials, holders, isCurried);
            }
            if (partialsRight) {
              args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
            }
            length -= holdersCount;
            if (isCurried && length < arity) {
              var newHolders = replaceHolders(args, placeholder);
              return createRecurry(func, bitmask, createHybrid, wrapper.placeholder, thisArg, args, newHolders, argPos, ary2, arity - length);
            }
            var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
            length = args.length;
            if (argPos) {
              args = reorder(args, argPos);
            } else if (isFlip && length > 1) {
              args.reverse();
            }
            if (isAry && ary2 < length) {
              args.length = ary2;
            }
            if (this && this !== root && this instanceof wrapper) {
              fn = Ctor || createCtor(fn);
            }
            return fn.apply(thisBinding, args);
          }
          return wrapper;
        }
        function createInverter(setter, toIteratee) {
          return function(object, iteratee2) {
            return baseInverter(object, setter, toIteratee(iteratee2), {});
          };
        }
        function createMathOperation(operator, defaultValue) {
          return function(value, other) {
            var result2;
            if (value === undefined2 && other === undefined2) {
              return defaultValue;
            }
            if (value !== undefined2) {
              result2 = value;
            }
            if (other !== undefined2) {
              if (result2 === undefined2) {
                return other;
              }
              if (typeof value == "string" || typeof other == "string") {
                value = baseToString(value);
                other = baseToString(other);
              } else {
                value = baseToNumber(value);
                other = baseToNumber(other);
              }
              result2 = operator(value, other);
            }
            return result2;
          };
        }
        function createOver(arrayFunc) {
          return flatRest(function(iteratees) {
            iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
            return baseRest(function(args) {
              var thisArg = this;
              return arrayFunc(iteratees, function(iteratee2) {
                return apply(iteratee2, thisArg, args);
              });
            });
          });
        }
        function createPadding(length, chars) {
          chars = chars === undefined2 ? " " : baseToString(chars);
          var charsLength = chars.length;
          if (charsLength < 2) {
            return charsLength ? baseRepeat(chars, length) : chars;
          }
          var result2 = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
          return hasUnicode(chars) ? castSlice(stringToArray(result2), 0, length).join("") : result2.slice(0, length);
        }
        function createPartial(func, bitmask, thisArg, partials) {
          var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
          function wrapper() {
            var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array2(leftLength + argsLength), fn = this && this !== root && this instanceof wrapper ? Ctor : func;
            while (++leftIndex < leftLength) {
              args[leftIndex] = partials[leftIndex];
            }
            while (argsLength--) {
              args[leftIndex++] = arguments[++argsIndex];
            }
            return apply(fn, isBind ? thisArg : this, args);
          }
          return wrapper;
        }
        function createRange(fromRight) {
          return function(start, end, step) {
            if (step && typeof step != "number" && isIterateeCall(start, end, step)) {
              end = step = undefined2;
            }
            start = toFinite(start);
            if (end === undefined2) {
              end = start;
              start = 0;
            } else {
              end = toFinite(end);
            }
            step = step === undefined2 ? start < end ? 1 : -1 : toFinite(step);
            return baseRange(start, end, step, fromRight);
          };
        }
        function createRelationalOperation(operator) {
          return function(value, other) {
            if (!(typeof value == "string" && typeof other == "string")) {
              value = toNumber(value);
              other = toNumber(other);
            }
            return operator(value, other);
          };
        }
        function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
          var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined2, newHoldersRight = isCurry ? undefined2 : holders, newPartials = isCurry ? partials : undefined2, newPartialsRight = isCurry ? undefined2 : partials;
          bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
          bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
          if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
            bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
          }
          var newData = [
            func,
            bitmask,
            thisArg,
            newPartials,
            newHolders,
            newPartialsRight,
            newHoldersRight,
            argPos,
            ary2,
            arity
          ];
          var result2 = wrapFunc.apply(undefined2, newData);
          if (isLaziable(func)) {
            setData(result2, newData);
          }
          result2.placeholder = placeholder;
          return setWrapToString(result2, func, bitmask);
        }
        function createRound(methodName) {
          var func = Math2[methodName];
          return function(number, precision) {
            number = toNumber(number);
            precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
            if (precision && nativeIsFinite(number)) {
              var pair = (toString(number) + "e").split("e"), value = func(pair[0] + "e" + (+pair[1] + precision));
              pair = (toString(value) + "e").split("e");
              return +(pair[0] + "e" + (+pair[1] - precision));
            }
            return func(number);
          };
        }
        var createSet = !(Set2 && 1 / setToArray(new Set2([
          ,
          -0
        ]))[1] == INFINITY) ? noop : function(values2) {
          return new Set2(values2);
        };
        function createToPairs(keysFunc) {
          return function(object) {
            var tag = getTag(object);
            if (tag == mapTag) {
              return mapToArray(object);
            }
            if (tag == setTag) {
              return setToPairs(object);
            }
            return baseToPairs(object, keysFunc(object));
          };
        }
        function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
          var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
          if (!isBindKey && typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          var length = partials ? partials.length : 0;
          if (!length) {
            bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
            partials = holders = undefined2;
          }
          ary2 = ary2 === undefined2 ? ary2 : nativeMax(toInteger(ary2), 0);
          arity = arity === undefined2 ? arity : toInteger(arity);
          length -= holders ? holders.length : 0;
          if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
            var partialsRight = partials, holdersRight = holders;
            partials = holders = undefined2;
          }
          var data = isBindKey ? undefined2 : getData(func);
          var newData = [
            func,
            bitmask,
            thisArg,
            partials,
            holders,
            partialsRight,
            holdersRight,
            argPos,
            ary2,
            arity
          ];
          if (data) {
            mergeData(newData, data);
          }
          func = newData[0];
          bitmask = newData[1];
          thisArg = newData[2];
          partials = newData[3];
          holders = newData[4];
          arity = newData[9] = newData[9] === undefined2 ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0);
          if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
            bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
          }
          if (!bitmask || bitmask == WRAP_BIND_FLAG) {
            var result2 = createBind(func, bitmask, thisArg);
          } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
            result2 = createCurry(func, bitmask, arity);
          } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
            result2 = createPartial(func, bitmask, thisArg, partials);
          } else {
            result2 = createHybrid.apply(undefined2, newData);
          }
          var setter = data ? baseSetData : setData;
          return setWrapToString(setter(result2, newData), func, bitmask);
        }
        function customDefaultsAssignIn(objValue, srcValue, key, object) {
          if (objValue === undefined2 || eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key)) {
            return srcValue;
          }
          return objValue;
        }
        function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
          if (isObject(objValue) && isObject(srcValue)) {
            stack.set(srcValue, objValue);
            baseMerge(objValue, srcValue, undefined2, customDefaultsMerge, stack);
            stack["delete"](srcValue);
          }
          return objValue;
        }
        function customOmitClone(value) {
          return isPlainObject(value) ? undefined2 : value;
        }
        function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
          if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
            return false;
          }
          var arrStacked = stack.get(array);
          var othStacked = stack.get(other);
          if (arrStacked && othStacked) {
            return arrStacked == other && othStacked == array;
          }
          var index = -1, result2 = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined2;
          stack.set(array, other);
          stack.set(other, array);
          while (++index < arrLength) {
            var arrValue = array[index], othValue = other[index];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
            }
            if (compared !== undefined2) {
              if (compared) {
                continue;
              }
              result2 = false;
              break;
            }
            if (seen) {
              if (!arraySome(other, function(othValue2, othIndex) {
                if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                  return seen.push(othIndex);
                }
              })) {
                result2 = false;
                break;
              }
            } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
              result2 = false;
              break;
            }
          }
          stack["delete"](array);
          stack["delete"](other);
          return result2;
        }
        function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
          switch (tag) {
            case dataViewTag:
              if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
                return false;
              }
              object = object.buffer;
              other = other.buffer;
            case arrayBufferTag:
              if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
                return false;
              }
              return true;
            case boolTag:
            case dateTag:
            case numberTag:
              return eq(+object, +other);
            case errorTag:
              return object.name == other.name && object.message == other.message;
            case regexpTag:
            case stringTag:
              return object == other + "";
            case mapTag:
              var convert2 = mapToArray;
            case setTag:
              var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
              convert2 || (convert2 = setToArray);
              if (object.size != other.size && !isPartial) {
                return false;
              }
              var stacked = stack.get(object);
              if (stacked) {
                return stacked == other;
              }
              bitmask |= COMPARE_UNORDERED_FLAG;
              stack.set(object, other);
              var result2 = equalArrays(convert2(object), convert2(other), bitmask, customizer, equalFunc, stack);
              stack["delete"](object);
              return result2;
            case symbolTag:
              if (symbolValueOf) {
                return symbolValueOf.call(object) == symbolValueOf.call(other);
              }
          }
          return false;
        }
        function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
          if (objLength != othLength && !isPartial) {
            return false;
          }
          var index = objLength;
          while (index--) {
            var key = objProps[index];
            if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
              return false;
            }
          }
          var objStacked = stack.get(object);
          var othStacked = stack.get(other);
          if (objStacked && othStacked) {
            return objStacked == other && othStacked == object;
          }
          var result2 = true;
          stack.set(object, other);
          stack.set(other, object);
          var skipCtor = isPartial;
          while (++index < objLength) {
            key = objProps[index];
            var objValue = object[key], othValue = other[key];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
            }
            if (!(compared === undefined2 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
              result2 = false;
              break;
            }
            skipCtor || (skipCtor = key == "constructor");
          }
          if (result2 && !skipCtor) {
            var objCtor = object.constructor, othCtor = other.constructor;
            if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
              result2 = false;
            }
          }
          stack["delete"](object);
          stack["delete"](other);
          return result2;
        }
        function flatRest(func) {
          return setToString(overRest(func, undefined2, flatten), func + "");
        }
        function getAllKeys(object) {
          return baseGetAllKeys(object, keys, getSymbols);
        }
        function getAllKeysIn(object) {
          return baseGetAllKeys(object, keysIn, getSymbolsIn);
        }
        var getData = !metaMap ? noop : function(func) {
          return metaMap.get(func);
        };
        function getFuncName(func) {
          var result2 = func.name + "", array = realNames[result2], length = hasOwnProperty.call(realNames, result2) ? array.length : 0;
          while (length--) {
            var data = array[length], otherFunc = data.func;
            if (otherFunc == null || otherFunc == func) {
              return data.name;
            }
          }
          return result2;
        }
        function getHolder(func) {
          var object = hasOwnProperty.call(lodash, "placeholder") ? lodash : func;
          return object.placeholder;
        }
        function getIteratee() {
          var result2 = lodash.iteratee || iteratee;
          result2 = result2 === iteratee ? baseIteratee : result2;
          return arguments.length ? result2(arguments[0], arguments[1]) : result2;
        }
        function getMapData(map2, key) {
          var data = map2.__data__;
          return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
        }
        function getMatchData(object) {
          var result2 = keys(object), length = result2.length;
          while (length--) {
            var key = result2[length], value = object[key];
            result2[length] = [
              key,
              value,
              isStrictComparable(value)
            ];
          }
          return result2;
        }
        function getNative(object, key) {
          var value = getValue(object, key);
          return baseIsNative(value) ? value : undefined2;
        }
        function getRawTag(value) {
          var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
          try {
            value[symToStringTag] = undefined2;
            var unmasked = true;
          } catch (e) {
          }
          var result2 = nativeObjectToString.call(value);
          if (unmasked) {
            if (isOwn) {
              value[symToStringTag] = tag;
            } else {
              delete value[symToStringTag];
            }
          }
          return result2;
        }
        var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
          if (object == null) {
            return [];
          }
          object = Object2(object);
          return arrayFilter(nativeGetSymbols(object), function(symbol) {
            return propertyIsEnumerable.call(object, symbol);
          });
        };
        var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
          var result2 = [];
          while (object) {
            arrayPush(result2, getSymbols(object));
            object = getPrototype(object);
          }
          return result2;
        };
        var getTag = baseGetTag;
        if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
          getTag = function(value) {
            var result2 = baseGetTag(value), Ctor = result2 == objectTag ? value.constructor : undefined2, ctorString = Ctor ? toSource(Ctor) : "";
            if (ctorString) {
              switch (ctorString) {
                case dataViewCtorString:
                  return dataViewTag;
                case mapCtorString:
                  return mapTag;
                case promiseCtorString:
                  return promiseTag;
                case setCtorString:
                  return setTag;
                case weakMapCtorString:
                  return weakMapTag;
              }
            }
            return result2;
          };
        }
        function getView(start, end, transforms) {
          var index = -1, length = transforms.length;
          while (++index < length) {
            var data = transforms[index], size2 = data.size;
            switch (data.type) {
              case "drop":
                start += size2;
                break;
              case "dropRight":
                end -= size2;
                break;
              case "take":
                end = nativeMin(end, start + size2);
                break;
              case "takeRight":
                start = nativeMax(start, end - size2);
                break;
            }
          }
          return {
            "start": start,
            "end": end
          };
        }
        function getWrapDetails(source) {
          var match2 = source.match(reWrapDetails);
          return match2 ? match2[1].split(reSplitDetails) : [];
        }
        function hasPath(object, path2, hasFunc) {
          path2 = castPath(path2, object);
          var index = -1, length = path2.length, result2 = false;
          while (++index < length) {
            var key = toKey(path2[index]);
            if (!(result2 = object != null && hasFunc(object, key))) {
              break;
            }
            object = object[key];
          }
          if (result2 || ++index != length) {
            return result2;
          }
          length = object == null ? 0 : object.length;
          return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
        }
        function initCloneArray(array) {
          var length = array.length, result2 = new array.constructor(length);
          if (length && typeof array[0] == "string" && hasOwnProperty.call(array, "index")) {
            result2.index = array.index;
            result2.input = array.input;
          }
          return result2;
        }
        function initCloneObject(object) {
          return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
        }
        function initCloneByTag(object, tag, isDeep) {
          var Ctor = object.constructor;
          switch (tag) {
            case arrayBufferTag:
              return cloneArrayBuffer(object);
            case boolTag:
            case dateTag:
              return new Ctor(+object);
            case dataViewTag:
              return cloneDataView(object, isDeep);
            case float32Tag:
            case float64Tag:
            case int8Tag:
            case int16Tag:
            case int32Tag:
            case uint8Tag:
            case uint8ClampedTag:
            case uint16Tag:
            case uint32Tag:
              return cloneTypedArray(object, isDeep);
            case mapTag:
              return new Ctor();
            case numberTag:
            case stringTag:
              return new Ctor(object);
            case regexpTag:
              return cloneRegExp(object);
            case setTag:
              return new Ctor();
            case symbolTag:
              return cloneSymbol(object);
          }
        }
        function insertWrapDetails(source, details) {
          var length = details.length;
          if (!length) {
            return source;
          }
          var lastIndex = length - 1;
          details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex];
          details = details.join(length > 2 ? ", " : " ");
          return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
        }
        function isFlattenable(value) {
          return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
        }
        function isIndex(value, length) {
          var type = typeof value;
          length = length == null ? MAX_SAFE_INTEGER : length;
          return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
        }
        function isIterateeCall(value, index, object) {
          if (!isObject(object)) {
            return false;
          }
          var type = typeof index;
          if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
            return eq(object[index], value);
          }
          return false;
        }
        function isKey(value, object) {
          if (isArray(value)) {
            return false;
          }
          var type = typeof value;
          if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
            return true;
          }
          return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object2(object);
        }
        function isKeyable(value) {
          var type = typeof value;
          return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
        }
        function isLaziable(func) {
          var funcName = getFuncName(func), other = lodash[funcName];
          if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
            return false;
          }
          if (func === other) {
            return true;
          }
          var data = getData(other);
          return !!data && func === data[0];
        }
        function isMasked(func) {
          return !!maskSrcKey && maskSrcKey in func;
        }
        var isMaskable = coreJsData ? isFunction : stubFalse;
        function isPrototype(value) {
          var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
          return value === proto;
        }
        function isStrictComparable(value) {
          return value === value && !isObject(value);
        }
        function matchesStrictComparable(key, srcValue) {
          return function(object) {
            if (object == null) {
              return false;
            }
            return object[key] === srcValue && (srcValue !== undefined2 || key in Object2(object));
          };
        }
        function memoizeCapped(func) {
          var result2 = memoize(func, function(key) {
            if (cache.size === MAX_MEMOIZE_SIZE) {
              cache.clear();
            }
            return key;
          });
          var cache = result2.cache;
          return result2;
        }
        function mergeData(data, source) {
          var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
          var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
          if (!(isCommon || isCombo)) {
            return data;
          }
          if (srcBitmask & WRAP_BIND_FLAG) {
            data[2] = source[2];
            newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
          }
          var value = source[3];
          if (value) {
            var partials = data[3];
            data[3] = partials ? composeArgs(partials, value, source[4]) : value;
            data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
          }
          value = source[5];
          if (value) {
            partials = data[5];
            data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
            data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
          }
          value = source[7];
          if (value) {
            data[7] = value;
          }
          if (srcBitmask & WRAP_ARY_FLAG) {
            data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
          }
          if (data[9] == null) {
            data[9] = source[9];
          }
          data[0] = source[0];
          data[1] = newBitmask;
          return data;
        }
        function nativeKeysIn(object) {
          var result2 = [];
          if (object != null) {
            for (var key in Object2(object)) {
              result2.push(key);
            }
          }
          return result2;
        }
        function objectToString(value) {
          return nativeObjectToString.call(value);
        }
        function overRest(func, start, transform2) {
          start = nativeMax(start === undefined2 ? func.length - 1 : start, 0);
          return function() {
            var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array2(length);
            while (++index < length) {
              array[index] = args[start + index];
            }
            index = -1;
            var otherArgs = Array2(start + 1);
            while (++index < start) {
              otherArgs[index] = args[index];
            }
            otherArgs[start] = transform2(array);
            return apply(func, this, otherArgs);
          };
        }
        function parent(object, path2) {
          return path2.length < 2 ? object : baseGet(object, baseSlice(path2, 0, -1));
        }
        function reorder(array, indexes) {
          var arrLength = array.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray(array);
          while (length--) {
            var index = indexes[length];
            array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined2;
          }
          return array;
        }
        function safeGet(object, key) {
          if (key === "constructor" && typeof object[key] === "function") {
            return;
          }
          if (key == "__proto__") {
            return;
          }
          return object[key];
        }
        var setData = shortOut(baseSetData);
        var setTimeout2 = ctxSetTimeout || function(func, wait) {
          return root.setTimeout(func, wait);
        };
        var setToString = shortOut(baseSetToString);
        function setWrapToString(wrapper, reference, bitmask) {
          var source = reference + "";
          return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
        }
        function shortOut(func) {
          var count = 0, lastCalled = 0;
          return function() {
            var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
            lastCalled = stamp;
            if (remaining > 0) {
              if (++count >= HOT_COUNT) {
                return arguments[0];
              }
            } else {
              count = 0;
            }
            return func.apply(undefined2, arguments);
          };
        }
        function shuffleSelf(array, size2) {
          var index = -1, length = array.length, lastIndex = length - 1;
          size2 = size2 === undefined2 ? length : size2;
          while (++index < size2) {
            var rand = baseRandom(index, lastIndex), value = array[rand];
            array[rand] = array[index];
            array[index] = value;
          }
          array.length = size2;
          return array;
        }
        var stringToPath = memoizeCapped(function(string) {
          var result2 = [];
          if (string.charCodeAt(0) === 46) {
            result2.push("");
          }
          string.replace(rePropName, function(match2, number, quote, subString) {
            result2.push(quote ? subString.replace(reEscapeChar, "$1") : number || match2);
          });
          return result2;
        });
        function toKey(value) {
          if (typeof value == "string" || isSymbol(value)) {
            return value;
          }
          var result2 = value + "";
          return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
        }
        function toSource(func) {
          if (func != null) {
            try {
              return funcToString.call(func);
            } catch (e) {
            }
            try {
              return func + "";
            } catch (e) {
            }
          }
          return "";
        }
        function updateWrapDetails(details, bitmask) {
          arrayEach(wrapFlags, function(pair) {
            var value = "_." + pair[0];
            if (bitmask & pair[1] && !arrayIncludes(details, value)) {
              details.push(value);
            }
          });
          return details.sort();
        }
        function wrapperClone(wrapper) {
          if (wrapper instanceof LazyWrapper) {
            return wrapper.clone();
          }
          var result2 = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
          result2.__actions__ = copyArray(wrapper.__actions__);
          result2.__index__ = wrapper.__index__;
          result2.__values__ = wrapper.__values__;
          return result2;
        }
        function chunk(array, size2, guard) {
          if (guard ? isIterateeCall(array, size2, guard) : size2 === undefined2) {
            size2 = 1;
          } else {
            size2 = nativeMax(toInteger(size2), 0);
          }
          var length = array == null ? 0 : array.length;
          if (!length || size2 < 1) {
            return [];
          }
          var index = 0, resIndex = 0, result2 = Array2(nativeCeil(length / size2));
          while (index < length) {
            result2[resIndex++] = baseSlice(array, index, index += size2);
          }
          return result2;
        }
        function compact(array) {
          var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result2 = [];
          while (++index < length) {
            var value = array[index];
            if (value) {
              result2[resIndex++] = value;
            }
          }
          return result2;
        }
        function concat() {
          var length = arguments.length;
          if (!length) {
            return [];
          }
          var args = Array2(length - 1), array = arguments[0], index = length;
          while (index--) {
            args[index - 1] = arguments[index];
          }
          return arrayPush(isArray(array) ? copyArray(array) : [
            array
          ], baseFlatten(args, 1));
        }
        var difference = baseRest(function(array, values2) {
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true)) : [];
        });
        var differenceBy = baseRest(function(array, values2) {
          var iteratee2 = last(values2);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined2;
          }
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2)) : [];
        });
        var differenceWith = baseRest(function(array, values2) {
          var comparator = last(values2);
          if (isArrayLikeObject(comparator)) {
            comparator = undefined2;
          }
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), undefined2, comparator) : [];
        });
        function drop(array, n, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger(n);
          return baseSlice(array, n < 0 ? 0 : n, length);
        }
        function dropRight(array, n, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger(n);
          n = length - n;
          return baseSlice(array, 0, n < 0 ? 0 : n);
        }
        function dropRightWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true, true) : [];
        }
        function dropWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true) : [];
        }
        function fill(array, value, start, end) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          if (start && typeof start != "number" && isIterateeCall(array, value, start)) {
            start = 0;
            end = length;
          }
          return baseFill(array, value, start, end);
        }
        function findIndex(array, predicate, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = fromIndex == null ? 0 : toInteger(fromIndex);
          if (index < 0) {
            index = nativeMax(length + index, 0);
          }
          return baseFindIndex(array, getIteratee(predicate, 3), index);
        }
        function findLastIndex(array, predicate, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = length - 1;
          if (fromIndex !== undefined2) {
            index = toInteger(fromIndex);
            index = fromIndex < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
          }
          return baseFindIndex(array, getIteratee(predicate, 3), index, true);
        }
        function flatten(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseFlatten(array, 1) : [];
        }
        function flattenDeep(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseFlatten(array, INFINITY) : [];
        }
        function flattenDepth(array, depth) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          depth = depth === undefined2 ? 1 : toInteger(depth);
          return baseFlatten(array, depth);
        }
        function fromPairs(pairs) {
          var index = -1, length = pairs == null ? 0 : pairs.length, result2 = {};
          while (++index < length) {
            var pair = pairs[index];
            result2[pair[0]] = pair[1];
          }
          return result2;
        }
        function head(array) {
          return array && array.length ? array[0] : undefined2;
        }
        function indexOf(array, value, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = fromIndex == null ? 0 : toInteger(fromIndex);
          if (index < 0) {
            index = nativeMax(length + index, 0);
          }
          return baseIndexOf(array, value, index);
        }
        function initial(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseSlice(array, 0, -1) : [];
        }
        var intersection = baseRest(function(arrays) {
          var mapped = arrayMap(arrays, castArrayLikeObject);
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
        });
        var intersectionBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
          if (iteratee2 === last(mapped)) {
            iteratee2 = undefined2;
          } else {
            mapped.pop();
          }
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];
        });
        var intersectionWith = baseRest(function(arrays) {
          var comparator = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          if (comparator) {
            mapped.pop();
          }
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined2, comparator) : [];
        });
        function join2(array, separator) {
          return array == null ? "" : nativeJoin.call(array, separator);
        }
        function last(array) {
          var length = array == null ? 0 : array.length;
          return length ? array[length - 1] : undefined2;
        }
        function lastIndexOf(array, value, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = length;
          if (fromIndex !== undefined2) {
            index = toInteger(fromIndex);
            index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
          }
          return value === value ? strictLastIndexOf(array, value, index) : baseFindIndex(array, baseIsNaN, index, true);
        }
        function nth(array, n) {
          return array && array.length ? baseNth(array, toInteger(n)) : undefined2;
        }
        var pull = baseRest(pullAll);
        function pullAll(array, values2) {
          return array && array.length && values2 && values2.length ? basePullAll(array, values2) : array;
        }
        function pullAllBy(array, values2, iteratee2) {
          return array && array.length && values2 && values2.length ? basePullAll(array, values2, getIteratee(iteratee2, 2)) : array;
        }
        function pullAllWith(array, values2, comparator) {
          return array && array.length && values2 && values2.length ? basePullAll(array, values2, undefined2, comparator) : array;
        }
        var pullAt = flatRest(function(array, indexes) {
          var length = array == null ? 0 : array.length, result2 = baseAt(array, indexes);
          basePullAt(array, arrayMap(indexes, function(index) {
            return isIndex(index, length) ? +index : index;
          }).sort(compareAscending));
          return result2;
        });
        function remove(array, predicate) {
          var result2 = [];
          if (!(array && array.length)) {
            return result2;
          }
          var index = -1, indexes = [], length = array.length;
          predicate = getIteratee(predicate, 3);
          while (++index < length) {
            var value = array[index];
            if (predicate(value, index, array)) {
              result2.push(value);
              indexes.push(index);
            }
          }
          basePullAt(array, indexes);
          return result2;
        }
        function reverse(array) {
          return array == null ? array : nativeReverse.call(array);
        }
        function slice(array, start, end) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          if (end && typeof end != "number" && isIterateeCall(array, start, end)) {
            start = 0;
            end = length;
          } else {
            start = start == null ? 0 : toInteger(start);
            end = end === undefined2 ? length : toInteger(end);
          }
          return baseSlice(array, start, end);
        }
        function sortedIndex(array, value) {
          return baseSortedIndex(array, value);
        }
        function sortedIndexBy(array, value, iteratee2) {
          return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2));
        }
        function sortedIndexOf(array, value) {
          var length = array == null ? 0 : array.length;
          if (length) {
            var index = baseSortedIndex(array, value);
            if (index < length && eq(array[index], value)) {
              return index;
            }
          }
          return -1;
        }
        function sortedLastIndex(array, value) {
          return baseSortedIndex(array, value, true);
        }
        function sortedLastIndexBy(array, value, iteratee2) {
          return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2), true);
        }
        function sortedLastIndexOf(array, value) {
          var length = array == null ? 0 : array.length;
          if (length) {
            var index = baseSortedIndex(array, value, true) - 1;
            if (eq(array[index], value)) {
              return index;
            }
          }
          return -1;
        }
        function sortedUniq(array) {
          return array && array.length ? baseSortedUniq(array) : [];
        }
        function sortedUniqBy(array, iteratee2) {
          return array && array.length ? baseSortedUniq(array, getIteratee(iteratee2, 2)) : [];
        }
        function tail(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseSlice(array, 1, length) : [];
        }
        function take(array, n, guard) {
          if (!(array && array.length)) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger(n);
          return baseSlice(array, 0, n < 0 ? 0 : n);
        }
        function takeRight(array, n, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger(n);
          n = length - n;
          return baseSlice(array, n < 0 ? 0 : n, length);
        }
        function takeRightWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), false, true) : [];
        }
        function takeWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : [];
        }
        var union = baseRest(function(arrays) {
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
        });
        var unionBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined2;
          }
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2));
        });
        var unionWith = baseRest(function(arrays) {
          var comparator = last(arrays);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined2, comparator);
        });
        function uniq(array) {
          return array && array.length ? baseUniq(array) : [];
        }
        function uniqBy(array, iteratee2) {
          return array && array.length ? baseUniq(array, getIteratee(iteratee2, 2)) : [];
        }
        function uniqWith(array, comparator) {
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return array && array.length ? baseUniq(array, undefined2, comparator) : [];
        }
        function unzip(array) {
          if (!(array && array.length)) {
            return [];
          }
          var length = 0;
          array = arrayFilter(array, function(group) {
            if (isArrayLikeObject(group)) {
              length = nativeMax(group.length, length);
              return true;
            }
          });
          return baseTimes(length, function(index) {
            return arrayMap(array, baseProperty(index));
          });
        }
        function unzipWith(array, iteratee2) {
          if (!(array && array.length)) {
            return [];
          }
          var result2 = unzip(array);
          if (iteratee2 == null) {
            return result2;
          }
          return arrayMap(result2, function(group) {
            return apply(iteratee2, undefined2, group);
          });
        }
        var without = baseRest(function(array, values2) {
          return isArrayLikeObject(array) ? baseDifference(array, values2) : [];
        });
        var xor = baseRest(function(arrays) {
          return baseXor(arrayFilter(arrays, isArrayLikeObject));
        });
        var xorBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined2;
          }
          return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee2, 2));
        });
        var xorWith = baseRest(function(arrays) {
          var comparator = last(arrays);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined2, comparator);
        });
        var zip = baseRest(unzip);
        function zipObject(props, values2) {
          return baseZipObject(props || [], values2 || [], assignValue);
        }
        function zipObjectDeep(props, values2) {
          return baseZipObject(props || [], values2 || [], baseSet);
        }
        var zipWith = baseRest(function(arrays) {
          var length = arrays.length, iteratee2 = length > 1 ? arrays[length - 1] : undefined2;
          iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined2;
          return unzipWith(arrays, iteratee2);
        });
        function chain(value) {
          var result2 = lodash(value);
          result2.__chain__ = true;
          return result2;
        }
        function tap(value, interceptor) {
          interceptor(value);
          return value;
        }
        function thru(value, interceptor) {
          return interceptor(value);
        }
        var wrapperAt = flatRest(function(paths) {
          var length = paths.length, start = length ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object) {
            return baseAt(object, paths);
          };
          if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start)) {
            return this.thru(interceptor);
          }
          value = value.slice(start, +start + (length ? 1 : 0));
          value.__actions__.push({
            "func": thru,
            "args": [
              interceptor
            ],
            "thisArg": undefined2
          });
          return new LodashWrapper(value, this.__chain__).thru(function(array) {
            if (length && !array.length) {
              array.push(undefined2);
            }
            return array;
          });
        });
        function wrapperChain() {
          return chain(this);
        }
        function wrapperCommit() {
          return new LodashWrapper(this.value(), this.__chain__);
        }
        function wrapperNext() {
          if (this.__values__ === undefined2) {
            this.__values__ = toArray(this.value());
          }
          var done = this.__index__ >= this.__values__.length, value = done ? undefined2 : this.__values__[this.__index__++];
          return {
            "done": done,
            "value": value
          };
        }
        function wrapperToIterator() {
          return this;
        }
        function wrapperPlant(value) {
          var result2, parent2 = this;
          while (parent2 instanceof baseLodash) {
            var clone3 = wrapperClone(parent2);
            clone3.__index__ = 0;
            clone3.__values__ = undefined2;
            if (result2) {
              previous.__wrapped__ = clone3;
            } else {
              result2 = clone3;
            }
            var previous = clone3;
            parent2 = parent2.__wrapped__;
          }
          previous.__wrapped__ = value;
          return result2;
        }
        function wrapperReverse() {
          var value = this.__wrapped__;
          if (value instanceof LazyWrapper) {
            var wrapped = value;
            if (this.__actions__.length) {
              wrapped = new LazyWrapper(this);
            }
            wrapped = wrapped.reverse();
            wrapped.__actions__.push({
              "func": thru,
              "args": [
                reverse
              ],
              "thisArg": undefined2
            });
            return new LodashWrapper(wrapped, this.__chain__);
          }
          return this.thru(reverse);
        }
        function wrapperValue() {
          return baseWrapperValue(this.__wrapped__, this.__actions__);
        }
        var countBy = createAggregator(function(result2, value, key) {
          if (hasOwnProperty.call(result2, key)) {
            ++result2[key];
          } else {
            baseAssignValue(result2, key, 1);
          }
        });
        function every(collection, predicate, guard) {
          var func = isArray(collection) ? arrayEvery : baseEvery;
          if (guard && isIterateeCall(collection, predicate, guard)) {
            predicate = undefined2;
          }
          return func(collection, getIteratee(predicate, 3));
        }
        function filter(collection, predicate) {
          var func = isArray(collection) ? arrayFilter : baseFilter;
          return func(collection, getIteratee(predicate, 3));
        }
        var find2 = createFind(findIndex);
        var findLast = createFind(findLastIndex);
        function flatMap(collection, iteratee2) {
          return baseFlatten(map(collection, iteratee2), 1);
        }
        function flatMapDeep(collection, iteratee2) {
          return baseFlatten(map(collection, iteratee2), INFINITY);
        }
        function flatMapDepth(collection, iteratee2, depth) {
          depth = depth === undefined2 ? 1 : toInteger(depth);
          return baseFlatten(map(collection, iteratee2), depth);
        }
        function forEach(collection, iteratee2) {
          var func = isArray(collection) ? arrayEach : baseEach;
          return func(collection, getIteratee(iteratee2, 3));
        }
        function forEachRight(collection, iteratee2) {
          var func = isArray(collection) ? arrayEachRight : baseEachRight;
          return func(collection, getIteratee(iteratee2, 3));
        }
        var groupBy = createAggregator(function(result2, value, key) {
          if (hasOwnProperty.call(result2, key)) {
            result2[key].push(value);
          } else {
            baseAssignValue(result2, key, [
              value
            ]);
          }
        });
        function includes(collection, value, fromIndex, guard) {
          collection = isArrayLike(collection) ? collection : values(collection);
          fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
          var length = collection.length;
          if (fromIndex < 0) {
            fromIndex = nativeMax(length + fromIndex, 0);
          }
          return isString(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
        }
        var invokeMap = baseRest(function(collection, path2, args) {
          var index = -1, isFunc = typeof path2 == "function", result2 = isArrayLike(collection) ? Array2(collection.length) : [];
          baseEach(collection, function(value) {
            result2[++index] = isFunc ? apply(path2, value, args) : baseInvoke(value, path2, args);
          });
          return result2;
        });
        var keyBy = createAggregator(function(result2, value, key) {
          baseAssignValue(result2, key, value);
        });
        function map(collection, iteratee2) {
          var func = isArray(collection) ? arrayMap : baseMap;
          return func(collection, getIteratee(iteratee2, 3));
        }
        function orderBy(collection, iteratees, orders, guard) {
          if (collection == null) {
            return [];
          }
          if (!isArray(iteratees)) {
            iteratees = iteratees == null ? [] : [
              iteratees
            ];
          }
          orders = guard ? undefined2 : orders;
          if (!isArray(orders)) {
            orders = orders == null ? [] : [
              orders
            ];
          }
          return baseOrderBy(collection, iteratees, orders);
        }
        var partition = createAggregator(function(result2, value, key) {
          result2[key ? 0 : 1].push(value);
        }, function() {
          return [
            [],
            []
          ];
        });
        function reduce(collection, iteratee2, accumulator) {
          var func = isArray(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
          return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach);
        }
        function reduceRight(collection, iteratee2, accumulator) {
          var func = isArray(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
          return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
        }
        function reject(collection, predicate) {
          var func = isArray(collection) ? arrayFilter : baseFilter;
          return func(collection, negate(getIteratee(predicate, 3)));
        }
        function sample(collection) {
          var func = isArray(collection) ? arraySample : baseSample;
          return func(collection);
        }
        function sampleSize(collection, n, guard) {
          if (guard ? isIterateeCall(collection, n, guard) : n === undefined2) {
            n = 1;
          } else {
            n = toInteger(n);
          }
          var func = isArray(collection) ? arraySampleSize : baseSampleSize;
          return func(collection, n);
        }
        function shuffle(collection) {
          var func = isArray(collection) ? arrayShuffle : baseShuffle;
          return func(collection);
        }
        function size(collection) {
          if (collection == null) {
            return 0;
          }
          if (isArrayLike(collection)) {
            return isString(collection) ? stringSize(collection) : collection.length;
          }
          var tag = getTag(collection);
          if (tag == mapTag || tag == setTag) {
            return collection.size;
          }
          return baseKeys(collection).length;
        }
        function some(collection, predicate, guard) {
          var func = isArray(collection) ? arraySome : baseSome;
          if (guard && isIterateeCall(collection, predicate, guard)) {
            predicate = undefined2;
          }
          return func(collection, getIteratee(predicate, 3));
        }
        var sortBy = baseRest(function(collection, iteratees) {
          if (collection == null) {
            return [];
          }
          var length = iteratees.length;
          if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
            iteratees = [];
          } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
            iteratees = [
              iteratees[0]
            ];
          }
          return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
        });
        var now = ctxNow || function() {
          return root.Date.now();
        };
        function after(n, func) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          n = toInteger(n);
          return function() {
            if (--n < 1) {
              return func.apply(this, arguments);
            }
          };
        }
        function ary(func, n, guard) {
          n = guard ? undefined2 : n;
          n = func && n == null ? func.length : n;
          return createWrap(func, WRAP_ARY_FLAG, undefined2, undefined2, undefined2, undefined2, n);
        }
        function before(n, func) {
          var result2;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          n = toInteger(n);
          return function() {
            if (--n > 0) {
              result2 = func.apply(this, arguments);
            }
            if (n <= 1) {
              func = undefined2;
            }
            return result2;
          };
        }
        var bind = baseRest(function(func, thisArg, partials) {
          var bitmask = WRAP_BIND_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bind));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(func, bitmask, thisArg, partials, holders);
        });
        var bindKey = baseRest(function(object, key, partials) {
          var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bindKey));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(key, bitmask, object, partials, holders);
        });
        function curry(func, arity, guard) {
          arity = guard ? undefined2 : arity;
          var result2 = createWrap(func, WRAP_CURRY_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
          result2.placeholder = curry.placeholder;
          return result2;
        }
        function curryRight(func, arity, guard) {
          arity = guard ? undefined2 : arity;
          var result2 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
          result2.placeholder = curryRight.placeholder;
          return result2;
        }
        function debounce(func, wait, options) {
          var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          wait = toNumber(wait) || 0;
          if (isObject(options)) {
            leading = !!options.leading;
            maxing = "maxWait" in options;
            maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
            trailing = "trailing" in options ? !!options.trailing : trailing;
          }
          function invokeFunc(time) {
            var args = lastArgs, thisArg = lastThis;
            lastArgs = lastThis = undefined2;
            lastInvokeTime = time;
            result2 = func.apply(thisArg, args);
            return result2;
          }
          function leadingEdge(time) {
            lastInvokeTime = time;
            timerId = setTimeout2(timerExpired, wait);
            return leading ? invokeFunc(time) : result2;
          }
          function remainingWait(time) {
            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
            return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
          }
          function shouldInvoke(time) {
            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
            return lastCallTime === undefined2 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
          }
          function timerExpired() {
            var time = now();
            if (shouldInvoke(time)) {
              return trailingEdge(time);
            }
            timerId = setTimeout2(timerExpired, remainingWait(time));
          }
          function trailingEdge(time) {
            timerId = undefined2;
            if (trailing && lastArgs) {
              return invokeFunc(time);
            }
            lastArgs = lastThis = undefined2;
            return result2;
          }
          function cancel() {
            if (timerId !== undefined2) {
              clearTimeout2(timerId);
            }
            lastInvokeTime = 0;
            lastArgs = lastCallTime = lastThis = timerId = undefined2;
          }
          function flush() {
            return timerId === undefined2 ? result2 : trailingEdge(now());
          }
          function debounced() {
            var time = now(), isInvoking = shouldInvoke(time);
            lastArgs = arguments;
            lastThis = this;
            lastCallTime = time;
            if (isInvoking) {
              if (timerId === undefined2) {
                return leadingEdge(lastCallTime);
              }
              if (maxing) {
                clearTimeout2(timerId);
                timerId = setTimeout2(timerExpired, wait);
                return invokeFunc(lastCallTime);
              }
            }
            if (timerId === undefined2) {
              timerId = setTimeout2(timerExpired, wait);
            }
            return result2;
          }
          debounced.cancel = cancel;
          debounced.flush = flush;
          return debounced;
        }
        var defer = baseRest(function(func, args) {
          return baseDelay(func, 1, args);
        });
        var delay = baseRest(function(func, wait, args) {
          return baseDelay(func, toNumber(wait) || 0, args);
        });
        function flip(func) {
          return createWrap(func, WRAP_FLIP_FLAG);
        }
        function memoize(func, resolver) {
          if (typeof func != "function" || resolver != null && typeof resolver != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          var memoized = function() {
            var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
            if (cache.has(key)) {
              return cache.get(key);
            }
            var result2 = func.apply(this, args);
            memoized.cache = cache.set(key, result2) || cache;
            return result2;
          };
          memoized.cache = new (memoize.Cache || MapCache)();
          return memoized;
        }
        memoize.Cache = MapCache;
        function negate(predicate) {
          if (typeof predicate != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return function() {
            var args = arguments;
            switch (args.length) {
              case 0:
                return !predicate.call(this);
              case 1:
                return !predicate.call(this, args[0]);
              case 2:
                return !predicate.call(this, args[0], args[1]);
              case 3:
                return !predicate.call(this, args[0], args[1], args[2]);
            }
            return !predicate.apply(this, args);
          };
        }
        function once(func) {
          return before(2, func);
        }
        var overArgs = castRest(function(func, transforms) {
          transforms = transforms.length == 1 && isArray(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
          var funcsLength = transforms.length;
          return baseRest(function(args) {
            var index = -1, length = nativeMin(args.length, funcsLength);
            while (++index < length) {
              args[index] = transforms[index].call(this, args[index]);
            }
            return apply(func, this, args);
          });
        });
        var partial = baseRest(function(func, partials) {
          var holders = replaceHolders(partials, getHolder(partial));
          return createWrap(func, WRAP_PARTIAL_FLAG, undefined2, partials, holders);
        });
        var partialRight = baseRest(function(func, partials) {
          var holders = replaceHolders(partials, getHolder(partialRight));
          return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined2, partials, holders);
        });
        var rearg = flatRest(function(func, indexes) {
          return createWrap(func, WRAP_REARG_FLAG, undefined2, undefined2, undefined2, indexes);
        });
        function rest(func, start) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          start = start === undefined2 ? start : toInteger(start);
          return baseRest(func, start);
        }
        function spread(func, start) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          start = start == null ? 0 : nativeMax(toInteger(start), 0);
          return baseRest(function(args) {
            var array = args[start], otherArgs = castSlice(args, 0, start);
            if (array) {
              arrayPush(otherArgs, array);
            }
            return apply(func, this, otherArgs);
          });
        }
        function throttle(func, wait, options) {
          var leading = true, trailing = true;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          if (isObject(options)) {
            leading = "leading" in options ? !!options.leading : leading;
            trailing = "trailing" in options ? !!options.trailing : trailing;
          }
          return debounce(func, wait, {
            "leading": leading,
            "maxWait": wait,
            "trailing": trailing
          });
        }
        function unary(func) {
          return ary(func, 1);
        }
        function wrap(value, wrapper) {
          return partial(castFunction(wrapper), value);
        }
        function castArray() {
          if (!arguments.length) {
            return [];
          }
          var value = arguments[0];
          return isArray(value) ? value : [
            value
          ];
        }
        function clone2(value) {
          return baseClone(value, CLONE_SYMBOLS_FLAG);
        }
        function cloneWith(value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
        }
        function cloneDeep(value) {
          return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
        }
        function cloneDeepWith(value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
        }
        function conformsTo(object, source) {
          return source == null || baseConformsTo(object, source, keys(source));
        }
        function eq(value, other) {
          return value === other || value !== value && other !== other;
        }
        var gt = createRelationalOperation(baseGt);
        var gte = createRelationalOperation(function(value, other) {
          return value >= other;
        });
        var isArguments = baseIsArguments(/* @__PURE__ */ function() {
          return arguments;
        }()) ? baseIsArguments : function(value) {
          return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
        };
        var isArray = Array2.isArray;
        var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
        function isArrayLike(value) {
          return value != null && isLength(value.length) && !isFunction(value);
        }
        function isArrayLikeObject(value) {
          return isObjectLike(value) && isArrayLike(value);
        }
        function isBoolean(value) {
          return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag;
        }
        var isBuffer = nativeIsBuffer || stubFalse;
        var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
        function isElement(value) {
          return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
        }
        function isEmpty(value) {
          if (value == null) {
            return true;
          }
          if (isArrayLike(value) && (isArray(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer(value) || isTypedArray(value) || isArguments(value))) {
            return !value.length;
          }
          var tag = getTag(value);
          if (tag == mapTag || tag == setTag) {
            return !value.size;
          }
          if (isPrototype(value)) {
            return !baseKeys(value).length;
          }
          for (var key in value) {
            if (hasOwnProperty.call(value, key)) {
              return false;
            }
          }
          return true;
        }
        function isEqual(value, other) {
          return baseIsEqual(value, other);
        }
        function isEqualWith(value, other, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          var result2 = customizer ? customizer(value, other) : undefined2;
          return result2 === undefined2 ? baseIsEqual(value, other, undefined2, customizer) : !!result2;
        }
        function isError(value) {
          if (!isObjectLike(value)) {
            return false;
          }
          var tag = baseGetTag(value);
          return tag == errorTag || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject(value);
        }
        function isFinite2(value) {
          return typeof value == "number" && nativeIsFinite(value);
        }
        function isFunction(value) {
          if (!isObject(value)) {
            return false;
          }
          var tag = baseGetTag(value);
          return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
        }
        function isInteger(value) {
          return typeof value == "number" && value == toInteger(value);
        }
        function isLength(value) {
          return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
        }
        function isObject(value) {
          var type = typeof value;
          return value != null && (type == "object" || type == "function");
        }
        function isObjectLike(value) {
          return value != null && typeof value == "object";
        }
        var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
        function isMatch(object, source) {
          return object === source || baseIsMatch(object, source, getMatchData(source));
        }
        function isMatchWith(object, source, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseIsMatch(object, source, getMatchData(source), customizer);
        }
        function isNaN2(value) {
          return isNumber(value) && value != +value;
        }
        function isNative(value) {
          if (isMaskable(value)) {
            throw new Error2(CORE_ERROR_TEXT);
          }
          return baseIsNative(value);
        }
        function isNull(value) {
          return value === null;
        }
        function isNil(value) {
          return value == null;
        }
        function isNumber(value) {
          return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
        }
        function isPlainObject(value) {
          if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
            return false;
          }
          var proto = getPrototype(value);
          if (proto === null) {
            return true;
          }
          var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
          return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
        }
        var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
        function isSafeInteger(value) {
          return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
        }
        var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
        function isString(value) {
          return typeof value == "string" || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
        }
        function isSymbol(value) {
          return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
        }
        var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
        function isUndefined(value) {
          return value === undefined2;
        }
        function isWeakMap(value) {
          return isObjectLike(value) && getTag(value) == weakMapTag;
        }
        function isWeakSet(value) {
          return isObjectLike(value) && baseGetTag(value) == weakSetTag;
        }
        var lt = createRelationalOperation(baseLt);
        var lte = createRelationalOperation(function(value, other) {
          return value <= other;
        });
        function toArray(value) {
          if (!value) {
            return [];
          }
          if (isArrayLike(value)) {
            return isString(value) ? stringToArray(value) : copyArray(value);
          }
          if (symIterator && value[symIterator]) {
            return iteratorToArray(value[symIterator]());
          }
          var tag = getTag(value), func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values;
          return func(value);
        }
        function toFinite(value) {
          if (!value) {
            return value === 0 ? value : 0;
          }
          value = toNumber(value);
          if (value === INFINITY || value === -INFINITY) {
            var sign = value < 0 ? -1 : 1;
            return sign * MAX_INTEGER;
          }
          return value === value ? value : 0;
        }
        function toInteger(value) {
          var result2 = toFinite(value), remainder = result2 % 1;
          return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
        }
        function toLength(value) {
          return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
        }
        function toNumber(value) {
          if (typeof value == "number") {
            return value;
          }
          if (isSymbol(value)) {
            return NAN;
          }
          if (isObject(value)) {
            var other = typeof value.valueOf == "function" ? value.valueOf() : value;
            value = isObject(other) ? other + "" : other;
          }
          if (typeof value != "string") {
            return value === 0 ? value : +value;
          }
          value = baseTrim(value);
          var isBinary = reIsBinary.test(value);
          return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
        }
        function toPlainObject(value) {
          return copyObject(value, keysIn(value));
        }
        function toSafeInteger(value) {
          return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : value === 0 ? value : 0;
        }
        function toString(value) {
          return value == null ? "" : baseToString(value);
        }
        var assign = createAssigner(function(object, source) {
          if (isPrototype(source) || isArrayLike(source)) {
            copyObject(source, keys(source), object);
            return;
          }
          for (var key in source) {
            if (hasOwnProperty.call(source, key)) {
              assignValue(object, key, source[key]);
            }
          }
        });
        var assignIn = createAssigner(function(object, source) {
          copyObject(source, keysIn(source), object);
        });
        var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
          copyObject(source, keysIn(source), object, customizer);
        });
        var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
          copyObject(source, keys(source), object, customizer);
        });
        var at = flatRest(baseAt);
        function create(prototype, properties) {
          var result2 = baseCreate(prototype);
          return properties == null ? result2 : baseAssign(result2, properties);
        }
        var defaults = baseRest(function(object, sources) {
          object = Object2(object);
          var index = -1;
          var length = sources.length;
          var guard = length > 2 ? sources[2] : undefined2;
          if (guard && isIterateeCall(sources[0], sources[1], guard)) {
            length = 1;
          }
          while (++index < length) {
            var source = sources[index];
            var props = keysIn(source);
            var propsIndex = -1;
            var propsLength = props.length;
            while (++propsIndex < propsLength) {
              var key = props[propsIndex];
              var value = object[key];
              if (value === undefined2 || eq(value, objectProto[key]) && !hasOwnProperty.call(object, key)) {
                object[key] = source[key];
              }
            }
          }
          return object;
        });
        var defaultsDeep = baseRest(function(args) {
          args.push(undefined2, customDefaultsMerge);
          return apply(mergeWith, undefined2, args);
        });
        function findKey(object, predicate) {
          return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
        }
        function findLastKey(object, predicate) {
          return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
        }
        function forIn(object, iteratee2) {
          return object == null ? object : baseFor(object, getIteratee(iteratee2, 3), keysIn);
        }
        function forInRight(object, iteratee2) {
          return object == null ? object : baseForRight(object, getIteratee(iteratee2, 3), keysIn);
        }
        function forOwn(object, iteratee2) {
          return object && baseForOwn(object, getIteratee(iteratee2, 3));
        }
        function forOwnRight(object, iteratee2) {
          return object && baseForOwnRight(object, getIteratee(iteratee2, 3));
        }
        function functions(object) {
          return object == null ? [] : baseFunctions(object, keys(object));
        }
        function functionsIn(object) {
          return object == null ? [] : baseFunctions(object, keysIn(object));
        }
        function get(object, path2, defaultValue) {
          var result2 = object == null ? undefined2 : baseGet(object, path2);
          return result2 === undefined2 ? defaultValue : result2;
        }
        function has(object, path2) {
          return object != null && hasPath(object, path2, baseHas);
        }
        function hasIn(object, path2) {
          return object != null && hasPath(object, path2, baseHasIn);
        }
        var invert = createInverter(function(result2, value, key) {
          if (value != null && typeof value.toString != "function") {
            value = nativeObjectToString.call(value);
          }
          result2[value] = key;
        }, constant(identity));
        var invertBy = createInverter(function(result2, value, key) {
          if (value != null && typeof value.toString != "function") {
            value = nativeObjectToString.call(value);
          }
          if (hasOwnProperty.call(result2, value)) {
            result2[value].push(key);
          } else {
            result2[value] = [
              key
            ];
          }
        }, getIteratee);
        var invoke = baseRest(baseInvoke);
        function keys(object) {
          return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
        }
        function keysIn(object) {
          return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
        }
        function mapKeys(object, iteratee2) {
          var result2 = {};
          iteratee2 = getIteratee(iteratee2, 3);
          baseForOwn(object, function(value, key, object2) {
            baseAssignValue(result2, iteratee2(value, key, object2), value);
          });
          return result2;
        }
        function mapValues(object, iteratee2) {
          var result2 = {};
          iteratee2 = getIteratee(iteratee2, 3);
          baseForOwn(object, function(value, key, object2) {
            baseAssignValue(result2, key, iteratee2(value, key, object2));
          });
          return result2;
        }
        var merge = createAssigner(function(object, source, srcIndex) {
          baseMerge(object, source, srcIndex);
        });
        var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
          baseMerge(object, source, srcIndex, customizer);
        });
        var omit = flatRest(function(object, paths) {
          var result2 = {};
          if (object == null) {
            return result2;
          }
          var isDeep = false;
          paths = arrayMap(paths, function(path2) {
            path2 = castPath(path2, object);
            isDeep || (isDeep = path2.length > 1);
            return path2;
          });
          copyObject(object, getAllKeysIn(object), result2);
          if (isDeep) {
            result2 = baseClone(result2, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
          }
          var length = paths.length;
          while (length--) {
            baseUnset(result2, paths[length]);
          }
          return result2;
        });
        function omitBy(object, predicate) {
          return pickBy(object, negate(getIteratee(predicate)));
        }
        var pick = flatRest(function(object, paths) {
          return object == null ? {} : basePick(object, paths);
        });
        function pickBy(object, predicate) {
          if (object == null) {
            return {};
          }
          var props = arrayMap(getAllKeysIn(object), function(prop) {
            return [
              prop
            ];
          });
          predicate = getIteratee(predicate);
          return basePickBy(object, props, function(value, path2) {
            return predicate(value, path2[0]);
          });
        }
        function result(object, path2, defaultValue) {
          path2 = castPath(path2, object);
          var index = -1, length = path2.length;
          if (!length) {
            length = 1;
            object = undefined2;
          }
          while (++index < length) {
            var value = object == null ? undefined2 : object[toKey(path2[index])];
            if (value === undefined2) {
              index = length;
              value = defaultValue;
            }
            object = isFunction(value) ? value.call(object) : value;
          }
          return object;
        }
        function set(object, path2, value) {
          return object == null ? object : baseSet(object, path2, value);
        }
        function setWith(object, path2, value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return object == null ? object : baseSet(object, path2, value, customizer);
        }
        var toPairs = createToPairs(keys);
        var toPairsIn = createToPairs(keysIn);
        function transform(object, iteratee2, accumulator) {
          var isArr = isArray(object), isArrLike = isArr || isBuffer(object) || isTypedArray(object);
          iteratee2 = getIteratee(iteratee2, 4);
          if (accumulator == null) {
            var Ctor = object && object.constructor;
            if (isArrLike) {
              accumulator = isArr ? new Ctor() : [];
            } else if (isObject(object)) {
              accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
            } else {
              accumulator = {};
            }
          }
          (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object2) {
            return iteratee2(accumulator, value, index, object2);
          });
          return accumulator;
        }
        function unset(object, path2) {
          return object == null ? true : baseUnset(object, path2);
        }
        function update(object, path2, updater) {
          return object == null ? object : baseUpdate(object, path2, castFunction(updater));
        }
        function updateWith(object, path2, updater, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return object == null ? object : baseUpdate(object, path2, castFunction(updater), customizer);
        }
        function values(object) {
          return object == null ? [] : baseValues(object, keys(object));
        }
        function valuesIn(object) {
          return object == null ? [] : baseValues(object, keysIn(object));
        }
        function clamp(number, lower, upper) {
          if (upper === undefined2) {
            upper = lower;
            lower = undefined2;
          }
          if (upper !== undefined2) {
            upper = toNumber(upper);
            upper = upper === upper ? upper : 0;
          }
          if (lower !== undefined2) {
            lower = toNumber(lower);
            lower = lower === lower ? lower : 0;
          }
          return baseClamp(toNumber(number), lower, upper);
        }
        function inRange(number, start, end) {
          start = toFinite(start);
          if (end === undefined2) {
            end = start;
            start = 0;
          } else {
            end = toFinite(end);
          }
          number = toNumber(number);
          return baseInRange(number, start, end);
        }
        function random(lower, upper, floating) {
          if (floating && typeof floating != "boolean" && isIterateeCall(lower, upper, floating)) {
            upper = floating = undefined2;
          }
          if (floating === undefined2) {
            if (typeof upper == "boolean") {
              floating = upper;
              upper = undefined2;
            } else if (typeof lower == "boolean") {
              floating = lower;
              lower = undefined2;
            }
          }
          if (lower === undefined2 && upper === undefined2) {
            lower = 0;
            upper = 1;
          } else {
            lower = toFinite(lower);
            if (upper === undefined2) {
              upper = lower;
              lower = 0;
            } else {
              upper = toFinite(upper);
            }
          }
          if (lower > upper) {
            var temp = lower;
            lower = upper;
            upper = temp;
          }
          if (floating || lower % 1 || upper % 1) {
            var rand = nativeRandom();
            return nativeMin(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
          }
          return baseRandom(lower, upper);
        }
        var camelCase = createCompounder(function(result2, word, index) {
          word = word.toLowerCase();
          return result2 + (index ? capitalize(word) : word);
        });
        function capitalize(string) {
          return upperFirst(toString(string).toLowerCase());
        }
        function deburr(string) {
          string = toString(string);
          return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
        }
        function endsWith(string, target, position) {
          string = toString(string);
          target = baseToString(target);
          var length = string.length;
          position = position === undefined2 ? length : baseClamp(toInteger(position), 0, length);
          var end = position;
          position -= target.length;
          return position >= 0 && string.slice(position, end) == target;
        }
        function escape2(string) {
          string = toString(string);
          return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
        }
        function escapeRegExp(string) {
          string = toString(string);
          return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, "\\$&") : string;
        }
        var kebabCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? "-" : "") + word.toLowerCase();
        });
        var lowerCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? " " : "") + word.toLowerCase();
        });
        var lowerFirst = createCaseFirst("toLowerCase");
        function pad(string, length, chars) {
          string = toString(string);
          length = toInteger(length);
          var strLength = length ? stringSize(string) : 0;
          if (!length || strLength >= length) {
            return string;
          }
          var mid = (length - strLength) / 2;
          return createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars);
        }
        function padEnd(string, length, chars) {
          string = toString(string);
          length = toInteger(length);
          var strLength = length ? stringSize(string) : 0;
          return length && strLength < length ? string + createPadding(length - strLength, chars) : string;
        }
        function padStart(string, length, chars) {
          string = toString(string);
          length = toInteger(length);
          var strLength = length ? stringSize(string) : 0;
          return length && strLength < length ? createPadding(length - strLength, chars) + string : string;
        }
        function parseInt2(string, radix, guard) {
          if (guard || radix == null) {
            radix = 0;
          } else if (radix) {
            radix = +radix;
          }
          return nativeParseInt(toString(string).replace(reTrimStart, ""), radix || 0);
        }
        function repeat(string, n, guard) {
          if (guard ? isIterateeCall(string, n, guard) : n === undefined2) {
            n = 1;
          } else {
            n = toInteger(n);
          }
          return baseRepeat(toString(string), n);
        }
        function replace() {
          var args = arguments, string = toString(args[0]);
          return args.length < 3 ? string : string.replace(args[1], args[2]);
        }
        var snakeCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? "_" : "") + word.toLowerCase();
        });
        function split(string, separator, limit) {
          if (limit && typeof limit != "number" && isIterateeCall(string, separator, limit)) {
            separator = limit = undefined2;
          }
          limit = limit === undefined2 ? MAX_ARRAY_LENGTH : limit >>> 0;
          if (!limit) {
            return [];
          }
          string = toString(string);
          if (string && (typeof separator == "string" || separator != null && !isRegExp(separator))) {
            separator = baseToString(separator);
            if (!separator && hasUnicode(string)) {
              return castSlice(stringToArray(string), 0, limit);
            }
          }
          return string.split(separator, limit);
        }
        var startCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? " " : "") + upperFirst(word);
        });
        function startsWith(string, target, position) {
          string = toString(string);
          position = position == null ? 0 : baseClamp(toInteger(position), 0, string.length);
          target = baseToString(target);
          return string.slice(position, position + target.length) == target;
        }
        function template(string, options, guard) {
          var settings = lodash.templateSettings;
          if (guard && isIterateeCall(string, options, guard)) {
            options = undefined2;
          }
          string = toString(string);
          options = assignInWith({}, options, settings, customDefaultsAssignIn);
          var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys);
          var isEscaping, isEvaluating, index = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
          var reDelimiters = RegExp2((options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$", "g");
          var sourceURL = "//# sourceURL=" + (hasOwnProperty.call(options, "sourceURL") ? (options.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
          string.replace(reDelimiters, function(match2, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
            interpolateValue || (interpolateValue = esTemplateValue);
            source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);
            if (escapeValue) {
              isEscaping = true;
              source += "' +\n__e(" + escapeValue + ") +\n'";
            }
            if (evaluateValue) {
              isEvaluating = true;
              source += "';\n" + evaluateValue + ";\n__p += '";
            }
            if (interpolateValue) {
              source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
            }
            index = offset + match2.length;
            return match2;
          });
          source += "';\n";
          var variable = hasOwnProperty.call(options, "variable") && options.variable;
          if (!variable) {
            source = "with (obj) {\n" + source + "\n}\n";
          } else if (reForbiddenIdentifierChars.test(variable)) {
            throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);
          }
          source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
          source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
          var result2 = attempt(function() {
            return Function2(importsKeys, sourceURL + "return " + source).apply(undefined2, importsValues);
          });
          result2.source = source;
          if (isError(result2)) {
            throw result2;
          }
          return result2;
        }
        function toLower(value) {
          return toString(value).toLowerCase();
        }
        function toUpper(value) {
          return toString(value).toUpperCase();
        }
        function trim(string, chars, guard) {
          string = toString(string);
          if (string && (guard || chars === undefined2)) {
            return baseTrim(string);
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
          return castSlice(strSymbols, start, end).join("");
        }
        function trimEnd(string, chars, guard) {
          string = toString(string);
          if (string && (guard || chars === undefined2)) {
            return string.slice(0, trimmedEndIndex(string) + 1);
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
          return castSlice(strSymbols, 0, end).join("");
        }
        function trimStart(string, chars, guard) {
          string = toString(string);
          if (string && (guard || chars === undefined2)) {
            return string.replace(reTrimStart, "");
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string), start = charsStartIndex(strSymbols, stringToArray(chars));
          return castSlice(strSymbols, start).join("");
        }
        function truncate(string, options) {
          var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
          if (isObject(options)) {
            var separator = "separator" in options ? options.separator : separator;
            length = "length" in options ? toInteger(options.length) : length;
            omission = "omission" in options ? baseToString(options.omission) : omission;
          }
          string = toString(string);
          var strLength = string.length;
          if (hasUnicode(string)) {
            var strSymbols = stringToArray(string);
            strLength = strSymbols.length;
          }
          if (length >= strLength) {
            return string;
          }
          var end = length - stringSize(omission);
          if (end < 1) {
            return omission;
          }
          var result2 = strSymbols ? castSlice(strSymbols, 0, end).join("") : string.slice(0, end);
          if (separator === undefined2) {
            return result2 + omission;
          }
          if (strSymbols) {
            end += result2.length - end;
          }
          if (isRegExp(separator)) {
            if (string.slice(end).search(separator)) {
              var match2, substring = result2;
              if (!separator.global) {
                separator = RegExp2(separator.source, toString(reFlags.exec(separator)) + "g");
              }
              separator.lastIndex = 0;
              while (match2 = separator.exec(substring)) {
                var newEnd = match2.index;
              }
              result2 = result2.slice(0, newEnd === undefined2 ? end : newEnd);
            }
          } else if (string.indexOf(baseToString(separator), end) != end) {
            var index = result2.lastIndexOf(separator);
            if (index > -1) {
              result2 = result2.slice(0, index);
            }
          }
          return result2 + omission;
        }
        function unescape2(string) {
          string = toString(string);
          return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
        }
        var upperCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? " " : "") + word.toUpperCase();
        });
        var upperFirst = createCaseFirst("toUpperCase");
        function words(string, pattern, guard) {
          string = toString(string);
          pattern = guard ? undefined2 : pattern;
          if (pattern === undefined2) {
            return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
          }
          return string.match(pattern) || [];
        }
        var attempt = baseRest(function(func, args) {
          try {
            return apply(func, undefined2, args);
          } catch (e) {
            return isError(e) ? e : new Error2(e);
          }
        });
        var bindAll = flatRest(function(object, methodNames) {
          arrayEach(methodNames, function(key) {
            key = toKey(key);
            baseAssignValue(object, key, bind(object[key], object));
          });
          return object;
        });
        function cond(pairs) {
          var length = pairs == null ? 0 : pairs.length, toIteratee = getIteratee();
          pairs = !length ? [] : arrayMap(pairs, function(pair) {
            if (typeof pair[1] != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            return [
              toIteratee(pair[0]),
              pair[1]
            ];
          });
          return baseRest(function(args) {
            var index = -1;
            while (++index < length) {
              var pair = pairs[index];
              if (apply(pair[0], this, args)) {
                return apply(pair[1], this, args);
              }
            }
          });
        }
        function conforms(source) {
          return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
        }
        function constant(value) {
          return function() {
            return value;
          };
        }
        function defaultTo(value, defaultValue) {
          return value == null || value !== value ? defaultValue : value;
        }
        var flow = createFlow();
        var flowRight = createFlow(true);
        function identity(value) {
          return value;
        }
        function iteratee(func) {
          return baseIteratee(typeof func == "function" ? func : baseClone(func, CLONE_DEEP_FLAG));
        }
        function matches(source) {
          return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
        }
        function matchesProperty(path2, srcValue) {
          return baseMatchesProperty(path2, baseClone(srcValue, CLONE_DEEP_FLAG));
        }
        var method = baseRest(function(path2, args) {
          return function(object) {
            return baseInvoke(object, path2, args);
          };
        });
        var methodOf = baseRest(function(object, args) {
          return function(path2) {
            return baseInvoke(object, path2, args);
          };
        });
        function mixin(object, source, options) {
          var props = keys(source), methodNames = baseFunctions(source, props);
          if (options == null && !(isObject(source) && (methodNames.length || !props.length))) {
            options = source;
            source = object;
            object = this;
            methodNames = baseFunctions(source, keys(source));
          }
          var chain2 = !(isObject(options) && "chain" in options) || !!options.chain, isFunc = isFunction(object);
          arrayEach(methodNames, function(methodName) {
            var func = source[methodName];
            object[methodName] = func;
            if (isFunc) {
              object.prototype[methodName] = function() {
                var chainAll = this.__chain__;
                if (chain2 || chainAll) {
                  var result2 = object(this.__wrapped__), actions = result2.__actions__ = copyArray(this.__actions__);
                  actions.push({
                    "func": func,
                    "args": arguments,
                    "thisArg": object
                  });
                  result2.__chain__ = chainAll;
                  return result2;
                }
                return func.apply(object, arrayPush([
                  this.value()
                ], arguments));
              };
            }
          });
          return object;
        }
        function noConflict() {
          if (root._ === this) {
            root._ = oldDash;
          }
          return this;
        }
        function noop() {
        }
        function nthArg(n) {
          n = toInteger(n);
          return baseRest(function(args) {
            return baseNth(args, n);
          });
        }
        var over = createOver(arrayMap);
        var overEvery = createOver(arrayEvery);
        var overSome = createOver(arraySome);
        function property(path2) {
          return isKey(path2) ? baseProperty(toKey(path2)) : basePropertyDeep(path2);
        }
        function propertyOf(object) {
          return function(path2) {
            return object == null ? undefined2 : baseGet(object, path2);
          };
        }
        var range = createRange();
        var rangeRight = createRange(true);
        function stubArray() {
          return [];
        }
        function stubFalse() {
          return false;
        }
        function stubObject() {
          return {};
        }
        function stubString() {
          return "";
        }
        function stubTrue() {
          return true;
        }
        function times(n, iteratee2) {
          n = toInteger(n);
          if (n < 1 || n > MAX_SAFE_INTEGER) {
            return [];
          }
          var index = MAX_ARRAY_LENGTH, length = nativeMin(n, MAX_ARRAY_LENGTH);
          iteratee2 = getIteratee(iteratee2);
          n -= MAX_ARRAY_LENGTH;
          var result2 = baseTimes(length, iteratee2);
          while (++index < n) {
            iteratee2(index);
          }
          return result2;
        }
        function toPath(value) {
          if (isArray(value)) {
            return arrayMap(value, toKey);
          }
          return isSymbol(value) ? [
            value
          ] : copyArray(stringToPath(toString(value)));
        }
        function uniqueId(prefix) {
          var id = ++idCounter;
          return toString(prefix) + id;
        }
        var add = createMathOperation(function(augend, addend) {
          return augend + addend;
        }, 0);
        var ceil = createRound("ceil");
        var divide = createMathOperation(function(dividend, divisor) {
          return dividend / divisor;
        }, 1);
        var floor = createRound("floor");
        function max(array) {
          return array && array.length ? baseExtremum(array, identity, baseGt) : undefined2;
        }
        function maxBy(array, iteratee2) {
          return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseGt) : undefined2;
        }
        function mean(array) {
          return baseMean(array, identity);
        }
        function meanBy(array, iteratee2) {
          return baseMean(array, getIteratee(iteratee2, 2));
        }
        function min(array) {
          return array && array.length ? baseExtremum(array, identity, baseLt) : undefined2;
        }
        function minBy(array, iteratee2) {
          return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseLt) : undefined2;
        }
        var multiply = createMathOperation(function(multiplier, multiplicand) {
          return multiplier * multiplicand;
        }, 1);
        var round = createRound("round");
        var subtract = createMathOperation(function(minuend, subtrahend) {
          return minuend - subtrahend;
        }, 0);
        function sum(array) {
          return array && array.length ? baseSum(array, identity) : 0;
        }
        function sumBy(array, iteratee2) {
          return array && array.length ? baseSum(array, getIteratee(iteratee2, 2)) : 0;
        }
        lodash.after = after;
        lodash.ary = ary;
        lodash.assign = assign;
        lodash.assignIn = assignIn;
        lodash.assignInWith = assignInWith;
        lodash.assignWith = assignWith;
        lodash.at = at;
        lodash.before = before;
        lodash.bind = bind;
        lodash.bindAll = bindAll;
        lodash.bindKey = bindKey;
        lodash.castArray = castArray;
        lodash.chain = chain;
        lodash.chunk = chunk;
        lodash.compact = compact;
        lodash.concat = concat;
        lodash.cond = cond;
        lodash.conforms = conforms;
        lodash.constant = constant;
        lodash.countBy = countBy;
        lodash.create = create;
        lodash.curry = curry;
        lodash.curryRight = curryRight;
        lodash.debounce = debounce;
        lodash.defaults = defaults;
        lodash.defaultsDeep = defaultsDeep;
        lodash.defer = defer;
        lodash.delay = delay;
        lodash.difference = difference;
        lodash.differenceBy = differenceBy;
        lodash.differenceWith = differenceWith;
        lodash.drop = drop;
        lodash.dropRight = dropRight;
        lodash.dropRightWhile = dropRightWhile;
        lodash.dropWhile = dropWhile;
        lodash.fill = fill;
        lodash.filter = filter;
        lodash.flatMap = flatMap;
        lodash.flatMapDeep = flatMapDeep;
        lodash.flatMapDepth = flatMapDepth;
        lodash.flatten = flatten;
        lodash.flattenDeep = flattenDeep;
        lodash.flattenDepth = flattenDepth;
        lodash.flip = flip;
        lodash.flow = flow;
        lodash.flowRight = flowRight;
        lodash.fromPairs = fromPairs;
        lodash.functions = functions;
        lodash.functionsIn = functionsIn;
        lodash.groupBy = groupBy;
        lodash.initial = initial;
        lodash.intersection = intersection;
        lodash.intersectionBy = intersectionBy;
        lodash.intersectionWith = intersectionWith;
        lodash.invert = invert;
        lodash.invertBy = invertBy;
        lodash.invokeMap = invokeMap;
        lodash.iteratee = iteratee;
        lodash.keyBy = keyBy;
        lodash.keys = keys;
        lodash.keysIn = keysIn;
        lodash.map = map;
        lodash.mapKeys = mapKeys;
        lodash.mapValues = mapValues;
        lodash.matches = matches;
        lodash.matchesProperty = matchesProperty;
        lodash.memoize = memoize;
        lodash.merge = merge;
        lodash.mergeWith = mergeWith;
        lodash.method = method;
        lodash.methodOf = methodOf;
        lodash.mixin = mixin;
        lodash.negate = negate;
        lodash.nthArg = nthArg;
        lodash.omit = omit;
        lodash.omitBy = omitBy;
        lodash.once = once;
        lodash.orderBy = orderBy;
        lodash.over = over;
        lodash.overArgs = overArgs;
        lodash.overEvery = overEvery;
        lodash.overSome = overSome;
        lodash.partial = partial;
        lodash.partialRight = partialRight;
        lodash.partition = partition;
        lodash.pick = pick;
        lodash.pickBy = pickBy;
        lodash.property = property;
        lodash.propertyOf = propertyOf;
        lodash.pull = pull;
        lodash.pullAll = pullAll;
        lodash.pullAllBy = pullAllBy;
        lodash.pullAllWith = pullAllWith;
        lodash.pullAt = pullAt;
        lodash.range = range;
        lodash.rangeRight = rangeRight;
        lodash.rearg = rearg;
        lodash.reject = reject;
        lodash.remove = remove;
        lodash.rest = rest;
        lodash.reverse = reverse;
        lodash.sampleSize = sampleSize;
        lodash.set = set;
        lodash.setWith = setWith;
        lodash.shuffle = shuffle;
        lodash.slice = slice;
        lodash.sortBy = sortBy;
        lodash.sortedUniq = sortedUniq;
        lodash.sortedUniqBy = sortedUniqBy;
        lodash.split = split;
        lodash.spread = spread;
        lodash.tail = tail;
        lodash.take = take;
        lodash.takeRight = takeRight;
        lodash.takeRightWhile = takeRightWhile;
        lodash.takeWhile = takeWhile;
        lodash.tap = tap;
        lodash.throttle = throttle;
        lodash.thru = thru;
        lodash.toArray = toArray;
        lodash.toPairs = toPairs;
        lodash.toPairsIn = toPairsIn;
        lodash.toPath = toPath;
        lodash.toPlainObject = toPlainObject;
        lodash.transform = transform;
        lodash.unary = unary;
        lodash.union = union;
        lodash.unionBy = unionBy;
        lodash.unionWith = unionWith;
        lodash.uniq = uniq;
        lodash.uniqBy = uniqBy;
        lodash.uniqWith = uniqWith;
        lodash.unset = unset;
        lodash.unzip = unzip;
        lodash.unzipWith = unzipWith;
        lodash.update = update;
        lodash.updateWith = updateWith;
        lodash.values = values;
        lodash.valuesIn = valuesIn;
        lodash.without = without;
        lodash.words = words;
        lodash.wrap = wrap;
        lodash.xor = xor;
        lodash.xorBy = xorBy;
        lodash.xorWith = xorWith;
        lodash.zip = zip;
        lodash.zipObject = zipObject;
        lodash.zipObjectDeep = zipObjectDeep;
        lodash.zipWith = zipWith;
        lodash.entries = toPairs;
        lodash.entriesIn = toPairsIn;
        lodash.extend = assignIn;
        lodash.extendWith = assignInWith;
        mixin(lodash, lodash);
        lodash.add = add;
        lodash.attempt = attempt;
        lodash.camelCase = camelCase;
        lodash.capitalize = capitalize;
        lodash.ceil = ceil;
        lodash.clamp = clamp;
        lodash.clone = clone2;
        lodash.cloneDeep = cloneDeep;
        lodash.cloneDeepWith = cloneDeepWith;
        lodash.cloneWith = cloneWith;
        lodash.conformsTo = conformsTo;
        lodash.deburr = deburr;
        lodash.defaultTo = defaultTo;
        lodash.divide = divide;
        lodash.endsWith = endsWith;
        lodash.eq = eq;
        lodash.escape = escape2;
        lodash.escapeRegExp = escapeRegExp;
        lodash.every = every;
        lodash.find = find2;
        lodash.findIndex = findIndex;
        lodash.findKey = findKey;
        lodash.findLast = findLast;
        lodash.findLastIndex = findLastIndex;
        lodash.findLastKey = findLastKey;
        lodash.floor = floor;
        lodash.forEach = forEach;
        lodash.forEachRight = forEachRight;
        lodash.forIn = forIn;
        lodash.forInRight = forInRight;
        lodash.forOwn = forOwn;
        lodash.forOwnRight = forOwnRight;
        lodash.get = get;
        lodash.gt = gt;
        lodash.gte = gte;
        lodash.has = has;
        lodash.hasIn = hasIn;
        lodash.head = head;
        lodash.identity = identity;
        lodash.includes = includes;
        lodash.indexOf = indexOf;
        lodash.inRange = inRange;
        lodash.invoke = invoke;
        lodash.isArguments = isArguments;
        lodash.isArray = isArray;
        lodash.isArrayBuffer = isArrayBuffer;
        lodash.isArrayLike = isArrayLike;
        lodash.isArrayLikeObject = isArrayLikeObject;
        lodash.isBoolean = isBoolean;
        lodash.isBuffer = isBuffer;
        lodash.isDate = isDate;
        lodash.isElement = isElement;
        lodash.isEmpty = isEmpty;
        lodash.isEqual = isEqual;
        lodash.isEqualWith = isEqualWith;
        lodash.isError = isError;
        lodash.isFinite = isFinite2;
        lodash.isFunction = isFunction;
        lodash.isInteger = isInteger;
        lodash.isLength = isLength;
        lodash.isMap = isMap;
        lodash.isMatch = isMatch;
        lodash.isMatchWith = isMatchWith;
        lodash.isNaN = isNaN2;
        lodash.isNative = isNative;
        lodash.isNil = isNil;
        lodash.isNull = isNull;
        lodash.isNumber = isNumber;
        lodash.isObject = isObject;
        lodash.isObjectLike = isObjectLike;
        lodash.isPlainObject = isPlainObject;
        lodash.isRegExp = isRegExp;
        lodash.isSafeInteger = isSafeInteger;
        lodash.isSet = isSet;
        lodash.isString = isString;
        lodash.isSymbol = isSymbol;
        lodash.isTypedArray = isTypedArray;
        lodash.isUndefined = isUndefined;
        lodash.isWeakMap = isWeakMap;
        lodash.isWeakSet = isWeakSet;
        lodash.join = join2;
        lodash.kebabCase = kebabCase;
        lodash.last = last;
        lodash.lastIndexOf = lastIndexOf;
        lodash.lowerCase = lowerCase;
        lodash.lowerFirst = lowerFirst;
        lodash.lt = lt;
        lodash.lte = lte;
        lodash.max = max;
        lodash.maxBy = maxBy;
        lodash.mean = mean;
        lodash.meanBy = meanBy;
        lodash.min = min;
        lodash.minBy = minBy;
        lodash.stubArray = stubArray;
        lodash.stubFalse = stubFalse;
        lodash.stubObject = stubObject;
        lodash.stubString = stubString;
        lodash.stubTrue = stubTrue;
        lodash.multiply = multiply;
        lodash.nth = nth;
        lodash.noConflict = noConflict;
        lodash.noop = noop;
        lodash.now = now;
        lodash.pad = pad;
        lodash.padEnd = padEnd;
        lodash.padStart = padStart;
        lodash.parseInt = parseInt2;
        lodash.random = random;
        lodash.reduce = reduce;
        lodash.reduceRight = reduceRight;
        lodash.repeat = repeat;
        lodash.replace = replace;
        lodash.result = result;
        lodash.round = round;
        lodash.runInContext = runInContext2;
        lodash.sample = sample;
        lodash.size = size;
        lodash.snakeCase = snakeCase;
        lodash.some = some;
        lodash.sortedIndex = sortedIndex;
        lodash.sortedIndexBy = sortedIndexBy;
        lodash.sortedIndexOf = sortedIndexOf;
        lodash.sortedLastIndex = sortedLastIndex;
        lodash.sortedLastIndexBy = sortedLastIndexBy;
        lodash.sortedLastIndexOf = sortedLastIndexOf;
        lodash.startCase = startCase;
        lodash.startsWith = startsWith;
        lodash.subtract = subtract;
        lodash.sum = sum;
        lodash.sumBy = sumBy;
        lodash.template = template;
        lodash.times = times;
        lodash.toFinite = toFinite;
        lodash.toInteger = toInteger;
        lodash.toLength = toLength;
        lodash.toLower = toLower;
        lodash.toNumber = toNumber;
        lodash.toSafeInteger = toSafeInteger;
        lodash.toString = toString;
        lodash.toUpper = toUpper;
        lodash.trim = trim;
        lodash.trimEnd = trimEnd;
        lodash.trimStart = trimStart;
        lodash.truncate = truncate;
        lodash.unescape = unescape2;
        lodash.uniqueId = uniqueId;
        lodash.upperCase = upperCase;
        lodash.upperFirst = upperFirst;
        lodash.each = forEach;
        lodash.eachRight = forEachRight;
        lodash.first = head;
        mixin(lodash, function() {
          var source = {};
          baseForOwn(lodash, function(func, methodName) {
            if (!hasOwnProperty.call(lodash.prototype, methodName)) {
              source[methodName] = func;
            }
          });
          return source;
        }(), {
          "chain": false
        });
        lodash.VERSION = VERSION;
        arrayEach([
          "bind",
          "bindKey",
          "curry",
          "curryRight",
          "partial",
          "partialRight"
        ], function(methodName) {
          lodash[methodName].placeholder = lodash;
        });
        arrayEach([
          "drop",
          "take"
        ], function(methodName, index) {
          LazyWrapper.prototype[methodName] = function(n) {
            n = n === undefined2 ? 1 : nativeMax(toInteger(n), 0);
            var result2 = this.__filtered__ && !index ? new LazyWrapper(this) : this.clone();
            if (result2.__filtered__) {
              result2.__takeCount__ = nativeMin(n, result2.__takeCount__);
            } else {
              result2.__views__.push({
                "size": nativeMin(n, MAX_ARRAY_LENGTH),
                "type": methodName + (result2.__dir__ < 0 ? "Right" : "")
              });
            }
            return result2;
          };
          LazyWrapper.prototype[methodName + "Right"] = function(n) {
            return this.reverse()[methodName](n).reverse();
          };
        });
        arrayEach([
          "filter",
          "map",
          "takeWhile"
        ], function(methodName, index) {
          var type = index + 1, isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
          LazyWrapper.prototype[methodName] = function(iteratee2) {
            var result2 = this.clone();
            result2.__iteratees__.push({
              "iteratee": getIteratee(iteratee2, 3),
              "type": type
            });
            result2.__filtered__ = result2.__filtered__ || isFilter;
            return result2;
          };
        });
        arrayEach([
          "head",
          "last"
        ], function(methodName, index) {
          var takeName = "take" + (index ? "Right" : "");
          LazyWrapper.prototype[methodName] = function() {
            return this[takeName](1).value()[0];
          };
        });
        arrayEach([
          "initial",
          "tail"
        ], function(methodName, index) {
          var dropName = "drop" + (index ? "" : "Right");
          LazyWrapper.prototype[methodName] = function() {
            return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
          };
        });
        LazyWrapper.prototype.compact = function() {
          return this.filter(identity);
        };
        LazyWrapper.prototype.find = function(predicate) {
          return this.filter(predicate).head();
        };
        LazyWrapper.prototype.findLast = function(predicate) {
          return this.reverse().find(predicate);
        };
        LazyWrapper.prototype.invokeMap = baseRest(function(path2, args) {
          if (typeof path2 == "function") {
            return new LazyWrapper(this);
          }
          return this.map(function(value) {
            return baseInvoke(value, path2, args);
          });
        });
        LazyWrapper.prototype.reject = function(predicate) {
          return this.filter(negate(getIteratee(predicate)));
        };
        LazyWrapper.prototype.slice = function(start, end) {
          start = toInteger(start);
          var result2 = this;
          if (result2.__filtered__ && (start > 0 || end < 0)) {
            return new LazyWrapper(result2);
          }
          if (start < 0) {
            result2 = result2.takeRight(-start);
          } else if (start) {
            result2 = result2.drop(start);
          }
          if (end !== undefined2) {
            end = toInteger(end);
            result2 = end < 0 ? result2.dropRight(-end) : result2.take(end - start);
          }
          return result2;
        };
        LazyWrapper.prototype.takeRightWhile = function(predicate) {
          return this.reverse().takeWhile(predicate).reverse();
        };
        LazyWrapper.prototype.toArray = function() {
          return this.take(MAX_ARRAY_LENGTH);
        };
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
          if (!lodashFunc) {
            return;
          }
          lodash.prototype[methodName] = function() {
            var value = this.__wrapped__, args = isTaker ? [
              1
            ] : arguments, isLazy = value instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray(value);
            var interceptor = function(value2) {
              var result3 = lodashFunc.apply(lodash, arrayPush([
                value2
              ], args));
              return isTaker && chainAll ? result3[0] : result3;
            };
            if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
              isLazy = useLazy = false;
            }
            var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
            if (!retUnwrapped && useLazy) {
              value = onlyLazy ? value : new LazyWrapper(this);
              var result2 = func.apply(value, args);
              result2.__actions__.push({
                "func": thru,
                "args": [
                  interceptor
                ],
                "thisArg": undefined2
              });
              return new LodashWrapper(result2, chainAll);
            }
            if (isUnwrapped && onlyLazy) {
              return func.apply(this, args);
            }
            result2 = this.thru(interceptor);
            return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
          };
        });
        arrayEach([
          "pop",
          "push",
          "shift",
          "sort",
          "splice",
          "unshift"
        ], function(methodName) {
          var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
          lodash.prototype[methodName] = function() {
            var args = arguments;
            if (retUnwrapped && !this.__chain__) {
              var value = this.value();
              return func.apply(isArray(value) ? value : [], args);
            }
            return this[chainName](function(value2) {
              return func.apply(isArray(value2) ? value2 : [], args);
            });
          };
        });
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var lodashFunc = lodash[methodName];
          if (lodashFunc) {
            var key = lodashFunc.name + "";
            if (!hasOwnProperty.call(realNames, key)) {
              realNames[key] = [];
            }
            realNames[key].push({
              "name": methodName,
              "func": lodashFunc
            });
          }
        });
        realNames[createHybrid(undefined2, WRAP_BIND_KEY_FLAG).name] = [
          {
            "name": "wrapper",
            "func": undefined2
          }
        ];
        LazyWrapper.prototype.clone = lazyClone;
        LazyWrapper.prototype.reverse = lazyReverse;
        LazyWrapper.prototype.value = lazyValue;
        lodash.prototype.at = wrapperAt;
        lodash.prototype.chain = wrapperChain;
        lodash.prototype.commit = wrapperCommit;
        lodash.prototype.next = wrapperNext;
        lodash.prototype.plant = wrapperPlant;
        lodash.prototype.reverse = wrapperReverse;
        lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;
        lodash.prototype.first = lodash.prototype.head;
        if (symIterator) {
          lodash.prototype[symIterator] = wrapperToIterator;
        }
        return lodash;
      };
      var _ = runInContext();
      if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
        root._ = _;
        define(function() {
          return _;
        });
      } else if (freeModule) {
        (freeModule.exports = _)._ = _;
        freeExports._ = _;
      } else {
        root._ = _;
      }
    }).call(exports);
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Php/utils.js
var require_utils15 = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Php/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.stringEscape = void 0;
    exports.phpNameStyle = phpNameStyle;
    var Strings_1 = require_Strings();
    exports.stringEscape = (0, Strings_1.utf16ConcatMap)((0, Strings_1.escapeNonPrintableMapper)(Strings_1.isAscii, Strings_1.standardUnicodeHexEscape));
    function isStartCharacter(codePoint) {
      if (codePoint === 95) return true;
      return (0, Strings_1.isAscii)(codePoint) && (0, Strings_1.isLetter)(codePoint);
    }
    function isPartCharacter(codePoint) {
      return isStartCharacter(codePoint) || (0, Strings_1.isAscii)(codePoint) && (0, Strings_1.isDigit)(codePoint);
    }
    var legalizeName = (0, Strings_1.utf16LegalizeCharacters)(isPartCharacter);
    function phpNameStyle(startWithUpper, upperUnderscore, original, acronymsStyle = Strings_1.allUpperWordStyle) {
      const words = (0, Strings_1.splitIntoWords)(original);
      return (0, Strings_1.combineWords)(words, legalizeName, upperUnderscore ? Strings_1.allUpperWordStyle : startWithUpper ? Strings_1.firstUpperWordStyle : Strings_1.allLowerWordStyle, upperUnderscore ? Strings_1.allUpperWordStyle : Strings_1.firstUpperWordStyle, upperUnderscore || startWithUpper ? Strings_1.allUpperWordStyle : Strings_1.allLowerWordStyle, acronymsStyle, upperUnderscore ? "_" : "", isStartCharacter);
    }
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Php/PhpRenderer.js
var require_PhpRenderer = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Php/PhpRenderer.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
          enumerable: true,
          get: function() {
            return m[k];
          }
        };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
      });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || /* @__PURE__ */ function() {
      var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      };
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i2 = 0; i2 < k.length; i2++) if (k[i2] !== "default") __createBinding(result, mod, k[i2]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.PhpRenderer = void 0;
    var _ = __importStar(require_lodash());
    var Annotation_1 = require_Annotation();
    var ConvenienceRenderer_1 = require_ConvenienceRenderer();
    var Naming_1 = require_Naming();
    var Source_1 = require_Source();
    var Acronyms_1 = require_Acronyms();
    var Support_1 = require_Support();
    var TypeUtils_1 = require_TypeUtils();
    var utils_1 = require_utils15();
    var PhpRenderer = class extends ConvenienceRenderer_1.ConvenienceRenderer {
      constructor(targetLanguage, renderContext, _options) {
        super(targetLanguage, renderContext);
        this._options = _options;
        this._gettersAndSettersForPropertyName = /* @__PURE__ */ new Map();
        this._haveEmittedLeadingComments = false;
        this._converterClassname = "Converter";
        this._converterKeywords = [];
      }
      forbiddenForObjectProperties(_c, _className) {
        return {
          names: [],
          includeGlobalForbidden: true
        };
      }
      makeNamedTypeNamer() {
        return this.getNameStyling("typeNamingFunction");
      }
      namerForObjectProperty() {
        return this.getNameStyling("propertyNamingFunction");
      }
      makeUnionMemberNamer() {
        return this.getNameStyling("propertyNamingFunction");
      }
      makeEnumCaseNamer() {
        return this.getNameStyling("enumCaseNamingFunction");
      }
      unionNeedsName(u) {
        return (0, TypeUtils_1.nullableFromUnion)(u) === null;
      }
      namedTypeToNameForTopLevel(type) {
        return (0, TypeUtils_1.directlyReachableSingleNamedType)(type);
      }
      makeNamesForPropertyGetterAndSetter(_c, _className, _p, _jsonName, name) {
        const getterName = new Naming_1.DependencyName(this.getNameStyling("propertyNamingFunction"), name.order, (lookup) => `get_${lookup(name)}`);
        const setterName = new Naming_1.DependencyName(this.getNameStyling("propertyNamingFunction"), name.order, (lookup) => `set_${lookup(name)}`);
        const validateName2 = new Naming_1.DependencyName(this.getNameStyling("propertyNamingFunction"), name.order, (lookup) => `validate_${lookup(name)}`);
        const fromName = new Naming_1.DependencyName(this.getNameStyling("propertyNamingFunction"), name.order, (lookup) => `from_${lookup(name)}`);
        const toName = new Naming_1.DependencyName(this.getNameStyling("propertyNamingFunction"), name.order, (lookup) => `to_${lookup(name)}`);
        const sampleName = new Naming_1.DependencyName(this.getNameStyling("propertyNamingFunction"), name.order, (lookup) => `sample_${lookup(name)}`);
        return {
          getter: getterName,
          setter: setterName,
          validate: validateName2,
          from: fromName,
          to: toName,
          sample: sampleName
        };
      }
      makePropertyDependencyNames(c, className, p, jsonName, name) {
        const getterAndSetterNames = this.makeNamesForPropertyGetterAndSetter(c, className, p, jsonName, name);
        this._gettersAndSettersForPropertyName.set(name, getterAndSetterNames);
        return [
          getterAndSetterNames.getter,
          getterAndSetterNames.setter,
          getterAndSetterNames.validate,
          getterAndSetterNames.to,
          getterAndSetterNames.from,
          getterAndSetterNames.sample
        ];
      }
      getNameStyling(convention) {
        const styling = {
          typeNamingFunction: (0, Naming_1.funPrefixNamer)("types", (n) => (0, utils_1.phpNameStyle)(true, false, n, (0, Acronyms_1.acronymStyle)(this._options.acronymStyle))),
          propertyNamingFunction: (0, Naming_1.funPrefixNamer)("properties", (n) => (0, utils_1.phpNameStyle)(false, false, n, (0, Acronyms_1.acronymStyle)(this._options.acronymStyle))),
          enumCaseNamingFunction: (0, Naming_1.funPrefixNamer)("enum-cases", (n) => (0, utils_1.phpNameStyle)(true, true, n, (0, Acronyms_1.acronymStyle)(this._options.acronymStyle)))
        };
        return styling[convention];
      }
      startFile(_basename) {
        this.ensureBlankLine();
        if (!this._haveEmittedLeadingComments && this.leadingComments !== void 0) {
          this.emitComments(this.leadingComments);
          this.ensureBlankLine();
          this._haveEmittedLeadingComments = true;
        }
      }
      finishFile() {
      }
      emitFileHeader(fileName, _imports) {
        this.startFile(fileName);
        this.emitLine("// This is a autogenerated file:", fileName);
        this.ensureBlankLine();
      }
      emitDescriptionBlock(lines) {
        this.emitCommentLines(lines, {
          lineStart: " * ",
          beforeComment: "/**",
          afterComment: " */"
        });
      }
      emitBlock(line, f) {
        this.emitLine(line, " {");
        this.indent(f);
        this.emitLine("}");
      }
      phpType(_reference, t, isOptional = false, prefix = "?", suffix = "") {
        function optionalize(s) {
          return [
            isOptional ? prefix : "",
            s,
            isOptional ? suffix : ""
          ];
        }
        return (0, TypeUtils_1.matchType)(t, (_anyType) => (0, Source_1.maybeAnnotated)(isOptional, Annotation_1.anyTypeIssueAnnotation, "Object"), (_nullType) => (0, Source_1.maybeAnnotated)(isOptional, Annotation_1.nullTypeIssueAnnotation, "Object"), (_boolType) => optionalize("bool"), (_integerType) => optionalize("int"), (_doubleType) => optionalize("float"), (_stringType) => optionalize("string"), (_arrayType) => optionalize("array"), (classType) => optionalize(this.nameForNamedType(classType)), (_mapType) => optionalize("stdClass"), (enumType) => optionalize(this.nameForNamedType(enumType)), (unionType) => {
          const nullable = (0, TypeUtils_1.nullableFromUnion)(unionType);
          if (nullable !== null) return this.phpType(true, nullable, true, prefix, suffix);
          return this.nameForNamedType(unionType);
        }, (transformedStringType) => {
          if (transformedStringType.kind === "time") {
            throw Error('transformedStringType.kind === "time"');
          }
          if (transformedStringType.kind === "date") {
            throw Error('transformedStringType.kind === "date"');
          }
          if (transformedStringType.kind === "date-time") {
            return "DateTime";
          }
          if (transformedStringType.kind === "uuid") {
            throw Error('transformedStringType.kind === "uuid"');
          }
          return "string";
        });
      }
      phpDocConvertType(className, t) {
        return (0, TypeUtils_1.matchType)(t, (_anyType) => "any", (_nullType) => "null", (_boolType) => "bool", (_integerType) => "int", (_doubleType) => "float", (_stringType) => "string", (arrayType) => [
          this.phpDocConvertType(className, arrayType.items),
          "[]"
        ], (_classType) => _classType.getCombinedName(), (_mapType) => "stdClass", (enumType) => this.nameForNamedType(enumType), (unionType) => {
          const nullable = (0, TypeUtils_1.nullableFromUnion)(unionType);
          if (nullable !== null) {
            return [
              this.phpDocConvertType(className, nullable),
              "|null"
            ];
          }
          throw Error("union are not supported");
        }, (transformedStringType) => {
          if (transformedStringType.kind === "date-time") {
            return "DateTime";
          }
          throw Error('transformedStringType.kind === "unknown"');
        });
      }
      phpConvertType(className, t) {
        return (0, TypeUtils_1.matchType)(t, (_anyType) => "any", (_nullType) => "null", (_boolType) => "bool", (_integerType) => "int", (_doubleType) => "float", (_stringType) => "string", (_arrayType) => "array", (_classType) => "stdClass", (_mapType) => "stdClass", (_enumType) => "string", (unionType) => {
          const nullable = (0, TypeUtils_1.nullableFromUnion)(unionType);
          if (nullable !== null) {
            return [
              "?",
              this.phpConvertType(className, nullable)
            ];
          }
          throw Error("union are not supported");
        }, (transformedStringType) => {
          if (transformedStringType.kind === "date-time") {
            return "string";
          }
          throw Error('transformedStringType.kind === "unknown"');
        });
      }
      phpToObjConvert(className, t, lhs, args) {
        (0, TypeUtils_1.matchType)(t, (_anyType) => this.emitLine(...lhs, ...args, "; /*any*/"), (_nullType) => this.emitLine(...lhs, ...args, "; /*null*/"), (_boolType) => this.emitLine(...lhs, ...args, "; /*bool*/"), (_integerType) => this.emitLine(...lhs, ...args, "; /*int*/"), (_doubleType) => this.emitLine(...lhs, ...args, "; /*float*/"), (_stringType) => this.emitLine(...lhs, ...args, "; /*string*/"), (arrayType) => {
          this.emitLine(...lhs, "array_map(function ($value) {");
          this.indent(() => {
            this.phpToObjConvert(className, arrayType.items, [
              "return "
            ], [
              "$value"
            ]);
          });
          this.emitLine("}, ", ...args, ");");
        }, (_classType) => this.emitLine(...lhs, ...args, "->to(); ", "/*class*/"), (mapType) => {
          this.emitBlock([
            "function to($my): stdClass"
          ], () => {
            this.emitLine("$out = new stdClass();");
            this.emitBlock([
              "foreach ($my as $k => $v)"
            ], () => {
              this.phpToObjConvert(className, mapType.values, [
                "$my->$k = "
              ], [
                "$v"
              ]);
            });
            this.emitLine("return $out;");
          });
          this.emitLine("return to(", ...args, ");");
        }, (enumType) => this.emitLine(...lhs, this.nameForNamedType(enumType), "::to(", ...args, "); ", "/*enum*/"), (unionType) => {
          const nullable = (0, TypeUtils_1.nullableFromUnion)(unionType);
          if (nullable !== null) {
            this.emitLine("if (!is_null(", ...args, ")) {");
            this.indent(() => this.phpToObjConvert(className, nullable, lhs, args));
            this.emitLine("} else {");
            this.indent(() => this.emitLine(...lhs, " null;"));
            this.emitLine("}");
            return;
          }
          throw Error("union are not supported");
        }, (transformedStringType) => {
          if (transformedStringType.kind === "date-time") {
            this.emitLine(...lhs, ...args, "->format(DateTimeInterface::ISO8601);");
            return;
          }
          throw Error('transformedStringType.kind === "unknown"');
        });
      }
      transformDateTime(className, attrName, scopeAttrName) {
        this.emitBlock([
          "if (!is_a(",
          scopeAttrName,
          ", 'DateTime'))"
        ], () => this.emitLine("throw new Exception('Attribute Error:", className, "::", attrName, "');"));
      }
      phpFromObjConvert(className, t, lhs, args) {
        (0, TypeUtils_1.matchType)(t, (_anyType) => this.emitLine(...lhs, ...args, "; /*any*/"), (_nullType) => this.emitLine(...lhs, ...args, "; /*null*/"), (_boolType) => this.emitLine(...lhs, ...args, "; /*bool*/"), (_integerType) => this.emitLine(...lhs, ...args, "; /*int*/"), (_doubleType) => this.emitLine(...lhs, ...args, "; /*float*/"), (_stringType) => this.emitLine(...lhs, ...args, "; /*string*/"), (arrayType) => {
          this.emitLine(...lhs, " array_map(function ($value) {");
          this.indent(() => {
            this.phpFromObjConvert(className, arrayType.items, [
              "return "
            ], [
              "$value"
            ]);
          });
          this.emitLine("}, ", ...args, ");");
        }, (classType) => this.emitLine(...lhs, this.nameForNamedType(classType), "::from(", ...args, "); ", "/*class*/"), (mapType) => {
          this.emitBlock([
            "function from($my): stdClass"
          ], () => {
            this.emitLine("$out = new stdClass();");
            this.emitBlock([
              "foreach ($my as $k => $v)"
            ], () => {
              this.phpFromObjConvert(className, mapType.values, [
                "$out->$k = "
              ], [
                "$v"
              ]);
            });
            this.emitLine("return $out;");
          });
          this.emitLine("return from(", ...args, ");");
        }, (enumType) => this.emitLine(...lhs, this.nameForNamedType(enumType), "::from(", ...args, "); ", "/*enum*/"), (unionType) => {
          const nullable = (0, TypeUtils_1.nullableFromUnion)(unionType);
          if (nullable !== null) {
            this.emitLine("if (!is_null(", ...args, ")) {");
            this.indent(() => this.phpFromObjConvert(className, nullable, lhs, args));
            this.emitLine("} else {");
            this.indent(() => this.emitLine("return null;"));
            this.emitLine("}");
            return;
          }
          throw Error("union are not supported");
        }, (transformedStringType) => {
          if (transformedStringType.kind === "date-time") {
            this.emitLine("$tmp = ", "DateTime::createFromFormat(DateTimeInterface::ISO8601, ", args, ");");
            this.transformDateTime(className, "", [
              "$tmp"
            ]);
            this.emitLine("return $tmp;");
            return;
          }
          throw Error('transformedStringType.kind === "unknown"');
        });
      }
      phpSampleConvert(className, t, lhs, args, idx, suffix) {
        (0, TypeUtils_1.matchType)(t, (_anyType) => this.emitLine(...lhs, "'AnyType::", className, "::", args, "::" + idx, "'", suffix, "/*", "" + idx, ":", args, "*/"), (_nullType) => this.emitLine(...lhs, "null", suffix, " /*", "" + idx, ":", args, "*/"), (_boolType) => this.emitLine(...lhs, "true", suffix, " /*", "" + idx, ":", args, "*/"), (_integerType) => this.emitLine(...lhs, "" + idx, suffix, " /*", "" + idx, ":", args, "*/"), (_doubleType) => this.emitLine(...lhs, "" + (idx + idx / 1e3), suffix, " /*", "" + idx, ":", args, "*/"), (_stringType) => this.emitLine(...lhs, "'", className, "::", args, "::" + idx, "'", suffix, " /*", "" + idx, ":", args, "*/"), (arrayType) => {
          this.emitLine(...lhs, " array(");
          this.indent(() => {
            this.phpSampleConvert(className, arrayType.items, [], [], idx, "");
          });
          this.emitLine("); /* ", "" + idx, ":", args, "*/");
        }, (classType) => this.emitLine(...lhs, this.nameForNamedType(classType), "::sample()", suffix, " /*", "" + idx, ":", args, "*/"), (mapType) => {
          this.emitBlock([
            "function sample(): stdClass"
          ], () => {
            this.emitLine("$out = new stdClass();");
            this.phpSampleConvert(className, mapType.values, [
              "$out->{'",
              className,
              "'} = "
            ], args, idx, ";");
            this.emitLine("return $out;");
          });
          this.emitLine("return sample();");
        }, (enumType) => this.emitLine(...lhs, this.nameForNamedType(enumType), "::sample()", suffix, " /*enum*/"), (unionType) => {
          const nullable = (0, TypeUtils_1.nullableFromUnion)(unionType);
          if (nullable !== null) {
            this.phpSampleConvert(className, nullable, lhs, args, idx, suffix);
            return;
          }
          throw Error(`union are not supported:${unionType}`);
        }, (transformedStringType) => {
          if (transformedStringType.kind === "date-time") {
            const x = _.pad("" + (1 + idx % 31), 2, "0");
            this.emitLine(...lhs, "DateTime::createFromFormat(DateTimeInterface::ISO8601, '", `2020-12-${x}T12:${x}:${x}+00:00`, "')", suffix);
            return;
          }
          throw Error('transformedStringType.kind === "unknown"');
        });
      }
      phpValidate(className, t, attrName, scopeAttrName) {
        const is = (isfn, myT = className) => {
          this.emitBlock([
            "if (!",
            isfn,
            "(",
            scopeAttrName,
            "))"
          ], () => this.emitLine('throw new Exception("Attribute Error:', myT, "::", attrName, '");'));
        };
        (0, TypeUtils_1.matchType)(t, (_anyType) => is("defined"), (_nullType) => is("is_null"), (_boolType) => is("is_bool"), (_integerType) => is("is_integer"), (_doubleType) => is("is_float"), (_stringType) => is("is_string"), (arrayType) => {
          is("is_array");
          this.emitLine("array_walk(", scopeAttrName, ", function(", scopeAttrName, "_v) {");
          this.indent(() => {
            this.phpValidate(className, arrayType.items, attrName, `${scopeAttrName}_v`);
          });
          this.emitLine("});");
        }, (_classType) => {
          this.emitLine(scopeAttrName, "->validate();");
        }, (mapType) => {
          this.emitLine("foreach (", scopeAttrName, " as $k => $v) {");
          this.indent(() => {
            this.phpValidate(className, mapType.values, attrName, "$v");
          });
          this.emitLine("}");
        }, (enumType) => {
          this.emitLine(this.phpType(false, enumType), "::to(", scopeAttrName, ");");
        }, (unionType) => {
          const nullable = (0, TypeUtils_1.nullableFromUnion)(unionType);
          if (nullable !== null) {
            this.emitBlock([
              "if (!is_null(",
              scopeAttrName,
              "))"
            ], () => {
              this.phpValidate(className, nullable, attrName, scopeAttrName);
            });
            return;
          }
          throw Error("not implemented");
        }, (transformedStringType) => {
          if (transformedStringType.kind === "date-time") {
            this.transformDateTime(className, attrName, [
              scopeAttrName
            ]);
            return;
          }
          throw Error(`transformedStringType.kind === ${transformedStringType.kind}`);
        });
      }
      emitFromMethod(names, p, className, _name, desc) {
        this.emitLine("/**");
        if (desc !== void 0) {
          this.emitLine(" * ", desc);
          this.emitLine(" *");
        }
        this.emitLine(" * @param ", this.phpConvertType(className, p.type), " $value");
        this.emitLine(" * @throws Exception");
        this.emitLine(" * @return ", this.phpType(false, p.type));
        this.emitLine(" */");
        this.emitBlock([
          "public static function ",
          names.from,
          "(",
          this.phpConvertType(className, p.type),
          " $value): ",
          this.phpType(false, p.type)
        ], () => {
          this.phpFromObjConvert(className, p.type, [
            "return "
          ], [
            "$value"
          ]);
        });
      }
      emitToMethod(names, p, className, name, desc) {
        this.emitLine("/**");
        if (desc !== void 0) {
          this.emitLine(" * ", desc);
          this.emitLine(" *");
        }
        this.emitLine(" * @throws Exception");
        this.emitLine(" * @return ", this.phpConvertType(className, p.type));
        this.emitLine(" */");
        this.emitBlock([
          "public function ",
          names.to,
          "(): ",
          this.phpConvertType(className, p.type)
        ], () => {
          this.emitBlock([
            "if (",
            className,
            "::",
            names.validate,
            "($this->",
            name,
            ")) "
          ], () => {
            this.phpToObjConvert(className, p.type, [
              "return "
            ], [
              "$this->",
              name
            ]);
          });
          this.emitLine("throw new Exception('never get to this ", className, "::", name, "');");
        });
      }
      emitValidateMethod(names, p, className, name, desc) {
        this.emitLine("/**");
        if (desc !== void 0) {
          this.emitLine(" * ", desc);
          this.emitLine(" *");
        }
        this.emitLine(" * @param ", this.phpType(false, p.type, false, "", "|null"));
        this.emitLine(" * @return bool");
        this.emitLine(" * @throws Exception");
        this.emitLine(" */");
        this.emitBlock([
          "public static function ",
          names.validate,
          "(",
          this.phpType(false, p.type),
          " $value): bool"
        ], () => {
          this.phpValidate(className, p.type, name, "$value");
          this.emitLine("return true;");
        });
      }
      emitGetMethod(names, p, className, name, desc) {
        if (this._options.withGet) {
          this.emitLine("/**");
          if (desc !== void 0) {
            this.emitLine(" * ", desc);
            this.emitLine(" *");
          }
          if (!this._options.fastGet) {
            this.emitLine(" * @throws Exception");
          }
          const rendered = this.phpType(false, p.type);
          this.emitLine(" * @return ", rendered);
          this.emitLine(" */");
          this.emitBlock([
            "public function ",
            names.getter,
            "(): ",
            rendered
          ], () => {
            if (!this._options.fastGet) {
              this.emitBlock([
                "if (",
                className,
                "::",
                names.validate,
                "($this->",
                name,
                ")) "
              ], () => {
                this.emitLine("return $this->", name, ";");
              });
              this.emitLine("throw new Exception('never get to ", names.getter, " ", className, "::", name, "');");
            } else {
              this.emitLine("return $this->", name, ";");
            }
          });
        }
      }
      emitSetMethod(names, p, className, name, desc) {
        if (this._options.withSet) {
          this.emitLine("/**");
          if (desc !== void 0) {
            this.emitLine(" * ", desc);
            this.emitLine(" *");
          }
          this.emitLine(" * @param ", this.phpType(false, p.type, false, "", "|null"));
          this.emitLine(" * @throws Exception");
          this.emitLine(" */");
          this.emitBlock([
            "public function ",
            names.setter,
            "(",
            this.phpType(false, p.type),
            " $value)"
          ], () => {
            this.emitBlock([
              "if (",
              className,
              "::",
              names.validate,
              "($value)) "
            ], () => {
              this.emitLine("$this->", name, " = $value;");
            });
          });
        }
      }
      emitSampleMethod(names, p, className, name, desc, idx) {
        if (this._options.withGet) {
          this.emitLine("/**");
          if (desc !== void 0) {
            this.emitLine(" * ", desc);
            this.emitLine(" *");
          }
          const rendered = this.phpType(false, p.type);
          this.emitLine(" * @return ", rendered);
          this.emitLine(" */");
          this.emitBlock([
            "public static function ",
            names.sample,
            "(): ",
            rendered
          ], () => {
            this.phpSampleConvert(className, p.type, [
              "return "
            ], [
              name
            ], idx, ";");
          });
        }
      }
      emitClassDefinition(c, className) {
        this.emitFileHeader(className, []);
        this.emitBlock([
          "class ",
          className
        ], () => {
          this.forEachClassProperty(c, "none", (name, jsonName, p) => {
            this.emitLine("private ", this.phpType(false, p.type), " $", name, "; // json:", jsonName, " ", p.type.isNullable ? "Optional" : "Required");
          });
          this.ensureBlankLine();
          const comments = [];
          const args = [];
          let prefix = "";
          this.forEachClassProperty(c, "none", (name, __, p) => {
            args.push([
              prefix,
              this.phpType(false, p.type),
              " $",
              name
            ]);
            prefix = ", ";
            comments.push([
              " * @param ",
              this.phpType(false, p.type, false, "", "|null"),
              " $",
              name,
              "\n"
            ]);
          });
          this.emitBlock([
            "/**\n",
            ...comments,
            " */\n",
            "public function __construct(",
            ...args,
            ")"
          ], () => {
            this.forEachClassProperty(c, "none", (name) => {
              this.emitLine("$this->", name, " = $", name, ";");
            });
          });
          let idx = 31;
          this.forEachClassProperty(c, "leading-and-interposing", (name, jsonName, p) => {
            const desc = this.descriptionForClassProperty(c, jsonName);
            const names = (0, Support_1.defined)(this._gettersAndSettersForPropertyName.get(name));
            this.ensureBlankLine();
            this.emitFromMethod(names, p, className, name, desc);
            this.ensureBlankLine();
            this.emitToMethod(names, p, className, name, desc);
            this.ensureBlankLine();
            this.emitValidateMethod(names, p, className, name, desc);
            this.ensureBlankLine();
            this.emitGetMethod(names, p, className, name, desc);
            this.ensureBlankLine();
            this.emitSetMethod(names, p, className, name, desc);
            this.ensureBlankLine();
            this.emitSampleMethod(names, p, className, name, desc, idx++);
          });
          this.ensureBlankLine();
          this.emitBlock([
            "/**\n",
            " * @throws Exception\n",
            " * @return bool\n",
            " */\n",
            "public function validate(): bool"
          ], () => {
            const lines = [];
            let p = "return ";
            this.forEachClassProperty(c, "none", (name, _jsonName, _p) => {
              const names = (0, Support_1.defined)(this._gettersAndSettersForPropertyName.get(name));
              lines.push([
                p,
                className,
                "::",
                names.validate,
                "($this->",
                name,
                ")"
              ]);
              p = "|| ";
            });
            lines.forEach((line, jdx) => {
              this.emitLine(...line, lines.length === jdx + 1 ? ";" : "");
            });
          });
          this.ensureBlankLine();
          this.emitBlock([
            "/**\n",
            " * @return stdClass\n",
            " * @throws Exception\n",
            " */\n",
            "public function to(): stdClass "
          ], () => {
            this.emitLine("$out = new stdClass();");
            this.forEachClassProperty(c, "none", (name, jsonName) => {
              const names = (0, Support_1.defined)(this._gettersAndSettersForPropertyName.get(name));
              this.emitLine("$out->{'", jsonName, "'} = $this->", names.to, "();");
            });
            this.emitLine("return $out;");
          });
          this.ensureBlankLine();
          this.emitBlock([
            "/**\n",
            " * @param stdClass $obj\n",
            " * @return ",
            className,
            "\n",
            " * @throws Exception\n",
            " */\n",
            "public static function from(stdClass $obj): ",
            className
          ], () => {
            if (this._options.fastGet) {
              this.forEachClassProperty(c, "none", (name) => {
                const names = (0, Support_1.defined)(this._gettersAndSettersForPropertyName.get(name));
                this.emitLine(className, "::", names.validate, "($this->", name, ", true);");
              });
            }
            this.emitLine("return new ", className, "(");
            let comma = " ";
            this.forEachClassProperty(c, "none", (name, jsonName) => {
              const names = (0, Support_1.defined)(this._gettersAndSettersForPropertyName.get(name));
              this.emitLine(comma, className, "::", names.from, "($obj->{'", jsonName, "'})");
              comma = ",";
            });
            this.emitLine(");");
          });
          this.ensureBlankLine();
          this.emitBlock([
            "/**\n",
            " * @return ",
            className,
            "\n",
            " */\n",
            "public static function sample(): ",
            className
          ], () => {
            this.emitLine("return new ", className, "(");
            let comma = " ";
            this.forEachClassProperty(c, "none", (name) => {
              const names = (0, Support_1.defined)(this._gettersAndSettersForPropertyName.get(name));
              this.emitLine(comma, className, "::", names.sample, "()");
              comma = ",";
            });
            this.emitLine(");");
          });
        });
        this.finishFile();
      }
      emitUnionAttributes(_u, _unionName) {
      }
      emitUnionSerializer(_u, _unionName) {
      }
      emitUnionDefinition(_u, _unionName) {
        throw Error("emitUnionDefinition not implemented");
      }
      emitEnumSerializationAttributes(_e) {
      }
      emitEnumDeserializationAttributes(_e) {
      }
      emitEnumDefinition(e, enumName) {
        this.emitFileHeader(enumName, []);
        this.emitDescription(this.descriptionForType(e));
        const caseNames = [];
        caseNames.push(";");
        const enumSerdeType = "string";
        this.emitBlock([
          "class ",
          enumName
        ], () => {
          this.forEachEnumCase(e, "none", (name, _jsonName) => {
            this.emitLine("public static ", enumName, " $", name, ";");
          });
          this.emitBlock("public static function init()", () => {
            this.forEachEnumCase(e, "none", (name, jsonName) => {
              this.emitLine(enumName, "::$", name, " = new ", enumName, "('", jsonName, "');");
            });
          });
          this.emitLine("private ", enumSerdeType, " $enum;");
          this.emitBlock([
            "public function __construct(",
            enumSerdeType,
            " $enum)"
          ], () => {
            this.emitLine("$this->enum = $enum;");
          });
          this.ensureBlankLine();
          this.emitEnumSerializationAttributes(e);
          this.emitBlock([
            "/**\n",
            " * @param ",
            enumName,
            "\n",
            " * @return ",
            enumSerdeType,
            "\n",
            " * @throws Exception\n",
            " */\n",
            "public static function to(",
            enumName,
            " $obj): ",
            enumSerdeType
          ], () => {
            this.emitLine("switch ($obj->enum) {");
            this.indent(() => {
              this.forEachEnumCase(e, "none", (name, jsonName) => {
                this.emitLine("case ", enumName, "::$", name, "->enum: return '", (0, utils_1.stringEscape)(jsonName), "';");
              });
            });
            this.emitLine("}");
            this.emitLine("throw new Exception('the give value is not an enum-value.');");
          });
          this.ensureBlankLine();
          this.emitEnumDeserializationAttributes(e);
          this.emitBlock([
            "/**\n",
            " * @param mixed\n",
            " * @return ",
            enumName,
            "\n",
            " * @throws Exception\n",
            " */\n",
            "public static function from($obj): ",
            enumName
          ], () => {
            this.emitLine("switch ($obj) {");
            this.indent(() => {
              this.forEachEnumCase(e, "none", (name, jsonName) => {
                this.emitLine("case '", (0, utils_1.stringEscape)(jsonName), "': return ", enumName, "::$", name, ";");
              });
            });
            this.emitLine("}");
            this.emitLine('throw new Exception("Cannot deserialize ', enumName, '");');
          });
          this.ensureBlankLine();
          this.emitBlock([
            "/**\n",
            " * @return ",
            enumName,
            "\n",
            " */\n",
            "public static function sample(): ",
            enumName
          ], () => {
            const lines = [];
            this.forEachEnumCase(e, "none", (name) => {
              lines.push([
                enumName,
                "::$",
                name
              ]);
            });
            this.emitLine("return ", lines[0], ";");
          });
        });
        this.emitLine(enumName, "::init();");
        this.finishFile();
      }
      emitSourceStructure(givenFilename) {
        this.emitLine("<?php");
        this.forEachNamedType("leading-and-interposing", (c, n) => this.emitClassDefinition(c, n), (e, n) => this.emitEnumDefinition(e, n), (u, n) => this.emitUnionDefinition(u, n));
        if (this._options.withClosing) {
          this.emitLine("?>");
        }
        super.finishFile((0, Support_1.defined)(givenFilename));
      }
    };
    exports.PhpRenderer = PhpRenderer;
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Php/language.js
var require_language16 = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Php/language.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.PhpTargetLanguage = exports.phpLanguageConfig = exports.phpOptions = void 0;
    var RendererOptions_1 = require_RendererOptions();
    var Acronyms_1 = require_Acronyms();
    var TargetLanguage_1 = require_TargetLanguage();
    var PhpRenderer_1 = require_PhpRenderer();
    exports.phpOptions = {
      withGet: new RendererOptions_1.BooleanOption("with-get", "Create Getter", true),
      fastGet: new RendererOptions_1.BooleanOption("fast-get", "getter without validation", false),
      withSet: new RendererOptions_1.BooleanOption("with-set", "Create Setter", false),
      withClosing: new RendererOptions_1.BooleanOption("with-closing", "PHP Closing Tag", false),
      acronymStyle: (0, Acronyms_1.acronymOption)(Acronyms_1.AcronymStyleOptions.Pascal)
    };
    exports.phpLanguageConfig = {
      displayName: "PHP",
      names: [
        "php"
      ],
      extension: "php"
    };
    var PhpTargetLanguage = class extends TargetLanguage_1.TargetLanguage {
      constructor() {
        super(exports.phpLanguageConfig);
      }
      getOptions() {
        return exports.phpOptions;
      }
      get supportsUnionsWithBothNumberTypes() {
        return true;
      }
      makeRenderer(renderContext, untypedOptionValues) {
        const options = (0, RendererOptions_1.getOptionValues)(exports.phpOptions, untypedOptionValues);
        return new PhpRenderer_1.PhpRenderer(this, renderContext, options);
      }
      get stringTypeMapping() {
        const mapping = /* @__PURE__ */ new Map();
        mapping.set("date", "date");
        mapping.set("time", "time");
        mapping.set("uuid", "uuid");
        mapping.set("date-time", "date-time");
        return mapping;
      }
    };
    exports.PhpTargetLanguage = PhpTargetLanguage;
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Php/index.js
var require_Php = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Php/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.PhpRenderer = exports.phpOptions = exports.PhpTargetLanguage = void 0;
    var language_1 = require_language16();
    Object.defineProperty(exports, "PhpTargetLanguage", {
      enumerable: true,
      get: function() {
        return language_1.PhpTargetLanguage;
      }
    });
    Object.defineProperty(exports, "phpOptions", {
      enumerable: true,
      get: function() {
        return language_1.phpOptions;
      }
    });
    var PhpRenderer_1 = require_PhpRenderer();
    Object.defineProperty(exports, "PhpRenderer", {
      enumerable: true,
      get: function() {
        return PhpRenderer_1.PhpRenderer;
      }
    });
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Pike/constants.js
var require_constants13 = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Pike/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.keywords = void 0;
    exports.keywords = [
      "auto",
      "nomask",
      "final",
      "static",
      "extern",
      "private",
      "local",
      "public",
      "protected",
      "inline",
      "optional",
      "variant",
      "void",
      "mixed",
      "array",
      "__attribute__",
      "__deprecated__",
      "mapping",
      "multiset",
      "object",
      "function",
      "__func__",
      "program",
      "string",
      "float",
      "int",
      "enum",
      "typedef",
      "if",
      "do",
      "for",
      "while",
      "else",
      "foreach",
      "catch",
      "gauge",
      "class",
      "break",
      "case",
      "const",
      "constant",
      "continue",
      "default",
      "import",
      "inherit",
      "lambda",
      "predef",
      "return",
      "sscanf",
      "switch",
      "typeof",
      "global"
    ];
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Pike/utils.js
var require_utils16 = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Pike/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.namedTypeNamingFunction = exports.namingFunction = exports.enumNamingFunction = void 0;
    var Naming_1 = require_Naming();
    var Strings_1 = require_Strings();
    var legalizeName = (0, Strings_1.legalizeCharacters)(Strings_1.isLetterOrUnderscoreOrDigit);
    exports.enumNamingFunction = (0, Naming_1.funPrefixNamer)("enumNamer", (0, Strings_1.makeNameStyle)("upper-underscore", legalizeName));
    exports.namingFunction = (0, Naming_1.funPrefixNamer)("genericNamer", (0, Strings_1.makeNameStyle)("underscore", legalizeName));
    exports.namedTypeNamingFunction = (0, Naming_1.funPrefixNamer)("typeNamer", (0, Strings_1.makeNameStyle)("pascal", legalizeName));
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Pike/PikeRenderer.js
var require_PikeRenderer = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Pike/PikeRenderer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.PikeRenderer = void 0;
    var ConvenienceRenderer_1 = require_ConvenienceRenderer();
    var Source_1 = require_Source();
    var Strings_1 = require_Strings();
    var Type_1 = require_Type2();
    var TypeUtils_1 = require_TypeUtils();
    var constants_1 = require_constants13();
    var utils_1 = require_utils16();
    var PikeRenderer = class extends ConvenienceRenderer_1.ConvenienceRenderer {
      emitSourceStructure() {
        this.emitInformationComment();
        this.ensureBlankLine();
        this.forEachTopLevel("leading", (t, name) => {
          this.emitTopLevelTypedef(t, name);
          this.ensureBlankLine();
          this.emitTopLevelConverter(t, name);
          this.ensureBlankLine();
        }, (t) => this.namedTypeToNameForTopLevel(t) === void 0);
        this.ensureBlankLine();
        this.forEachNamedType("leading-and-interposing", (c, className) => this.emitClassDefinition(c, className), (e, n) => this.emitEnum(e, n), (u, n) => this.emitUnion(u, n));
      }
      get enumCasesInGlobalNamespace() {
        return true;
      }
      makeEnumCaseNamer() {
        return utils_1.enumNamingFunction;
      }
      makeNamedTypeNamer() {
        return utils_1.namedTypeNamingFunction;
      }
      makeUnionMemberNamer() {
        return utils_1.namingFunction;
      }
      namerForObjectProperty() {
        return utils_1.namingFunction;
      }
      forbiddenNamesForGlobalNamespace() {
        return [
          ...constants_1.keywords
        ];
      }
      forbiddenForObjectProperties(_c, _className) {
        return {
          names: [],
          includeGlobalForbidden: true
        };
      }
      forbiddenForEnumCases(_e, _enumName) {
        return {
          names: [],
          includeGlobalForbidden: true
        };
      }
      forbiddenForUnionMembers(_u, _unionName) {
        return {
          names: [],
          includeGlobalForbidden: true
        };
      }
      sourceFor(t) {
        if ([
          "class",
          "object",
          "enum"
        ].includes(t.kind)) {
          return (0, Source_1.singleWord)(this.nameForNamedType(t));
        }
        return (0, TypeUtils_1.matchType)(t, (_anyType) => (0, Source_1.singleWord)("mixed"), (_nullType) => (0, Source_1.singleWord)("mixed"), (_boolType) => (0, Source_1.singleWord)("bool"), (_integerType) => (0, Source_1.singleWord)("int"), (_doubleType) => (0, Source_1.singleWord)("float"), (_stringType) => (0, Source_1.singleWord)("string"), (arrayType) => (0, Source_1.singleWord)([
          "array(",
          this.sourceFor(arrayType.items).source,
          ")"
        ]), (_classType) => (0, Source_1.singleWord)(this.nameForNamedType(_classType)), (mapType) => {
          const v = mapType.values;
          const valueSource = this.sourceFor(v).source;
          return (0, Source_1.singleWord)([
            "mapping(string:",
            valueSource,
            ")"
          ]);
        }, (_enumType) => (0, Source_1.singleWord)("enum"), (unionType) => {
          if ((0, TypeUtils_1.nullableFromUnion)(unionType) !== null) {
            const children = Array.from(unionType.getChildren()).map((c) => (0, Source_1.parenIfNeeded)(this.sourceFor(c)));
            return (0, Source_1.multiWord)("|", ...children);
          }
          return (0, Source_1.singleWord)(this.nameForNamedType(unionType));
        });
      }
      emitClassDefinition(c, className) {
        this.emitDescription(this.descriptionForType(c));
        this.emitBlock([
          "class ",
          className
        ], () => {
          this.emitClassMembers(c);
          this.ensureBlankLine();
          this.emitEncodingFunction(c);
        });
        this.ensureBlankLine();
        this.emitDecodingFunction(className, c);
      }
      emitEnum(e, enumName) {
        this.emitBlock([
          e.kind,
          " ",
          enumName
        ], () => {
          const table = [];
          this.forEachEnumCase(e, "none", (name, jsonName) => {
            table.push([
              [
                name,
                ' = "',
                (0, Strings_1.stringEscape)(jsonName),
                '", '
              ],
              [
                '// json: "',
                jsonName,
                '"'
              ]
            ]);
          });
          this.emitTable(table);
        });
      }
      emitUnion(u, unionName) {
        const isMaybeWithSingleType = (0, TypeUtils_1.nullableFromUnion)(u);
        if (isMaybeWithSingleType !== null) {
          return;
        }
        this.emitDescription(this.descriptionForType(u));
        const [, nonNulls] = (0, TypeUtils_1.removeNullFromUnion)(u);
        const types = [];
        this.forEachUnionMember(u, nonNulls, "none", null, (_name, t) => {
          const pikeType = this.sourceFor(t).source;
          types.push([
            pikeType
          ]);
        });
        this.emitLine([
          "typedef ",
          types.map((r) => r.map((sl) => this.sourcelikeToString(sl))).join("|"),
          " ",
          unionName,
          ";"
        ]);
        this.ensureBlankLine();
        this.emitBlock([
          unionName,
          " ",
          unionName,
          "_from_JSON(mixed json)"
        ], () => {
          this.emitLine([
            "return json;"
          ]);
        });
      }
      emitBlock(line, f, opening = " {", closing = "}") {
        this.emitLine(line, opening);
        this.indent(f);
        this.emitLine(closing);
      }
      emitMappingBlock(line, f) {
        this.emitBlock(line, f, "([", "]);");
      }
      emitClassMembers(c) {
        const table = [];
        this.forEachClassProperty(c, "none", (name, jsonName, p) => {
          const pikeType = this.sourceFor(p.type).source;
          table.push([
            [
              pikeType,
              " "
            ],
            [
              name,
              "; "
            ],
            [
              '// json: "',
              jsonName,
              '"'
            ]
          ]);
        });
        this.emitTable(table);
      }
      emitInformationComment() {
        this.emitCommentLines([
          "This source has been automatically generated by quicktype.",
          "( https://github.com/quicktype/quicktype )",
          "",
          "To use this code, simply import it into your project as a Pike module.",
          "To JSON-encode your object, you can pass it to `Standards.JSON.encode`",
          "or call `encode_json` on it.",
          "",
          "To decode a JSON string, first pass it to `Standards.JSON.decode`,",
          "and then pass the result to `<YourClass>_from_JSON`.",
          "It will return an instance of <YourClass>.",
          "Bear in mind that these functions have unexpected behavior,",
          "and will likely throw an error, if the JSON string does not",
          "match the expected interface, even if the JSON itself is valid."
        ], {
          lineStart: "// "
        });
      }
      emitTopLevelTypedef(t, name) {
        this.emitLine("typedef ", this.sourceFor(t).source, " ", name, ";");
      }
      emitTopLevelConverter(t, name) {
        this.emitBlock([
          name,
          " ",
          name,
          "_from_JSON(mixed json)"
        ], () => {
          if (t instanceof Type_1.PrimitiveType) {
            this.emitLine([
              "return json;"
            ]);
          } else if (t instanceof Type_1.ArrayType) {
            if (t.items instanceof Type_1.PrimitiveType) this.emitLine([
              "return json;"
            ]);
            else this.emitLine([
              "return map(json, ",
              this.sourceFor(t.items).source,
              "_from_JSON);"
            ]);
          } else if (t instanceof Type_1.MapType) {
            const type = this.sourceFor(t.values).source;
            this.emitLine([
              "mapping(string:",
              type,
              ") retval = ([]);"
            ]);
            let assignmentRval;
            if (t.values instanceof Type_1.PrimitiveType) assignmentRval = [
              "(",
              type,
              ") v"
            ];
            else assignmentRval = [
              type,
              "_from_JSON(v)"
            ];
            this.emitBlock([
              "foreach (json; string k; mixed v)"
            ], () => {
              this.emitLine([
                "retval[k] = ",
                assignmentRval,
                ";"
              ]);
            });
            this.emitLine([
              "return retval;"
            ]);
          }
        });
      }
      emitEncodingFunction(c) {
        this.emitBlock([
          "string encode_json()"
        ], () => {
          this.emitMappingBlock([
            "mapping(string:mixed) json = "
          ], () => {
            this.forEachClassProperty(c, "none", (name, jsonName) => {
              this.emitLine([
                '"',
                (0, Strings_1.stringEscape)(jsonName),
                '" : ',
                name,
                ","
              ]);
            });
          });
          this.ensureBlankLine();
          this.emitLine([
            "return Standards.JSON.encode(json);"
          ]);
        });
      }
      emitDecodingFunction(className, c) {
        this.emitBlock([
          className,
          " ",
          className,
          "_from_JSON(mixed json)"
        ], () => {
          this.emitLine([
            className,
            " retval = ",
            className,
            "();"
          ]);
          this.ensureBlankLine();
          this.forEachClassProperty(c, "none", (name, jsonName) => {
            this.emitLine([
              "retval.",
              name,
              ' = json["',
              (0, Strings_1.stringEscape)(jsonName),
              '"];'
            ]);
          });
          this.ensureBlankLine();
          this.emitLine([
            "return retval;"
          ]);
        });
      }
    };
    exports.PikeRenderer = PikeRenderer;
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Pike/language.js
var require_language17 = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Pike/language.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.PikeTargetLanguage = exports.pikeLanguageConfig = exports.pikeOptions = void 0;
    var TargetLanguage_1 = require_TargetLanguage();
    var PikeRenderer_1 = require_PikeRenderer();
    exports.pikeOptions = {};
    exports.pikeLanguageConfig = {
      displayName: "Pike",
      names: [
        "pike",
        "pikelang"
      ],
      extension: "pmod"
    };
    var PikeTargetLanguage = class extends TargetLanguage_1.TargetLanguage {
      constructor() {
        super(exports.pikeLanguageConfig);
      }
      getOptions() {
        return {};
      }
      makeRenderer(renderContext) {
        return new PikeRenderer_1.PikeRenderer(this, renderContext);
      }
    };
    exports.PikeTargetLanguage = PikeTargetLanguage;
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Pike/index.js
var require_Pike = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Pike/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.PikeRenderer = exports.pikeOptions = exports.PikeTargetLanguage = void 0;
    var language_1 = require_language17();
    Object.defineProperty(exports, "PikeTargetLanguage", {
      enumerable: true,
      get: function() {
        return language_1.PikeTargetLanguage;
      }
    });
    Object.defineProperty(exports, "pikeOptions", {
      enumerable: true,
      get: function() {
        return language_1.pikeOptions;
      }
    });
    var PikeRenderer_1 = require_PikeRenderer();
    Object.defineProperty(exports, "PikeRenderer", {
      enumerable: true,
      get: function() {
        return PikeRenderer_1.PikeRenderer;
      }
    });
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Python/constants.js
var require_constants14 = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Python/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.forbiddenPropertyNames = exports.forbiddenTypeNames = void 0;
    exports.forbiddenTypeNames = [
      "Any",
      "True",
      "False",
      "None",
      "Enum",
      "List",
      "Dict",
      "Optional",
      "Union",
      "Iterable",
      "Type",
      "TypeVar",
      "T",
      "EnumT"
    ];
    exports.forbiddenPropertyNames = [
      "and",
      "as",
      "assert",
      "async",
      "await",
      "bool",
      "break",
      "class",
      "continue",
      "datetime",
      "def",
      "del",
      "dict",
      "elif",
      "else",
      "except",
      "finally",
      "float",
      "for",
      "from",
      "global",
      "if",
      "import",
      "in",
      "int",
      "is",
      "lambda",
      "nonlocal",
      "not",
      "or",
      "pass",
      "print",
      "raise",
      "return",
      "self",
      "str",
      "try",
      "while",
      "with",
      "yield"
    ];
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Python/utils.js
var require_utils17 = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Python/utils.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : {
        "default": mod
      };
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.classNameStyle = classNameStyle;
    exports.snakeNameStyle = snakeNameStyle;
    var unicode_properties_1 = __importDefault(require_main());
    var Strings_1 = require_Strings();
    function isNormalizedStartCharacter3(utf16Unit) {
      const category = unicode_properties_1.default.getCategory(utf16Unit);
      return [
        "Lu",
        "Ll",
        "Lt",
        "Lm",
        "Lo",
        "Nl"
      ].includes(category);
    }
    function isNormalizedPartCharacter3(utf16Unit) {
      if (isNormalizedStartCharacter3(utf16Unit)) return true;
      const category = unicode_properties_1.default.getCategory(utf16Unit);
      return [
        "Mn",
        "Mc",
        "Nd",
        "Pc"
      ].includes(category);
    }
    function isStartCharacter3(utf16Unit) {
      const s = String.fromCharCode(utf16Unit).normalize("NFKC");
      const l = s.length;
      if (l === 0 || !isNormalizedStartCharacter3(s.charCodeAt(0))) return false;
      for (let i2 = 1; i2 < l; i2++) {
        if (!isNormalizedPartCharacter3(s.charCodeAt(i2))) return false;
      }
      return true;
    }
    function isPartCharacter3(utf16Unit) {
      const s = String.fromCharCode(utf16Unit).normalize("NFKC");
      const l = s.length;
      for (let i2 = 0; i2 < l; i2++) {
        if (!isNormalizedPartCharacter3(s.charCodeAt(i2))) return false;
      }
      return true;
    }
    var legalizeName3 = (0, Strings_1.utf16LegalizeCharacters)(isPartCharacter3);
    function classNameStyle(original) {
      const words = (0, Strings_1.splitIntoWords)(original);
      return (0, Strings_1.combineWords)(words, legalizeName3, Strings_1.firstUpperWordStyle, Strings_1.firstUpperWordStyle, Strings_1.allUpperWordStyle, Strings_1.allUpperWordStyle, "", isStartCharacter3);
    }
    function getWordStyle(uppercase, forceSnakeNameStyle) {
      if (!forceSnakeNameStyle) {
        return Strings_1.originalWord;
      }
      return uppercase ? Strings_1.allUpperWordStyle : Strings_1.allLowerWordStyle;
    }
    function snakeNameStyle(original, uppercase, forceSnakeNameStyle) {
      const wordStyle = getWordStyle(uppercase, forceSnakeNameStyle);
      const separator = forceSnakeNameStyle ? "_" : "";
      const words = (0, Strings_1.splitIntoWords)(original);
      return (0, Strings_1.combineWords)(words, legalizeName3, wordStyle, wordStyle, wordStyle, wordStyle, separator, isStartCharacter3);
    }
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Python/PythonRenderer.js
var require_PythonRenderer = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Python/PythonRenderer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.PythonRenderer = void 0;
    var collection_utils_1 = require_dist();
    var ConvenienceRenderer_1 = require_ConvenienceRenderer();
    var Naming_1 = require_Naming();
    var Source_1 = require_Source();
    var Strings_1 = require_Strings();
    var Support_1 = require_Support();
    var Transformers_1 = require_Transformers();
    var Type_1 = require_Type2();
    var TypeUtils_1 = require_TypeUtils();
    var constants_1 = require_constants14();
    var utils_1 = require_utils17();
    var PythonRenderer = class extends ConvenienceRenderer_1.ConvenienceRenderer {
      constructor(targetLanguage, renderContext, pyOptions) {
        super(targetLanguage, renderContext);
        this.pyOptions = pyOptions;
        this.imports = /* @__PURE__ */ new Map();
        this.declaredTypes = /* @__PURE__ */ new Set();
      }
      forbiddenNamesForGlobalNamespace() {
        return constants_1.forbiddenTypeNames;
      }
      forbiddenForObjectProperties(_, _classNamed) {
        return {
          names: constants_1.forbiddenPropertyNames,
          includeGlobalForbidden: false
        };
      }
      makeNamedTypeNamer() {
        return (0, Naming_1.funPrefixNamer)("type", utils_1.classNameStyle);
      }
      namerForObjectProperty() {
        return (0, Naming_1.funPrefixNamer)("property", (s) => (0, utils_1.snakeNameStyle)(s, false, this.pyOptions.nicePropertyNames));
      }
      makeUnionMemberNamer() {
        return null;
      }
      makeEnumCaseNamer() {
        return (0, Naming_1.funPrefixNamer)("enum-case", (s) => (0, utils_1.snakeNameStyle)(s, true, this.pyOptions.nicePropertyNames));
      }
      get commentLineStart() {
        return "# ";
      }
      emitDescriptionBlock(lines) {
        if (lines.length === 1) {
          const docstring = (0, Source_1.modifySource)((content) => {
            if (content.endsWith('"')) {
              return content.slice(0, -1) + '\\"';
            }
            return content;
          }, lines[0]);
          this.emitComments([
            {
              customLines: [
                docstring
              ],
              lineStart: '"""',
              lineEnd: '"""'
            }
          ]);
        } else {
          this.emitCommentLines(lines, {
            firstLineStart: '"""',
            lineStart: "",
            afterComment: '"""'
          });
        }
      }
      get needsTypeDeclarationBeforeUse() {
        return true;
      }
      canBeForwardDeclared(t) {
        const kind = t.kind;
        return kind === "class" || kind === "enum";
      }
      emitBlock(line, f) {
        this.emitLine(line);
        this.indent(f);
      }
      string(s) {
        const openQuote = '"';
        return [
          openQuote,
          (0, Strings_1.stringEscape)(s),
          '"'
        ];
      }
      withImport(module2, name) {
        if (this.pyOptions.features.typeHints || module2 !== "typing") {
          (0, collection_utils_1.mapUpdateInto)(this.imports, module2, (s) => s ? (0, collection_utils_1.setUnionInto)(s, [
            name
          ]) : /* @__PURE__ */ new Set([
            name
          ]));
        }
        return name;
      }
      withTyping(name) {
        return this.withImport("typing", name);
      }
      namedType(t) {
        const name = this.nameForNamedType(t);
        if (this.declaredTypes.has(t)) return name;
        return [
          "'",
          name,
          "'"
        ];
      }
      pythonType(t, _isRootTypeDef = false) {
        const actualType = (0, Transformers_1.followTargetType)(t);
        return (0, TypeUtils_1.matchType)(actualType, (_anyType) => this.withTyping("Any"), (_nullType) => "None", (_boolType) => "bool", (_integerType) => "int", (_doubletype) => "float", (_stringType) => "str", (arrayType) => [
          this.withTyping("List"),
          "[",
          this.pythonType(arrayType.items),
          "]"
        ], (classType) => this.namedType(classType), (mapType) => [
          this.withTyping("Dict"),
          "[str, ",
          this.pythonType(mapType.values),
          "]"
        ], (enumType) => this.namedType(enumType), (unionType) => {
          const [hasNull, nonNulls] = (0, TypeUtils_1.removeNullFromUnion)(unionType);
          const memberTypes = Array.from(nonNulls).map((m) => this.pythonType(m));
          if (hasNull !== null) {
            const rest = [];
            if (!this.getAlphabetizeProperties() && (this.pyOptions.features.dataClasses || this.pyOptions.pydanticBaseModel) && _isRootTypeDef) {
              rest.push(" = None");
            }
            if (nonNulls.size > 1) {
              this.withImport("typing", "Union");
              return [
                this.withTyping("Optional"),
                "[Union[",
                (0, collection_utils_1.arrayIntercalate)(", ", memberTypes),
                "]]",
                ...rest
              ];
            }
            return [
              this.withTyping("Optional"),
              "[",
              (0, Support_1.defined)((0, collection_utils_1.iterableFirst)(memberTypes)),
              "]",
              ...rest
            ];
          }
          return [
            this.withTyping("Union"),
            "[",
            (0, collection_utils_1.arrayIntercalate)(", ", memberTypes),
            "]"
          ];
        }, (transformedStringType) => {
          if (transformedStringType.kind === "date-time") {
            return this.withImport("datetime", "datetime");
          }
          if (transformedStringType.kind === "uuid") {
            return this.withImport("uuid", "UUID");
          }
          return (0, Support_1.panic)(`Transformed type ${transformedStringType.kind} not supported`);
        });
      }
      declarationLine(t) {
        if (t instanceof Type_1.ClassType) {
          if (this.pyOptions.pydanticBaseModel) {
            return [
              "class ",
              this.nameForNamedType(t),
              "(",
              this.withImport("pydantic", "BaseModel"),
              "):"
            ];
          }
          return [
            "class ",
            this.nameForNamedType(t),
            ":"
          ];
        }
        if (t instanceof Type_1.EnumType) {
          return [
            "class ",
            this.nameForNamedType(t),
            "(",
            this.withImport("enum", "Enum"),
            "):"
          ];
        }
        return (0, Support_1.panic)(`Can't declare type ${t.kind}`);
      }
      declareType(t, emitter) {
        this.emitBlock(this.declarationLine(t), () => {
          this.emitDescription(this.descriptionForType(t));
          emitter();
        });
        this.declaredTypes.add(t);
      }
      emitClassMembers(t) {
        if (this.pyOptions.features.dataClasses || this.pyOptions.pydanticBaseModel) return;
        const args = [];
        this.forEachClassProperty(t, "none", (name, _, cp) => {
          args.push([
            name,
            this.typeHint(": ", this.pythonType(cp.type))
          ]);
        });
        this.emitBlock([
          "def __init__(self, ",
          (0, collection_utils_1.arrayIntercalate)(", ", args),
          ")",
          this.typeHint(" -> None"),
          ":"
        ], () => {
          if (args.length === 0) {
            this.emitLine("pass");
          } else {
            this.forEachClassProperty(t, "none", (name) => {
              this.emitLine("self.", name, " = ", name);
            });
          }
        });
      }
      typeHint(...sl) {
        if (this.pyOptions.features.typeHints) {
          return sl;
        }
        return [];
      }
      typingDecl(name, type) {
        return [
          name,
          this.typeHint(": ", this.withTyping(type))
        ];
      }
      typingReturn(type) {
        return this.typeHint(" -> ", this.withTyping(type));
      }
      sortClassProperties(properties, propertyNames) {
        if (this.pyOptions.features.dataClasses || this.pyOptions.pydanticBaseModel) {
          return (0, collection_utils_1.mapSortBy)(properties, (p) => {
            return p.type instanceof Type_1.UnionType && (0, TypeUtils_1.nullableFromUnion)(p.type) != null || p.isOptional ? 1 : 0;
          });
        }
        return super.sortClassProperties(properties, propertyNames);
      }
      emitClass(t) {
        if (this.pyOptions.features.dataClasses && !this.pyOptions.pydanticBaseModel) {
          this.emitLine("@", this.withImport("dataclasses", "dataclass"));
        }
        this.declareType(t, () => {
          if (this.pyOptions.features.typeHints) {
            if (t.getProperties().size === 0) {
              this.emitLine("pass");
            } else {
              this.forEachClassProperty(t, "none", (name, jsonName, cp) => {
                this.emitLine(name, this.typeHint(": ", this.pythonType(cp.type, true)));
                this.emitDescription(this.descriptionForClassProperty(t, jsonName));
              });
            }
            this.ensureBlankLine();
          }
          this.emitClassMembers(t);
        });
      }
      emitEnum(t) {
        this.declareType(t, () => {
          this.forEachEnumCase(t, "none", (name, jsonName) => {
            this.emitLine([
              name,
              " = ",
              this.string(jsonName)
            ]);
          });
        });
      }
      emitImports() {
        this.imports.forEach((names, module2) => {
          this.emitLine("from ", module2, " import ", Array.from(names).join(", "));
        });
      }
      emitSupportCode() {
        return;
      }
      emitClosingCode() {
        return;
      }
      emitSourceStructure(_givenOutputFilename) {
        const declarationLines = this.gatherSource(() => {
          this.forEachNamedType([
            "interposing",
            2
          ], (c) => this.emitClass(c), (e) => this.emitEnum(e), (_u) => {
            return;
          });
        });
        const closingLines = this.gatherSource(() => this.emitClosingCode());
        const supportLines = this.gatherSource(() => this.emitSupportCode());
        if (this.leadingComments !== void 0) {
          this.emitComments(this.leadingComments);
        }
        this.ensureBlankLine();
        this.emitImports();
        this.ensureBlankLine(2);
        this.emitGatheredSource(supportLines);
        this.ensureBlankLine(2);
        this.emitGatheredSource(declarationLines);
        this.ensureBlankLine(2);
        this.emitGatheredSource(closingLines);
      }
    };
    exports.PythonRenderer = PythonRenderer;
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Python/JSONPythonRenderer.js
var require_JSONPythonRenderer = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Python/JSONPythonRenderer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.JSONPythonRenderer = void 0;
    var collection_utils_1 = require_dist();
    var ConvenienceRenderer_1 = require_ConvenienceRenderer();
    var Naming_1 = require_Naming();
    var Source_1 = require_Source();
    var Support_1 = require_Support();
    var Transformers_1 = require_Transformers();
    var TypeUtils_1 = require_TypeUtils();
    var PythonRenderer_1 = require_PythonRenderer();
    var utils_1 = require_utils17();
    function compose(input, f) {
      if (typeof f === "function") {
        if (input.value !== void 0) {
          return {
            value: f(makeValue(input))
          };
        }
        if (input.lambda !== void 0) {
          return {
            lambda: (0, Source_1.multiWord)(" ", "lambda x:", f([
              (0, Source_1.parenIfNeeded)(input.lambda),
              "(x)"
            ])),
            value: void 0
          };
        }
        return {
          lambda: (0, Source_1.multiWord)(" ", "lambda x:", f("x")),
          value: void 0
        };
      }
      if (f.value !== void 0) {
        return (0, Support_1.panic)("Cannot compose into a value");
      }
      if (f.lambda === void 0) {
        return input;
      }
      if (input.value === void 0) {
        if (input.lambda === void 0) {
          return f;
        }
        return {
          lambda: (0, Source_1.multiWord)("", "lambda x: ", (0, Source_1.parenIfNeeded)(f.lambda), "(", (0, Source_1.parenIfNeeded)(input.lambda), "(x))"),
          value: void 0
        };
      }
      return {
        lambda: f.lambda,
        value: makeValue(input)
      };
    }
    var identity = {
      value: void 0
    };
    function makeLambda(vol) {
      if (vol.lambda !== void 0) {
        if (vol.value === void 0) {
          return vol.lambda;
        }
        return (0, Source_1.multiWord)("", "lambda x: ", (0, Source_1.parenIfNeeded)(vol.lambda), "(", vol.value, ")");
      }
      if (vol.value !== void 0) {
        return (0, Source_1.multiWord)(" ", "lambda x:", vol.value);
      }
      return (0, Source_1.multiWord)(" ", "lambda x:", "x");
    }
    function makeValue(vol) {
      if (vol.value === void 0) {
        return (0, Support_1.panic)("Cannot make value from lambda without value");
      }
      if (vol.lambda !== void 0) {
        return [
          (0, Source_1.parenIfNeeded)(vol.lambda),
          "(",
          vol.value,
          ")"
        ];
      }
      return vol.value;
    }
    var JSONPythonRenderer = class extends PythonRenderer_1.PythonRenderer {
      constructor() {
        super(...arguments);
        this._deserializerFunctions = /* @__PURE__ */ new Set();
        this._converterNamer = (0, Naming_1.funPrefixNamer)("converter", (s) => (0, utils_1.snakeNameStyle)(s, false, this.pyOptions.nicePropertyNames));
        this._topLevelConverterNames = /* @__PURE__ */ new Map();
        this._haveTypeVar = false;
        this._haveEnumTypeVar = false;
        this._haveDateutil = false;
      }
      emitTypeVar(tvar, constraints) {
        if (!this.pyOptions.features.typeHints) {
          return;
        }
        this.emitLine(tvar, " = ", this.withTyping("TypeVar"), "(", this.string(tvar), constraints, ")");
      }
      typeVar() {
        this._haveTypeVar = true;
        this.withTyping("TypeVar");
        return "T";
      }
      enumTypeVar() {
        this._haveEnumTypeVar = true;
        this.withTyping("TypeVar");
        this.withImport("enum", "Enum");
        return "EnumT";
      }
      cast(type, v) {
        if (!this.pyOptions.features.typeHints) {
          return v;
        }
        return [
          this.withTyping("cast"),
          "(",
          type,
          ", ",
          v,
          ")"
        ];
      }
      emitNoneConverter() {
        this.emitBlock([
          "def from_none(",
          this.typingDecl("x", "Any"),
          ")",
          this.typeHint(" -> ", this.withTyping("Any")),
          ":"
        ], () => {
          this.emitLine("assert x is None");
          this.emitLine("return x");
        });
      }
      emitBoolConverter() {
        this.emitBlock([
          "def from_bool(",
          this.typingDecl("x", "Any"),
          ")",
          this.typeHint(" -> bool"),
          ":"
        ], () => {
          this.emitLine("assert isinstance(x, bool)");
          this.emitLine("return x");
        });
      }
      emitIntConverter() {
        this.emitBlock([
          "def from_int(",
          this.typingDecl("x", "Any"),
          ")",
          this.typeHint(" -> int"),
          ":"
        ], () => {
          this.emitLine("assert isinstance(x, int) and not isinstance(x, bool)");
          this.emitLine("return x");
        });
      }
      emitFromFloatConverter() {
        this.emitBlock([
          "def from_float(",
          this.typingDecl("x", "Any"),
          ")",
          this.typeHint(" -> float"),
          ":"
        ], () => {
          this.emitLine("assert isinstance(x, (float, int)) and not isinstance(x, bool)");
          this.emitLine("return float(x)");
        });
      }
      emitToFloatConverter() {
        this.emitBlock([
          "def to_float(",
          this.typingDecl("x", "Any"),
          ")",
          this.typeHint(" -> float"),
          ":"
        ], () => {
          this.emitLine("assert isinstance(x, (int, float))");
          this.emitLine("return x");
        });
      }
      emitStrConverter() {
        this.emitBlock([
          "def from_str(",
          this.typingDecl("x", "Any"),
          ")",
          this.typeHint(" -> str"),
          ":"
        ], () => {
          const strType = "str";
          this.emitLine("assert isinstance(x, ", strType, ")");
          this.emitLine("return x");
        });
      }
      emitToEnumConverter() {
        const tvar = this.enumTypeVar();
        this.emitBlock([
          "def to_enum(c",
          this.typeHint(": ", this.withTyping("Type"), "[", tvar, "]"),
          ", ",
          this.typingDecl("x", "Any"),
          ")",
          this.typeHint(" -> ", tvar),
          ":"
        ], () => {
          this.emitLine("assert isinstance(x, c)");
          this.emitLine("return x.value");
        });
      }
      emitListConverter() {
        const tvar = this.typeVar();
        this.emitBlock([
          "def from_list(f",
          this.typeHint(": ", this.withTyping("Callable"), "[[", this.withTyping("Any"), "], ", tvar, "]"),
          ", ",
          this.typingDecl("x", "Any"),
          ")",
          this.typeHint(" -> ", this.withTyping("List"), "[", tvar, "]"),
          ":"
        ], () => {
          this.emitLine("assert isinstance(x, list)");
          this.emitLine("return [f(y) for y in x]");
        });
      }
      emitToClassConverter() {
        const tvar = this.typeVar();
        this.emitBlock([
          "def to_class(c",
          this.typeHint(": ", this.withTyping("Type"), "[", tvar, "]"),
          ", ",
          this.typingDecl("x", "Any"),
          ")",
          this.typeHint(" -> dict"),
          ":"
        ], () => {
          this.emitLine("assert isinstance(x, c)");
          this.emitLine("return ", this.cast(this.withTyping("Any"), "x"), ".to_dict()");
        });
      }
      emitDictConverter() {
        const tvar = this.typeVar();
        this.emitBlock([
          "def from_dict(f",
          this.typeHint(": ", this.withTyping("Callable"), "[[", this.withTyping("Any"), "], ", tvar, "]"),
          ", ",
          this.typingDecl("x", "Any"),
          ")",
          this.typeHint(" -> ", this.withTyping("Dict"), "[str, ", tvar, "]"),
          ":"
        ], () => {
          this.emitLine("assert isinstance(x, dict)");
          this.emitLine("return { k: f(v) for (k, v) in x.items() }");
        });
      }
      // This is not easily idiomatically typeable in Python.  See
      // https://stackoverflow.com/questions/51066468/computed-types-in-mypy/51084497
      emitUnionConverter() {
        this.emitMultiline(`def from_union(fs, x):
    for f in fs:
        try:
            return f(x)
        except:
            pass
    assert False`);
      }
      emitFromDatetimeConverter() {
        this.emitBlock([
          "def from_datetime(",
          this.typingDecl("x", "Any"),
          ")",
          this.typeHint(" -> ", this.withImport("datetime", "datetime")),
          ":"
        ], () => {
          this._haveDateutil = true;
          this.emitLine("return dateutil.parser.parse(x)");
        });
      }
      emitFromStringifiedBoolConverter() {
        this.emitBlock([
          "def from_stringified_bool(x",
          this.typeHint(": str"),
          ")",
          this.typeHint(" -> bool"),
          ":"
        ], () => {
          this.emitBlock('if x == "true":', () => this.emitLine("return True"));
          this.emitBlock('if x == "false":', () => this.emitLine("return False"));
          this.emitLine("assert False");
        });
      }
      emitIsTypeConverter() {
        const tvar = this.typeVar();
        this.emitBlock([
          "def is_type(t",
          this.typeHint(": ", this.withTyping("Type"), "[", tvar, "]"),
          ", ",
          this.typingDecl("x", "Any"),
          ")",
          this.typeHint(" -> ", tvar),
          ":"
        ], () => {
          this.emitLine("assert isinstance(x, t)");
          this.emitLine("return x");
        });
      }
      emitConverter(cf) {
        switch (cf) {
          case "none": {
            this.emitNoneConverter();
            return;
          }
          case "bool": {
            this.emitBoolConverter();
            return;
          }
          case "int": {
            this.emitIntConverter();
            return;
          }
          case "from-float": {
            this.emitFromFloatConverter();
            return;
          }
          case "to-float": {
            this.emitToFloatConverter();
            return;
          }
          case "str": {
            this.emitStrConverter();
            return;
          }
          case "to-enum": {
            this.emitToEnumConverter();
            return;
          }
          case "list": {
            this.emitListConverter();
            return;
          }
          case "to-class": {
            this.emitToClassConverter();
            return;
          }
          case "dict": {
            this.emitDictConverter();
            return;
          }
          case "union": {
            this.emitUnionConverter();
            return;
          }
          case "from-datetime": {
            this.emitFromDatetimeConverter();
            return;
          }
          case "from-stringified-bool": {
            this.emitFromStringifiedBoolConverter();
            return;
          }
          case "is-type": {
            this.emitIsTypeConverter();
            return;
          }
          default:
            (0, Support_1.assertNever)(cf);
        }
      }
      // Return the name of the Python converter function `cf`.
      conv(cf) {
        this._deserializerFunctions.add(cf);
        const name = cf.replace(/-/g, "_");
        if (cf.startsWith("from-") || cf.startsWith("to-") || cf.startsWith("is-")) return name;
        return [
          "from_",
          name
        ];
      }
      // Applies the converter function to `arg`
      convFn(cf, arg) {
        return compose(arg, {
          lambda: (0, Source_1.singleWord)(this.conv(cf)),
          value: void 0
        });
      }
      typeObject(t) {
        const s = (0, TypeUtils_1.matchType)(t, (_anyType) => void 0, (_nullType) => "type(None)", (_boolType) => "bool", (_integerType) => "int", (_doubleType) => "float", (_stringType) => "str", (_arrayType) => "List", (classType) => this.nameForNamedType(classType), (_mapType) => "dict", (enumType) => this.nameForNamedType(enumType), (_unionType) => void 0, (transformedStringType) => {
          if (transformedStringType.kind === "date-time") {
            return this.withImport("datetime", "datetime");
          }
          if (transformedStringType.kind === "uuid") {
            return this.withImport("uuid", "UUID");
          }
          return void 0;
        });
        if (s === void 0) {
          return (0, Support_1.panic)(`No type object for ${t.kind}`);
        }
        return s;
      }
      transformer(inputTransformer, xfer, targetType) {
        const consume = (consumer, vol) => {
          if (consumer === void 0) {
            return vol;
          }
          return this.transformer(vol, consumer, targetType);
        };
        const isType = (t, valueToCheck) => {
          return compose(valueToCheck, (v) => [
            this.conv("is-type"),
            "(",
            this.typeObject(t),
            ", ",
            v,
            ")"
          ]);
        };
        if (xfer instanceof Transformers_1.DecodingChoiceTransformer || xfer instanceof Transformers_1.ChoiceTransformer) {
          const lambdas = xfer.transformers.map((x) => makeLambda(this.transformer(identity, x, targetType)).source);
          return compose(inputTransformer, (v) => [
            this.conv("union"),
            "([",
            (0, collection_utils_1.arrayIntercalate)(", ", lambdas),
            "], ",
            v,
            ")"
          ]);
        }
        if (xfer instanceof Transformers_1.DecodingTransformer) {
          const consumer = xfer.consumer;
          const vol = this.deserializer(inputTransformer, xfer.sourceType);
          return consume(consumer, vol);
        }
        if (xfer instanceof Transformers_1.EncodingTransformer) {
          return this.serializer(inputTransformer, xfer.sourceType);
        }
        if (xfer instanceof Transformers_1.UnionInstantiationTransformer) {
          return inputTransformer;
        }
        if (xfer instanceof Transformers_1.UnionMemberMatchTransformer) {
          const consumer = xfer.transformer;
          const vol = isType(xfer.memberType, inputTransformer);
          return consume(consumer, vol);
        }
        if (xfer instanceof Transformers_1.ParseStringTransformer) {
          const consumer = xfer.consumer;
          const immediateTargetType = consumer === void 0 ? targetType : consumer.sourceType;
          let vol;
          switch (immediateTargetType.kind) {
            case "integer":
              vol = compose(inputTransformer, (v) => [
                "int(",
                v,
                ")"
              ]);
              break;
            case "bool":
              vol = this.convFn("from-stringified-bool", inputTransformer);
              break;
            case "enum":
              vol = this.deserializer(inputTransformer, immediateTargetType);
              break;
            case "date-time":
              vol = this.convFn("from-datetime", inputTransformer);
              break;
            case "uuid":
              vol = compose(inputTransformer, (v) => [
                this.withImport("uuid", "UUID"),
                "(",
                v,
                ")"
              ]);
              break;
            default:
              return (0, Support_1.panic)(`Parsing of ${immediateTargetType.kind} in a transformer is not supported`);
          }
          return consume(consumer, vol);
        }
        if (xfer instanceof Transformers_1.StringifyTransformer) {
          const consumer = xfer.consumer;
          let vol;
          switch (xfer.sourceType.kind) {
            case "integer":
              vol = compose(inputTransformer, (v) => [
                "str(",
                v,
                ")"
              ]);
              break;
            case "bool":
              vol = compose(inputTransformer, (v) => [
                "str(",
                v,
                ").lower()"
              ]);
              break;
            case "enum":
              vol = this.serializer(inputTransformer, xfer.sourceType);
              break;
            case "date-time":
              vol = compose(inputTransformer, (v) => [
                v,
                ".isoformat()"
              ]);
              break;
            case "uuid":
              vol = compose(inputTransformer, (v) => [
                "str(",
                v,
                ")"
              ]);
              break;
            default:
              return (0, Support_1.panic)(`Parsing of ${xfer.sourceType.kind} in a transformer is not supported`);
          }
          return consume(consumer, vol);
        }
        return (0, Support_1.panic)(`Transformer ${xfer.kind} is not supported`);
      }
      // Returns the code to deserialize `value` as type `t`.  If `t` has
      // an associated transformer, the code for that transformer is
      // returned.
      deserializer(value, t) {
        const xf = (0, Transformers_1.transformationForType)(t);
        if (xf !== void 0) {
          return this.transformer(value, xf.transformer, xf.targetType);
        }
        return (0, TypeUtils_1.matchType)(t, (_anyType) => value, (_nullType) => this.convFn("none", value), (_boolType) => this.convFn("bool", value), (_integerType) => this.convFn("int", value), (_doubleType) => this.convFn("from-float", value), (_stringType) => this.convFn("str", value), (arrayType) => compose(value, (v) => [
          this.conv("list"),
          "(",
          makeLambda(this.deserializer(identity, arrayType.items)).source,
          ", ",
          v,
          ")"
        ]), (classType) => compose(value, {
          lambda: (0, Source_1.singleWord)(this.nameForNamedType(classType), ".from_dict"),
          value: void 0
        }), (mapType) => compose(value, (v) => [
          this.conv("dict"),
          "(",
          makeLambda(this.deserializer(identity, mapType.values)).source,
          ", ",
          v,
          ")"
        ]), (enumType) => compose(value, {
          lambda: (0, Source_1.singleWord)(this.nameForNamedType(enumType)),
          value: void 0
        }), (unionType) => {
          const deserializers = Array.from(unionType.members).map((m) => makeLambda(this.deserializer(identity, m)).source);
          return compose(value, (v) => [
            this.conv("union"),
            "([",
            (0, collection_utils_1.arrayIntercalate)(", ", deserializers),
            "], ",
            v,
            ")"
          ]);
        }, (transformedStringType) => {
          if (transformedStringType.kind === "date-time") {
            return this.convFn("from-datetime", value);
          }
          if (transformedStringType.kind === "uuid") {
            return compose(value, (v) => [
              this.withImport("uuid", "UUID"),
              "(",
              v,
              ")"
            ]);
          }
          return (0, Support_1.panic)(`Transformed type ${transformedStringType.kind} not supported`);
        });
      }
      serializer(value, t) {
        const xf = (0, Transformers_1.transformationForType)(t);
        if (xf !== void 0) {
          const reverse = xf.reverse;
          return this.transformer(value, reverse.transformer, reverse.targetType);
        }
        return (0, TypeUtils_1.matchType)(t, (_anyType) => value, (_nullType) => this.convFn("none", value), (_boolType) => this.convFn("bool", value), (_integerType) => this.convFn("int", value), (_doubleType) => this.convFn("to-float", value), (_stringType) => this.convFn("str", value), (arrayType) => compose(value, (v) => [
          this.conv("list"),
          "(",
          makeLambda(this.serializer(identity, arrayType.items)).source,
          ", ",
          v,
          ")"
        ]), (classType) => compose(value, (v) => [
          this.conv("to-class"),
          "(",
          this.nameForNamedType(classType),
          ", ",
          v,
          ")"
        ]), (mapType) => compose(value, (v) => [
          this.conv("dict"),
          "(",
          makeLambda(this.serializer(identity, mapType.values)).source,
          ", ",
          v,
          ")"
        ]), (enumType) => compose(value, (v) => [
          this.conv("to-enum"),
          "(",
          this.nameForNamedType(enumType),
          ", ",
          v,
          ")"
        ]), (unionType) => {
          const serializers = Array.from(unionType.members).map((m) => makeLambda(this.serializer(identity, m)).source);
          return compose(value, (v) => [
            this.conv("union"),
            "([",
            (0, collection_utils_1.arrayIntercalate)(", ", serializers),
            "], ",
            v,
            ")"
          ]);
        }, (transformedStringType) => {
          if (transformedStringType.kind === "date-time") {
            return compose(value, (v) => [
              v,
              ".isoformat()"
            ]);
          }
          if (transformedStringType.kind === "uuid") {
            return compose(value, (v) => [
              "str(",
              v,
              ")"
            ]);
          }
          return (0, Support_1.panic)(`Transformed type ${transformedStringType.kind} not supported`);
        });
      }
      emitClassMembers(t) {
        super.emitClassMembers(t);
        this.ensureBlankLine();
        const className = this.nameForNamedType(t);
        this.emitLine("@staticmethod");
        this.emitBlock([
          "def from_dict(",
          this.typingDecl("obj", "Any"),
          ")",
          this.typeHint(" -> ", this.namedType(t)),
          ":"
        ], () => {
          const args = [];
          this.emitLine("assert isinstance(obj, dict)");
          this.forEachClassProperty(t, "none", (name, jsonName, cp) => {
            const property = {
              value: [
                "obj.get(",
                this.string(jsonName),
                ")"
              ]
            };
            this.emitLine(name, " = ", makeValue(this.deserializer(property, cp.type)));
            args.push(name);
          });
          this.emitLine("return ", className, "(", (0, collection_utils_1.arrayIntercalate)(", ", args), ")");
        });
        this.ensureBlankLine();
        this.emitBlock([
          "def to_dict(self)",
          this.typeHint(" -> dict"),
          ":"
        ], () => {
          this.emitLine("result", this.typeHint(": dict"), " = {}");
          this.forEachClassProperty(t, "none", (name, jsonName, cp) => {
            const property = {
              value: [
                "self.",
                name
              ]
            };
            if (cp.isOptional) {
              this.emitBlock([
                "if self.",
                name,
                " is not None:"
              ], () => {
                this.emitLine("result[", this.string(jsonName), "] = ", makeValue(this.serializer(property, cp.type)));
              });
            } else {
              this.emitLine("result[", this.string(jsonName), "] = ", makeValue(this.serializer(property, cp.type)));
            }
          });
          this.emitLine("return result");
        });
      }
      emitImports() {
        super.emitImports();
        if (this._haveDateutil) {
          this.emitLine("import dateutil.parser");
        }
        if (!this._haveTypeVar && !this._haveEnumTypeVar) return;
        this.ensureBlankLine(2);
        if (this._haveTypeVar) {
          this.emitTypeVar(this.typeVar(), []);
        }
        if (this._haveEnumTypeVar) {
          this.emitTypeVar(this.enumTypeVar(), [
            ", bound=",
            this.withImport("enum", "Enum")
          ]);
        }
      }
      emitSupportCode() {
        const map = Array.from(this._deserializerFunctions).map((f) => [
          f,
          f
        ]);
        this.forEachWithBlankLines(map, [
          "interposing",
          2
        ], (cf) => {
          this.emitConverter(cf);
        });
      }
      makeTopLevelDependencyNames(_t, topLevelName) {
        const fromDict = new Naming_1.DependencyName(this._converterNamer, ConvenienceRenderer_1.topLevelNameOrder, (l) => `${l(topLevelName)}_from_dict`);
        const toDict = new Naming_1.DependencyName(this._converterNamer, ConvenienceRenderer_1.topLevelNameOrder, (l) => `${l(topLevelName)}_to_dict`);
        this._topLevelConverterNames.set(topLevelName, {
          fromDict,
          toDict
        });
        return [
          fromDict,
          toDict
        ];
      }
      emitDefaultLeadingComments() {
        this.ensureBlankLine();
        if (this._haveDateutil) {
          this.emitCommentLines([
            "This code parses date/times, so please",
            "",
            "    pip install python-dateutil",
            ""
          ]);
        }
        this.emitCommentLines([
          "To use this code, make sure you",
          "",
          "    import json",
          "",
          "and then, to convert JSON from a string, do",
          ""
        ]);
        this.forEachTopLevel("none", (_, name) => {
          const { fromDict } = (0, Support_1.defined)(this._topLevelConverterNames.get(name));
          this.emitLine(this.commentLineStart, "    result = ", fromDict, "(json.loads(json_string))");
        });
      }
      emitClosingCode() {
        this.forEachTopLevel([
          "interposing",
          2
        ], (t, name) => {
          const { fromDict, toDict } = (0, Support_1.defined)(this._topLevelConverterNames.get(name));
          const pythonType = this.pythonType(t);
          this.emitBlock([
            "def ",
            fromDict,
            "(",
            this.typingDecl("s", "Any"),
            ")",
            this.typeHint(" -> ", pythonType),
            ":"
          ], () => {
            this.emitLine("return ", makeValue(this.deserializer({
              value: "s"
            }, t)));
          });
          this.ensureBlankLine(2);
          this.emitBlock([
            "def ",
            toDict,
            "(x",
            this.typeHint(": ", pythonType),
            ")",
            this.typingReturn("Any"),
            ":"
          ], () => {
            this.emitLine("return ", makeValue(this.serializer({
              value: "x"
            }, t)));
          });
        });
      }
    };
    exports.JSONPythonRenderer = JSONPythonRenderer;
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Python/language.js
var require_language18 = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Python/language.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.PythonTargetLanguage = exports.pythonLanguageConfig = exports.pythonOptions = void 0;
    var collection_utils_1 = require_dist();
    var RendererOptions_1 = require_RendererOptions();
    var TargetLanguage_1 = require_TargetLanguage();
    var Type_1 = require_Type2();
    var JSONPythonRenderer_1 = require_JSONPythonRenderer();
    var PythonRenderer_1 = require_PythonRenderer();
    exports.pythonOptions = {
      features: new RendererOptions_1.EnumOption("python-version", "Python version", {
        "3.5": {
          typeHints: false,
          dataClasses: false
        },
        "3.6": {
          typeHints: true,
          dataClasses: false
        },
        "3.7": {
          typeHints: true,
          dataClasses: true
        }
      }, "3.6"),
      justTypes: new RendererOptions_1.BooleanOption("just-types", "Classes only", false),
      nicePropertyNames: new RendererOptions_1.BooleanOption("nice-property-names", "Transform property names to be Pythonic", true),
      pydanticBaseModel: new RendererOptions_1.BooleanOption("pydantic-base-model", "Uses pydantic BaseModel", false)
    };
    exports.pythonLanguageConfig = {
      displayName: "Python",
      names: [
        "python",
        "py"
      ],
      extension: "py"
    };
    var PythonTargetLanguage = class extends TargetLanguage_1.TargetLanguage {
      constructor() {
        super(exports.pythonLanguageConfig);
      }
      getOptions() {
        return exports.pythonOptions;
      }
      get stringTypeMapping() {
        const mapping = /* @__PURE__ */ new Map();
        const dateTimeType = "date-time";
        mapping.set("date", dateTimeType);
        mapping.set("time", dateTimeType);
        mapping.set("date-time", dateTimeType);
        mapping.set("uuid", "uuid");
        mapping.set("integer-string", "integer-string");
        mapping.set("bool-string", "bool-string");
        return mapping;
      }
      get supportsUnionsWithBothNumberTypes() {
        return true;
      }
      get supportsOptionalClassProperties() {
        return false;
      }
      needsTransformerForType(t) {
        if (t instanceof Type_1.UnionType) {
          return (0, collection_utils_1.iterableSome)(t.members, (m) => this.needsTransformerForType(m));
        }
        return t.kind === "integer-string" || t.kind === "bool-string";
      }
      makeRenderer(renderContext, untypedOptionValues) {
        const options = (0, RendererOptions_1.getOptionValues)(exports.pythonOptions, untypedOptionValues);
        if (options.justTypes) {
          return new PythonRenderer_1.PythonRenderer(this, renderContext, options);
        }
        return new JSONPythonRenderer_1.JSONPythonRenderer(this, renderContext, options);
      }
    };
    exports.PythonTargetLanguage = PythonTargetLanguage;
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Python/index.js
var require_Python = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Python/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.JSONPythonRenderer = exports.PythonRenderer = exports.pythonOptions = exports.PythonTargetLanguage = void 0;
    var language_1 = require_language18();
    Object.defineProperty(exports, "PythonTargetLanguage", {
      enumerable: true,
      get: function() {
        return language_1.PythonTargetLanguage;
      }
    });
    Object.defineProperty(exports, "pythonOptions", {
      enumerable: true,
      get: function() {
        return language_1.pythonOptions;
      }
    });
    var PythonRenderer_1 = require_PythonRenderer();
    Object.defineProperty(exports, "PythonRenderer", {
      enumerable: true,
      get: function() {
        return PythonRenderer_1.PythonRenderer;
      }
    });
    var JSONPythonRenderer_1 = require_JSONPythonRenderer();
    Object.defineProperty(exports, "JSONPythonRenderer", {
      enumerable: true,
      get: function() {
        return JSONPythonRenderer_1.JSONPythonRenderer;
      }
    });
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Ruby/constants.js
var require_constants15 = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Ruby/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.reservedProperties = exports.globals = exports.keywords = void 0;
    exports.keywords = [
      "__ENCODING__",
      "__FILE__",
      "__LINE__",
      "alias",
      "and",
      "begin",
      "BEGIN",
      "break",
      "case",
      "class",
      "def",
      "defined?",
      "do",
      "else",
      "elsif",
      "end",
      "END",
      "ensure",
      "false",
      "for",
      "if",
      "in",
      "module",
      "next",
      "nil",
      "not",
      "or",
      "redo",
      "rescue",
      "retry",
      "return",
      "self",
      "super",
      "then",
      "true",
      "undef",
      "unless",
      "until",
      "when",
      "while",
      "yield"
    ];
    var globalClasses = [
      "ArgumentError",
      "Array",
      "BasicObject",
      "Class",
      "ClosedQueueError",
      "Comparable",
      "Complex",
      "ConditionVariable",
      "Continuation",
      "Data",
      "Date",
      "Dir",
      "ENV",
      "EOFError",
      "Encoding",
      "EncodingError",
      "Enumerable",
      "Enumerator",
      "Errno",
      "Exception",
      "FalseClass",
      "Fiber",
      "FiberError",
      "File",
      "FileTest",
      "Float",
      "FloatDomainError",
      "FrozenError",
      "GC",
      "Hash",
      "IO",
      "IOError",
      "IndexError",
      "Integer",
      "Interrupt",
      "KeyError",
      "LoadError",
      "LocalJumpError",
      "Marshal",
      "MatchData",
      "Math",
      "Method",
      "Module",
      "Mutex",
      "NameError",
      "NilClass",
      "NoMemoryError",
      "NoMethodError",
      "NotImplementedError",
      "Numeric",
      "Object",
      "ObjectSpace",
      "Proc",
      "Process",
      "Queue",
      "Random",
      "Range",
      "RangeError",
      "Rational",
      "Regexp",
      "RegexpError",
      "RubyVM",
      "RuntimeError",
      "ScriptError",
      "SecurityError",
      "Set",
      "Signal",
      "SignalException",
      "SizedQueue",
      "StandardError",
      "StopIteration",
      "String",
      "Struct",
      "Symbol",
      "SyntaxError",
      "SystemCallError",
      "SystemExit",
      "SystemStackError",
      "Thread",
      "ThreadError",
      "ThreadGroup",
      "Time",
      "TracePoint",
      "TrueClass",
      "TypeError",
      "UnboundMethod",
      "UncaughtThrowError",
      "Undefined",
      "UnicodeNormalize",
      "Warning",
      "ZeroDivisionError"
    ];
    var kernel = [
      "__callee__",
      "__dir__",
      "__id__",
      "__method__",
      "__send__",
      "!",
      "!=",
      "!~",
      "<",
      "<=",
      "<=>",
      "==",
      "===",
      "=~",
      ">",
      ">=",
      "abort",
      "ancestors",
      "at_exit",
      "autoload",
      "autoload?",
      "binding",
      "block_given?",
      "caller",
      "caller_locations",
      "catch",
      "class",
      "class_eval",
      "class_exec",
      "class_variable_defined?",
      "class_variable_get",
      "class_variable_set",
      "class_variables",
      "clone",
      "const_defined?",
      "const_get",
      "const_missing",
      "const_set",
      "constants",
      "define_singleton_method",
      "deprecate_constant",
      "display",
      "dup",
      "enum_for",
      "eql?",
      "equal?",
      "eval",
      "exec",
      "exit",
      "exit!",
      "extend",
      "fail",
      "fork",
      "format",
      "freeze",
      "frozen?",
      "gets",
      "global_variables",
      "hash",
      "include",
      "include?",
      "included_modules",
      "inspect",
      "instance_eval",
      "instance_exec",
      "instance_method",
      "instance_methods",
      "instance_of?",
      "instance_variable_defined?",
      "instance_variable_get",
      "instance_variable_set",
      "instance_variables",
      "is_a?",
      "iterator?",
      "itself",
      "kind_of?",
      "lambda",
      "load",
      "local_variables",
      "loop",
      "method",
      "method_defined?",
      "methods",
      "module_eval",
      "module_exec",
      "name",
      "new",
      "nil?",
      "object_id",
      "open",
      "p",
      "prepend",
      "print",
      "printf",
      "private_class_method",
      "private_constant",
      "private_instance_methods",
      "private_method_defined?",
      "private_methods",
      "proc",
      "protected_instance_methods",
      "protected_method_defined?",
      "protected_methods",
      "public_class_method",
      "public_constant",
      "public_instance_method",
      "public_instance_methods",
      "public_method",
      "public_method_defined?",
      "public_methods",
      "public_send",
      "putc",
      "puts",
      "raise",
      "rand",
      "readline",
      "readlines",
      "remove_class_variable",
      "remove_instance_variable",
      "require",
      "require_relative",
      "respond_to?",
      "select",
      "send",
      "set_trace_func",
      "singleton_class",
      "singleton_class?",
      "singleton_method",
      "singleton_methods",
      "sleep",
      "spawn",
      "sprintf",
      "srand",
      "syscall",
      "system",
      "taint",
      "tainted?",
      "tap",
      "test",
      "throw",
      "to_enum",
      "to_s",
      "trace_var",
      "trap",
      "trust",
      "untaint",
      "untrace_var",
      "untrust",
      "untrusted?",
      "warn"
    ];
    exports.globals = [
      ...kernel,
      ...globalClasses
    ];
    exports.reservedProperties = [
      "__id__",
      "__send__",
      "break",
      "call",
      "case",
      "class",
      "clone",
      "constrained_type",
      "constrained?",
      "constrained",
      "constructor",
      "default",
      "define_singleton_method",
      "display",
      "dup",
      "enum_for",
      "enum",
      "extend",
      "freeze",
      "gem",
      "hash",
      "inspect",
      "instance_eval",
      "instance_exec",
      "instance_variable_defined?",
      "instance_variable_get",
      "instance_variable_set",
      "instance_variables",
      "itself",
      "meta",
      "method",
      "methods",
      "next",
      "object_id",
      "optional",
      "options",
      "pristine",
      "private_methods",
      "protected_methods",
      "public_method",
      "public_methods",
      "public_send",
      "remove_instance_variable",
      "rule",
      "safe",
      "self",
      "send",
      "singleton_class",
      "singleton_method",
      "singleton_methods",
      "taint",
      "tap",
      "to_ast",
      "to_enum",
      "to_json",
      "to_s",
      "trust",
      "try",
      "type",
      "untaint",
      "undef",
      "untrust",
      "while",
      "with"
    ];
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Ruby/utils.js
var require_utils18 = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Ruby/utils.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
          enumerable: true,
          get: function() {
            return m[k];
          }
        };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
      });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || /* @__PURE__ */ function() {
      var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      };
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i2 = 0; i2 < k.length; i2++) if (k[i2] !== "default") __createBinding(result, mod, k[i2]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : {
        "default": mod
      };
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.stringEscape = exports.forbiddenForObjectProperties = exports.Strictness = void 0;
    exports.simpleNameStyle = simpleNameStyle;
    exports.memberNameStyle = memberNameStyle;
    var unicode_properties_1 = __importDefault(require_main());
    var Strings_1 = require_Strings();
    var keywords = __importStar(require_constants15());
    var Strictness;
    (function(Strictness2) {
      Strictness2["Strict"] = "Strict::";
      Strictness2["Coercible"] = "Coercible::";
      Strictness2["None"] = "Types::";
    })(Strictness || (exports.Strictness = Strictness = {}));
    exports.forbiddenForObjectProperties = Array.from(/* @__PURE__ */ new Set([
      ...keywords.keywords,
      ...keywords.reservedProperties
    ]));
    function unicodeEscape(codePoint) {
      return "\\u{" + (0, Strings_1.intToHex)(codePoint, 0) + "}";
    }
    exports.stringEscape = (0, Strings_1.utf32ConcatMap)((0, Strings_1.escapeNonPrintableMapper)(Strings_1.isPrintable, unicodeEscape));
    var isStartCharacter = Strings_1.isLetterOrUnderscore;
    function isPartCharacter(utf16Unit) {
      const category = unicode_properties_1.default.getCategory(utf16Unit);
      return [
        "Nd",
        "Pc",
        "Mn",
        "Mc"
      ].includes(category) || isStartCharacter(utf16Unit);
    }
    var legalizeName = (0, Strings_1.legalizeCharacters)(isPartCharacter);
    function simpleNameStyle(original, uppercase) {
      if (/^[0-9]+$/.test(original)) {
        original = original + "N";
      }
      const words = (0, Strings_1.splitIntoWords)(original);
      return (0, Strings_1.combineWords)(words, legalizeName, uppercase ? Strings_1.firstUpperWordStyle : Strings_1.allLowerWordStyle, uppercase ? Strings_1.firstUpperWordStyle : Strings_1.allLowerWordStyle, Strings_1.allUpperWordStyle, Strings_1.allUpperWordStyle, "", isStartCharacter);
    }
    function memberNameStyle(original) {
      const words = (0, Strings_1.splitIntoWords)(original);
      return (0, Strings_1.combineWords)(words, legalizeName, Strings_1.allLowerWordStyle, Strings_1.allLowerWordStyle, Strings_1.allLowerWordStyle, Strings_1.allLowerWordStyle, "_", isStartCharacter);
    }
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Ruby/RubyRenderer.js
var require_RubyRenderer = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Ruby/RubyRenderer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.RubyRenderer = void 0;
    var ConvenienceRenderer_1 = require_ConvenienceRenderer();
    var Naming_1 = require_Naming();
    var Source_1 = require_Source();
    var Strings_1 = require_Strings();
    var Type_1 = require_Type2();
    var TypeUtils_1 = require_TypeUtils();
    var constants_1 = require_constants15();
    var utils_1 = require_utils18();
    var RubyRenderer = class extends ConvenienceRenderer_1.ConvenienceRenderer {
      constructor(targetLanguage, renderContext, _options) {
        super(targetLanguage, renderContext);
        this._options = _options;
      }
      get commentLineStart() {
        return "# ";
      }
      get needsTypeDeclarationBeforeUse() {
        return true;
      }
      canBeForwardDeclared(t) {
        return "class" === t.kind;
      }
      forbiddenNamesForGlobalNamespace() {
        return [
          ...constants_1.globals,
          "Types",
          "JSON",
          "Dry",
          "Constructor",
          "Self"
        ];
      }
      forbiddenForObjectProperties(_c, _classNamed) {
        return {
          names: utils_1.forbiddenForObjectProperties,
          includeGlobalForbidden: true
        };
      }
      makeNamedTypeNamer() {
        return new Naming_1.Namer("types", (n) => (0, utils_1.simpleNameStyle)(n, true), []);
      }
      namerForObjectProperty() {
        return new Naming_1.Namer("properties", utils_1.memberNameStyle, []);
      }
      makeUnionMemberNamer() {
        return new Naming_1.Namer("properties", utils_1.memberNameStyle, []);
      }
      makeEnumCaseNamer() {
        return new Naming_1.Namer("enum-cases", (n) => (0, utils_1.simpleNameStyle)(n, true), []);
      }
      dryType(t, isOptional = false) {
        const optional = isOptional ? ".optional" : "";
        return (0, TypeUtils_1.matchType)(t, (_anyType) => [
          "Types::Any",
          optional
        ], (_nullType) => [
          "Types::Nil",
          optional
        ], (_boolType) => [
          "Types::Bool",
          optional
        ], (_integerType) => [
          "Types::Integer",
          optional
        ], (_doubleType) => [
          "Types::Double",
          optional
        ], (_stringType) => [
          "Types::String",
          optional
        ], (arrayType) => [
          "Types.Array(",
          this.dryType(arrayType.items),
          ")",
          optional
        ], (classType) => [
          this.nameForNamedType(classType),
          optional
        ], (mapType) => [
          "Types::Hash.meta(of: ",
          this.dryType(mapType.values),
          ")",
          optional
        ], (enumType) => [
          "Types::",
          this.nameForNamedType(enumType),
          optional
        ], (unionType) => {
          const nullable = (0, TypeUtils_1.nullableFromUnion)(unionType);
          if (nullable !== null) {
            return [
              this.dryType(nullable),
              ".optional"
            ];
          }
          return [
            "Types.Instance(",
            this.nameForNamedType(unionType),
            ")",
            optional
          ];
        });
      }
      exampleUse(t, exp, depth = 6, optional = false) {
        if (depth-- <= 0) {
          return exp;
        }
        const safeNav = optional ? "&" : "";
        return (0, TypeUtils_1.matchType)(t, (_anyType) => exp, (_nullType) => [
          exp,
          ".nil?"
        ], (_boolType) => exp, (_integerType) => [
          exp,
          ".even?"
        ], (_doubleType) => exp, (_stringType) => exp, (arrayType) => this.exampleUse(arrayType.items, [
          exp,
          safeNav,
          ".first"
        ], depth), (classType) => {
          let info;
          this.forEachClassProperty(classType, "none", (name, _json, prop) => {
            if ([
              "class",
              "map",
              "array"
            ].includes(prop.type.kind)) {
              info = {
                name,
                prop
              };
            } else if (info === void 0) {
              info = {
                name,
                prop
              };
            }
          });
          if (info !== void 0) {
            return this.exampleUse(info.prop.type, [
              exp,
              safeNav,
              ".",
              info.name
            ], depth, info.prop.isOptional);
          }
          return exp;
        }, (mapType) => this.exampleUse(mapType.values, [
          exp,
          safeNav,
          '["\u2026"]'
        ], depth), (enumType) => {
          let name;
          this.forEachEnumCase(enumType, "none", (theName) => {
            if (name === void 0) {
              name = theName;
            }
          });
          if (name !== void 0) {
            return [
              exp,
              " == ",
              this.nameForNamedType(enumType),
              "::",
              name
            ];
          }
          return exp;
        }, (unionType) => {
          const nullable = (0, TypeUtils_1.nullableFromUnion)(unionType);
          if (nullable !== null) {
            if ([
              "class",
              "map",
              "array"
            ].includes(nullable.kind)) {
              return this.exampleUse(nullable, exp, depth, true);
            }
            return [
              exp,
              ".nil?"
            ];
          }
          return exp;
        });
      }
      jsonSample(t) {
        function inner() {
          if (t instanceof Type_1.ArrayType) {
            return "[\u2026]";
          }
          if (t instanceof Type_1.MapType) {
            return "{\u2026}";
          }
          if (t instanceof Type_1.ClassType) {
            return "{\u2026}";
          }
          return "\u2026";
        }
        return `"${inner()}"`;
      }
      fromDynamic(t, e, optional = false, castPrimitives = false) {
        const primitiveCast = [
          this.dryType(t, optional),
          "[",
          e,
          "]"
        ];
        const primitive = castPrimitives ? primitiveCast : e;
        const safeAccess = optional ? "&" : "";
        return (0, TypeUtils_1.matchType)(t, (_anyType) => primitive, (_nullType) => primitive, (_boolType) => primitive, (_integerType) => primitive, (_doubleType) => primitive, (_stringType) => primitive, (arrayType) => [
          e,
          safeAccess,
          ".map { |x| ",
          this.fromDynamic(arrayType.items, "x", false, true),
          " }"
        ], (classType) => {
          const expression = [
            this.nameForNamedType(classType),
            ".from_dynamic!(",
            e,
            ")"
          ];
          return optional ? [
            e,
            " ? ",
            expression,
            " : nil"
          ] : expression;
        }, (mapType) => [
          [
            "Types::Hash",
            optional ? ".optional" : "",
            "[",
            e,
            "]"
          ],
          safeAccess,
          ".map { |k, v| [k, ",
          this.fromDynamic(mapType.values, "v", false, true),
          "] }",
          safeAccess,
          ".to_h"
        ], (enumType) => {
          const expression = [
            "Types::",
            this.nameForNamedType(enumType),
            "[",
            e,
            "]"
          ];
          return optional ? [
            e,
            ".nil? ? nil : ",
            expression
          ] : expression;
        }, (unionType) => {
          const nullable = (0, TypeUtils_1.nullableFromUnion)(unionType);
          if (nullable !== null) {
            return this.fromDynamic(nullable, e, true);
          }
          const expression = [
            this.nameForNamedType(unionType),
            ".from_dynamic!(",
            e,
            ")"
          ];
          return optional ? [
            e,
            " ? ",
            expression,
            " : nil"
          ] : expression;
        });
      }
      toDynamic(t, e, optional = false) {
        if (this.marshalsImplicitlyToDynamic(t)) {
          return e;
        }
        return (0, TypeUtils_1.matchType)(t, (_anyType) => e, (_nullType) => e, (_boolType) => e, (_integerType) => e, (_doubleType) => e, (_stringType) => e, (arrayType) => [
          e,
          optional ? "&" : "",
          ".map { |x| ",
          this.toDynamic(arrayType.items, "x"),
          " }"
        ], (_classType) => [
          e,
          optional ? "&" : "",
          ".to_dynamic"
        ], (mapType) => [
          e,
          optional ? "&" : "",
          ".map { |k, v| [k, ",
          this.toDynamic(mapType.values, "v"),
          "] }.to_h"
        ], (_enumType) => e, (unionType) => {
          const nullable = (0, TypeUtils_1.nullableFromUnion)(unionType);
          if (nullable !== null) {
            return this.toDynamic(nullable, e, true);
          }
          if (this.marshalsImplicitlyToDynamic(unionType)) {
            return e;
          }
          return [
            e,
            optional ? "&" : "",
            ".to_dynamic"
          ];
        });
      }
      marshalsImplicitlyToDynamic(t) {
        return (0, TypeUtils_1.matchType)(t, (_anyType) => true, (_nullType) => true, (_boolType) => true, (_integerType) => true, (_doubleType) => true, (_stringType) => true, (arrayType) => this.marshalsImplicitlyToDynamic(arrayType.items), (_classType) => false, (mapType) => this.marshalsImplicitlyToDynamic(mapType.values), (_enumType) => true, (unionType) => {
          const nullable = (0, TypeUtils_1.nullableFromUnion)(unionType);
          if (nullable !== null) {
            return this.marshalsImplicitlyToDynamic(nullable);
          }
          return false;
        });
      }
      // This is only to be used to allow class properties to possibly
      // marshal implicitly. They are allowed to do this because they will
      // be checked in Dry::Struct.new
      propertyTypeMarshalsImplicitlyFromDynamic(t) {
        return (0, TypeUtils_1.matchType)(
          t,
          (_anyType) => true,
          (_nullType) => true,
          (_boolType) => true,
          (_integerType) => true,
          (_doubleType) => true,
          (_stringType) => true,
          (arrayType) => this.propertyTypeMarshalsImplicitlyFromDynamic(arrayType.items),
          (_classType) => false,
          // Map properties must be checked because Dry:Types doesn't have a generic Map
          (_mapType) => false,
          (_enumType) => true,
          (unionType) => {
            const nullable = (0, TypeUtils_1.nullableFromUnion)(unionType);
            if (nullable !== null) {
              return this.propertyTypeMarshalsImplicitlyFromDynamic(nullable);
            }
            return false;
          }
        );
      }
      emitBlock(source, emit) {
        this.emitLine(source);
        this.indent(emit);
        this.emitLine("end");
      }
      emitModule(emit) {
        const emitModuleInner = (moduleName) => {
          const [firstModule, ...subModules] = moduleName.split("::");
          if (subModules.length > 0) {
            this.emitBlock([
              "module ",
              firstModule
            ], () => {
              emitModuleInner(subModules.join("::"));
            });
          } else {
            this.emitBlock([
              "module ",
              moduleName
            ], emit);
          }
        };
        if (this._options.namespace !== void 0 && this._options.namespace !== "") {
          emitModuleInner(this._options.namespace);
        } else {
          emit();
        }
      }
      emitClass(c, className) {
        this.emitDescription(this.descriptionForType(c));
        this.emitBlock([
          "class ",
          className,
          " < Dry::Struct"
        ], () => {
          let table = [];
          let count = c.getProperties().size;
          this.forEachClassProperty(c, "none", (name, jsonName, p) => {
            const last = --count === 0;
            const description = this.descriptionForClassProperty(c, jsonName);
            const attribute = [
              [
                "attribute :",
                name,
                ","
              ],
              [
                " ",
                this.dryType(p.type),
                p.isOptional ? ".optional" : ""
              ]
            ];
            if (description !== void 0) {
              if (table.length > 0) {
                this.emitTable(table);
                table = [];
              }
              this.ensureBlankLine();
              this.emitDescriptionBlock(description);
              this.emitLine(attribute);
              if (!last) {
                this.ensureBlankLine();
              }
            } else {
              table.push(attribute);
            }
          });
          if (table.length > 0) {
            this.emitTable(table);
          }
          if (this._options.justTypes) {
            return;
          }
          this.ensureBlankLine();
          this.emitBlock([
            "def self.from_dynamic!(d)"
          ], () => {
            this.emitLine("d = Types::Hash[d]");
            this.emitLine("new(");
            this.indent(() => {
              const inits = [];
              this.forEachClassProperty(c, "none", (name, jsonName, p) => {
                const dynamic = p.isOptional ? `d["${(0, utils_1.stringEscape)(jsonName)}"]` : `d.fetch("${(0, utils_1.stringEscape)(jsonName)}")`;
                if (this.propertyTypeMarshalsImplicitlyFromDynamic(p.type)) {
                  inits.push([
                    [
                      name,
                      ": "
                    ],
                    [
                      dynamic,
                      ","
                    ]
                  ]);
                } else {
                  const expression = this.fromDynamic(p.type, dynamic, p.isOptional);
                  inits.push([
                    [
                      name,
                      ": "
                    ],
                    [
                      expression,
                      ","
                    ]
                  ]);
                }
              });
              this.emitTable(inits);
            });
            this.emitLine(")");
          });
          this.ensureBlankLine();
          this.emitBlock("def self.from_json!(json)", () => {
            this.emitLine("from_dynamic!(JSON.parse(json))");
          });
          this.ensureBlankLine();
          this.emitBlock([
            "def to_dynamic"
          ], () => {
            this.emitLine("{");
            this.indent(() => {
              const inits = [];
              this.forEachClassProperty(c, "none", (name, jsonName, p) => {
                const expression = this.toDynamic(p.type, name, p.isOptional);
                inits.push([
                  [
                    `"${(0, utils_1.stringEscape)(jsonName)}"`
                  ],
                  [
                    " => ",
                    expression,
                    ","
                  ]
                ]);
              });
              this.emitTable(inits);
            });
            this.emitLine("}");
          });
          this.ensureBlankLine();
          this.emitBlock("def to_json(options = nil)", () => {
            this.emitLine("JSON.generate(to_dynamic, options)");
          });
        });
      }
      emitEnum(e, enumName) {
        this.emitDescription(this.descriptionForType(e));
        this.emitBlock([
          "module ",
          enumName
        ], () => {
          const table = [];
          this.forEachEnumCase(e, "none", (name, json) => {
            table.push([
              [
                name
              ],
              [
                ` = "${(0, utils_1.stringEscape)(json)}"`
              ]
            ]);
          });
          this.emitTable(table);
        });
      }
      emitUnion(u, unionName) {
        this.emitDescription(this.descriptionForType(u));
        this.emitBlock([
          "class ",
          unionName,
          " < Dry::Struct"
        ], () => {
          const table = [];
          this.forEachUnionMember(u, u.getChildren(), "none", null, (name, t) => {
            table.push([
              [
                "attribute :",
                name,
                ", "
              ],
              [
                this.dryType(t, true)
              ]
            ]);
          });
          this.emitTable(table);
          if (this._options.justTypes) {
            return;
          }
          this.ensureBlankLine();
          const [maybeNull, nonNulls] = (0, TypeUtils_1.removeNullFromUnion)(u, false);
          this.emitBlock("def self.from_dynamic!(d)", () => {
            const memberNames = Array.from(u.getChildren()).map((member) => this.nameForUnionMember(u, member));
            this.forEachUnionMember(u, u.getChildren(), "none", null, (name, t) => {
              const nilMembers = memberNames.filter((n) => n !== name).map((memberName) => [
                ", ",
                memberName,
                ": nil"
              ]);
              if (this.propertyTypeMarshalsImplicitlyFromDynamic(t)) {
                this.emitBlock([
                  "if schema[:",
                  name,
                  "].right.valid? d"
                ], () => {
                  this.emitLine("return new(", name, ": d", nilMembers, ")");
                });
              } else {
                this.emitLine("begin");
                this.indent(() => {
                  this.emitLine("value = ", this.fromDynamic(t, "d"));
                  this.emitBlock([
                    "if schema[:",
                    name,
                    "].right.valid? value"
                  ], () => {
                    this.emitLine("return new(", name, ": value", nilMembers, ")");
                  });
                });
                this.emitLine("rescue");
                this.emitLine("end");
              }
            });
            this.emitLine('raise "Invalid union"');
          });
          this.ensureBlankLine();
          this.emitBlock("def self.from_json!(json)", () => {
            this.emitLine("from_dynamic!(JSON.parse(json))");
          });
          this.ensureBlankLine();
          this.emitBlock("def to_dynamic", () => {
            let first = true;
            this.forEachUnionMember(u, nonNulls, "none", null, (name, t) => {
              this.emitLine(first ? "if" : "elsif", " ", name, " != nil");
              this.indent(() => {
                this.emitLine(this.toDynamic(t, name));
              });
              first = false;
            });
            if (maybeNull !== null) {
              this.emitLine("else");
              this.indent(() => {
                this.emitLine("nil");
              });
            }
            this.emitLine("end");
          });
          this.ensureBlankLine();
          this.emitBlock("def to_json(options = nil)", () => {
            this.emitLine("JSON.generate(to_dynamic, options)");
          });
        });
      }
      emitTypesModule() {
        this.emitBlock([
          "module Types"
        ], () => {
          this.emitLine("include Dry.Types(default: :nominal)");
          const declarations = [];
          if (this._options.strictness !== utils_1.Strictness.None) {
            let has = {
              int: false,
              nil: false,
              bool: false,
              hash: false,
              string: false,
              double: false
            };
            this.forEachType((t) => {
              has = {
                int: has.int || t.kind === "integer",
                nil: has.nil || t.kind === "null",
                bool: has.bool || t.kind === "bool",
                hash: has.hash || t.kind === "map" || t.kind === "class",
                string: has.string || t.kind === "string" || t.kind === "enum",
                double: has.double || t.kind === "double"
              };
            });
            if (has.int) declarations.push([
              [
                "Integer"
              ],
              [
                ` = ${this._options.strictness}Integer`
              ]
            ]);
            if (this._options.strictness === utils_1.Strictness.Strict) {
              if (has.nil) declarations.push([
                [
                  "Nil"
                ],
                [
                  ` = ${this._options.strictness}Nil`
                ]
              ]);
            }
            if (has.bool) declarations.push([
              [
                "Bool"
              ],
              [
                ` = ${this._options.strictness}Bool`
              ]
            ]);
            if (has.hash) declarations.push([
              [
                "Hash"
              ],
              [
                ` = ${this._options.strictness}Hash`
              ]
            ]);
            if (has.string) declarations.push([
              [
                "String"
              ],
              [
                ` = ${this._options.strictness}String`
              ]
            ]);
            if (has.double) declarations.push([
              [
                "Double"
              ],
              [
                ` = ${this._options.strictness}Float | ${this._options.strictness}Integer`
              ]
            ]);
          }
          this.forEachEnum("none", (enumType, enumName) => {
            const cases = [];
            this.forEachEnumCase(enumType, "none", (_name, json) => {
              cases.push([
                cases.length === 0 ? "" : ", ",
                `"${(0, utils_1.stringEscape)(json)}"`
              ]);
            });
            declarations.push([
              [
                enumName
              ],
              [
                " = ",
                this._options.strictness,
                "String.enum(",
                ...cases,
                ")"
              ]
            ]);
          });
          if (declarations.length > 0) {
            this.ensureBlankLine();
            this.emitTable(declarations);
          }
        });
      }
      emitSourceStructure() {
        if (this.leadingComments !== void 0) {
          this.emitComments(this.leadingComments);
        } else if (!this._options.justTypes) {
          this.emitLine("# This code may look unusually verbose for Ruby (and it is), but");
          this.emitLine("# it performs some subtle and complex validation of JSON data.");
          this.emitLine("#");
          this.emitLine("# To parse this JSON, add 'dry-struct' and 'dry-types' gems, then do:");
          this.emitLine("#");
          this.forEachTopLevel("none", (topLevel, name) => {
            const variable = (0, Source_1.modifySource)(Strings_1.snakeCase, name);
            this.emitLine("#   ", variable, " = ", name, ".from_json! ", this.jsonSample(topLevel));
            this.emitLine("#   puts ", this.exampleUse(topLevel, variable));
            this.emitLine("#");
          });
          this.emitLine("# If from_json! succeeds, the value returned matches the schema.");
        }
        this.ensureBlankLine();
        this.emitLine("require 'json'");
        this.emitLine("require 'dry-types'");
        this.emitLine("require 'dry-struct'");
        this.ensureBlankLine();
        this.emitModule(() => {
          this.emitTypesModule();
          this.forEachDeclaration("leading-and-interposing", (decl) => {
            if (decl.kind === "forward") {
              this.emitCommentLines([
                "(forward declaration)"
              ]);
              this.emitModule(() => {
                this.emitLine("class ", this.nameForNamedType(decl.type), " < Dry::Struct; end");
              });
            }
          });
          this.forEachNamedType("leading-and-interposing", (c, n) => this.emitClass(c, n), (e, n) => this.emitEnum(e, n), (u, n) => this.emitUnion(u, n));
          if (!this._options.justTypes) {
            this.forEachTopLevel("leading-and-interposing", (topLevel, name) => {
              const self2 = (0, Source_1.modifySource)(Strings_1.snakeCase, name);
              const needsToJsonDefined = "array" === topLevel.kind;
              const classDeclaration = () => {
                this.emitBlock([
                  "class ",
                  name
                ], () => {
                  this.emitBlock([
                    "def self.from_json!(json)"
                  ], () => {
                    if (needsToJsonDefined) {
                      this.emitLine(self2, " = ", this.fromDynamic(topLevel, "JSON.parse(json, quirks_mode: true)"));
                      this.emitBlock([
                        self2,
                        ".define_singleton_method(:to_json) do"
                      ], () => {
                        this.emitLine("JSON.generate(", this.toDynamic(topLevel, "self"), ")");
                      });
                      this.emitLine(self2);
                    } else {
                      this.emitLine(this.fromDynamic(topLevel, "JSON.parse(json, quirks_mode: true)"));
                    }
                  });
                });
              };
              this.emitModule(() => {
                classDeclaration();
              });
            }, (t) => this.namedTypeToNameForTopLevel(t) === void 0);
          }
        });
      }
    };
    exports.RubyRenderer = RubyRenderer;
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Ruby/language.js
var require_language19 = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Ruby/language.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.RubyTargetLanguage = exports.rubyLanguageConfig = exports.rubyOptions = void 0;
    var RendererOptions_1 = require_RendererOptions();
    var TargetLanguage_1 = require_TargetLanguage();
    var RubyRenderer_1 = require_RubyRenderer();
    var utils_1 = require_utils18();
    exports.rubyOptions = {
      justTypes: new RendererOptions_1.BooleanOption("just-types", "Plain types only", false),
      strictness: new RendererOptions_1.EnumOption("strictness", "Type strictness", {
        strict: utils_1.Strictness.Strict,
        coercible: utils_1.Strictness.Coercible,
        none: utils_1.Strictness.None
      }, "strict"),
      namespace: new RendererOptions_1.StringOption("namespace", "Specify a wrapping Namespace", "NAME", "", "secondary")
    };
    exports.rubyLanguageConfig = {
      displayName: "Ruby",
      names: [
        "ruby"
      ],
      extension: "rb"
    };
    var RubyTargetLanguage = class extends TargetLanguage_1.TargetLanguage {
      constructor() {
        super(exports.rubyLanguageConfig);
      }
      getOptions() {
        return exports.rubyOptions;
      }
      get supportsOptionalClassProperties() {
        return true;
      }
      get defaultIndentation() {
        return "  ";
      }
      makeRenderer(renderContext, untypedOptionValues) {
        return new RubyRenderer_1.RubyRenderer(this, renderContext, (0, RendererOptions_1.getOptionValues)(exports.rubyOptions, untypedOptionValues));
      }
    };
    exports.RubyTargetLanguage = RubyTargetLanguage;
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Ruby/index.js
var require_Ruby = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Ruby/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.RubyRenderer = exports.rubyOptions = exports.RubyTargetLanguage = void 0;
    var language_1 = require_language19();
    Object.defineProperty(exports, "RubyTargetLanguage", {
      enumerable: true,
      get: function() {
        return language_1.RubyTargetLanguage;
      }
    });
    Object.defineProperty(exports, "rubyOptions", {
      enumerable: true,
      get: function() {
        return language_1.rubyOptions;
      }
    });
    var RubyRenderer_1 = require_RubyRenderer();
    Object.defineProperty(exports, "RubyRenderer", {
      enumerable: true,
      get: function() {
        return RubyRenderer_1.RubyRenderer;
      }
    });
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Rust/constants.js
var require_constants16 = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Rust/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.keywords = void 0;
    exports.keywords = [
      "Serialize",
      "Deserialize",
      // Special reserved identifiers used internally for elided lifetimes,
      // unnamed method parameters, crate root module, error recovery etc.
      "{{root}}",
      "$crate",
      // Keywords used in the language.
      "as",
      "async",
      "box",
      "break",
      "const",
      "continue",
      "crate",
      "else",
      "enum",
      "extern",
      "false",
      "fn",
      "for",
      "if",
      "impl",
      "in",
      "let",
      "loop",
      "match",
      "mod",
      "move",
      "mut",
      "pub",
      "ref",
      "return",
      "self",
      "Self",
      "static",
      "struct",
      "super",
      "trait",
      "true",
      "type",
      "unsafe",
      "use",
      "where",
      "while",
      // Keywords reserved for future use.
      "abstract",
      "alignof",
      "become",
      "do",
      "final",
      "macro",
      "offsetof",
      "override",
      "priv",
      "proc",
      "pure",
      "sizeof",
      "typeof",
      "unsized",
      "virtual",
      "yield",
      // Weak keywords, have special meaning only in specific contexts.
      "catch",
      "default",
      "dyn",
      "'static",
      "union",
      // Conflict between `std::Option` and potentially generated Option
      "option"
    ];
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Rust/utils.js
var require_utils19 = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Rust/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.rustStringEscape = exports.camelNamingFunction = exports.snakeNamingFunction = exports.namingStyles = exports.Visibility = exports.Density = void 0;
    exports.getPreferredNamingStyle = getPreferredNamingStyle;
    exports.listMatchingNamingStyles = listMatchingNamingStyles;
    exports.nameWithNamingStyle = nameWithNamingStyle;
    var Naming_1 = require_Naming();
    var Strings_1 = require_Strings();
    var Density;
    (function(Density2) {
      Density2["Normal"] = "Normal";
      Density2["Dense"] = "Dense";
    })(Density || (exports.Density = Density = {}));
    var Visibility;
    (function(Visibility2) {
      Visibility2["Private"] = "Private";
      Visibility2["Crate"] = "Crate";
      Visibility2["Public"] = "Public";
    })(Visibility || (exports.Visibility = Visibility = {}));
    exports.namingStyles = {
      snake_case: {
        regex: /^[a-z][a-z0-9]*(_[a-z0-9]+)*$/,
        toParts: (name) => name.split("_"),
        fromParts: (parts) => parts.map((p) => p.toLowerCase()).join("_")
      },
      SCREAMING_SNAKE_CASE: {
        regex: /^[A-Z][A-Z0-9]*(_[A-Z0-9]+)*$/,
        toParts: (name) => name.split("_"),
        fromParts: (parts) => parts.map((p) => p.toUpperCase()).join("_")
      },
      camelCase: {
        regex: /^[a-z]+([A-Z0-9][a-z]*)*$/,
        toParts: (name) => exports.namingStyles.snake_case.toParts(name.replace(/(.)([A-Z])/g, "$1_$2")),
        fromParts: (parts) => parts.map((p, i2) => i2 === 0 ? p.toLowerCase() : p.substring(0, 1).toUpperCase() + p.substring(1).toLowerCase()).join("")
      },
      PascalCase: {
        regex: /^[A-Z][a-z]*([A-Z0-9][a-z]*)*$/,
        toParts: (name) => exports.namingStyles.snake_case.toParts(name.replace(/(.)([A-Z])/g, "$1_$2")),
        fromParts: (parts) => parts.map((p) => p.substring(0, 1).toUpperCase() + p.substring(1).toLowerCase()).join("")
      },
      "kebab-case": {
        regex: /^[a-z][a-z0-9]*(-[a-z0-9]+)*$/,
        toParts: (name) => name.split("-"),
        fromParts: (parts) => parts.map((p) => p.toLowerCase()).join("-")
      },
      "SCREAMING-KEBAB-CASE": {
        regex: /^[A-Z][A-Z0-9]*(-[A-Z0-9]+)*$/,
        toParts: (name) => name.split("-"),
        fromParts: (parts) => parts.map((p) => p.toUpperCase()).join("-")
      },
      lowercase: {
        regex: /^[a-z][a-z0-9]*$/,
        toParts: (name) => [
          name
        ],
        fromParts: (parts) => parts.map((p) => p.toLowerCase()).join("")
      },
      UPPERCASE: {
        regex: /^[A-Z][A-Z0-9]*$/,
        toParts: (name) => [
          name
        ],
        fromParts: (parts) => parts.map((p) => p.toUpperCase()).join("")
      }
    };
    exports.namingStyles;
    var isAsciiLetterOrUnderscoreOrDigit = (codePoint) => {
      if (!(0, Strings_1.isAscii)(codePoint)) {
        return false;
      }
      return (0, Strings_1.isLetterOrUnderscoreOrDigit)(codePoint);
    };
    var isAsciiLetterOrUnderscore = (codePoint) => {
      if (!(0, Strings_1.isAscii)(codePoint)) {
        return false;
      }
      return (0, Strings_1.isLetterOrUnderscore)(codePoint);
    };
    var legalizeName = (0, Strings_1.legalizeCharacters)(isAsciiLetterOrUnderscoreOrDigit);
    function rustStyle(original, isSnakeCase) {
      const words = (0, Strings_1.splitIntoWords)(original);
      const wordStyle = isSnakeCase ? Strings_1.allLowerWordStyle : Strings_1.firstUpperWordStyle;
      const combined = (0, Strings_1.combineWords)(words, legalizeName, wordStyle, wordStyle, wordStyle, wordStyle, isSnakeCase ? "_" : "", isAsciiLetterOrUnderscore);
      return combined === "_" ? "_underscore" : combined;
    }
    exports.snakeNamingFunction = (0, Naming_1.funPrefixNamer)("default", (original) => rustStyle(original, true));
    exports.camelNamingFunction = (0, Naming_1.funPrefixNamer)("camel", (original) => rustStyle(original, false));
    var standardUnicodeRustEscape = (codePoint) => {
      if (codePoint <= 65535) {
        return "\\u{" + (0, Strings_1.intToHex)(codePoint, 4) + "}";
      } else {
        return "\\u{" + (0, Strings_1.intToHex)(codePoint, 6) + "}";
      }
    };
    exports.rustStringEscape = (0, Strings_1.utf32ConcatMap)((0, Strings_1.escapeNonPrintableMapper)(Strings_1.isPrintable, standardUnicodeRustEscape));
    function getPreferredNamingStyle(namingStyleOccurences, defaultStyle) {
      const occurrences = Object.fromEntries(Object.keys(exports.namingStyles).map((key) => [
        key,
        0
      ]));
      namingStyleOccurences.forEach((style) => ++occurrences[style]);
      const max = Math.max(...Object.values(occurrences));
      const preferedStyles = Object.entries(occurrences).flatMap(([style, num]) => num === max ? [
        style
      ] : []);
      if (preferedStyles.includes(defaultStyle)) {
        return defaultStyle;
      }
      return preferedStyles[0];
    }
    function listMatchingNamingStyles(name) {
      return Object.entries(exports.namingStyles).flatMap(([namingStyleKey, { regex }]) => regex.test(name) ? [
        namingStyleKey
      ] : []);
    }
    function nameWithNamingStyle(name, style) {
      if (exports.namingStyles[style].regex.test(name)) {
        return name;
      }
      const fromStyle = listMatchingNamingStyles(name)[0];
      if (fromStyle === void 0) {
        return name;
      }
      return exports.namingStyles[style].fromParts(exports.namingStyles[fromStyle].toParts(name));
    }
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Rust/RustRenderer.js
var require_RustRenderer = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Rust/RustRenderer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.RustRenderer = void 0;
    var collection_utils_1 = require_dist();
    var Annotation_1 = require_Annotation();
    var ConvenienceRenderer_1 = require_ConvenienceRenderer();
    var Source_1 = require_Source();
    var Support_1 = require_Support();
    var Type_1 = require_Type2();
    var TypeUtils_1 = require_TypeUtils();
    var constants_1 = require_constants16();
    var utils_1 = require_utils19();
    var RustRenderer = class extends ConvenienceRenderer_1.ConvenienceRenderer {
      constructor(targetLanguage, renderContext, _options) {
        super(targetLanguage, renderContext);
        this._options = _options;
      }
      makeNamedTypeNamer() {
        return utils_1.camelNamingFunction;
      }
      namerForObjectProperty() {
        return utils_1.snakeNamingFunction;
      }
      makeUnionMemberNamer() {
        return utils_1.camelNamingFunction;
      }
      makeEnumCaseNamer() {
        return utils_1.camelNamingFunction;
      }
      forbiddenNamesForGlobalNamespace() {
        return constants_1.keywords;
      }
      forbiddenForObjectProperties(_c, _className) {
        return {
          names: [],
          includeGlobalForbidden: true
        };
      }
      forbiddenForUnionMembers(_u, _unionName) {
        return {
          names: [],
          includeGlobalForbidden: true
        };
      }
      forbiddenForEnumCases(_e, _enumName) {
        return {
          names: [],
          includeGlobalForbidden: true
        };
      }
      get commentLineStart() {
        return "/// ";
      }
      nullableRustType(t, withIssues) {
        return [
          "Option<",
          this.breakCycle(t, withIssues),
          ">"
        ];
      }
      isImplicitCycleBreaker(t) {
        const kind = t.kind;
        return kind === "array" || kind === "map";
      }
      rustType(t, withIssues = false) {
        return (0, TypeUtils_1.matchType)(t, (_anyType) => (0, Source_1.maybeAnnotated)(withIssues, Annotation_1.anyTypeIssueAnnotation, "Option<serde_json::Value>"), (_nullType) => (0, Source_1.maybeAnnotated)(withIssues, Annotation_1.nullTypeIssueAnnotation, "Option<serde_json::Value>"), (_boolType) => "bool", (_integerType) => "i64", (_doubleType) => "f64", (_stringType) => "String", (arrayType) => [
          "Vec<",
          this.rustType(arrayType.items, withIssues),
          ">"
        ], (classType) => this.nameForNamedType(classType), (mapType) => [
          "HashMap<String, ",
          this.rustType(mapType.values, withIssues),
          ">"
        ], (enumType) => this.nameForNamedType(enumType), (unionType) => {
          const nullable = (0, TypeUtils_1.nullableFromUnion)(unionType);
          if (nullable !== null) return this.nullableRustType(nullable, withIssues);
          const [hasNull] = (0, TypeUtils_1.removeNullFromUnion)(unionType);
          const isCycleBreaker = this.isCycleBreakerType(unionType);
          const name = isCycleBreaker ? [
            "Box<",
            this.nameForNamedType(unionType),
            ">"
          ] : this.nameForNamedType(unionType);
          return hasNull !== null ? [
            "Option<",
            name,
            ">"
          ] : name;
        });
      }
      breakCycle(t, withIssues) {
        const rustType = this.rustType(t, withIssues);
        const isCycleBreaker = this.isCycleBreakerType(t);
        return isCycleBreaker ? [
          "Box<",
          rustType,
          ">"
        ] : rustType;
      }
      emitRenameAttribute(propName, jsonName, defaultNamingStyle, preferedNamingStyle) {
        const escapedName = (0, utils_1.rustStringEscape)(jsonName);
        const name = utils_1.namingStyles[defaultNamingStyle].fromParts(this.sourcelikeToString(propName).split(" "));
        const styledName = (0, utils_1.nameWithNamingStyle)(name, preferedNamingStyle);
        const namesDiffer = escapedName !== styledName;
        if (namesDiffer) {
          this.emitLine('#[serde(rename = "', escapedName, '")]');
        }
      }
      emitSkipSerializeNone(t) {
        if (t instanceof Type_1.UnionType) {
          const nullable = (0, TypeUtils_1.nullableFromUnion)(t);
          if (nullable !== null) this.emitLine('#[serde(skip_serializing_if = "Option::is_none")]');
        }
      }
      get visibility() {
        if (this._options.visibility === utils_1.Visibility.Crate) {
          return "pub(crate) ";
        }
        if (this._options.visibility === utils_1.Visibility.Public) {
          return "pub ";
        }
        return "";
      }
      emitStructDefinition(c, className) {
        this.emitDescription(this.descriptionForType(c));
        this.emitLine("#[derive(", this._options.deriveDebug ? "Debug, " : "", this._options.deriveClone ? "Clone, " : "", this._options.derivePartialEq ? "PartialEq, " : "", "Serialize, Deserialize)]");
        const propertiesNamingStyles = {};
        this.forEachClassProperty(c, "none", (_name, jsonName, _prop) => {
          propertiesNamingStyles[jsonName] = (0, utils_1.listMatchingNamingStyles)(jsonName);
        });
        const defaultStyle = "snake_case";
        const preferedNamingStyle = (0, utils_1.getPreferredNamingStyle)(Object.values(propertiesNamingStyles).flat(), defaultStyle);
        if (preferedNamingStyle !== defaultStyle) {
          this.emitLine(`#[serde(rename_all = "${preferedNamingStyle}")]`);
        }
        const blankLines = this._options.density === utils_1.Density.Dense ? "none" : "interposing";
        const structBody = () => this.forEachClassProperty(c, blankLines, (name, jsonName, prop) => {
          this.emitDescription(this.descriptionForClassProperty(c, jsonName));
          this.emitRenameAttribute(name, jsonName, defaultStyle, preferedNamingStyle);
          if (this._options.skipSerializingNone) {
            this.emitSkipSerializeNone(prop.type);
          }
          this.emitLine(this.visibility, name, ": ", this.breakCycle(prop.type, true), ",");
        });
        this.emitBlock([
          "pub struct ",
          className
        ], structBody);
      }
      emitBlock(line, f) {
        this.emitLine(line, " {");
        this.indent(f);
        this.emitLine("}");
      }
      emitUnion(u, unionName) {
        const isMaybeWithSingleType = (0, TypeUtils_1.nullableFromUnion)(u);
        if (isMaybeWithSingleType !== null) {
          return;
        }
        this.emitDescription(this.descriptionForType(u));
        this.emitLine("#[derive(", this._options.deriveDebug ? "Debug, " : "", this._options.deriveClone ? "Clone, " : "", this._options.derivePartialEq ? "PartialEq, " : "", "Serialize, Deserialize)]");
        this.emitLine("#[serde(untagged)]");
        const [, nonNulls] = (0, TypeUtils_1.removeNullFromUnion)(u);
        const blankLines = this._options.density === utils_1.Density.Dense ? "none" : "interposing";
        this.emitBlock([
          "pub enum ",
          unionName
        ], () => this.forEachUnionMember(u, nonNulls, blankLines, null, (fieldName, t) => {
          const rustType = this.breakCycle(t, true);
          this.emitLine([
            fieldName,
            "(",
            rustType,
            "),"
          ]);
        }));
      }
      emitEnumDefinition(e, enumName) {
        this.emitDescription(this.descriptionForType(e));
        this.emitLine("#[derive(", this._options.deriveDebug ? "Debug, " : "", this._options.deriveClone ? "Clone, " : "", this._options.derivePartialEq ? "PartialEq, " : "", "Serialize, Deserialize)]");
        const enumCasesNamingStyles = {};
        this.forEachEnumCase(e, "none", (_name, jsonName) => {
          enumCasesNamingStyles[jsonName] = (0, utils_1.listMatchingNamingStyles)(jsonName);
        });
        const defaultStyle = "PascalCase";
        const preferedNamingStyle = (0, utils_1.getPreferredNamingStyle)(Object.values(enumCasesNamingStyles).flat(), defaultStyle);
        if (preferedNamingStyle !== defaultStyle) {
          this.emitLine(`#[serde(rename_all = "${preferedNamingStyle}")]`);
        }
        const blankLines = this._options.density === utils_1.Density.Dense ? "none" : "interposing";
        this.emitBlock([
          "pub enum ",
          enumName
        ], () => this.forEachEnumCase(e, blankLines, (name, jsonName) => {
          this.emitRenameAttribute(name, jsonName, defaultStyle, preferedNamingStyle);
          this.emitLine([
            name,
            ","
          ]);
        }));
      }
      emitTopLevelAlias(t, name) {
        this.emitLine("pub type ", name, " = ", this.rustType(t), ";");
      }
      emitLeadingComments() {
        if (this.leadingComments !== void 0) {
          this.emitComments(this.leadingComments);
          return;
        }
        const topLevelName = (0, Support_1.defined)((0, collection_utils_1.mapFirst)(this.topLevels)).getCombinedName();
        this.emitMultiline(`// Example code that deserializes and serializes the model.
// extern crate serde;
// #[macro_use]
// extern crate serde_derive;
// extern crate serde_json;
//
// use generated_module::${topLevelName};
//
// fn main() {
//     let json = r#"{"answer": 42}"#;
//     let model: ${topLevelName} = serde_json::from_str(&json).unwrap();
// }`);
      }
      emitSourceStructure() {
        if (this._options.leadingComments) {
          this.emitLeadingComments();
        }
        this.ensureBlankLine();
        if (this._options.edition2018) {
          this.emitLine("use serde::{Serialize, Deserialize};");
        } else {
          this.emitLine("extern crate serde_derive;");
        }
        if (this.haveMaps) {
          this.emitLine("use std::collections::HashMap;");
        }
        this.forEachTopLevel("leading", (t, name) => this.emitTopLevelAlias(t, name), (t) => this.namedTypeToNameForTopLevel(t) === void 0);
        this.forEachNamedType("leading-and-interposing", (c, name) => this.emitStructDefinition(c, name), (e, name) => this.emitEnumDefinition(e, name), (u, name) => this.emitUnion(u, name));
      }
    };
    exports.RustRenderer = RustRenderer;
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Rust/language.js
var require_language20 = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Rust/language.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.RustTargetLanguage = exports.rustLanguageConfig = exports.rustOptions = void 0;
    var RendererOptions_1 = require_RendererOptions();
    var TargetLanguage_1 = require_TargetLanguage();
    var RustRenderer_1 = require_RustRenderer();
    var utils_1 = require_utils19();
    exports.rustOptions = {
      density: new RendererOptions_1.EnumOption("density", "Density", {
        normal: utils_1.Density.Normal,
        dense: utils_1.Density.Dense
      }, "normal"),
      visibility: new RendererOptions_1.EnumOption("visibility", "Field visibility", {
        private: utils_1.Visibility.Private,
        crate: utils_1.Visibility.Crate,
        public: utils_1.Visibility.Public
      }, "private"),
      deriveDebug: new RendererOptions_1.BooleanOption("derive-debug", "Derive Debug impl", false),
      deriveClone: new RendererOptions_1.BooleanOption("derive-clone", "Derive Clone impl", false),
      derivePartialEq: new RendererOptions_1.BooleanOption("derive-partial-eq", "Derive PartialEq impl", false),
      skipSerializingNone: new RendererOptions_1.BooleanOption("skip-serializing-none", "Skip serializing empty Option fields", false),
      edition2018: new RendererOptions_1.BooleanOption("edition-2018", "Edition 2018", true),
      leadingComments: new RendererOptions_1.BooleanOption("leading-comments", "Leading Comments", true)
    };
    exports.rustLanguageConfig = {
      displayName: "Rust",
      names: [
        "rust",
        "rs",
        "rustlang"
      ],
      extension: "rs"
    };
    var RustTargetLanguage = class extends TargetLanguage_1.TargetLanguage {
      constructor() {
        super(exports.rustLanguageConfig);
      }
      getOptions() {
        return exports.rustOptions;
      }
      makeRenderer(renderContext, untypedOptionValues) {
        return new RustRenderer_1.RustRenderer(this, renderContext, (0, RendererOptions_1.getOptionValues)(exports.rustOptions, untypedOptionValues));
      }
    };
    exports.RustTargetLanguage = RustTargetLanguage;
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Rust/index.js
var require_Rust = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Rust/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.RustRenderer = exports.rustOptions = exports.RustTargetLanguage = void 0;
    var language_1 = require_language20();
    Object.defineProperty(exports, "RustTargetLanguage", {
      enumerable: true,
      get: function() {
        return language_1.RustTargetLanguage;
      }
    });
    Object.defineProperty(exports, "rustOptions", {
      enumerable: true,
      get: function() {
        return language_1.rustOptions;
      }
    });
    var RustRenderer_1 = require_RustRenderer();
    Object.defineProperty(exports, "RustRenderer", {
      enumerable: true,
      get: function() {
        return RustRenderer_1.RustRenderer;
      }
    });
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Scala3/constants.js
var require_constants17 = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Scala3/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.keywords = exports.invalidSymbols = void 0;
    exports.invalidSymbols = [
      ":",
      "-",
      "+",
      "!",
      "@",
      "#",
      "$",
      "%",
      "^",
      "&",
      "*",
      "(",
      ")",
      ">",
      "<",
      "/",
      ";",
      "'",
      '"',
      "{",
      "}",
      ":",
      "~",
      "`",
      "."
    ];
    exports.keywords = [
      "abstract",
      "case",
      "catch",
      "class",
      "def",
      "do",
      "else",
      "enum",
      "extends",
      "export",
      "false",
      "final",
      "finally",
      "for",
      "forSome",
      "if",
      "implicit",
      "import",
      "lazy",
      "match",
      "new",
      "null",
      "object",
      "override",
      "package",
      "private",
      "protected",
      "return",
      "sealed",
      "super",
      "this",
      "then",
      "throw",
      "trait",
      "try",
      "true",
      "type",
      "val",
      "var",
      "while",
      "with",
      "yield",
      "Any",
      "Boolean",
      "Double",
      "Float",
      "Long",
      "Int",
      "Short",
      "System",
      "Byte",
      "String",
      "Array",
      "List",
      "Map",
      "Enum"
    ];
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Scala3/utils.js
var require_utils20 = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Scala3/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.lowerNamingFunction = exports.upperNamingFunction = exports.wrapOption = exports.shouldAddBacktick = void 0;
    exports.scalaNameStyle = scalaNameStyle;
    var Naming_1 = require_Naming();
    var Strings_1 = require_Strings();
    var constants_1 = require_constants17();
    var shouldAddBacktick = (paramName) => {
      return constants_1.keywords.some((s) => paramName === s) || constants_1.invalidSymbols.some((s) => paramName.includes(s)) || !isNaN(+Number.parseFloat(paramName)) || !isNaN(Number.parseInt(paramName.charAt(0)));
    };
    exports.shouldAddBacktick = shouldAddBacktick;
    var wrapOption = (s, optional) => {
      if (optional) {
        return "Option[" + s + "]";
      } else {
        return s;
      }
    };
    exports.wrapOption = wrapOption;
    function isPartCharacter(codePoint) {
      return (0, Strings_1.isLetterOrUnderscore)(codePoint) || (0, Strings_1.isNumeric)(codePoint);
    }
    function isStartCharacter(codePoint) {
      return isPartCharacter(codePoint) && !(0, Strings_1.isDigit)(codePoint);
    }
    var legalizeName = (0, Strings_1.legalizeCharacters)(isPartCharacter);
    function scalaNameStyle(isUpper, original) {
      const words = (0, Strings_1.splitIntoWords)(original);
      return (0, Strings_1.combineWords)(words, legalizeName, isUpper ? Strings_1.firstUpperWordStyle : Strings_1.allLowerWordStyle, Strings_1.firstUpperWordStyle, isUpper ? Strings_1.allUpperWordStyle : Strings_1.allLowerWordStyle, Strings_1.allUpperWordStyle, "", isStartCharacter);
    }
    exports.upperNamingFunction = (0, Naming_1.funPrefixNamer)("upper", (s) => scalaNameStyle(true, s));
    exports.lowerNamingFunction = (0, Naming_1.funPrefixNamer)("lower", (s) => scalaNameStyle(false, s));
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Scala3/Scala3Renderer.js
var require_Scala3Renderer = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Scala3/Scala3Renderer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Scala3Renderer = void 0;
    var Annotation_1 = require_Annotation();
    var ConvenienceRenderer_1 = require_ConvenienceRenderer();
    var Naming_1 = require_Naming();
    var Source_1 = require_Source();
    var Type_1 = require_Type2();
    var TypeUtils_1 = require_TypeUtils();
    var constants_1 = require_constants17();
    var utils_1 = require_utils20();
    var Scala3Renderer = class extends ConvenienceRenderer_1.ConvenienceRenderer {
      constructor(targetLanguage, renderContext, _scalaOptions) {
        super(targetLanguage, renderContext);
        this._scalaOptions = _scalaOptions;
      }
      forbiddenNamesForGlobalNamespace() {
        return constants_1.keywords;
      }
      forbiddenForObjectProperties(_, _classNamed) {
        return {
          names: [],
          includeGlobalForbidden: true
        };
      }
      forbiddenForEnumCases(_, _enumName) {
        return {
          names: [],
          includeGlobalForbidden: true
        };
      }
      forbiddenForUnionMembers(_u, _unionName) {
        return {
          names: [],
          includeGlobalForbidden: false
        };
      }
      topLevelNameStyle(rawName) {
        return (0, utils_1.scalaNameStyle)(true, rawName);
      }
      makeNamedTypeNamer() {
        return utils_1.upperNamingFunction;
      }
      namerForObjectProperty() {
        return utils_1.lowerNamingFunction;
      }
      makeUnionMemberNamer() {
        return (0, Naming_1.funPrefixNamer)("upper", (s) => `${(0, utils_1.scalaNameStyle)(true, s)}Value`);
      }
      makeEnumCaseNamer() {
        return (0, Naming_1.funPrefixNamer)("upper", (s) => s.replace(" ", ""));
      }
      emitDescriptionBlock(lines) {
        this.emitCommentLines(lines, {
          lineStart: " * ",
          beforeComment: "/**",
          afterComment: " */"
        });
      }
      emitBlock(line, f, delimiter = "curly") {
        const [open, close] = delimiter === "curly" ? [
          "{",
          "}"
        ] : delimiter === "paren" ? [
          "(",
          ")"
        ] : delimiter === "none" ? [
          "",
          ""
        ] : [
          "{",
          "})"
        ];
        this.emitLine(line, " ", open);
        this.indent(f);
        this.emitLine(close);
      }
      anySourceType(optional) {
        return [
          (0, utils_1.wrapOption)("Any", optional)
        ];
      }
      // (asarazan): I've broken out the following two functions
      // because some renderers, such as kotlinx, can cope with `any`, while some get mad.
      arrayType(arrayType, withIssues = false) {
        return [
          "Seq[",
          this.scalaType(arrayType.items, withIssues),
          "]"
        ];
      }
      mapType(mapType, withIssues = false) {
        return [
          "Map[String, ",
          this.scalaType(mapType.values, withIssues),
          "]"
        ];
      }
      scalaType(t, withIssues = false, noOptional = false) {
        return (0, TypeUtils_1.matchType)(t, (_anyType) => {
          return (0, Source_1.maybeAnnotated)(withIssues, Annotation_1.anyTypeIssueAnnotation, this.anySourceType(!noOptional));
        }, (_nullType) => {
          return (0, Source_1.maybeAnnotated)(withIssues, Annotation_1.nullTypeIssueAnnotation, this.anySourceType(!noOptional));
        }, (_boolType) => "Boolean", (_integerType) => "Long", (_doubleType) => "Double", (_stringType) => "String", (arrayType) => this.arrayType(arrayType, withIssues), (classType) => this.nameForNamedType(classType), (mapType) => this.mapType(mapType, withIssues), (enumType) => this.nameForNamedType(enumType), (unionType) => {
          const nullable = (0, TypeUtils_1.nullableFromUnion)(unionType);
          if (nullable !== null) {
            if (noOptional) {
              return [
                this.scalaType(nullable, withIssues)
              ];
            }
            return [
              "Option[",
              this.scalaType(nullable, withIssues),
              "]"
            ];
          }
          return this.nameForNamedType(unionType);
        });
      }
      emitUsageHeader() {
      }
      emitHeader() {
        if (this.leadingComments !== void 0) {
          this.emitComments(this.leadingComments);
        } else {
          this.emitUsageHeader();
        }
        this.ensureBlankLine();
        this.emitLine("package ", this._scalaOptions.packageName);
        this.ensureBlankLine();
      }
      emitTopLevelArray(t, name) {
        const elementType = this.scalaType(t.items);
        this.emitLine([
          "type ",
          name,
          " = List[",
          elementType,
          "]"
        ]);
      }
      emitTopLevelMap(t, name) {
        const elementType = this.scalaType(t.values);
        this.emitLine([
          "type ",
          name,
          " = Map[String, ",
          elementType,
          "]"
        ]);
      }
      emitEmptyClassDefinition(c, className) {
        this.emitDescription(this.descriptionForType(c));
        this.emitLine("case class ", className, "()");
      }
      emitClassDefinition(c, className) {
        if (c.getProperties().size === 0) {
          this.emitEmptyClassDefinition(c, className);
          return;
        }
        const scalaType = (p) => {
          if (p.isOptional) {
            return [
              "Option[",
              this.scalaType(p.type, true, true),
              "]"
            ];
          }
          return this.scalaType(p.type, true);
        };
        this.emitDescription(this.descriptionForType(c));
        this.emitLine("case class ", className, " (");
        this.indent(() => {
          let count = c.getProperties().size;
          let first = true;
          this.forEachClassProperty(c, "none", (_, jsonName, p) => {
            const nullable = p.type.kind === "union" && (0, TypeUtils_1.nullableFromUnion)(p.type) !== null;
            const nullableOrOptional = p.isOptional || p.type.kind === "null" || nullable;
            const last = --count === 0;
            const meta = [];
            const description = this.descriptionForClassProperty(c, jsonName);
            if (description !== void 0) {
              meta.push(() => this.emitDescription(description));
            }
            if (meta.length > 0 && !first) {
              this.ensureBlankLine();
            }
            for (const emit of meta) {
              emit();
            }
            const nameNeedsBackticks = jsonName.endsWith("_") || (0, utils_1.shouldAddBacktick)(jsonName);
            const nameWithBackticks = nameNeedsBackticks ? "`" + jsonName + "`" : jsonName;
            this.emitLine("val ", nameWithBackticks, " : ", scalaType(p), p.isOptional ? " = None" : nullableOrOptional ? " = None" : "", last ? "" : ",");
            if (meta.length > 0 && !last) {
              this.ensureBlankLine();
            }
            first = false;
          });
        });
        this.emitClassDefinitionMethods();
      }
      emitClassDefinitionMethods() {
        this.emitLine(")");
      }
      emitEnumDefinition(e, enumName) {
        this.emitDescription(this.descriptionForType(e));
        this.emitBlock([
          "enum ",
          enumName,
          " : "
        ], () => {
          let count = e.cases.size;
          if (count > 0) {
            this.emitItem("	 case ");
          }
          this.forEachEnumCase(e, "none", (name, jsonName) => {
            if (!(jsonName === "")) {
              const backticks = (0, utils_1.shouldAddBacktick)(jsonName) || jsonName.includes(" ") || !Number.isNaN(Number.parseInt(jsonName.charAt(0)));
              if (backticks) {
                this.emitItem("`");
              }
              this.emitItemOnce([
                name
              ]);
              if (backticks) {
                this.emitItem("`");
              }
              if (--count > 0) this.emitItem([
                ","
              ]);
            } else {
              --count;
            }
          });
        }, "none");
      }
      emitUnionDefinition(u, unionName) {
        function sortBy(t) {
          const kind = t.kind;
          if (kind === "class") return kind;
          return `_${kind}`;
        }
        this.emitDescription(this.descriptionForType(u));
        const [maybeNull, nonNulls] = (0, TypeUtils_1.removeNullFromUnion)(u, sortBy);
        const theTypes = [];
        this.forEachUnionMember(u, nonNulls, "none", null, (_, t) => {
          theTypes.push(this.scalaType(t));
        });
        if (maybeNull !== null) {
          theTypes.push(this.nameForUnionMember(u, maybeNull));
        }
        this.emitItem([
          "type ",
          unionName,
          " = "
        ]);
        theTypes.forEach((t, i2) => {
          this.emitItem(i2 === 0 ? t : [
            " | ",
            t
          ]);
        });
        this.ensureBlankLine();
      }
      emitSourceStructure() {
        this.emitHeader();
        this.forEachTopLevel("leading", (t, name) => {
          if (t instanceof Type_1.ArrayType) {
            this.emitTopLevelArray(t, name);
          } else if (t instanceof Type_1.MapType) {
            this.emitTopLevelMap(t, name);
          }
        });
        this.forEachNamedType("leading-and-interposing", (c, n) => this.emitClassDefinition(c, n), (e, n) => this.emitEnumDefinition(e, n), (u, n) => this.emitUnionDefinition(u, n));
      }
    };
    exports.Scala3Renderer = Scala3Renderer;
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Scala3/CirceRenderer.js
var require_CirceRenderer = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Scala3/CirceRenderer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.CirceRenderer = void 0;
    var TypeUtils_1 = require_TypeUtils();
    var Scala3Renderer_1 = require_Scala3Renderer();
    var utils_1 = require_utils20();
    var CirceRenderer = class extends Scala3Renderer_1.Scala3Renderer {
      constructor() {
        super(...arguments);
        this.seenUnionTypes = [];
      }
      circeEncoderForType(t, __ = false, noOptional = false, paramName = "") {
        return (0, TypeUtils_1.matchType)(t, (_anyType) => [
          "Encoder.encodeJson(",
          paramName,
          ")"
        ], (_nullType) => [
          "Encoder.encodeNone(",
          paramName,
          ")"
        ], (_boolType) => [
          "Encoder.encodeBoolean(",
          paramName,
          ")"
        ], (_integerType) => [
          "Encoder.encodeLong(",
          paramName,
          ")"
        ], (_doubleType) => [
          "Encoder.encodeDouble(",
          paramName,
          ")"
        ], (_stringType) => [
          "Encoder.encodeString(",
          paramName,
          ")"
        ], (arrayType) => [
          "Encoder.encodeSeq[",
          this.scalaType(arrayType.items),
          "].apply(",
          paramName,
          ")"
        ], (classType) => [
          "Encoder.AsObject[",
          this.scalaType(classType),
          "].apply(",
          paramName,
          ")"
        ], (mapType) => [
          "Encoder.encodeMap[String,",
          this.scalaType(mapType.values),
          "].apply(",
          paramName,
          ")"
        ], (_) => [
          "Encoder.encodeString(",
          paramName,
          ")"
        ], (unionType) => {
          const nullable = (0, TypeUtils_1.nullableFromUnion)(unionType);
          if (nullable !== null) {
            if (noOptional) {
              return [
                "Encoder.AsObject[",
                this.nameForNamedType(nullable),
                "]"
              ];
            }
            return [
              "Encoder.AsObject[Option[",
              this.nameForNamedType(nullable),
              "]]"
            ];
          }
          return [
            "Encoder.AsObject[",
            this.nameForNamedType(unionType),
            "]"
          ];
        });
      }
      emitEmptyClassDefinition(c, className) {
        this.emitDescription(this.descriptionForType(c));
        this.ensureBlankLine();
        this.emitLine("case class ", className, "()  derives Encoder.AsObject, Decoder");
      }
      anySourceType(optional) {
        return [
          (0, utils_1.wrapOption)("Json", optional)
        ];
      }
      emitClassDefinitionMethods() {
        this.emitLine(") derives Encoder.AsObject, Decoder");
      }
      emitEnumDefinition(e, enumName) {
        this.emitDescription(this.descriptionForType(e));
        this.ensureBlankLine();
        this.emitItem([
          "type ",
          enumName,
          " = "
        ]);
        let count = e.cases.size;
        this.forEachEnumCase(e, "none", (_, jsonName) => {
          this.emitItem([
            '"',
            jsonName,
            '"'
          ]);
          if (--count > 0) this.emitItem([
            " | "
          ]);
        });
        this.ensureBlankLine();
      }
      emitHeader() {
        super.emitHeader();
        this.emitLine("import scala.util.Try");
        this.emitLine("import io.circe.syntax._");
        this.emitLine("import io.circe._");
        this.emitLine("import cats.syntax.functor._");
        this.ensureBlankLine();
        this.emitLine("// For serialising string unions");
        this.emitLine("given [A <: Singleton](using A <:< String): Decoder[A] = Decoder.decodeString.emapTry(x => Try(x.asInstanceOf[A])) ");
        this.emitLine("given [A <: Singleton](using ev: A <:< String): Encoder[A] = Encoder.encodeString.contramap(ev) ");
        this.ensureBlankLine();
        this.emitLine("// If a union has a null in, then we'll need this too... ");
        this.emitLine("type NullValue = None.type");
      }
      emitTopLevelArray(t, name) {
        super.emitTopLevelArray(t, name);
        const elementType = this.scalaType(t.items);
        this.emitLine([
          "given (using ev : ",
          elementType,
          "): Encoder[Map[String,",
          elementType,
          "]] = Encoder.encodeMap[String, ",
          elementType,
          "]"
        ]);
      }
      emitTopLevelMap(t, name) {
        super.emitTopLevelMap(t, name);
        const elementType = this.scalaType(t.values);
        this.ensureBlankLine();
        this.emitLine([
          "given (using ev : ",
          elementType,
          "): Encoder[Map[String, ",
          elementType,
          "]] = Encoder.encodeMap[String, ",
          elementType,
          "]"
        ]);
      }
      emitUnionDefinition(u, unionName) {
        function sortBy(t) {
          const kind = t.kind;
          if (kind === "class") return kind;
          return "_" + kind;
        }
        this.emitDescription(this.descriptionForType(u));
        const [maybeNull, nonNulls] = (0, TypeUtils_1.removeNullFromUnion)(u, sortBy);
        const theTypes = [];
        this.forEachUnionMember(u, nonNulls, "none", null, (_, t) => {
          theTypes.push(this.scalaType(t));
        });
        if (maybeNull !== null) {
          theTypes.push(this.nameForUnionMember(u, maybeNull));
        }
        this.emitItem([
          "type ",
          unionName,
          " = "
        ]);
        theTypes.forEach((t, i2) => {
          this.emitItem(i2 === 0 ? t : [
            " | ",
            t
          ]);
        });
        const thisUnionType = theTypes.map((x) => this.sourcelikeToString(x)).join(" | ");
        this.ensureBlankLine();
        if (!this.seenUnionTypes.some((y) => y === thisUnionType)) {
          this.seenUnionTypes.push(thisUnionType);
          const sourceLikeTypes = [];
          this.forEachUnionMember(u, nonNulls, "none", null, (_, t) => {
            sourceLikeTypes.push([
              this.scalaType(t),
              t
            ]);
          });
          if (maybeNull !== null) {
            sourceLikeTypes.push([
              this.nameForUnionMember(u, maybeNull),
              maybeNull
            ]);
          }
          this.emitLine([
            "given Decoder[",
            unionName,
            "] = {"
          ]);
          this.indent(() => {
            this.emitLine([
              "List[Decoder[",
              unionName,
              "]]("
            ]);
            this.indent(() => {
              sourceLikeTypes.forEach((t) => {
                this.emitLine([
                  "Decoder[",
                  t[0],
                  "].widen,"
                ]);
              });
            });
            this.emitLine(").reduceLeft(_ or _)");
          });
          this.emitLine([
            "}"
          ]);
          this.ensureBlankLine();
          this.emitLine([
            "given Encoder[",
            unionName,
            "] = Encoder.instance {"
          ]);
          this.indent(() => {
            sourceLikeTypes.forEach((t, i2) => {
              const paramTemp = `enc${i2.toString()}`;
              this.emitLine([
                "case ",
                paramTemp,
                " : ",
                t[0],
                " => ",
                this.circeEncoderForType(t[1], false, false, paramTemp)
              ]);
            });
          });
          this.emitLine("}");
        }
      }
    };
    exports.CirceRenderer = CirceRenderer;
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Scala3/UpickleRenderer.js
var require_UpickleRenderer = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Scala3/UpickleRenderer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.UpickleRenderer = void 0;
    var Scala3Renderer_1 = require_Scala3Renderer();
    var UpickleRenderer = class extends Scala3Renderer_1.Scala3Renderer {
      emitClassDefinitionMethods() {
        this.emitLine(") derives ReadWriter ");
      }
      emitHeader() {
        super.emitHeader();
        this.emitLine("import upickle.default.*");
        this.ensureBlankLine();
      }
    };
    exports.UpickleRenderer = UpickleRenderer;
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Scala3/language.js
var require_language21 = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Scala3/language.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Scala3TargetLanguage = exports.scala3LanguageConfig = exports.scala3Options = void 0;
    var RendererOptions_1 = require_RendererOptions();
    var Support_1 = require_Support();
    var TargetLanguage_1 = require_TargetLanguage();
    var CirceRenderer_1 = require_CirceRenderer();
    var Scala3Renderer_1 = require_Scala3Renderer();
    var UpickleRenderer_1 = require_UpickleRenderer();
    exports.scala3Options = {
      framework: new RendererOptions_1.EnumOption("framework", "Serialization framework", {
        "just-types": "None",
        circe: "Circe",
        upickle: "Upickle"
      }, "just-types"),
      packageName: new RendererOptions_1.StringOption("package", "Package", "PACKAGE", "quicktype")
    };
    exports.scala3LanguageConfig = {
      displayName: "Scala3",
      names: [
        "scala3"
      ],
      extension: "scala"
    };
    var Scala3TargetLanguage = class extends TargetLanguage_1.TargetLanguage {
      constructor() {
        super(exports.scala3LanguageConfig);
      }
      getOptions() {
        return exports.scala3Options;
      }
      get supportsOptionalClassProperties() {
        return true;
      }
      get supportsUnionsWithBothNumberTypes() {
        return true;
      }
      makeRenderer(renderContext, untypedOptionValues) {
        const options = (0, RendererOptions_1.getOptionValues)(exports.scala3Options, untypedOptionValues);
        switch (options.framework) {
          case "None":
            return new Scala3Renderer_1.Scala3Renderer(this, renderContext, options);
          case "Upickle":
            return new UpickleRenderer_1.UpickleRenderer(this, renderContext, options);
          case "Circe":
            return new CirceRenderer_1.CirceRenderer(this, renderContext, options);
          default:
            return (0, Support_1.assertNever)(options.framework);
        }
      }
    };
    exports.Scala3TargetLanguage = Scala3TargetLanguage;
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Scala3/index.js
var require_Scala3 = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Scala3/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.UpickleRenderer = exports.CirceRenderer = exports.Scala3Renderer = exports.scala3Options = exports.Scala3TargetLanguage = void 0;
    var language_1 = require_language21();
    Object.defineProperty(exports, "Scala3TargetLanguage", {
      enumerable: true,
      get: function() {
        return language_1.Scala3TargetLanguage;
      }
    });
    Object.defineProperty(exports, "scala3Options", {
      enumerable: true,
      get: function() {
        return language_1.scala3Options;
      }
    });
    var Scala3Renderer_1 = require_Scala3Renderer();
    Object.defineProperty(exports, "Scala3Renderer", {
      enumerable: true,
      get: function() {
        return Scala3Renderer_1.Scala3Renderer;
      }
    });
    var CirceRenderer_1 = require_CirceRenderer();
    Object.defineProperty(exports, "CirceRenderer", {
      enumerable: true,
      get: function() {
        return CirceRenderer_1.CirceRenderer;
      }
    });
    var UpickleRenderer_1 = require_UpickleRenderer();
    Object.defineProperty(exports, "UpickleRenderer", {
      enumerable: true,
      get: function() {
        return UpickleRenderer_1.UpickleRenderer;
      }
    });
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Smithy4s/constants.js
var require_constants18 = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Smithy4s/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.keywords = exports.invalidSymbols = void 0;
    exports.invalidSymbols = [
      ":",
      "-",
      "+",
      "!",
      "@",
      "#",
      "%",
      "^",
      "&",
      "*",
      "(",
      ")",
      ">",
      "<",
      "/",
      ";",
      "'",
      '"',
      "{",
      "}",
      ":",
      "~",
      "`",
      "."
    ];
    exports.keywords = [
      "abstract",
      "case",
      "catch",
      "do",
      "else",
      "export",
      "false",
      "final",
      "finally",
      "for",
      "forSome",
      "if",
      "implicit",
      "import",
      "new",
      "override",
      "package",
      "private",
      "protected",
      "return",
      "sealed",
      "super",
      "this",
      "then",
      "throw",
      "trait",
      "try",
      "true",
      "val",
      "var",
      "while",
      "with",
      "yield",
      "Any",
      "Boolean",
      "Double",
      "Float",
      "Long",
      "Int",
      "Short",
      "System",
      "Byte",
      "String",
      "Array",
      "List",
      "Map",
      "Enum"
    ];
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Smithy4s/utils.js
var require_utils21 = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Smithy4s/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.lowerNamingFunction = exports.upperNamingFunction = exports.shouldAddBacktick = void 0;
    exports.scalaNameStyle = scalaNameStyle;
    var unicode_properties_1 = require_main();
    var Naming_1 = require_Naming();
    var Strings_1 = require_Strings();
    var constants_1 = require_constants18();
    var shouldAddBacktick = (paramName) => {
      return constants_1.keywords.some((s) => paramName === s) || constants_1.invalidSymbols.some((s) => paramName.includes(s)) || !isNaN(Number.parseFloat(paramName)) || !isNaN(Number.parseInt(paramName.charAt(0)));
    };
    exports.shouldAddBacktick = shouldAddBacktick;
    function isPartCharacter(codePoint) {
      return (0, Strings_1.isLetterOrUnderscore)(codePoint) || (0, Strings_1.isNumeric)(codePoint);
    }
    function isStartCharacter(codePoint) {
      return isPartCharacter(codePoint) && !(0, unicode_properties_1.isDigit)(codePoint);
    }
    var legalizeName = (0, Strings_1.legalizeCharacters)(isPartCharacter);
    function scalaNameStyle(isUpper, original) {
      const words = (0, Strings_1.splitIntoWords)(original);
      return (0, Strings_1.combineWords)(words, legalizeName, isUpper ? Strings_1.firstUpperWordStyle : Strings_1.allLowerWordStyle, Strings_1.firstUpperWordStyle, isUpper ? Strings_1.allUpperWordStyle : Strings_1.allLowerWordStyle, Strings_1.allUpperWordStyle, "", isStartCharacter);
    }
    exports.upperNamingFunction = (0, Naming_1.funPrefixNamer)("upper", (s) => scalaNameStyle(true, s));
    exports.lowerNamingFunction = (0, Naming_1.funPrefixNamer)("lower", (s) => scalaNameStyle(false, s));
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Smithy4s/Smithy4sRenderer.js
var require_Smithy4sRenderer = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Smithy4s/Smithy4sRenderer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Smithy4sRenderer = void 0;
    var Annotation_1 = require_Annotation();
    var ConvenienceRenderer_1 = require_ConvenienceRenderer();
    var Naming_1 = require_Naming();
    var Source_1 = require_Source();
    var Type_1 = require_Type2();
    var TypeUtils_1 = require_TypeUtils();
    var constants_1 = require_constants18();
    var utils_1 = require_utils21();
    var Smithy4sRenderer = class extends ConvenienceRenderer_1.ConvenienceRenderer {
      constructor(targetLanguage, renderContext, _scalaOptions) {
        super(targetLanguage, renderContext);
        this._scalaOptions = _scalaOptions;
      }
      forbiddenNamesForGlobalNamespace() {
        return constants_1.keywords;
      }
      forbiddenForObjectProperties(_, _classNamed) {
        return {
          names: [],
          includeGlobalForbidden: true
        };
      }
      forbiddenForEnumCases(_, _enumName) {
        return {
          names: [],
          includeGlobalForbidden: true
        };
      }
      forbiddenForUnionMembers(_u, _unionName) {
        return {
          names: [],
          includeGlobalForbidden: false
        };
      }
      topLevelNameStyle(rawName) {
        return (0, utils_1.scalaNameStyle)(true, rawName);
      }
      makeNamedTypeNamer() {
        return utils_1.upperNamingFunction;
      }
      namerForObjectProperty() {
        return utils_1.lowerNamingFunction;
      }
      makeUnionMemberNamer() {
        return (0, Naming_1.funPrefixNamer)("upper", (s) => `${(0, utils_1.scalaNameStyle)(true, s)}Value`);
      }
      makeEnumCaseNamer() {
        return (0, Naming_1.funPrefixNamer)("upper", (s) => s.replace(" ", ""));
      }
      emitDescriptionBlock(lines) {
        this.emitCommentLines(lines, {
          lineStart: " * ",
          beforeComment: "/**",
          afterComment: " */"
        });
      }
      emitBlock(line, f, delimiter = "curly") {
        const [open, close] = delimiter === "curly" ? [
          "{",
          "}"
        ] : delimiter === "paren" ? [
          "(",
          ")"
        ] : delimiter === "none" ? [
          "",
          ""
        ] : [
          "{",
          "})"
        ];
        this.emitLine(line, " ", open);
        this.indent(f);
        this.emitLine(close);
      }
      anySourceType(_) {
        return [
          "Document"
        ];
      }
      // (asarazan): I've broken out the following two functions
      // because some renderers, such as kotlinx, can cope with `any`, while some get mad.
      arrayType(arrayType, _ = false) {
        return arrayType.getCombinedName().toString() + "List";
      }
      emitArrayType(_, smithyType) {
        this.emitLine([
          "list ",
          smithyType,
          " { member : ",
          "}"
        ]);
      }
      mapType(mapType, _ = false) {
        return mapType.getCombinedName().toString() + "Map";
      }
      scalaType(t, withIssues = false, noOptional = false) {
        return (0, TypeUtils_1.matchType)(t, (_anyType) => {
          return (0, Source_1.maybeAnnotated)(withIssues, Annotation_1.anyTypeIssueAnnotation, this.anySourceType(!noOptional));
        }, (_nullType) => {
          return (0, Source_1.maybeAnnotated)(withIssues, Annotation_1.nullTypeIssueAnnotation, this.anySourceType(!noOptional));
        }, (_boolType) => "Boolean", (_integerType) => "Long", (_doubleType) => "Double", (_stringType) => "String", (arrayType) => this.arrayType(arrayType, withIssues), (classType) => this.nameForNamedType(classType), (mapType) => this.mapType(mapType, withIssues), (enumType) => this.nameForNamedType(enumType), (unionType) => {
          const nullable = (0, TypeUtils_1.nullableFromUnion)(unionType);
          if (nullable !== null) {
            return [
              this.scalaType(nullable, withIssues)
            ];
          }
          return this.nameForNamedType(unionType);
        });
      }
      emitUsageHeader() {
      }
      emitHeader() {
        if (this.leadingComments !== void 0) {
          this.emitComments(this.leadingComments);
        } else {
          this.emitUsageHeader();
        }
        this.ensureBlankLine();
        this.emitLine('$version: "2"');
        this.emitLine("namespace ", this._scalaOptions.packageName);
        this.ensureBlankLine();
        this.emitLine("document NullValue");
        this.ensureBlankLine();
      }
      emitTopLevelArray(t, name) {
        const elementType = this.scalaType(t.items);
        this.emitLine([
          "list ",
          name,
          " { member : ",
          elementType,
          "}"
        ]);
      }
      emitTopLevelMap(t, name) {
        const elementType = this.scalaType(t.values);
        this.emitLine([
          "map ",
          name,
          " { map[ key : String , value : ",
          elementType,
          "}"
        ]);
      }
      emitEmptyClassDefinition(c, className) {
        this.emitDescription(this.descriptionForType(c));
        this.emitLine("structure ", className, "{}");
      }
      emitClassDefinition(c, className) {
        if (c.getProperties().size === 0) {
          this.emitEmptyClassDefinition(c, className);
          return;
        }
        const scalaType = (p) => {
          if (p.isOptional) {
            return [
              this.scalaType(p.type, true, true)
            ];
          }
          return [
            this.scalaType(p.type, true)
          ];
        };
        const emitLater = [];
        this.emitDescription(this.descriptionForType(c));
        this.emitLine("structure ", className, " {");
        this.indent(() => {
          let count = c.getProperties().size;
          let first = true;
          this.forEachClassProperty(c, "none", (_, jsonName, p) => {
            const nullable = p.type.kind === "union" && (0, TypeUtils_1.nullableFromUnion)(p.type) !== null;
            const nullableOrOptional = p.isOptional || p.type.kind === "null" || nullable;
            const last = --count === 0;
            const meta = [];
            const laterType = p.type.kind === "array" || p.type.kind === "map";
            if (laterType) {
              emitLater.push(p);
            }
            const description = this.descriptionForClassProperty(c, jsonName);
            if (description !== void 0) {
              meta.push(() => this.emitDescription(description));
            }
            if (meta.length > 0 && !first) {
              this.ensureBlankLine();
            }
            for (const emit of meta) {
              emit();
            }
            const nameNeedsBackticks = jsonName.endsWith("_") || (0, utils_1.shouldAddBacktick)(jsonName);
            const nameWithBackticks = nameNeedsBackticks ? "`" + jsonName + "`" : jsonName;
            this.emitLine(p.isOptional ? "" : nullableOrOptional ? "" : "@required ", nameWithBackticks, " : ", scalaType(p), last ? "" : ",");
            if (meta.length > 0 && !last) {
              this.ensureBlankLine();
            }
            first = false;
          });
        });
        this.emitClassDefinitionMethods(emitLater);
      }
      emitClassDefinitionMethods(arrayTypes) {
        this.emitLine("}");
        arrayTypes.forEach((p) => {
          function ignore(_) {
            return;
          }
          (0, TypeUtils_1.matchCompoundType)(p.type, (at) => {
            this.emitLine([
              "list ",
              this.scalaType(at, true),
              "{ member: ",
              this.scalaType(at.items, true),
              "}"
            ]);
          }, ignore, (mt) => {
            this.emitLine([
              "map ",
              this.scalaType(mt, true),
              "{ key: String , value: ",
              this.scalaType(mt.values, true),
              "}"
            ]);
          }, ignore, ignore);
        });
      }
      emitEnumDefinition(e, enumName) {
        this.emitDescription(this.descriptionForType(e));
        this.ensureBlankLine();
        this.emitItem([
          "enum ",
          enumName,
          " { "
        ]);
        let count = e.cases.size;
        this.forEachEnumCase(e, "none", (name, jsonName) => {
          this.emitLine();
          this.emitItem([
            name,
            ' = "',
            jsonName,
            '"'
          ]);
          if (--count > 0) this.emitItem([
            ","
          ]);
        });
        this.ensureBlankLine();
        this.emitItem([
          "}"
        ]);
      }
      emitUnionDefinition(u, unionName) {
        function sortBy(t) {
          const kind = t.kind;
          if (kind === "class") return kind;
          return `_${kind}`;
        }
        const emitLater = [];
        this.emitDescription(this.descriptionForType(u));
        const [maybeNull, nonNulls] = (0, TypeUtils_1.removeNullFromUnion)(u, sortBy);
        const theTypes = [];
        this.forEachUnionMember(u, nonNulls, "none", null, (_, t) => {
          const laterType = t.kind === "array" || t.kind === "map";
          if (laterType) {
            emitLater.push(t);
          }
          theTypes.push(this.scalaType(t));
        });
        if (maybeNull !== null) {
          theTypes.push(this.nameForUnionMember(u, maybeNull));
        }
        this.emitLine([
          "@untagged union ",
          unionName,
          " { "
        ]);
        this.indent(() => {
          theTypes.forEach((t, i2) => {
            this.emitLine([
              String.fromCharCode(i2 + 65),
              " : ",
              t
            ]);
          });
        });
        this.emitLine("}");
        this.ensureBlankLine();
        emitLater.forEach((p) => {
          function ignore(_) {
            return;
          }
          (0, TypeUtils_1.matchCompoundType)(p, (at) => {
            this.emitLine([
              "list ",
              this.scalaType(at, true),
              "{ member: ",
              this.scalaType(at.items, true),
              "}"
            ]);
          }, ignore, (mt) => {
            this.emitLine([
              "map ",
              this.scalaType(mt, true),
              "{ key: String , value: ",
              this.scalaType(mt.values, true),
              "}"
            ]);
          }, ignore, ignore);
        });
      }
      emitSourceStructure() {
        this.emitHeader();
        this.forEachTopLevel("leading", (t, name) => {
          if (t instanceof Type_1.ArrayType) {
            this.emitTopLevelArray(t, name);
          } else if (t instanceof Type_1.MapType) {
            this.emitTopLevelMap(t, name);
          }
        });
        this.forEachNamedType("leading-and-interposing", (c, n) => this.emitClassDefinition(c, n), (e, n) => this.emitEnumDefinition(e, n), (u, n) => this.emitUnionDefinition(u, n));
      }
    };
    exports.Smithy4sRenderer = Smithy4sRenderer;
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Smithy4s/language.js
var require_language22 = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Smithy4s/language.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.SmithyTargetLanguage = exports.smithyLanguageConfig = exports.smithyOptions = exports.Framework = void 0;
    var RendererOptions_1 = require_RendererOptions();
    var Support_1 = require_Support();
    var TargetLanguage_1 = require_TargetLanguage();
    var Smithy4sRenderer_1 = require_Smithy4sRenderer();
    var Framework;
    (function(Framework2) {
      Framework2["None"] = "None";
    })(Framework || (exports.Framework = Framework = {}));
    exports.smithyOptions = {
      // FIXME: why does this exist
      framework: new RendererOptions_1.EnumOption("framework", "Serialization framework", {
        "just-types": Framework.None
      }, "just-types"),
      packageName: new RendererOptions_1.StringOption("package", "Package", "PACKAGE", "quicktype")
    };
    exports.smithyLanguageConfig = {
      displayName: "Smithy",
      names: [
        "smithy4a"
      ],
      extension: "smithy"
    };
    var SmithyTargetLanguage = class extends TargetLanguage_1.TargetLanguage {
      constructor() {
        super(exports.smithyLanguageConfig);
      }
      getOptions() {
        return exports.smithyOptions;
      }
      get supportsOptionalClassProperties() {
        return true;
      }
      get supportsUnionsWithBothNumberTypes() {
        return true;
      }
      makeRenderer(renderContext, untypedOptionValues) {
        const options = (0, RendererOptions_1.getOptionValues)(exports.smithyOptions, untypedOptionValues);
        switch (options.framework) {
          case Framework.None:
            return new Smithy4sRenderer_1.Smithy4sRenderer(this, renderContext, options);
          default:
            return (0, Support_1.assertNever)(options.framework);
        }
      }
    };
    exports.SmithyTargetLanguage = SmithyTargetLanguage;
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Smithy4s/index.js
var require_Smithy4s = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Smithy4s/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Smithy4sRenderer = exports.smithyOptions = exports.SmithyTargetLanguage = void 0;
    var language_1 = require_language22();
    Object.defineProperty(exports, "SmithyTargetLanguage", {
      enumerable: true,
      get: function() {
        return language_1.SmithyTargetLanguage;
      }
    });
    Object.defineProperty(exports, "smithyOptions", {
      enumerable: true,
      get: function() {
        return language_1.smithyOptions;
      }
    });
    var Smithy4sRenderer_1 = require_Smithy4sRenderer();
    Object.defineProperty(exports, "Smithy4sRenderer", {
      enumerable: true,
      get: function() {
        return Smithy4sRenderer_1.Smithy4sRenderer;
      }
    });
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Swift/constants.js
var require_constants19 = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Swift/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.keywords = void 0;
    exports.keywords = [
      "await",
      "associatedtype",
      "class",
      "deinit",
      "enum",
      "extension",
      "fileprivate",
      "func",
      "import",
      "init",
      "inout",
      "internal",
      "let",
      "open",
      "operator",
      "private",
      "protocol",
      "public",
      "static",
      "struct",
      "subscript",
      "typealias",
      "var",
      "break",
      "case",
      "continue",
      "default",
      "defer",
      "do",
      "else",
      "fallthrough",
      "for",
      "guard",
      "if",
      "in",
      "repeat",
      "return",
      "switch",
      "where",
      "while",
      "as",
      "Any",
      "catch",
      "false",
      "is",
      "nil",
      "rethrows",
      "super",
      "self",
      "Self",
      "throw",
      "throws",
      "true",
      "try",
      "_",
      "associativity",
      "convenience",
      "dynamic",
      "didSet",
      "final",
      "get",
      "infix",
      "indirect",
      "lazy",
      "left",
      "mutating",
      "nonmutating",
      "optional",
      "override",
      "postfix",
      "precedence",
      "prefix",
      "Protocol",
      "required",
      "right",
      "set",
      "Type",
      "unowned",
      "weak",
      "willSet",
      "String",
      "Int",
      "Double",
      "Bool",
      "Data",
      "Date",
      "URL",
      "CommandLine",
      "FileHandle",
      "JSONSerialization",
      "checkNull",
      "removeNSNull",
      "nilToNSNull",
      "convertArray",
      "convertOptional",
      "convertDict",
      "convertDouble",
      "jsonString",
      "jsonData"
    ];
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Swift/utils.js
var require_utils22 = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Swift/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.stringEscape = exports.SwiftDateTimeRecognizer = exports.MAX_SAMELINE_PROPERTIES = void 0;
    exports.swiftNameStyle = swiftNameStyle;
    var DateTime_1 = require_DateTime();
    var Strings_1 = require_Strings();
    exports.MAX_SAMELINE_PROPERTIES = 4;
    var swiftDateTimeRegex = /^\d+-\d+-\d+T\d+:\d+:\d+([zZ]|[+-]\d+(:\d+)?)$/;
    var SwiftDateTimeRecognizer = class extends DateTime_1.DefaultDateTimeRecognizer {
      isDateTime(str) {
        return swiftDateTimeRegex.exec(str) !== null;
      }
    };
    exports.SwiftDateTimeRecognizer = SwiftDateTimeRecognizer;
    function isPartCharacter(codePoint) {
      return (0, Strings_1.isLetterOrUnderscore)(codePoint) || (0, Strings_1.isNumeric)(codePoint);
    }
    function isStartCharacter(codePoint) {
      return isPartCharacter(codePoint) && !(0, Strings_1.isDigit)(codePoint);
    }
    var legalizeName = (0, Strings_1.legalizeCharacters)(isPartCharacter);
    function swiftNameStyle(prefix, isUpper, original, acronymsStyle = Strings_1.allUpperWordStyle) {
      const words = (0, Strings_1.splitIntoWords)(original);
      const combined = (0, Strings_1.combineWords)(words, legalizeName, isUpper ? Strings_1.firstUpperWordStyle : Strings_1.allLowerWordStyle, Strings_1.firstUpperWordStyle, isUpper ? Strings_1.allUpperWordStyle : Strings_1.allLowerWordStyle, acronymsStyle, "", isStartCharacter);
      return (0, Strings_1.addPrefixIfNecessary)(prefix, combined);
    }
    function unicodeEscape(codePoint) {
      return "\\u{" + (0, Strings_1.intToHex)(codePoint, 0) + "}";
    }
    exports.stringEscape = (0, Strings_1.utf32ConcatMap)((0, Strings_1.escapeNonPrintableMapper)(Strings_1.isPrintable, unicodeEscape));
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Swift/SwiftRenderer.js
var require_SwiftRenderer = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Swift/SwiftRenderer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.SwiftRenderer = void 0;
    var collection_utils_1 = require_dist();
    var Annotation_1 = require_Annotation();
    var ConvenienceRenderer_1 = require_ConvenienceRenderer();
    var Naming_1 = require_Naming();
    var Source_1 = require_Source();
    var Acronyms_1 = require_Acronyms();
    var Strings_1 = require_Strings();
    var Support_1 = require_Support();
    var Type_1 = require_Type2();
    var TypeUtils_1 = require_TypeUtils();
    var constants_1 = require_constants19();
    var utils_1 = require_utils22();
    var SwiftRenderer = class extends ConvenienceRenderer_1.ConvenienceRenderer {
      constructor(targetLanguage, renderContext, _options) {
        super(targetLanguage, renderContext);
        this._options = _options;
        this._needAny = false;
        this._needNull = false;
        this.emitSupportFunctions4 = () => {
          this.startFile("JSONSchemaSupport");
          this.emitLineOnce("import Foundation");
          this.forEachTopLevel("leading", (t, name) => this.renderTopLevelAlias(t, name), (t) => this.namedTypeToNameForTopLevel(t) === void 0);
          if (this._options.convenienceInitializers) {
            this.ensureBlankLine();
            this.forEachTopLevel("leading-and-interposing", (t, name) => this.emitTopLevelMapAndArrayConvenienceInitializerExtensions(t, name));
          }
          if (!this._options.justTypes && this._options.convenienceInitializers || this._options.alamofire) {
            this.ensureBlankLine();
            this.emitMark("Helper functions for creating encoders and decoders", true);
            this.ensureBlankLine();
            this.emitNewEncoderDecoder();
          }
          if (this._options.alamofire) {
            this.ensureBlankLine();
            this.emitMark("Alamofire response handlers", true);
            this.ensureBlankLine();
            this.emitAlamofireExtension();
          }
          if (this._needAny || this._needNull) {
            this.ensureBlankLine();
            this.emitMark("Encode/decode helpers", true);
            this.ensureBlankLine();
            if (this._options.objcSupport) {
              this.emitLine(this.objcMembersDeclaration, this.accessLevel, "class JSONNull: NSObject, Codable {");
            } else {
              this.emitLine(this.accessLevel, "class JSONNull: Codable, Hashable {");
            }
            this.ensureBlankLine();
            this.emitMultiline(`    public static func == (lhs: JSONNull, rhs: JSONNull) -> Bool {
			return true
	}`);
            if (this._options.objcSupport === false) {
              this.ensureBlankLine();
              this.emitMultiline(`    public var hashValue: Int {
			return 0
	}`);
              if (this._options.swift5Support) {
                this.ensureBlankLine();
                this.emitMultiline(`    public func hash(into hasher: inout Hasher) {
			// No-op
	}`);
              }
            }
            this.ensureBlankLine();
            if (this._options.objcSupport) {
              this.emitItem("    override ");
            } else {
              this.emitItem("    ");
            }
            this.emitMultiline(`public init() {}
	
	public required init(from decoder: Decoder) throws {
			let container = try decoder.singleValueContainer()
			if !container.decodeNil() {
					throw DecodingError.typeMismatch(JSONNull.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for JSONNull"))
			}
	}
	
	public func encode(to encoder: Encoder) throws {
			var container = encoder.singleValueContainer()
			try container.encodeNil()
	}
}`);
          }
          if (this._needAny) {
            this.ensureBlankLine();
            this.emitMultiline(`class JSONCodingKey: CodingKey {
	let key: String
	
	required init?(intValue: Int) {
			return nil
	}
	
	required init?(stringValue: String) {
			key = stringValue
	}
	
	var intValue: Int? {
			return nil
	}
	
	var stringValue: String {
			return key
	}
}`);
            this.ensureBlankLine();
            if (this._options.objcSupport) {
              this.emitLine(this.objcMembersDeclaration, this.accessLevel, "class JSONAny: NSObject, Codable {");
            } else {
              this.emitLine(this.accessLevel, "class JSONAny: Codable {");
            }
            this.ensureBlankLine();
            this.emitMultiline(`    ${this.accessLevel}let value: Any
	
	static func decodingError(forCodingPath codingPath: [CodingKey]) -> DecodingError {
			let context = DecodingError.Context(codingPath: codingPath, debugDescription: "Cannot decode JSONAny")
			return DecodingError.typeMismatch(JSONAny.self, context)
	}
	
	static func encodingError(forValue value: Any, codingPath: [CodingKey]) -> EncodingError {
			let context = EncodingError.Context(codingPath: codingPath, debugDescription: "Cannot encode JSONAny")
			return EncodingError.invalidValue(value, context)
	}

	static func decode(from container: SingleValueDecodingContainer) throws -> Any {
			if let value = try? container.decode(Bool.self) {
					return value
			}
			if let value = try? container.decode(Int64.self) {
					return value
			}
			if let value = try? container.decode(Double.self) {
					return value
			}
			if let value = try? container.decode(String.self) {
					return value
			}
			if container.decodeNil() {
					return JSONNull()
			}
			throw decodingError(forCodingPath: container.codingPath)
	}
	
	static func decode(from container: inout UnkeyedDecodingContainer) throws -> Any {
			if let value = try? container.decode(Bool.self) {
					return value
			}
			if let value = try? container.decode(Int64.self) {
					return value
			}
			if let value = try? container.decode(Double.self) {
					return value
			}
			if let value = try? container.decode(String.self) {
					return value
			}
			if let value = try? container.decodeNil() {
					if value {
							return JSONNull()
					}
			}
			if var container = try? container.nestedUnkeyedContainer() {
					return try decodeArray(from: &container)
			}
			if var container = try? container.nestedContainer(keyedBy: JSONCodingKey.self) {
					return try decodeDictionary(from: &container)
			}
			throw decodingError(forCodingPath: container.codingPath)
	}
	
	static func decode(from container: inout KeyedDecodingContainer<JSONCodingKey>, forKey key: JSONCodingKey) throws -> Any {
			if let value = try? container.decode(Bool.self, forKey: key) {
					return value
			}
			if let value = try? container.decode(Int64.self, forKey: key) {
					return value
			}
			if let value = try? container.decode(Double.self, forKey: key) {
					return value
			}
			if let value = try? container.decode(String.self, forKey: key) {
					return value
			}
			if let value = try? container.decodeNil(forKey: key) {
					if value {
							return JSONNull()
					}
			}
			if var container = try? container.nestedUnkeyedContainer(forKey: key) {
					return try decodeArray(from: &container)
			}
			if var container = try? container.nestedContainer(keyedBy: JSONCodingKey.self, forKey: key) {
					return try decodeDictionary(from: &container)
			}
			throw decodingError(forCodingPath: container.codingPath)
	}
	
	static func decodeArray(from container: inout UnkeyedDecodingContainer) throws -> [Any] {
			var arr: [Any] = []
			while !container.isAtEnd {
					let value = try decode(from: &container)
					arr.append(value)
			}
			return arr
	}

	static func decodeDictionary(from container: inout KeyedDecodingContainer<JSONCodingKey>) throws -> [String: Any] {
			var dict = [String: Any]()
			for key in container.allKeys {
					let value = try decode(from: &container, forKey: key)
					dict[key.stringValue] = value
			}
			return dict
	}
	
	static func encode(to container: inout UnkeyedEncodingContainer, array: [Any]) throws {
			for value in array {
					if let value = value as? Bool {
							try container.encode(value)
					} else if let value = value as? Int64 {
							try container.encode(value)
					} else if let value = value as? Double {
							try container.encode(value)
					} else if let value = value as? String {
							try container.encode(value)
					} else if value is JSONNull {
							try container.encodeNil()
					} else if let value = value as? [Any] {
							var container = container.nestedUnkeyedContainer()
							try encode(to: &container, array: value)
					} else if let value = value as? [String: Any] {
							var container = container.nestedContainer(keyedBy: JSONCodingKey.self)
							try encode(to: &container, dictionary: value)
					} else {
							throw encodingError(forValue: value, codingPath: container.codingPath)
					}
			}
	}
	
	static func encode(to container: inout KeyedEncodingContainer<JSONCodingKey>, dictionary: [String: Any]) throws {
			for (key, value) in dictionary {
					let key = JSONCodingKey(stringValue: key)!
					if let value = value as? Bool {
							try container.encode(value, forKey: key)
					} else if let value = value as? Int64 {
							try container.encode(value, forKey: key)
					} else if let value = value as? Double {
							try container.encode(value, forKey: key)
					} else if let value = value as? String {
							try container.encode(value, forKey: key)
					} else if value is JSONNull {
							try container.encodeNil(forKey: key)
					} else if let value = value as? [Any] {
							var container = container.nestedUnkeyedContainer(forKey: key)
							try encode(to: &container, array: value)
					} else if let value = value as? [String: Any] {
							var container = container.nestedContainer(keyedBy: JSONCodingKey.self, forKey: key)
							try encode(to: &container, dictionary: value)
					} else {
							throw encodingError(forValue: value, codingPath: container.codingPath)
					}
			}
	}

	static func encode(to container: inout SingleValueEncodingContainer, value: Any) throws {
			if let value = value as? Bool {
					try container.encode(value)
			} else if let value = value as? Int64 {
					try container.encode(value)
			} else if let value = value as? Double {
					try container.encode(value)
			} else if let value = value as? String {
					try container.encode(value)
			} else if value is JSONNull {
					try container.encodeNil()
			} else {
					throw encodingError(forValue: value, codingPath: container.codingPath)
			}
	}
	
	public required init(from decoder: Decoder) throws {
			if var arrayContainer = try? decoder.unkeyedContainer() {
					self.value = try JSONAny.decodeArray(from: &arrayContainer)
			} else if var container = try? decoder.container(keyedBy: JSONCodingKey.self) {
					self.value = try JSONAny.decodeDictionary(from: &container)
			} else {
					let container = try decoder.singleValueContainer()
					self.value = try JSONAny.decode(from: container)
			}
	}
	
	public func encode(to encoder: Encoder) throws {
			if let arr = self.value as? [Any] {
					var container = encoder.unkeyedContainer()
					try JSONAny.encode(to: &container, array: arr)
			} else if let dict = self.value as? [String: Any] {
					var container = encoder.container(keyedBy: JSONCodingKey.self)
					try JSONAny.encode(to: &container, dictionary: dict)
			} else {
					var container = encoder.singleValueContainer()
					try JSONAny.encode(to: &container, value: self.value)
			}
	}
}`);
          }
          this.endFile();
        };
      }
      forbiddenNamesForGlobalNamespace() {
        if (this._options.alamofire) {
          return [
            "DataRequest",
            ...constants_1.keywords
          ];
        }
        return constants_1.keywords;
      }
      forbiddenForObjectProperties(_c, _classNamed) {
        return {
          names: [
            "fromURL",
            "json"
          ],
          includeGlobalForbidden: true
        };
      }
      forbiddenForEnumCases(_e, _enumName) {
        return {
          names: [],
          includeGlobalForbidden: true
        };
      }
      forbiddenForUnionMembers(_u, _unionName) {
        return {
          names: [],
          includeGlobalForbidden: true
        };
      }
      makeNamedTypeNamer() {
        return (0, Naming_1.funPrefixNamer)("upper", (s) => (0, utils_1.swiftNameStyle)(this._options.namedTypePrefix, true, s, (0, Acronyms_1.acronymStyle)(this._options.acronymStyle)));
      }
      namerForObjectProperty() {
        return this.lowerNamingFunction;
      }
      makeUnionMemberNamer() {
        return this.lowerNamingFunction;
      }
      makeEnumCaseNamer() {
        return this.lowerNamingFunction;
      }
      isImplicitCycleBreaker(t) {
        const kind = t.kind;
        return kind === "array" || kind === "map";
      }
      emitDescriptionBlock(lines) {
        this.emitCommentLines(lines, {
          lineStart: "/// "
        });
      }
      emitBlock(line, f) {
        this.emitLine(line, " {");
        this.indent(f);
        this.emitLine("}");
      }
      emitBlockWithAccess(line, f) {
        this.emitBlock([
          this.accessLevel,
          line
        ], f);
      }
      justTypesCase(justTypes, notJustTypes) {
        if (this._options.justTypes) {
          return justTypes;
        }
        return notJustTypes;
      }
      get lowerNamingFunction() {
        return (0, Naming_1.funPrefixNamer)("lower", (s) => (0, utils_1.swiftNameStyle)("", false, s, (0, Acronyms_1.acronymStyle)(this._options.acronymStyle)));
      }
      swiftPropertyType(p) {
        if (p.isOptional || this._options.optionalEnums && p.type.kind === "enum") {
          return [
            this.swiftType(p.type, true, true),
            "?"
          ];
        }
        return this.swiftType(p.type, true);
      }
      swiftType(t, withIssues = false, noOptional = false) {
        const optional = noOptional ? "" : "?";
        return (0, TypeUtils_1.matchType)(t, (_anyType) => {
          this._needAny = true;
          return (0, Source_1.maybeAnnotated)(withIssues, Annotation_1.anyTypeIssueAnnotation, this.justTypesCase([
            "Any",
            optional
          ], "JSONAny"));
        }, (_nullType) => {
          this._needNull = true;
          return (0, Source_1.maybeAnnotated)(withIssues, Annotation_1.nullTypeIssueAnnotation, this.justTypesCase("NSNull", [
            "JSONNull",
            optional
          ]));
        }, (_boolType) => "Bool", (_integerType) => "Int", (_doubleType) => "Double", (_stringType) => "String", (arrayType) => [
          "[",
          this.swiftType(arrayType.items, withIssues),
          "]"
        ], (classType) => this.nameForNamedType(classType), (mapType) => [
          "[String: ",
          this.swiftType(mapType.values, withIssues),
          "]"
        ], (enumType) => this.nameForNamedType(enumType), (unionType) => {
          const nullable = (0, TypeUtils_1.nullableFromUnion)(unionType);
          if (nullable !== null) return [
            this.swiftType(nullable, withIssues),
            optional
          ];
          return this.nameForNamedType(unionType);
        }, (transformedStringType) => {
          if (transformedStringType.kind === "date-time") {
            return "Date";
          }
          return (0, Support_1.panic)(`Transformed string type ${transformedStringType.kind} not supported`);
        });
      }
      proposedUnionMemberNameForTypeKind(kind) {
        if (kind === "enum") {
          return "enumeration";
        }
        if (kind === "union") {
          return "one_of";
        }
        return null;
      }
      renderSingleFileHeaderComments() {
        this.emitLineOnce("// This file was generated from JSON Schema using quicktype, do not modify it directly.");
        this.emitLineOnce("// To parse the JSON, add this file to your project and do:");
        this.emitLineOnce("//");
        this.forEachTopLevel("none", (t, topLevelName) => {
          if (this._options.convenienceInitializers && !(t instanceof Type_1.EnumType)) {
            this.emitLineOnce("//   let ", (0, Source_1.modifySource)(Strings_1.camelCase, topLevelName), " = try ", topLevelName, "(json)");
          } else {
            this.emitLineOnce("//   let ", (0, Source_1.modifySource)(Strings_1.camelCase, topLevelName), " = ", "try? JSONDecoder().decode(", topLevelName, ".self, from: jsonData)");
          }
        });
      }
      renderHeader(type, name) {
        if (this.leadingComments !== void 0) {
          this.emitComments(this.leadingComments);
        } else if (!this._options.justTypes) {
          if (this._options.multiFileOutput) {
            this.emitLineOnce("// This file was generated from JSON Schema using quicktype, do not modify it directly.");
            this.emitLineOnce("// To parse the JSON, add this file to your project and do:");
            this.emitLineOnce("//");
            if (this._options.convenienceInitializers && !(type instanceof Type_1.EnumType)) {
              this.emitLine("//   let ", (0, Source_1.modifySource)(Strings_1.camelCase, name), " = try ", name, "(json)");
            } else {
              this.emitLine("//   let ", (0, Source_1.modifySource)(Strings_1.camelCase, name), " = ", "try? newJSONDecoder().decode(", name, ".self, from: jsonData)");
            }
          }
          if (this._options.alamofire) {
            this.emitLine("//");
            this.emitLine("// To parse values from Alamofire responses:");
            this.emitLine("//");
            this.emitLine("//   Alamofire.request(url).response", name, " { response in");
            this.emitLine("//     if let ", (0, Source_1.modifySource)(Strings_1.camelCase, name), " = response.result.value {");
            this.emitLine("//       ...");
            this.emitLine("//     }");
            this.emitLine("//   }");
          }
          if (this._options.protocol.hashable || this._options.protocol.equatable) {
            this.emitLine("//");
            this.emitLine("// Hashable or Equatable:");
            this.emitLine("// The compiler will not be able to synthesize the implementation of Hashable or Equatable");
            this.emitLine("// for types that require the use of JSONAny, nor will the implementation of Hashable be");
            this.emitLine("// synthesized for types that have collections (such as arrays or dictionaries).");
          }
        }
        this.ensureBlankLine();
        this.emitLineOnce("import Foundation");
        if (!this._options.justTypes && this._options.alamofire) {
          this.emitLineOnce("import Alamofire");
        }
        if (this._options.optionalEnums) {
          this.emitLineOnce("import OptionallyDecodable // https://github.com/idrougge/OptionallyDecodable");
        }
        this.ensureBlankLine();
      }
      renderTopLevelAlias(t, name) {
        this.emitLine(this.accessLevel, "typealias ", name, " = ", this.swiftType(t, true));
      }
      getProtocolsArray(kind) {
        const protocols = [];
        const isClass = kind === "class";
        if (isClass && this._options.objcSupport) {
          protocols.push("NSObject");
        }
        if (!this._options.justTypes) {
          protocols.push("Codable");
        }
        if (this._options.protocol.hashable) {
          protocols.push("Hashable");
        }
        if (this._options.protocol.equatable) {
          protocols.push("Equatable");
        }
        if (this._options.sendable && (!this._options.mutableProperties || !isClass) && !this._options.objcSupport) {
          protocols.push("Sendable");
        }
        return protocols;
      }
      getProtocolString(kind, baseClass = void 0) {
        const protocols = this.getProtocolsArray(kind);
        if (baseClass) {
          protocols.unshift(baseClass);
        }
        return protocols.length > 0 ? `: ${protocols.join(", ")}` : "";
      }
      getEnumPropertyGroups(c) {
        const groups = [];
        let group = [];
        this.forEachClassProperty(c, "none", (name, jsonName) => {
          const label = (0, utils_1.stringEscape)(jsonName);
          const redundant = this.sourcelikeToString(name) === label;
          if (this._options.dense && redundant) {
            group.push({
              name
            });
          } else {
            if (group.length > 0) {
              groups.push(group);
              group = [];
            }
            groups.push([
              {
                name,
                label
              }
            ]);
          }
        });
        if (group.length > 0) {
          groups.push(group);
        }
        return groups;
      }
      /// Access level with trailing space (e.g. "public "), or empty string
      get accessLevel() {
        return this._options.accessLevel === "internal" ? "" : this._options.accessLevel + " ";
      }
      get objcMembersDeclaration() {
        if (this._options.objcSupport) {
          return "@objcMembers ";
        }
        return "";
      }
      /// startFile takes a file name, appends ".swift" to it and sets it as the current filename.
      startFile(basename) {
        if (this._options.multiFileOutput === false) {
          return;
        }
        (0, Support_1.assert)(this._currentFilename === void 0, `Previous file wasn't finished: ${this._currentFilename}`);
        this._currentFilename = `${this.sourcelikeToString(basename)}.swift`;
        this.initializeEmitContextForFilename(this._currentFilename);
      }
      /// endFile pushes the current file name onto the collection of finished files and then resets the current file name. These finished files are used in index.ts to write the output.
      endFile() {
        if (this._options.multiFileOutput === false) {
          return;
        }
        this.finishFile((0, Support_1.defined)(this._currentFilename));
        this._currentFilename = void 0;
      }
      propertyLinesDefinition(name, parameter) {
        const useMutableProperties = this._options.mutableProperties;
        return [
          this.accessLevel,
          useMutableProperties ? "var " : "let ",
          name,
          ": ",
          this.swiftPropertyType(parameter)
        ];
      }
      renderClassDefinition(c, className) {
        this.startFile(className);
        this.renderHeader(c, className);
        this.emitDescription(this.descriptionForType(c));
        this.emitMark(this.sourcelikeToString(className), true);
        const isClass = this._options.useClasses || this.isCycleBreakerType(c);
        const structOrClass = isClass ? "class" : "struct";
        if (isClass && this._options.objcSupport) {
          this.emitItem(this.objcMembersDeclaration);
        }
        this.emitBlockWithAccess([
          structOrClass,
          " ",
          className,
          this.getProtocolString(structOrClass)
        ], () => {
          if (this._options.dense) {
            let lastProperty = void 0;
            let lastNames = [];
            const emitLastProperty = () => {
              if (lastProperty === void 0) return;
              const useMutableProperties = this._options.mutableProperties;
              const sources = [
                [
                  this._options.optionalEnums && lastProperty.type.kind === "enum" ? "@OptionallyDecodable " : "",
                  this.accessLevel,
                  useMutableProperties || this._options.optionalEnums && lastProperty.type.kind === "enum" ? "var " : "let "
                ]
              ];
              lastNames.forEach((n, i2) => {
                if (i2 > 0) sources.push(", ");
                sources.push(n);
              });
              sources.push(": ");
              sources.push(this.swiftPropertyType(lastProperty));
              this.emitLine(sources);
              lastProperty = void 0;
              lastNames = [];
            };
            this.forEachClassProperty(c, "none", (name, jsonName, p) => {
              const description = this.descriptionForClassProperty(c, jsonName);
              if (lastProperty && !p.equals(lastProperty) || lastNames.length >= utils_1.MAX_SAMELINE_PROPERTIES || description !== void 0) {
                emitLastProperty();
              }
              if (lastProperty === void 0) {
                lastProperty = p;
              }
              lastNames.push(name);
              if (description !== void 0) {
                this.emitDescription(description);
                emitLastProperty();
              }
            });
            emitLastProperty();
          } else {
            this.forEachClassProperty(c, "none", (name, jsonName, p) => {
              const description = this.descriptionForClassProperty(c, jsonName);
              const propertyLines = this.propertyLinesDefinition(name, p);
              this.emitDescription(description);
              this.emitLine(propertyLines);
            });
          }
          if (!this._options.justTypes) {
            const groups = this.getEnumPropertyGroups(c);
            const allPropertiesRedundant = groups.every((group) => {
              return group.every((p) => p.label === void 0);
            });
            if (!allPropertiesRedundant && c.getProperties().size > 0) {
              this.ensureBlankLine();
              let enumDeclaration = this.accessLevel;
              enumDeclaration += "enum CodingKeys: String, CodingKey";
              if (this._options.codingKeysProtocol && this._options.codingKeysProtocol.length > 0) {
                enumDeclaration += ", ";
                enumDeclaration += this._options.codingKeysProtocol;
              }
              this.emitBlock(enumDeclaration, () => {
                for (const group of groups) {
                  const { name, label } = group[0];
                  if (this._options.explicitCodingKeys && label !== void 0) {
                    this.emitLine("case ", name, ' = "', label, '"');
                  } else {
                    const names = (0, collection_utils_1.arrayIntercalate)(", ", group.map((p) => p.name));
                    this.emitLine("case ", names);
                  }
                }
              });
            }
          }
          if (isClass || // Public structs need explicit initializers
          // https://github.com/quicktype/quicktype/issues/899
          this._options.accessLevel === "public") {
            this.ensureBlankLine();
            const initProperties = this.initializableProperties(c);
            const propertiesLines = [];
            for (const property of initProperties) {
              if (propertiesLines.length > 0) propertiesLines.push(", ");
              propertiesLines.push(property.name, ": ", this.swiftPropertyType(property.parameter));
            }
            if (this.propertyCount(c) === 0 && this._options.objcSupport) {
              this.emitBlockWithAccess([
                "override init()"
              ], () => {
                return "";
              });
            } else {
              this.emitBlockWithAccess([
                "init(",
                ...propertiesLines,
                ")"
              ], () => {
                for (const property of initProperties) {
                  this.emitLine("self.", property.name, " = ", property.name);
                }
              });
            }
          }
        });
        if (!this._options.justTypes) {
          if (this._options.convenienceInitializers) {
            this.ensureBlankLine();
            this.emitMark(this.sourcelikeToString(className) + " convenience initializers and mutators");
            this.ensureBlankLine();
            this.emitConvenienceInitializersExtension(c, className);
            this.ensureBlankLine();
          }
        }
        this.endFile();
      }
      initializableProperties(c) {
        const properties = [];
        this.forEachClassProperty(c, "none", (name, jsonName, parameter, position) => {
          const property = {
            name,
            jsonName,
            parameter,
            position
          };
          properties.push(property);
        });
        return properties;
      }
      emitNewEncoderDecoder() {
        this.emitBlock("func newJSONDecoder() -> JSONDecoder", () => {
          this.emitLine("let decoder = JSONDecoder()");
          if (!this._options.linux) {
            this.emitBlock("if #available(iOS 10.0, OSX 10.12, tvOS 10.0, watchOS 3.0, *)", () => {
              this.emitLine("decoder.dateDecodingStrategy = .iso8601");
            });
          } else {
            this.emitMultiline(`decoder.dateDecodingStrategy = .custom({ (decoder) -> Date in
	let container = try decoder.singleValueContainer()
	let dateStr = try container.decode(String.self)

	let formatter = DateFormatter()
	formatter.calendar = Calendar(identifier: .iso8601)
	formatter.locale = Locale(identifier: "en_US_POSIX")
	formatter.timeZone = TimeZone(secondsFromGMT: 0)
	formatter.dateFormat = "yyyy-MM-dd'T'HH:mm:ss.SSSXXXXX"
	if let date = formatter.date(from: dateStr) {
			return date
	}
	formatter.dateFormat = "yyyy-MM-dd'T'HH:mm:ssXXXXX"
	if let date = formatter.date(from: dateStr) {
			return date
	}
	throw DecodingError.typeMismatch(Date.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Could not decode date"))
})`);
          }
          this.emitLine("return decoder");
        });
        this.ensureBlankLine();
        this.emitBlock("func newJSONEncoder() -> JSONEncoder", () => {
          this.emitLine("let encoder = JSONEncoder()");
          if (!this._options.linux) {
            this.emitBlock("if #available(iOS 10.0, OSX 10.12, tvOS 10.0, watchOS 3.0, *)", () => {
              this.emitLine("encoder.dateEncodingStrategy = .iso8601");
            });
          } else {
            this.emitMultiline(`let formatter = DateFormatter()
formatter.calendar = Calendar(identifier: .iso8601)
formatter.locale = Locale(identifier: "en_US_POSIX")
formatter.timeZone = TimeZone(secondsFromGMT: 0)
formatter.dateFormat = "yyyy-MM-dd'T'HH:mm:ssXXXXX"
encoder.dateEncodingStrategy = .formatted(formatter)`);
          }
          this.emitLine("return encoder");
        });
      }
      emitConvenienceInitializersExtension(c, className) {
        const isClass = this._options.useClasses || this.isCycleBreakerType(c);
        const convenience = isClass ? "convenience " : "";
        this.emitBlockWithAccess([
          "extension ",
          className
        ], () => {
          if (isClass) {
            this.emitBlock("convenience init(data: Data) throws", () => {
              if (this.propertyCount(c) > 0) {
                this.emitLine("let me = try newJSONDecoder().decode(", this.swiftType(c), ".self, from: data)");
              } else {
                this.emitLine("let _ = try newJSONDecoder().decode(", this.swiftType(c), ".self, from: data)");
              }
              const args = [];
              this.forEachClassProperty(c, "none", (name) => {
                if (args.length > 0) args.push(", ");
                args.push(name, ": ", "me.", name);
              });
              this.emitLine("self.init(", ...args, ")");
            });
          } else {
            this.emitBlock("init(data: Data) throws", () => {
              this.emitLine("self = try newJSONDecoder().decode(", this.swiftType(c), ".self, from: data)");
            });
          }
          this.ensureBlankLine();
          this.emitBlock([
            convenience,
            "init(_ json: String, using encoding: String.Encoding = .utf8) throws"
          ], () => {
            this.emitBlock("guard let data = json.data(using: encoding) else", () => {
              this.emitLine('throw NSError(domain: "JSONDecoding", code: 0, userInfo: nil)');
            });
            this.emitLine("try self.init(data: data)");
          });
          this.ensureBlankLine();
          this.emitBlock([
            convenience,
            "init(fromURL url: URL) throws"
          ], () => {
            this.emitLine("try self.init(data: try Data(contentsOf: url))");
          });
          this.ensureBlankLine();
          this.emitConvenienceMutator(c, className);
          this.ensureBlankLine();
          this.emitBlock("func jsonData() throws -> Data", () => {
            this.emitLine("return try newJSONEncoder().encode(self)");
          });
          this.ensureBlankLine();
          this.emitBlock("func jsonString(encoding: String.Encoding = .utf8) throws -> String?", () => {
            this.emitLine("return String(data: try self.jsonData(), encoding: encoding)");
          });
        });
      }
      renderEnumDefinition(e, enumName) {
        this.startFile(enumName);
        this.emitLineOnce("import Foundation");
        this.ensureBlankLine();
        this.emitDescription(this.descriptionForType(e));
        const protocolString = this.getProtocolString("enum", "String");
        if (this._options.justTypes) {
          this.emitBlockWithAccess([
            "enum ",
            enumName,
            protocolString
          ], () => {
            this.forEachEnumCase(e, "none", (name) => {
              this.emitLine("case ", name);
            });
          });
        } else {
          this.emitBlockWithAccess([
            "enum ",
            enumName,
            protocolString
          ], () => {
            this.forEachEnumCase(e, "none", (name, jsonName) => {
              this.emitLine("case ", name, ' = "', (0, utils_1.stringEscape)(jsonName), '"');
            });
          });
        }
        this.endFile();
      }
      renderUnionDefinition(u, unionName) {
        this.startFile(unionName);
        this.emitLineOnce("import Foundation");
        this.ensureBlankLine();
        function sortBy(t) {
          const kind = t.kind;
          if (kind === "class") return kind;
          return `_${kind}`;
        }
        const renderUnionCase = (t) => {
          this.emitBlock([
            "if let x = try? container.decode(",
            this.swiftType(t),
            ".self)"
          ], () => {
            this.emitLine("self = .", this.nameForUnionMember(u, t), "(x)");
            this.emitLine("return");
          });
        };
        this.emitDescription(this.descriptionForType(u));
        const indirect = this.isCycleBreakerType(u) ? "indirect " : "";
        const [maybeNull, nonNulls] = (0, TypeUtils_1.removeNullFromUnion)(u, sortBy);
        this.emitBlockWithAccess([
          indirect,
          "enum ",
          unionName,
          this.getProtocolString("enum")
        ], () => {
          this.forEachUnionMember(u, nonNulls, "none", null, (name, t) => {
            this.emitLine("case ", name, "(", this.swiftType(t), ")");
          });
          if (maybeNull !== null) {
            this.emitLine("case ", this.nameForUnionMember(u, maybeNull));
          }
          if (!this._options.justTypes) {
            this.ensureBlankLine();
            this.emitBlockWithAccess("init(from decoder: Decoder) throws", () => {
              this.emitLine("let container = try decoder.singleValueContainer()");
              const boolMember = u.findMember("bool");
              if (boolMember !== void 0) renderUnionCase(boolMember);
              const integerMember = u.findMember("integer");
              if (integerMember !== void 0) renderUnionCase(integerMember);
              for (const t of nonNulls) {
                if (t.kind === "bool" || t.kind === "integer") continue;
                renderUnionCase(t);
              }
              if (maybeNull !== null) {
                this.emitBlock("if container.decodeNil()", () => {
                  this.emitLine("self = .", this.nameForUnionMember(u, maybeNull));
                  this.emitLine("return");
                });
              }
              this.emitDecodingError(unionName);
            });
            this.ensureBlankLine();
            this.emitBlockWithAccess("func encode(to encoder: Encoder) throws", () => {
              this.emitLine("var container = encoder.singleValueContainer()");
              this.emitLine("switch self {");
              this.forEachUnionMember(u, nonNulls, "none", null, (name, _) => {
                this.emitLine("case .", name, "(let x):");
                this.indent(() => this.emitLine("try container.encode(x)"));
              });
              if (maybeNull !== null) {
                this.emitLine("case .", this.nameForUnionMember(u, maybeNull), ":");
                this.indent(() => this.emitLine("try container.encodeNil()"));
              }
              this.emitLine("}");
            });
          }
        });
        this.endFile();
      }
      emitTopLevelMapAndArrayConvenienceInitializerExtensions(t, name) {
        let extensionSource;
        if (t instanceof Type_1.ArrayType) {
          extensionSource = [
            "Array where Element == ",
            name,
            ".Element"
          ];
        } else if (t instanceof Type_1.MapType) {
          extensionSource = [
            "Dictionary where Key == String, Value == ",
            this.swiftType(t.values)
          ];
        } else {
          return;
        }
        this.emitBlockWithAccess([
          "extension ",
          extensionSource
        ], () => {
          this.emitBlock([
            "init(data: Data) throws"
          ], () => {
            this.emitLine("self = try newJSONDecoder().decode(", name, ".self, from: data)");
          });
          this.ensureBlankLine();
          this.emitBlock("init(_ json: String, using encoding: String.Encoding = .utf8) throws", () => {
            this.emitBlock("guard let data = json.data(using: encoding) else", () => {
              this.emitLine('throw NSError(domain: "JSONDecoding", code: 0, userInfo: nil)');
            });
            this.emitLine("try self.init(data: data)");
          });
          this.ensureBlankLine();
          this.emitBlock("init(fromURL url: URL) throws", () => {
            this.emitLine("try self.init(data: try Data(contentsOf: url))");
          });
          this.ensureBlankLine();
          this.emitBlock("func jsonData() throws -> Data", () => {
            this.emitLine("return try newJSONEncoder().encode(self)");
          });
          this.ensureBlankLine();
          this.emitBlock("func jsonString(encoding: String.Encoding = .utf8) throws -> String?", () => {
            this.emitLine("return String(data: try self.jsonData(), encoding: encoding)");
          });
        });
      }
      emitDecodingError(name) {
        this.emitLine("throw DecodingError.typeMismatch(", name, '.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for ', name, '"))');
      }
      emitConvenienceMutator(c, className) {
        this.emitLine("func with(");
        this.indent(() => {
          this.forEachClassProperty(c, "none", (name, _, p, position) => {
            this.emitLine(name, ": ", this.swiftPropertyType(p), "? = nil", position !== "only" && position !== "last" ? "," : "");
          });
        });
        this.emitBlock([
          ") -> ",
          className
        ], () => {
          this.emitLine("return ", className, "(");
          this.indent(() => {
            this.forEachClassProperty(c, "none", (name, _, _p, position) => {
              this.emitLine(name, ": ", name, " ?? self.", name, position !== "only" && position !== "last" ? "," : "");
            });
          });
          this.emitLine(")");
        });
      }
      emitMark(line, horizontalLine = false) {
        this.emitLine("// MARK:", horizontalLine ? " - " : " ", line);
      }
      emitSourceStructure() {
        if (this._options.multiFileOutput === false) {
          this.renderSingleFileHeaderComments();
        }
        this.forEachNamedType("leading-and-interposing", (c, className) => this.renderClassDefinition(c, className), (e, enumName) => this.renderEnumDefinition(e, enumName), (u, unionName) => this.renderUnionDefinition(u, unionName));
        if (!this._options.justTypes) {
          this.emitSupportFunctions4();
        }
      }
      emitAlamofireExtension() {
        this.ensureBlankLine();
        this.emitBlockWithAccess("extension DataRequest", () => {
          this.emitMultiline(`fileprivate func decodableResponseSerializer<T: Decodable>() -> DataResponseSerializer<T> {
	return DataResponseSerializer { _, response, data, error in
			guard error == nil else { return .failure(error!) }
			
			guard let data = data else {
					return .failure(AFError.responseSerializationFailed(reason: .inputDataNil))
			}
			
			return Result { try newJSONDecoder().decode(T.self, from: data) }
	}
}

@discardableResult
fileprivate func responseDecodable<T: Decodable>(queue: DispatchQueue? = nil, completionHandler: @escaping (DataResponse<T>) -> Void) -> Self {
	return response(queue: queue, responseSerializer: decodableResponseSerializer(), completionHandler: completionHandler)
}`);
          this.ensureBlankLine();
          this.forEachTopLevel("leading-and-interposing", (_, name) => {
            this.emitLine("@discardableResult");
            this.emitBlock([
              "func response",
              name,
              "(queue: DispatchQueue? = nil, completionHandler: @escaping (DataResponse<",
              name,
              ">) -> Void) -> Self"
            ], () => {
              this.emitLine("return responseDecodable(queue: queue, completionHandler: completionHandler)");
            });
          });
        });
      }
    };
    exports.SwiftRenderer = SwiftRenderer;
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Swift/language.js
var require_language23 = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Swift/language.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.SwiftTargetLanguage = exports.swiftLanguageConfig = exports.swiftOptions = void 0;
    var RendererOptions_1 = require_RendererOptions();
    var Acronyms_1 = require_Acronyms();
    var TargetLanguage_1 = require_TargetLanguage();
    var SwiftRenderer_1 = require_SwiftRenderer();
    var utils_1 = require_utils22();
    exports.swiftOptions = {
      justTypes: new RendererOptions_1.BooleanOption("just-types", "Plain types only", false),
      convenienceInitializers: new RendererOptions_1.BooleanOption("initializers", "Generate initializers and mutators", true),
      explicitCodingKeys: new RendererOptions_1.BooleanOption("coding-keys", "Explicit CodingKey values in Codable types", true),
      codingKeysProtocol: new RendererOptions_1.StringOption("coding-keys-protocol", "CodingKeys implements protocols", "protocol1, protocol2...", "", "secondary"),
      alamofire: new RendererOptions_1.BooleanOption("alamofire", "Alamofire extensions", false),
      namedTypePrefix: new RendererOptions_1.StringOption("type-prefix", "Prefix for type names", "PREFIX", "", "secondary"),
      useClasses: new RendererOptions_1.EnumOption("struct-or-class", "Structs or classes", {
        struct: false,
        class: true
      }, "struct"),
      mutableProperties: new RendererOptions_1.BooleanOption("mutable-properties", "Use var instead of let for object properties", false),
      acronymStyle: (0, Acronyms_1.acronymOption)(Acronyms_1.AcronymStyleOptions.Pascal),
      dense: new RendererOptions_1.EnumOption("density", "Code density", {
        dense: true,
        normal: false
      }, "dense", "secondary"),
      linux: new RendererOptions_1.BooleanOption("support-linux", "Support Linux", false, "secondary"),
      objcSupport: new RendererOptions_1.BooleanOption("objective-c-support", "Objects inherit from NSObject and @objcMembers is added to classes", false),
      optionalEnums: new RendererOptions_1.BooleanOption("optional-enums", "If no matching case is found enum value is set to null", false),
      swift5Support: new RendererOptions_1.BooleanOption("swift-5-support", "Renders output in a Swift 5 compatible mode", false),
      sendable: new RendererOptions_1.BooleanOption("sendable", "Mark generated models as Sendable", false),
      multiFileOutput: new RendererOptions_1.BooleanOption("multi-file-output", "Renders each top-level object in its own Swift file", false),
      accessLevel: new RendererOptions_1.EnumOption("access-level", "Access level", {
        internal: "internal",
        public: "public"
      }, "internal", "secondary"),
      protocol: new RendererOptions_1.EnumOption("protocol", "Make types implement protocol", {
        none: {
          equatable: false,
          hashable: false
        },
        equatable: {
          equatable: true,
          hashable: false
        },
        hashable: {
          equatable: false,
          hashable: true
        }
      }, "none", "secondary")
    };
    exports.swiftLanguageConfig = {
      displayName: "Swift",
      names: [
        "swift",
        "swift4"
      ],
      extension: "swift"
    };
    var SwiftTargetLanguage = class extends TargetLanguage_1.TargetLanguage {
      constructor() {
        super(exports.swiftLanguageConfig);
      }
      getOptions() {
        return exports.swiftOptions;
      }
      get stringTypeMapping() {
        const mapping = /* @__PURE__ */ new Map();
        mapping.set("date-time", "date-time");
        return mapping;
      }
      get supportsOptionalClassProperties() {
        return true;
      }
      get supportsUnionsWithBothNumberTypes() {
        return true;
      }
      makeRenderer(renderContext, untypedOptionValues) {
        return new SwiftRenderer_1.SwiftRenderer(this, renderContext, (0, RendererOptions_1.getOptionValues)(exports.swiftOptions, untypedOptionValues));
      }
      get dateTimeRecognizer() {
        return new utils_1.SwiftDateTimeRecognizer();
      }
    };
    exports.SwiftTargetLanguage = SwiftTargetLanguage;
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Swift/index.js
var require_Swift = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/Swift/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.SwiftRenderer = exports.swiftOptions = exports.SwiftTargetLanguage = void 0;
    var language_1 = require_language23();
    Object.defineProperty(exports, "SwiftTargetLanguage", {
      enumerable: true,
      get: function() {
        return language_1.SwiftTargetLanguage;
      }
    });
    Object.defineProperty(exports, "swiftOptions", {
      enumerable: true,
      get: function() {
        return language_1.swiftOptions;
      }
    });
    var SwiftRenderer_1 = require_SwiftRenderer();
    Object.defineProperty(exports, "SwiftRenderer", {
      enumerable: true,
      get: function() {
        return SwiftRenderer_1.SwiftRenderer;
      }
    });
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/TypeScriptEffectSchema/TypeScriptEffectSchemaRenderer.js
var require_TypeScriptEffectSchemaRenderer = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/TypeScriptEffectSchema/TypeScriptEffectSchemaRenderer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.TypeScriptEffectSchemaRenderer = void 0;
    var collection_utils_1 = require_dist();
    var ConvenienceRenderer_1 = require_ConvenienceRenderer();
    var Naming_1 = require_Naming();
    var Acronyms_1 = require_Acronyms();
    var Strings_1 = require_Strings();
    var Support_1 = require_Support();
    var Type_1 = require_Type2();
    var TypeUtils_1 = require_TypeUtils();
    var utils_1 = require_utils11();
    var TypeScriptEffectSchemaRenderer = class extends ConvenienceRenderer_1.ConvenienceRenderer {
      constructor(targetLanguage, renderContext, _options) {
        super(targetLanguage, renderContext);
        this._options = _options;
        this.emittedObjects = /* @__PURE__ */ new Set();
      }
      forbiddenNamesForGlobalNamespace() {
        return [
          "Class",
          "Date",
          "Object",
          "String",
          "Array",
          "JSON",
          "Error"
        ];
      }
      nameStyle(original, upper) {
        const acronyms = (0, Acronyms_1.acronymStyle)(Acronyms_1.AcronymStyleOptions.Camel);
        const words = (0, Strings_1.splitIntoWords)(original);
        return (0, Strings_1.combineWords)(words, utils_1.legalizeName, upper ? Strings_1.firstUpperWordStyle : Strings_1.allLowerWordStyle, Strings_1.firstUpperWordStyle, upper ? (s) => (0, Strings_1.capitalize)(acronyms(s)) : Strings_1.allLowerWordStyle, acronyms, "", Strings_1.isLetterOrUnderscore);
      }
      makeNamedTypeNamer() {
        return (0, Naming_1.funPrefixNamer)("types", (s) => this.nameStyle(s, true));
      }
      makeUnionMemberNamer() {
        return (0, Naming_1.funPrefixNamer)("properties", (s) => this.nameStyle(s, true));
      }
      namerForObjectProperty() {
        return (0, Naming_1.funPrefixNamer)("properties", (s) => this.nameStyle(s, true));
      }
      makeEnumCaseNamer() {
        return (0, Naming_1.funPrefixNamer)("enum-cases", (s) => this.nameStyle(s, false));
      }
      importStatement(lhs, moduleName) {
        return [
          "import ",
          lhs,
          " from ",
          moduleName,
          ";"
        ];
      }
      emitImports() {
        this.ensureBlankLine();
        this.emitLine(this.importStatement("* as S", '"effect/Schema"'));
      }
      typeMapTypeForProperty(p) {
        if (!p.isOptional) {
          return this.typeMapTypeFor(p.type);
        }
        return [
          "S.optional(",
          this.typeMapTypeFor(p.type),
          ")"
        ];
      }
      typeMapTypeFor(t, required = true) {
        if (t.kind === "class" || t.kind === "object" || t.kind === "enum") {
          const name = this.nameForNamedType(t);
          if (this.emittedObjects.has(name)) {
            return [
              name
            ];
          }
          return [
            "S.suspend(() => ",
            name,
            ")"
          ];
        }
        const match2 = (0, TypeUtils_1.matchType)(t, (_anyType) => "S.Any", (_nullType) => "S.Null", (_boolType) => "S.Boolean", (_integerType) => "S.Number", (_doubleType) => "S.Number", (_stringType) => "S.String", (arrayType) => [
          "S.Array(",
          this.typeMapTypeFor(arrayType.items, false),
          ")"
        ], (_classType) => (0, Support_1.panic)("Should already be handled."), (_mapType) => [
          "S.Record({ key: S.String, value: ",
          this.typeMapTypeFor(_mapType.values, false),
          "})"
        ], (_enumType) => (0, Support_1.panic)("Should already be handled."), (unionType) => {
          const types = Array.from(unionType.getChildren());
          const children = [];
          let nullable = false;
          for (const type of types) {
            if (type.kind === "null") {
              nullable = true;
            } else {
              children.push(this.typeMapTypeFor(type, false));
            }
          }
          if (nullable && children.length === 1) {
            return [
              "S.NullOr(",
              children[0],
              ")"
            ];
          }
          return [
            "S.Union(",
            ...(0, collection_utils_1.arrayIntercalate)(", ", children),
            nullable ? ", S.Null)" : ")"
          ];
        }, (_transformedStringType) => {
          return "S.String";
        });
        if (required) {
          return [
            match2
          ];
        }
        return match2;
      }
      emitObject(name, t) {
        this.emittedObjects.add(name);
        this.ensureBlankLine();
        this.emitLine("\nexport class ", name, " extends S.Class<", name, '>("', name, '")({');
        this.indent(() => {
          this.forEachClassProperty(t, "none", (_, jsonName, property) => {
            this.emitLine(`"${(0, Strings_1.utf16StringEscape)(jsonName)}"`, ": ", this.typeMapTypeForProperty(property), ",");
          });
        });
        this.emitLine("}) {}");
      }
      emitEnum(e, enumName) {
        this.emittedObjects.add(enumName);
        this.ensureBlankLine();
        this.emitDescription(this.descriptionForType(e));
        this.emitLine("\nexport const ", enumName, " = ", "S.Literal(");
        this.indent(() => this.forEachEnumCase(e, "none", (_, jsonName) => {
          this.emitLine('"', (0, Strings_1.stringEscape)(jsonName), '",');
        }));
        this.emitLine(");");
        if (!this._options.justSchema) {
          this.emitLine("export type ", enumName, " = S.Schema.Type<typeof ", enumName, ">;");
        }
      }
      walkObjectNames(objectType) {
        const names = [];
        const recurse = (type) => {
          if (type.kind === "object" || type.kind === "class") {
            names.push(this.nameForNamedType(type));
            this.forEachClassProperty(type, "none", (_, __, prop) => {
              recurse(prop.type);
            });
          } else if (type instanceof Type_1.ArrayType) {
            recurse(type.items);
          } else if (type instanceof Type_1.MapType) {
            recurse(type.values);
          } else if (type instanceof Type_1.EnumType) {
            for (const t of type.getChildren()) {
              recurse(t);
            }
          }
        };
        this.forEachClassProperty(objectType, "none", (_, __, prop) => {
          recurse(prop.type);
        });
        return names;
      }
      emitSchemas() {
        this.ensureBlankLine();
        this.forEachEnum("leading-and-interposing", (u, enumName) => {
          this.emitEnum(u, enumName);
        });
        const order = [];
        const mapKey = [];
        const mapValue = [];
        this.forEachObject("none", (type, name) => {
          mapKey.push(name);
          mapValue.push(type);
        });
        mapKey.forEach((_, index) => {
          let ordinal = 0;
          const source = mapValue[index];
          const names = this.walkObjectNames(source);
          names.forEach((name) => {
            const depName = name;
            order.forEach((orderItem) => {
              const depIndex = orderItem;
              if (mapKey[depIndex] === depName) {
                ordinal = Math.max(ordinal, depIndex + 1);
              }
            });
          });
          order.splice(ordinal, 0, index);
        });
        order.forEach((i2) => this.emitGatheredSource(this.gatherSource(() => this.emitObject(mapKey[i2], mapValue[i2]))));
      }
      emitSourceStructure() {
        if (this.leadingComments !== void 0) {
          this.emitComments(this.leadingComments);
        }
        this.emitImports();
        this.emitSchemas();
      }
    };
    exports.TypeScriptEffectSchemaRenderer = TypeScriptEffectSchemaRenderer;
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/TypeScriptEffectSchema/language.js
var require_language24 = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/TypeScriptEffectSchema/language.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.TypeScriptEffectSchemaTargetLanguage = exports.typeScriptEffectSchemaLanguageConfig = exports.typeScriptEffectSchemaOptions = void 0;
    var RendererOptions_1 = require_RendererOptions();
    var TargetLanguage_1 = require_TargetLanguage();
    var TypeScriptEffectSchemaRenderer_1 = require_TypeScriptEffectSchemaRenderer();
    exports.typeScriptEffectSchemaOptions = {
      justSchema: new RendererOptions_1.BooleanOption("just-schema", "Schema only", false)
    };
    exports.typeScriptEffectSchemaLanguageConfig = {
      displayName: "TypeScript Effect Schema",
      names: [
        "typescript-effect-schema"
      ],
      extension: "ts"
    };
    var TypeScriptEffectSchemaTargetLanguage = class extends TargetLanguage_1.TargetLanguage {
      constructor() {
        super(exports.typeScriptEffectSchemaLanguageConfig);
      }
      getOptions() {
        return {};
      }
      makeRenderer(renderContext, untypedOptionValues) {
        return new TypeScriptEffectSchemaRenderer_1.TypeScriptEffectSchemaRenderer(this, renderContext, (0, RendererOptions_1.getOptionValues)(exports.typeScriptEffectSchemaOptions, untypedOptionValues));
      }
    };
    exports.TypeScriptEffectSchemaTargetLanguage = TypeScriptEffectSchemaTargetLanguage;
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/TypeScriptEffectSchema/index.js
var require_TypeScriptEffectSchema = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/TypeScriptEffectSchema/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.TypeScriptEffectSchemaRenderer = exports.typeScriptEffectSchemaOptions = exports.TypeScriptEffectSchemaTargetLanguage = void 0;
    var language_1 = require_language24();
    Object.defineProperty(exports, "TypeScriptEffectSchemaTargetLanguage", {
      enumerable: true,
      get: function() {
        return language_1.TypeScriptEffectSchemaTargetLanguage;
      }
    });
    Object.defineProperty(exports, "typeScriptEffectSchemaOptions", {
      enumerable: true,
      get: function() {
        return language_1.typeScriptEffectSchemaOptions;
      }
    });
    var TypeScriptEffectSchemaRenderer_1 = require_TypeScriptEffectSchemaRenderer();
    Object.defineProperty(exports, "TypeScriptEffectSchemaRenderer", {
      enumerable: true,
      get: function() {
        return TypeScriptEffectSchemaRenderer_1.TypeScriptEffectSchemaRenderer;
      }
    });
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/TypeScriptFlow/utils.js
var require_utils23 = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/TypeScriptFlow/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.tsFlowTypeAnnotations = void 0;
    exports.quotePropertyName = quotePropertyName;
    var Strings_1 = require_Strings();
    var unicodeMaps_1 = require_unicodeMaps();
    var utils_1 = require_utils11();
    exports.tsFlowTypeAnnotations = {
      any: ": any",
      anyArray: ": any[]",
      anyMap: ": { [k: string]: any }",
      string: ": string",
      stringArray: ": string[]",
      boolean: ": boolean"
    };
    function quotePropertyName(original) {
      const escaped = (0, Strings_1.utf16StringEscape)(original);
      const quoted = `"${escaped}"`;
      if (original.length === 0) {
        return quoted;
      } else if (!(0, unicodeMaps_1.isES3IdentifierStart)(original.codePointAt(0))) {
        return quoted;
      } else if (escaped !== original) {
        return quoted;
      } else if ((0, utils_1.legalizeName)(original) !== original) {
        return quoted;
      } else {
        return original;
      }
    }
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/TypeScriptFlow/TypeScriptFlowBaseRenderer.js
var require_TypeScriptFlowBaseRenderer = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/TypeScriptFlow/TypeScriptFlowBaseRenderer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.TypeScriptFlowBaseRenderer = void 0;
    var Naming_1 = require_Naming();
    var Source_1 = require_Source();
    var Strings_1 = require_Strings();
    var Support_1 = require_Support();
    var Type_1 = require_Type2();
    var TypeUtils_1 = require_TypeUtils();
    var JavaScript_1 = require_JavaScript();
    var utils_1 = require_utils23();
    var TypeScriptFlowBaseRenderer = class extends JavaScript_1.JavaScriptRenderer {
      constructor(targetLanguage, renderContext, _tsFlowOptions) {
        super(targetLanguage, renderContext, _tsFlowOptions);
        this._tsFlowOptions = _tsFlowOptions;
      }
      namerForObjectProperty() {
        if (this._tsFlowOptions.nicePropertyNames) {
          return (0, Naming_1.funPrefixNamer)("properties", (s) => this.nameStyle(s, false));
        }
        return super.namerForObjectProperty();
      }
      sourceFor(t) {
        var _a;
        if (this._tsFlowOptions.preferConstValues && t.kind === "enum" && t instanceof Type_1.EnumType && t.cases.size === 1) {
          const item = (_a = t.cases.values().next().value) !== null && _a !== void 0 ? _a : "";
          return (0, Source_1.singleWord)(`"${(0, Strings_1.utf16StringEscape)(item)}"`);
        }
        if ([
          "class",
          "object",
          "enum"
        ].includes(t.kind)) {
          return (0, Source_1.singleWord)(this.nameForNamedType(t));
        }
        return (0, TypeUtils_1.matchType)(t, (_anyType) => (0, Source_1.singleWord)("any"), (_nullType) => (0, Source_1.singleWord)("null"), (_boolType) => (0, Source_1.singleWord)("boolean"), (_integerType) => (0, Source_1.singleWord)("number"), (_doubleType) => (0, Source_1.singleWord)("number"), (_stringType) => (0, Source_1.singleWord)("string"), (arrayType) => {
          const itemType = this.sourceFor(arrayType.items);
          if (arrayType.items instanceof Type_1.UnionType && !this._tsFlowOptions.declareUnions || arrayType.items instanceof Type_1.ArrayType) {
            return (0, Source_1.singleWord)([
              "Array<",
              itemType.source,
              ">"
            ]);
          }
          return (0, Source_1.singleWord)([
            (0, Source_1.parenIfNeeded)(itemType),
            "[]"
          ]);
        }, (_classType) => (0, Support_1.panic)("We handled this above"), (mapType) => (0, Source_1.singleWord)([
          "{ [key: string]: ",
          this.sourceFor(mapType.values).source,
          " }"
        ]), (_enumType) => (0, Support_1.panic)("We handled this above"), (unionType) => {
          if (!this._tsFlowOptions.declareUnions || (0, TypeUtils_1.nullableFromUnion)(unionType) !== null) {
            const children = Array.from(unionType.getChildren()).map((c) => (0, Source_1.parenIfNeeded)(this.sourceFor(c)));
            return (0, Source_1.multiWord)(" | ", ...children);
          }
          return (0, Source_1.singleWord)(this.nameForNamedType(unionType));
        }, (transformedStringType) => {
          if (transformedStringType.kind === "date-time") {
            return (0, Source_1.singleWord)("Date");
          }
          return (0, Source_1.singleWord)("string");
        });
      }
      emitClassBlockBody(c) {
        this.emitPropertyTable(c, (name, _jsonName, p) => {
          const t = p.type;
          let propertyName = name;
          propertyName = (0, Source_1.modifySource)(utils_1.quotePropertyName, name);
          if (this._tsFlowOptions.readonly) {
            propertyName = (0, Source_1.modifySource)((_propertyName) => `readonly ${_propertyName}`, propertyName);
          }
          return [
            [
              propertyName,
              p.isOptional ? "?" : "",
              ": "
            ],
            [
              this.sourceFor(t).source,
              ";"
            ]
          ];
        });
        const additionalProperties = c.getAdditionalProperties();
        if (additionalProperties) {
          this.emitTable([
            [
              "[property: string]",
              ": ",
              this.sourceFor(additionalProperties).source,
              ";"
            ]
          ]);
        }
      }
      emitClass(c, className) {
        this.emitDescription(this.descriptionForType(c));
        this.emitClassBlock(c, className);
      }
      emitUnion(u, unionName) {
        if (!this._tsFlowOptions.declareUnions) {
          return;
        }
        this.emitDescription(this.descriptionForType(u));
        const children = (0, Source_1.multiWord)(" | ", ...Array.from(u.getChildren()).map((c) => (0, Source_1.parenIfNeeded)(this.sourceFor(c))));
        this.emitLine("export type ", unionName, " = ", children.source, ";");
      }
      emitTypes() {
        this.forEachTopLevel("none", (t, name) => {
          if (!t.isPrimitive()) {
            return;
          }
          this.ensureBlankLine();
          this.emitDescription(this.descriptionForType(t));
          this.emitLine("type ", name, " = ", this.sourceFor(t).source, ";");
        });
        this.forEachNamedType("leading-and-interposing", (c, n) => this.emitClass(c, n), (e, n) => this.emitEnum(e, n), (u, n) => this.emitUnion(u, n));
      }
      emitUsageComments() {
        if (this._tsFlowOptions.justTypes) return;
        super.emitUsageComments();
      }
      deserializerFunctionLine(t, name) {
        const jsonType = this._tsFlowOptions.rawType === "json" ? "string" : "any";
        return [
          "function to",
          name,
          "(json: ",
          jsonType,
          "): ",
          this.sourceFor(t).source
        ];
      }
      serializerFunctionLine(t, name) {
        const camelCaseName = (0, Source_1.modifySource)(Strings_1.camelCase, name);
        const returnType = this._tsFlowOptions.rawType === "json" ? "string" : "any";
        return [
          "function ",
          camelCaseName,
          "ToJson(value: ",
          this.sourceFor(t).source,
          "): ",
          returnType
        ];
      }
      get moduleLine() {
        return void 0;
      }
      get castFunctionLines() {
        return [
          "function cast<T>(val: any, typ: any): T",
          "function uncast<T>(val: T, typ: any): any"
        ];
      }
      get typeAnnotations() {
        throw new Error("not implemented");
      }
      emitConvertModule() {
        if (this._tsFlowOptions.justTypes) return;
        super.emitConvertModule();
      }
      emitConvertModuleHelpers() {
        if (this._tsFlowOptions.justTypes) return;
        super.emitConvertModuleHelpers();
      }
      emitModuleExports() {
        if (this._tsFlowOptions.justTypes) {
          return;
        } else {
          super.emitModuleExports();
        }
      }
    };
    exports.TypeScriptFlowBaseRenderer = TypeScriptFlowBaseRenderer;
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/TypeScriptFlow/FlowRenderer.js
var require_FlowRenderer = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/TypeScriptFlow/FlowRenderer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.FlowRenderer = void 0;
    var Strings_1 = require_Strings();
    var Support_1 = require_Support();
    var TypeScriptFlowBaseRenderer_1 = require_TypeScriptFlowBaseRenderer();
    var utils_1 = require_utils23();
    var FlowRenderer = class extends TypeScriptFlowBaseRenderer_1.TypeScriptFlowBaseRenderer {
      forbiddenNamesForGlobalNamespace() {
        return [
          "Class",
          "Date",
          "Object",
          "String",
          "Array",
          "JSON",
          "Error"
        ];
      }
      get typeAnnotations() {
        return Object.assign({
          never: ""
        }, utils_1.tsFlowTypeAnnotations);
      }
      emitEnum(e, enumName) {
        this.emitDescription(this.descriptionForType(e));
        const lines = [];
        this.forEachEnumCase(e, "none", (_, jsonName) => {
          const maybeOr = lines.length === 0 ? "  " : "| ";
          lines.push([
            maybeOr,
            '"',
            (0, Strings_1.utf16StringEscape)(jsonName),
            '"'
          ]);
        });
        (0, Support_1.defined)(lines[lines.length - 1]).push(";");
        this.emitLine("export type ", enumName, " =");
        this.indent(() => {
          for (const line of lines) {
            this.emitLine(line);
          }
        });
      }
      emitClassBlock(c, className) {
        this.emitBlock([
          "export type ",
          className,
          " = "
        ], ";", () => {
          this.emitClassBlockBody(c);
        });
      }
      emitSourceStructure() {
        this.emitLine("// @flow");
        this.ensureBlankLine();
        super.emitSourceStructure();
      }
    };
    exports.FlowRenderer = FlowRenderer;
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/TypeScriptFlow/TypeScriptRenderer.js
var require_TypeScriptRenderer = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/TypeScriptFlow/TypeScriptRenderer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.TypeScriptRenderer = void 0;
    var Source_1 = require_Source();
    var Strings_1 = require_Strings();
    var TypeUtils_1 = require_TypeUtils();
    var TypeScriptFlowBaseRenderer_1 = require_TypeScriptFlowBaseRenderer();
    var utils_1 = require_utils23();
    var TypeScriptRenderer = class extends TypeScriptFlowBaseRenderer_1.TypeScriptFlowBaseRenderer {
      forbiddenNamesForGlobalNamespace() {
        return [
          "Array",
          "Date"
        ];
      }
      deserializerFunctionLine(t, name) {
        const jsonType = this._tsFlowOptions.rawType === "json" ? "string" : "any";
        return [
          "public static to",
          name,
          "(json: ",
          jsonType,
          "): ",
          this.sourceFor(t).source
        ];
      }
      serializerFunctionLine(t, name) {
        const camelCaseName = (0, Source_1.modifySource)(Strings_1.camelCase, name);
        const returnType = this._tsFlowOptions.rawType === "json" ? "string" : "any";
        return [
          "public static ",
          camelCaseName,
          "ToJson(value: ",
          this.sourceFor(t).source,
          "): ",
          returnType
        ];
      }
      get moduleLine() {
        return "export class Convert";
      }
      get typeAnnotations() {
        return Object.assign({
          never: ": never"
        }, utils_1.tsFlowTypeAnnotations);
      }
      emitModuleExports() {
        return;
      }
      emitUsageImportComment() {
        const topLevelNames = [];
        this.forEachTopLevel("none", (_t, name) => {
          topLevelNames.push(", ", name);
        }, TypeUtils_1.isNamedType);
        this.emitLine("//   import { Convert", topLevelNames, ' } from "./file";');
      }
      emitEnum(e, enumName) {
        this.emitDescription(this.descriptionForType(e));
        if (this._tsFlowOptions.preferConstValues && e.cases.size === 1) return;
        if (this._tsFlowOptions.preferUnions) {
          let items = "";
          e.cases.forEach((item) => {
            if (items === "") {
              items += `"${(0, Strings_1.utf16StringEscape)(item)}"`;
              return;
            }
            items += ` | "${(0, Strings_1.utf16StringEscape)(item)}"`;
          });
          this.emitLine("export type ", enumName, " = ", items, ";");
        } else {
          this.emitBlock([
            "export enum ",
            enumName,
            " "
          ], "", () => {
            this.forEachEnumCase(e, "none", (name, jsonName) => {
              this.emitLine(name, ` = "${(0, Strings_1.utf16StringEscape)(jsonName)}",`);
            });
          });
        }
      }
      emitClassBlock(c, className) {
        this.emitBlock(this._tsFlowOptions.preferTypes ? [
          "export type ",
          className,
          " = "
        ] : [
          "export interface ",
          className,
          " "
        ], "", () => {
          this.emitClassBlockBody(c);
        });
      }
    };
    exports.TypeScriptRenderer = TypeScriptRenderer;
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/TypeScriptFlow/language.js
var require_language25 = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/TypeScriptFlow/language.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.FlowTargetLanguage = exports.flowLanguageConfig = exports.TypeScriptTargetLanguage = exports.typeScriptLanguageConfig = exports.tsFlowOptions = void 0;
    var RendererOptions_1 = require_RendererOptions();
    var TargetLanguage_1 = require_TargetLanguage();
    var JavaScript_1 = require_JavaScript();
    var FlowRenderer_1 = require_FlowRenderer();
    var TypeScriptRenderer_1 = require_TypeScriptRenderer();
    exports.tsFlowOptions = Object.assign({}, JavaScript_1.javaScriptOptions, {
      justTypes: new RendererOptions_1.BooleanOption("just-types", "Interfaces only", false),
      nicePropertyNames: new RendererOptions_1.BooleanOption("nice-property-names", "Transform property names to be JavaScripty", false),
      declareUnions: new RendererOptions_1.BooleanOption("explicit-unions", "Explicitly name unions", false),
      preferUnions: new RendererOptions_1.BooleanOption("prefer-unions", "Use union type instead of enum", false),
      preferTypes: new RendererOptions_1.BooleanOption("prefer-types", "Use types instead of interfaces", false),
      preferConstValues: new RendererOptions_1.BooleanOption("prefer-const-values", "Use string instead of enum for string enums with single value", false),
      readonly: new RendererOptions_1.BooleanOption("readonly", "Use readonly type members", false)
    });
    exports.typeScriptLanguageConfig = {
      displayName: "TypeScript",
      names: [
        "typescript",
        "ts",
        "tsx"
      ],
      extension: "ts"
    };
    var TypeScriptTargetLanguage = class extends TargetLanguage_1.TargetLanguage {
      constructor() {
        super(exports.typeScriptLanguageConfig);
      }
      getOptions() {
        return exports.tsFlowOptions;
      }
      get stringTypeMapping() {
        const mapping = /* @__PURE__ */ new Map();
        const dateTimeType = "date-time";
        mapping.set("date", dateTimeType);
        mapping.set("date-time", dateTimeType);
        return mapping;
      }
      get supportsOptionalClassProperties() {
        return true;
      }
      get supportsFullObjectType() {
        return true;
      }
      makeRenderer(renderContext, untypedOptionValues) {
        return new TypeScriptRenderer_1.TypeScriptRenderer(this, renderContext, (0, RendererOptions_1.getOptionValues)(exports.tsFlowOptions, untypedOptionValues));
      }
    };
    exports.TypeScriptTargetLanguage = TypeScriptTargetLanguage;
    exports.flowLanguageConfig = {
      displayName: "Flow",
      names: [
        "flow"
      ],
      extension: "js"
    };
    var FlowTargetLanguage = class extends TargetLanguage_1.TargetLanguage {
      constructor() {
        super(exports.flowLanguageConfig);
      }
      getOptions() {
        return exports.tsFlowOptions;
      }
      get stringTypeMapping() {
        const mapping = /* @__PURE__ */ new Map();
        const dateTimeType = "date-time";
        mapping.set("date", dateTimeType);
        mapping.set("date-time", dateTimeType);
        return mapping;
      }
      get supportsOptionalClassProperties() {
        return true;
      }
      get supportsFullObjectType() {
        return true;
      }
      makeRenderer(renderContext, untypedOptionValues) {
        return new FlowRenderer_1.FlowRenderer(this, renderContext, (0, RendererOptions_1.getOptionValues)(exports.tsFlowOptions, untypedOptionValues));
      }
    };
    exports.FlowTargetLanguage = FlowTargetLanguage;
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/TypeScriptFlow/index.js
var require_TypeScriptFlow = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/TypeScriptFlow/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.tsFlowOptions = exports.TypeScriptTargetLanguage = exports.FlowTargetLanguage = exports.TypeScriptRenderer = exports.FlowRenderer = void 0;
    var FlowRenderer_1 = require_FlowRenderer();
    Object.defineProperty(exports, "FlowRenderer", {
      enumerable: true,
      get: function() {
        return FlowRenderer_1.FlowRenderer;
      }
    });
    var TypeScriptRenderer_1 = require_TypeScriptRenderer();
    Object.defineProperty(exports, "TypeScriptRenderer", {
      enumerable: true,
      get: function() {
        return TypeScriptRenderer_1.TypeScriptRenderer;
      }
    });
    var language_1 = require_language25();
    Object.defineProperty(exports, "FlowTargetLanguage", {
      enumerable: true,
      get: function() {
        return language_1.FlowTargetLanguage;
      }
    });
    Object.defineProperty(exports, "TypeScriptTargetLanguage", {
      enumerable: true,
      get: function() {
        return language_1.TypeScriptTargetLanguage;
      }
    });
    Object.defineProperty(exports, "tsFlowOptions", {
      enumerable: true,
      get: function() {
        return language_1.tsFlowOptions;
      }
    });
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/TypeScriptZod/TypeScriptZodRenderer.js
var require_TypeScriptZodRenderer = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/TypeScriptZod/TypeScriptZodRenderer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.TypeScriptZodRenderer = void 0;
    var collection_utils_1 = require_dist();
    var ConvenienceRenderer_1 = require_ConvenienceRenderer();
    var Naming_1 = require_Naming();
    var Acronyms_1 = require_Acronyms();
    var Strings_1 = require_Strings();
    var Support_1 = require_Support();
    var Type_1 = require_Type2();
    var TypeUtils_1 = require_TypeUtils();
    var utils_1 = require_utils11();
    var TypeScriptZodRenderer = class _TypeScriptZodRenderer extends ConvenienceRenderer_1.ConvenienceRenderer {
      constructor(targetLanguage, renderContext, _options) {
        super(targetLanguage, renderContext);
        this._options = _options;
      }
      forbiddenNamesForGlobalNamespace() {
        return [
          "Class",
          "Date",
          "Object",
          "String",
          "Array",
          "JSON",
          "Error"
        ];
      }
      nameStyle(original, upper) {
        const acronyms = (0, Acronyms_1.acronymStyle)(Acronyms_1.AcronymStyleOptions.Camel);
        const words = (0, Strings_1.splitIntoWords)(original);
        return (0, Strings_1.combineWords)(words, utils_1.legalizeName, upper ? Strings_1.firstUpperWordStyle : Strings_1.allLowerWordStyle, Strings_1.firstUpperWordStyle, upper ? (s) => (0, Strings_1.capitalize)(acronyms(s)) : Strings_1.allLowerWordStyle, acronyms, "", Strings_1.isLetterOrUnderscore);
      }
      makeNamedTypeNamer() {
        return (0, Naming_1.funPrefixNamer)("types", (s) => this.nameStyle(s, true));
      }
      makeUnionMemberNamer() {
        return (0, Naming_1.funPrefixNamer)("properties", (s) => this.nameStyle(s, true));
      }
      namerForObjectProperty() {
        return (0, Naming_1.funPrefixNamer)("properties", (s) => this.nameStyle(s, true));
      }
      makeEnumCaseNamer() {
        return (0, Naming_1.funPrefixNamer)("enum-cases", (s) => this.nameStyle(s, false));
      }
      importStatement(lhs, moduleName) {
        return [
          "import ",
          lhs,
          " from ",
          moduleName,
          ";"
        ];
      }
      emitImports() {
        this.ensureBlankLine();
        this.emitLine(this.importStatement("* as z", '"zod"'));
      }
      typeMapTypeForProperty(p) {
        const typeMap = this.typeMapTypeFor(p.type);
        return p.isOptional ? [
          typeMap,
          ".optional()"
        ] : typeMap;
      }
      typeMapTypeFor(t, required = true) {
        if ([
          "class",
          "object",
          "enum"
        ].includes(t.kind)) {
          return [
            this.nameForNamedType(t),
            "Schema"
          ];
        }
        const match2 = (0, TypeUtils_1.matchType)(t, (_anyType) => "z.any()", (_nullType) => "z.null()", (_boolType) => "z.boolean()", (_integerType) => "z.number()", (_doubleType) => "z.number()", (_stringType) => "z.string()", (arrayType) => [
          "z.array(",
          this.typeMapTypeFor(arrayType.items, false),
          ")"
        ], (_classType) => (0, Support_1.panic)("Should already be handled."), (_mapType) => [
          "z.record(z.string(), ",
          this.typeMapTypeFor(_mapType.values, false),
          ")"
        ], (_enumType) => (0, Support_1.panic)("Should already be handled."), (unionType) => {
          const children = Array.from(unionType.getChildren()).map((type) => this.typeMapTypeFor(type, false));
          return [
            "z.union([",
            ...(0, collection_utils_1.arrayIntercalate)(", ", children),
            "])"
          ];
        }, (_transformedStringType) => {
          if (_transformedStringType.kind === "date-time") {
            return "z.coerce.date()";
          }
          return "z.string()";
        });
        if (required) {
          return [
            match2
          ];
        }
        return match2;
      }
      emitObject(name, t) {
        this.ensureBlankLine();
        this.emitLine("\nexport const ", name, "Schema = ", "z.object({");
        this.indent(() => {
          this.forEachClassProperty(t, "none", (_, jsonName, property) => {
            this.emitLine(`"${(0, Strings_1.utf16StringEscape)(jsonName)}"`, ": ", this.typeMapTypeForProperty(property), ",");
          });
        });
        this.emitLine("});");
        if (!this._options.justSchema) {
          this.emitLine("export type ", name, " = z.infer<typeof ", name, "Schema>;");
        }
      }
      emitEnum(e, enumName) {
        this.ensureBlankLine();
        this.emitDescription(this.descriptionForType(e));
        this.emitLine("\nexport const ", enumName, "Schema = ", "z.enum([");
        this.indent(() => this.forEachEnumCase(e, "none", (_, jsonName) => {
          this.emitLine('"', (0, Strings_1.stringEscape)(jsonName), '",');
        }));
        this.emitLine("]);");
        if (!this._options.justSchema) {
          this.emitLine("export type ", enumName, " = z.infer<typeof ", enumName, "Schema>;");
        }
      }
      /** Static function that extracts underlying type refs for types that form part of the
         * definition of the passed type - used to ensure that these appear in generated source
         * before types that reference them.
         *
         * Primitive types don't need defining and enums are output before other types, hence,
         * these are ignored.
         */
      static extractUnderlyingTyperefs(type) {
        const typeRefs = [];
        if (!type.isPrimitive() && type.kind !== "enum") {
          if (type instanceof Type_1.SetOperationType) {
            type.members.forEach((member) => {
              typeRefs.push(..._TypeScriptZodRenderer.extractUnderlyingTyperefs(member));
            });
          }
          if (type instanceof Type_1.ObjectType) {
            const addType = type.getAdditionalProperties();
            if (addType) {
              typeRefs.push(..._TypeScriptZodRenderer.extractUnderlyingTyperefs(addType));
            }
          }
          if (type instanceof Type_1.ArrayType) {
            const itemsType = type.items;
            if (itemsType) {
              typeRefs.push(..._TypeScriptZodRenderer.extractUnderlyingTyperefs(itemsType));
            }
          }
          if (type instanceof Type_1.ClassType) {
            typeRefs.push(type.typeRef);
          }
        }
        return typeRefs;
      }
      emitSchemas() {
        this.ensureBlankLine();
        this.forEachEnum("leading-and-interposing", (u, enumName) => {
          this.emitEnum(u, enumName);
        });
        const order = [];
        const mapType = [];
        const mapTypeRef = [];
        const mapName = [];
        const mapChildTypeRefs = [];
        this.forEachObject("none", (type, name) => {
          mapType.push(type);
          mapTypeRef.push(type.typeRef);
          mapName.push(name);
          const children = type.getChildren();
          let childTypeRefs = [];
          children.forEach((child) => {
            childTypeRefs = childTypeRefs.concat(_TypeScriptZodRenderer.extractUnderlyingTyperefs(child));
          });
          mapChildTypeRefs.push(childTypeRefs);
        });
        let indices = [];
        mapType.forEach((_, index) => {
          indices.push(index);
        });
        let deferredIndices = [];
        const MAX_PASSES = 999;
        let passNum = 0;
        do {
          indices.forEach((index) => {
            const childTypeRefs = mapChildTypeRefs[index];
            let foundAllChildren = true;
            childTypeRefs.forEach((childRef) => {
              if (mapTypeRef.includes(childRef)) {
                let found = false;
                for (let j = 0; j < order.length; j++) {
                  const childIndex = order[j];
                  if (mapTypeRef[childIndex] === childRef) {
                    found = true;
                    break;
                  }
                }
                foundAllChildren = foundAllChildren && found;
              } else {
                console.error("A child type reference was not found amongst all Object definitions! TypeRef: " + childRef);
              }
            });
            if (foundAllChildren) {
              order.push(index);
            } else {
              deferredIndices.push(index);
            }
          });
          indices = deferredIndices;
          deferredIndices = [];
          passNum++;
          if (passNum > MAX_PASSES) {
            order.push(...deferredIndices);
            console.warn("Exceeded maximum number of passes when determining output order, output may contain forward references");
          }
        } while (indices.length > 0 && passNum <= MAX_PASSES);
        order.forEach((i2) => this.emitGatheredSource(this.gatherSource(() => this.emitObject(mapName[i2], mapType[i2]))));
      }
      emitSourceStructure() {
        if (this.leadingComments !== void 0) {
          this.emitComments(this.leadingComments);
        }
        this.emitImports();
        this.emitSchemas();
      }
    };
    exports.TypeScriptZodRenderer = TypeScriptZodRenderer;
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/TypeScriptZod/language.js
var require_language26 = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/TypeScriptZod/language.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.TypeScriptZodTargetLanguage = exports.typeScriptZodLanguageConfig = exports.typeScriptZodOptions = void 0;
    var RendererOptions_1 = require_RendererOptions();
    var TargetLanguage_1 = require_TargetLanguage();
    var TypeScriptZodRenderer_1 = require_TypeScriptZodRenderer();
    exports.typeScriptZodOptions = {
      justSchema: new RendererOptions_1.BooleanOption("just-schema", "Schema only", false)
    };
    exports.typeScriptZodLanguageConfig = {
      displayName: "TypeScript Zod",
      names: [
        "typescript-zod"
      ],
      extension: "ts"
    };
    var TypeScriptZodTargetLanguage = class extends TargetLanguage_1.TargetLanguage {
      constructor() {
        super(exports.typeScriptZodLanguageConfig);
      }
      getOptions() {
        return {};
      }
      get stringTypeMapping() {
        const mapping = /* @__PURE__ */ new Map();
        const dateTimeType = "date-time";
        mapping.set("date-time", dateTimeType);
        return mapping;
      }
      get supportsOptionalClassProperties() {
        return true;
      }
      makeRenderer(renderContext, untypedOptionValues) {
        return new TypeScriptZodRenderer_1.TypeScriptZodRenderer(this, renderContext, (0, RendererOptions_1.getOptionValues)(exports.typeScriptZodOptions, untypedOptionValues));
      }
    };
    exports.TypeScriptZodTargetLanguage = TypeScriptZodTargetLanguage;
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/TypeScriptZod/index.js
var require_TypeScriptZod = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/TypeScriptZod/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.TypeScriptZodRenderer = exports.typeScriptZodOptions = exports.TypeScriptZodTargetLanguage = void 0;
    var language_1 = require_language26();
    Object.defineProperty(exports, "TypeScriptZodTargetLanguage", {
      enumerable: true,
      get: function() {
        return language_1.TypeScriptZodTargetLanguage;
      }
    });
    Object.defineProperty(exports, "typeScriptZodOptions", {
      enumerable: true,
      get: function() {
        return language_1.typeScriptZodOptions;
      }
    });
    var TypeScriptZodRenderer_1 = require_TypeScriptZodRenderer();
    Object.defineProperty(exports, "TypeScriptZodRenderer", {
      enumerable: true,
      get: function() {
        return TypeScriptZodRenderer_1.TypeScriptZodRenderer;
      }
    });
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/All.js
var require_All = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/All.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.all = void 0;
    exports.languageNamed = languageNamed;
    exports.isLanguageName = isLanguageName;
    exports.isLanguageDisplayName = isLanguageDisplayName;
    var CJSON_1 = require_CJSON();
    var CPlusPlus_1 = require_CPlusPlus();
    var Crystal_1 = require_Crystal();
    var CSharp_1 = require_CSharp();
    var Dart_1 = require_Dart();
    var Elixir_1 = require_Elixir();
    var Elm_1 = require_Elm();
    var Golang_1 = require_Golang();
    var Haskell_1 = require_Haskell();
    var Java_1 = require_Java();
    var JavaScript_1 = require_JavaScript();
    var JavaScriptPropTypes_1 = require_JavaScriptPropTypes();
    var JSONSchema_1 = require_JSONSchema();
    var Kotlin_1 = require_Kotlin();
    var Objective_C_1 = require_Objective_C();
    var Php_1 = require_Php();
    var Pike_1 = require_Pike();
    var Python_1 = require_Python();
    var Ruby_1 = require_Ruby();
    var Rust_1 = require_Rust();
    var Scala3_1 = require_Scala3();
    var Smithy4s_1 = require_Smithy4s();
    var Swift_1 = require_Swift();
    var TypeScriptEffectSchema_1 = require_TypeScriptEffectSchema();
    var TypeScriptFlow_1 = require_TypeScriptFlow();
    var TypeScriptZod_1 = require_TypeScriptZod();
    exports.all = [
      new CJSON_1.CJSONTargetLanguage(),
      new CPlusPlus_1.CPlusPlusTargetLanguage(),
      new Crystal_1.CrystalTargetLanguage(),
      new CSharp_1.CSharpTargetLanguage(),
      new Dart_1.DartTargetLanguage(),
      new Elixir_1.ElixirTargetLanguage(),
      new Elm_1.ElmTargetLanguage(),
      new TypeScriptFlow_1.FlowTargetLanguage(),
      new Golang_1.GoTargetLanguage(),
      new Haskell_1.HaskellTargetLanguage(),
      new Java_1.JavaTargetLanguage(),
      new JavaScript_1.JavaScriptTargetLanguage(),
      new JavaScriptPropTypes_1.JavaScriptPropTypesTargetLanguage(),
      new JSONSchema_1.JSONSchemaTargetLanguage(),
      new Kotlin_1.KotlinTargetLanguage(),
      new Objective_C_1.ObjectiveCTargetLanguage(),
      new Php_1.PhpTargetLanguage(),
      new Pike_1.PikeTargetLanguage(),
      new Python_1.PythonTargetLanguage(),
      new Ruby_1.RubyTargetLanguage(),
      new Rust_1.RustTargetLanguage(),
      new Scala3_1.Scala3TargetLanguage(),
      new Smithy4s_1.SmithyTargetLanguage(),
      new Swift_1.SwiftTargetLanguage(),
      new TypeScriptFlow_1.TypeScriptTargetLanguage(),
      new TypeScriptEffectSchema_1.TypeScriptEffectSchemaTargetLanguage(),
      new TypeScriptZod_1.TypeScriptZodTargetLanguage()
    ];
    exports.all;
    function languageNamed(name, targetLanguages = exports.all) {
      const foundLanguage = targetLanguages.find((language) => language.names.includes(name));
      if (!foundLanguage) {
        throw new Error(`Unknown language name: ${name}`);
      }
      return foundLanguage;
    }
    function isLanguageName(maybeName) {
      if (exports.all.some((lang) => lang.names.includes(maybeName))) {
        return true;
      }
      return false;
    }
    function isLanguageDisplayName(maybeName) {
      if (exports.all.some((lang) => lang.displayName === maybeName)) {
        return true;
      }
      return false;
    }
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/input/CompressedJSON.js
var require_CompressedJSON = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/input/CompressedJSON.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.CompressedJSONFromString = exports.CompressedJSON = exports.Tag = void 0;
    exports.makeValue = makeValue;
    exports.valueTag = valueTag;
    var collection_utils_1 = require_dist();
    var StringTypes_1 = require_StringTypes();
    var Support_1 = require_Support();
    var Type_1 = require_Type2();
    var Tag;
    (function(Tag2) {
      Tag2[Tag2["Null"] = 1] = "Null";
      Tag2[Tag2["False"] = 2] = "False";
      Tag2[Tag2["True"] = 3] = "True";
      Tag2[Tag2["Integer"] = 4] = "Integer";
      Tag2[Tag2["Double"] = 5] = "Double";
      Tag2[Tag2["InternedString"] = 6] = "InternedString";
      Tag2[Tag2["UninternedString"] = 7] = "UninternedString";
      Tag2[Tag2["Object"] = 8] = "Object";
      Tag2[Tag2["Array"] = 9] = "Array";
      Tag2[Tag2["StringFormat"] = 10] = "StringFormat";
      Tag2[Tag2["TransformedString"] = 11] = "TransformedString";
    })(Tag || (exports.Tag = Tag = {}));
    var TAG_BITS = 4;
    var TAG_MASK = (1 << TAG_BITS) - 1;
    function makeValue(t, index) {
      return t | index << TAG_BITS;
    }
    function getIndex(v, tag) {
      (0, Support_1.assert)(valueTag(v) === tag, "Trying to get index for value with invalid tag");
      return v >> TAG_BITS;
    }
    function valueTag(v) {
      return v & TAG_MASK;
    }
    var CompressedJSON = class {
      constructor(dateTimeRecognizer, handleRefs) {
        this.dateTimeRecognizer = dateTimeRecognizer;
        this.handleRefs = handleRefs;
        this._contextStack = [];
        this._strings = [];
        this._stringIndexes = {};
        this._objects = [];
        this._arrays = [];
        this.getObjectForValue = (v) => {
          return this._objects[getIndex(v, Tag.Object)];
        };
        this.getArrayForValue = (v) => {
          return this._arrays[getIndex(v, Tag.Array)];
        };
        this.internArray = (arr) => {
          const index = this._arrays.length;
          this._arrays.push(arr);
          return makeValue(Tag.Array, index);
        };
      }
      parseSync(_input) {
        return (0, Support_1.panic)("parseSync not implemented in CompressedJSON");
      }
      getStringForValue(v) {
        const tag = valueTag(v);
        (0, Support_1.assert)(tag === Tag.InternedString || tag === Tag.TransformedString);
        return this._strings[getIndex(v, tag)];
      }
      getStringFormatTypeKind(v) {
        const kind = this._strings[getIndex(v, Tag.StringFormat)];
        if (!(0, Type_1.isPrimitiveStringTypeKind)(kind) || kind === "string") {
          return (0, Support_1.panic)("Not a transformed string type kind");
        }
        return kind;
      }
      get context() {
        return (0, Support_1.defined)(this._ctx);
      }
      internString(s) {
        if (Object.prototype.hasOwnProperty.call(this._stringIndexes, s)) {
          return this._stringIndexes[s];
        }
        const index = this._strings.length;
        this._strings.push(s);
        this._stringIndexes[s] = index;
        return index;
      }
      makeString(s) {
        const value = makeValue(Tag.InternedString, this.internString(s));
        (0, Support_1.assert)(typeof value === "number", `Interned string value is not a number: ${value}`);
        return value;
      }
      internObject(obj2) {
        const index = this._objects.length;
        this._objects.push(obj2);
        return makeValue(Tag.Object, index);
      }
      get isExpectingRef() {
        return this._ctx !== void 0 && this._ctx.currentKey === "$ref";
      }
      commitValue(value) {
        (0, Support_1.assert)(typeof value === "number", `CompressedJSON value is not a number: ${value}`);
        if (this._ctx === void 0) {
          (0, Support_1.assert)(this._rootValue === void 0, "Committing value but nowhere to commit to - root value still there.");
          this._rootValue = value;
        } else if (this._ctx.currentObject !== void 0) {
          if (this._ctx.currentKey === void 0) {
            return (0, Support_1.panic)("Must have key and can't have string when committing");
          }
          this._ctx.currentObject.push(this.makeString(this._ctx.currentKey), value);
          this._ctx.currentKey = void 0;
        } else if (this._ctx.currentArray !== void 0) {
          this._ctx.currentArray.push(value);
        } else {
          return (0, Support_1.panic)("Committing value but nowhere to commit to");
        }
      }
      commitNull() {
        this.commitValue(makeValue(Tag.Null, 0));
      }
      commitBoolean(v) {
        this.commitValue(makeValue(v ? Tag.True : Tag.False, 0));
      }
      commitNumber(isDouble) {
        const numberTag = isDouble ? Tag.Double : Tag.Integer;
        this.commitValue(makeValue(numberTag, 0));
      }
      commitString(s) {
        let value = void 0;
        if (this.handleRefs && this.isExpectingRef) {
          value = this.makeString(s);
        } else {
          const format = (0, StringTypes_1.inferTransformedStringTypeKindForString)(s, this.dateTimeRecognizer);
          if (format !== void 0) {
            if ((0, Support_1.defined)(Type_1.transformedStringTypeTargetTypeKindsMap.get(format)).attributesProducer !== void 0) {
              value = makeValue(Tag.TransformedString, this.internString(s));
            } else {
              value = makeValue(Tag.StringFormat, this.internString(format));
            }
          } else if (s.length <= 64) {
            value = this.makeString(s);
          } else {
            value = makeValue(Tag.UninternedString, 0);
          }
        }
        this.commitValue(value);
      }
      finish() {
        const value = this._rootValue;
        if (value === void 0) {
          return (0, Support_1.panic)("Finished without root document");
        }
        (0, Support_1.assert)(this._ctx === void 0 && this._contextStack.length === 0, "Finished with contexts present");
        this._rootValue = void 0;
        return value;
      }
      pushContext() {
        if (this._ctx !== void 0) {
          this._contextStack.push(this._ctx);
        }
        this._ctx = {
          currentObject: void 0,
          currentArray: void 0,
          currentKey: void 0,
          currentNumberIsDouble: false
        };
      }
      pushObjectContext() {
        this.pushContext();
        (0, Support_1.defined)(this._ctx).currentObject = [];
      }
      setPropertyKey(key) {
        const ctx = this.context;
        ctx.currentKey = key;
      }
      finishObject() {
        const obj2 = this.context.currentObject;
        if (obj2 === void 0) {
          return (0, Support_1.panic)("Object ended but not started");
        }
        this.popContext();
        this.commitValue(this.internObject(obj2));
      }
      pushArrayContext() {
        this.pushContext();
        (0, Support_1.defined)(this._ctx).currentArray = [];
      }
      finishArray() {
        const arr = this.context.currentArray;
        if (arr === void 0) {
          return (0, Support_1.panic)("Array ended but not started");
        }
        this.popContext();
        this.commitValue(this.internArray(arr));
      }
      popContext() {
        (0, Support_1.assert)(this._ctx !== void 0, "Popping context when there isn't one");
        this._ctx = this._contextStack.pop();
      }
      equals(other) {
        return this === other;
      }
      hashCode() {
        let hashAccumulator = collection_utils_1.hashCodeInit;
        for (const s of this._strings) {
          hashAccumulator = (0, collection_utils_1.addHashCode)(hashAccumulator, (0, collection_utils_1.hashString)(s));
        }
        for (const s of Object.getOwnPropertyNames(this._stringIndexes).sort()) {
          hashAccumulator = (0, collection_utils_1.addHashCode)(hashAccumulator, (0, collection_utils_1.hashString)(s));
          hashAccumulator = (0, collection_utils_1.addHashCode)(hashAccumulator, this._stringIndexes[s]);
        }
        for (const o of this._objects) {
          for (const v of o) {
            hashAccumulator = (0, collection_utils_1.addHashCode)(hashAccumulator, v);
          }
        }
        for (const o of this._arrays) {
          for (const v of o) {
            hashAccumulator = (0, collection_utils_1.addHashCode)(hashAccumulator, v);
          }
        }
        return hashAccumulator;
      }
    };
    exports.CompressedJSON = CompressedJSON;
    var CompressedJSONFromString = class extends CompressedJSON {
      parse(input) {
        return __awaiter(this, void 0, void 0, function* () {
          return this.parseSync(input);
        });
      }
      parseSync(input) {
        const json = JSON.parse(input);
        this.process(json);
        return this.finish();
      }
      process(json) {
        if (json === null) {
          this.commitNull();
        } else if (typeof json === "boolean") {
          this.commitBoolean(json);
        } else if (typeof json === "string") {
          this.commitString(json);
        } else if (typeof json === "number") {
          const isDouble = json !== Math.floor(json) || json < Number.MIN_SAFE_INTEGER || json > Number.MAX_SAFE_INTEGER;
          this.commitNumber(isDouble);
        } else if (Array.isArray(json)) {
          this.pushArrayContext();
          for (const v of json) {
            this.process(v);
          }
          this.finishArray();
        } else if (typeof json === "object") {
          this.pushObjectContext();
          for (const key of Object.getOwnPropertyNames(json)) {
            this.setPropertyKey(key);
            this.process(json[key]);
          }
          this.finishObject();
        } else {
          return (0, Support_1.panic)("Invalid JSON object");
        }
      }
    };
    exports.CompressedJSONFromString = CompressedJSONFromString;
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/UnionBuilder.js
var require_UnionBuilder = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/UnionBuilder.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.UnionBuilder = exports.TypeRefUnionAccumulator = exports.UnionAccumulator = void 0;
    var collection_utils_1 = require_dist();
    var StringTypes_1 = require_StringTypes();
    var TypeAttributes_1 = require_TypeAttributes();
    var Support_1 = require_Support();
    var Type_1 = require_Type2();
    var TypeUtils_1 = require_TypeUtils();
    function addAttributes(accumulatorAttributes, newAttributes) {
      if (accumulatorAttributes === void 0) return newAttributes;
      return (0, TypeAttributes_1.combineTypeAttributes)("union", accumulatorAttributes, newAttributes);
    }
    function setAttributes(attributeMap, kind, newAttributes) {
      attributeMap.set(kind, addAttributes(attributeMap.get(kind), newAttributes));
    }
    function addAttributesToBuilder(builder, kind, newAttributes) {
      let arr = builder.get(kind);
      if (arr === void 0) {
        arr = [];
        builder.set(kind, arr);
      }
      arr.push(newAttributes);
    }
    function buildTypeAttributeMap(builder) {
      return (0, collection_utils_1.mapMap)(builder, (arr) => (0, TypeAttributes_1.combineTypeAttributes)("union", arr));
    }
    function moveAttributes(map, fromKind, toKind) {
      const fromAttributes = (0, Support_1.defined)(map.get(fromKind));
      map.delete(fromKind);
      setAttributes(map, toKind, fromAttributes);
    }
    var UnionAccumulator = class {
      constructor(_conflateNumbers) {
        this._conflateNumbers = _conflateNumbers;
        this._nonStringTypeAttributes = /* @__PURE__ */ new Map();
        this._stringTypeAttributes = /* @__PURE__ */ new Map();
        this.arrayData = [];
        this.objectData = [];
        this._enumCases = /* @__PURE__ */ new Set();
        this._lostTypeAttributes = false;
      }
      have(kind) {
        return this._nonStringTypeAttributes.has(kind) || this._stringTypeAttributes.has(kind);
      }
      addNone(_attributes) {
        this._lostTypeAttributes = true;
      }
      addAny(attributes) {
        addAttributesToBuilder(this._nonStringTypeAttributes, "any", attributes);
        this._lostTypeAttributes = true;
      }
      addPrimitive(kind, attributes) {
        (0, Support_1.assert)(kind !== "any", "any must be added with addAny");
        addAttributesToBuilder(this._nonStringTypeAttributes, kind, attributes);
      }
      addFullStringType(attributes, stringTypes) {
        let stringTypesAttributes = void 0;
        if (stringTypes === void 0) {
          stringTypes = StringTypes_1.stringTypesTypeAttributeKind.tryGetInAttributes(attributes);
        } else {
          stringTypesAttributes = StringTypes_1.stringTypesTypeAttributeKind.makeAttributes(stringTypes);
        }
        if (stringTypes === void 0) {
          stringTypes = StringTypes_1.StringTypes.unrestricted;
          stringTypesAttributes = StringTypes_1.stringTypesTypeAttributeKind.makeAttributes(stringTypes);
        }
        const maybeEnumAttributes = this._nonStringTypeAttributes.get("enum");
        if (stringTypes.isRestricted) {
          (0, Support_1.assert)(maybeEnumAttributes === void 0, "We can't add both an enum as well as a restricted string type to a union builder");
        }
        addAttributesToBuilder(this._stringTypeAttributes, "string", attributes);
        if (stringTypesAttributes !== void 0) {
          addAttributesToBuilder(this._stringTypeAttributes, "string", stringTypesAttributes);
        }
      }
      addStringType(kind, attributes, stringTypes) {
        if (kind === "string") {
          this.addFullStringType(attributes, stringTypes);
          return;
        }
        addAttributesToBuilder(this._stringTypeAttributes, kind, attributes);
        if (stringTypes !== void 0) {
          addAttributesToBuilder(this._stringTypeAttributes, kind, StringTypes_1.stringTypesTypeAttributeKind.makeAttributes(stringTypes));
        }
      }
      addArray(t, attributes) {
        this.arrayData.push(t);
        addAttributesToBuilder(this._nonStringTypeAttributes, "array", attributes);
      }
      addObject(t, attributes) {
        this.objectData.push(t);
        addAttributesToBuilder(this._nonStringTypeAttributes, "object", attributes);
      }
      addEnum(cases, attributes) {
        const maybeStringAttributes = this._stringTypeAttributes.get("string");
        if (maybeStringAttributes !== void 0) {
          addAttributesToBuilder(this._stringTypeAttributes, "string", attributes);
          return;
        }
        addAttributesToBuilder(this._nonStringTypeAttributes, "enum", attributes);
        (0, collection_utils_1.setUnionInto)(this._enumCases, cases);
      }
      addStringCases(cases, attributes) {
        this.addFullStringType(attributes, StringTypes_1.StringTypes.fromCases(cases));
      }
      addStringCase(s, count, attributes) {
        this.addFullStringType(attributes, StringTypes_1.StringTypes.fromCase(s, count));
      }
      get enumCases() {
        return this._enumCases;
      }
      getMemberKinds() {
        (0, Support_1.assert)(!(this.have("enum") && this.have("string")), "We can't have both strings and enums in the same union");
        const merged = (0, collection_utils_1.mapMerge)(buildTypeAttributeMap(this._nonStringTypeAttributes), buildTypeAttributeMap(this._stringTypeAttributes));
        if (merged.size === 0) {
          return /* @__PURE__ */ new Map([
            [
              "none",
              TypeAttributes_1.emptyTypeAttributes
            ]
          ]);
        }
        if (this._nonStringTypeAttributes.has("any")) {
          (0, Support_1.assert)(this._lostTypeAttributes, "This had to be set when we added 'any'");
          const allAttributes = (0, TypeAttributes_1.combineTypeAttributes)("union", Array.from(merged.values()));
          return /* @__PURE__ */ new Map([
            [
              "any",
              allAttributes
            ]
          ]);
        }
        if (this._conflateNumbers && this.have("integer") && this.have("double")) {
          moveAttributes(merged, "integer", "double");
        }
        if (this.have("map")) {
          moveAttributes(merged, "map", "class");
        }
        return merged;
      }
      get lostTypeAttributes() {
        return this._lostTypeAttributes;
      }
    };
    exports.UnionAccumulator = UnionAccumulator;
    var FauxUnion = class {
      getAttributes() {
        return TypeAttributes_1.emptyTypeAttributes;
      }
    };
    function attributesForTypes(types) {
      const unionsForType = /* @__PURE__ */ new Map();
      const typesForUnion = /* @__PURE__ */ new Map();
      const unions = /* @__PURE__ */ new Set();
      let unionsEquivalentToRoot = /* @__PURE__ */ new Set();
      function traverse(t, path2, isEquivalentToRoot) {
        if (t instanceof Type_1.UnionType) {
          unions.add(t);
          if (isEquivalentToRoot) {
            unionsEquivalentToRoot = unionsEquivalentToRoot.add(t);
          }
          isEquivalentToRoot = isEquivalentToRoot && t.members.size === 1;
          path2.push(t);
          for (const m of t.members) {
            traverse(m, path2, isEquivalentToRoot);
          }
          path2.pop();
        } else {
          (0, collection_utils_1.mapUpdateInto)(unionsForType, t, (s) => s === void 0 ? new Set(path2) : (0, collection_utils_1.setUnionInto)(s, path2));
          for (const u of path2) {
            (0, collection_utils_1.mapUpdateInto)(typesForUnion, u, (s) => s === void 0 ? /* @__PURE__ */ new Set([
              t
            ]) : s.add(t));
          }
        }
      }
      const rootPath = [
        new FauxUnion()
      ];
      const typesArray = Array.from(types);
      for (const t of typesArray) {
        traverse(t, rootPath, typesArray.length === 1);
      }
      const resultAttributes = (0, collection_utils_1.mapMap)(unionsForType, (unionForType, t) => {
        const singleAncestors = Array.from(unionForType).filter((u) => (0, Support_1.defined)(typesForUnion.get(u)).size === 1);
        (0, Support_1.assert)(singleAncestors.every((u) => (0, Support_1.defined)(typesForUnion.get(u)).has(t)), "We messed up bookkeeping");
        const inheritedAttributes = singleAncestors.map((u) => u.getAttributes());
        return (0, TypeAttributes_1.combineTypeAttributes)("union", [
          t.getAttributes()
        ].concat(inheritedAttributes));
      });
      const unionAttributes = Array.from(unions).map((u) => {
        const t = typesForUnion.get(u);
        if (t !== void 0 && t.size === 1) {
          return TypeAttributes_1.emptyTypeAttributes;
        }
        const attributes = u.getAttributes();
        if (unionsEquivalentToRoot.has(u)) {
          return attributes;
        }
        return (0, TypeAttributes_1.makeTypeAttributesInferred)(attributes);
      });
      return [
        resultAttributes,
        (0, TypeAttributes_1.combineTypeAttributes)("union", unionAttributes)
      ];
    }
    var TypeRefUnionAccumulator = class extends UnionAccumulator {
      // There is a method analogous to this in the IntersectionAccumulator.  It might
      // make sense to find a common interface.
      addType(t, attributes) {
        (0, TypeUtils_1.matchTypeExhaustive)(
          t,
          (_noneType) => this.addNone(attributes),
          (_anyType) => this.addAny(attributes),
          (_nullType) => this.addPrimitive("null", attributes),
          (_boolType) => this.addPrimitive("bool", attributes),
          (_integerType) => this.addPrimitive("integer", attributes),
          (_doubleType) => this.addPrimitive("double", attributes),
          (_stringType) => this.addStringType("string", attributes),
          (arrayType) => this.addArray(arrayType.items.typeRef, attributes),
          (classType) => this.addObject(classType.typeRef, attributes),
          (mapType) => this.addObject(mapType.typeRef, attributes),
          (objectType) => this.addObject(objectType.typeRef, attributes),
          // FIXME: We're not carrying counts, so this is not correct if we do enum
          // inference.  JSON Schema input uses this case, however, without enum
          // inference, which is fine, but still a bit ugly.
          (enumType) => this.addEnum(enumType.cases, attributes),
          (_unionType) => {
            return (0, Support_1.panic)("The unions should have been eliminated in attributesForTypesInUnion");
          },
          (transformedStringType) => this.addStringType(transformedStringType.kind, attributes)
        );
      }
      addTypes(types) {
        const [attributesMap, unionAttributes] = attributesForTypes(types);
        for (const [t, attributes] of attributesMap) {
          this.addType(t, attributes);
        }
        return unionAttributes;
      }
    };
    exports.TypeRefUnionAccumulator = TypeRefUnionAccumulator;
    var UnionBuilder = class {
      constructor(typeBuilder) {
        this.typeBuilder = typeBuilder;
      }
      makeTypeOfKind(typeProvider, kind, typeAttributes, forwardingRef) {
        switch (kind) {
          case "string":
            return this.typeBuilder.getStringType(typeAttributes, void 0, forwardingRef);
          case "enum":
            return this.typeBuilder.getEnumType(typeAttributes, typeProvider.enumCases, forwardingRef);
          case "object":
            return this.makeObject(typeProvider.objectData, typeAttributes, forwardingRef);
          case "array":
            return this.makeArray(typeProvider.arrayData, typeAttributes, forwardingRef);
          default:
            if ((0, Type_1.isPrimitiveTypeKind)(kind)) {
              return this.typeBuilder.getPrimitiveType(kind, typeAttributes, forwardingRef);
            }
            if (kind === "union" || kind === "class" || kind === "map" || kind === "intersection") {
              return (0, Support_1.panic)(`getMemberKinds() shouldn't return ${kind}`);
            }
            return (0, Support_1.assertNever)(kind);
        }
      }
      buildUnion(typeProvider, unique, typeAttributes, forwardingRef) {
        const kinds = typeProvider.getMemberKinds();
        if (typeProvider.lostTypeAttributes) {
          this.typeBuilder.setLostTypeAttributes();
        }
        if (kinds.size === 1) {
          const [[kind, memberAttributes]] = Array.from(kinds);
          const allAttributes = (0, TypeAttributes_1.combineTypeAttributes)("union", typeAttributes, (0, TypeAttributes_1.increaseTypeAttributesDistance)(memberAttributes));
          const t = this.makeTypeOfKind(typeProvider, kind, allAttributes, forwardingRef);
          return t;
        }
        const union = unique ? this.typeBuilder.getUniqueUnionType(typeAttributes, void 0, forwardingRef) : void 0;
        const types = [];
        for (const [kind, memberAttributes] of kinds) {
          types.push(this.makeTypeOfKind(typeProvider, kind, memberAttributes, void 0));
        }
        const typesSet = new Set(types);
        if (union !== void 0) {
          this.typeBuilder.setSetOperationMembers(union, typesSet);
          return union;
        } else {
          return this.typeBuilder.getUnionType(typeAttributes, typesSet, forwardingRef);
        }
      }
    };
    exports.UnionBuilder = UnionBuilder;
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/input/Inference.js
var require_Inference = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/input/Inference.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.TypeInference = void 0;
    var StringTypes_1 = require_StringTypes();
    var TypeAttributes_1 = require_TypeAttributes();
    var Messages_1 = require_Messages();
    var Support_1 = require_Support();
    var Type_1 = require_Type2();
    var TypeRef_1 = require_TypeRef();
    var TypeUtils_1 = require_TypeUtils();
    var UnionBuilder_1 = require_UnionBuilder();
    var CompressedJSON_1 = require_CompressedJSON();
    function forEachArrayInNestedValueArray(va, f) {
      if (va.length === 0) {
        return;
      }
      if (Array.isArray(va[0])) {
        for (const x of va) {
          forEachArrayInNestedValueArray(x, f);
        }
      } else {
        f(va);
      }
    }
    function forEachValueInNestedValueArray(va, f) {
      forEachArrayInNestedValueArray(va, (a) => {
        for (const x of a) {
          f(x);
        }
      });
    }
    var InferenceUnionBuilder = class extends UnionBuilder_1.UnionBuilder {
      constructor(typeBuilder, _typeInference, _fixed) {
        super(typeBuilder);
        this._typeInference = _typeInference;
        this._fixed = _fixed;
      }
      makeObject(objects, typeAttributes, forwardingRef) {
        return this._typeInference.inferClassType(typeAttributes, objects, this._fixed, forwardingRef);
      }
      makeArray(arrays, typeAttributes, forwardingRef) {
        return this.typeBuilder.getArrayType(typeAttributes, this._typeInference.inferType(TypeAttributes_1.emptyTypeAttributes, arrays, this._fixed, forwardingRef));
      }
    };
    function canBeEnumCase(_s) {
      return true;
    }
    var TypeInference = class {
      constructor(_cjson, _typeBuilder, _inferMaps, _inferEnums) {
        this._cjson = _cjson;
        this._typeBuilder = _typeBuilder;
        this._inferMaps = _inferMaps;
        this._inferEnums = _inferEnums;
      }
      addValuesToAccumulator(valueArray, accumulator) {
        forEachValueInNestedValueArray(valueArray, (value) => {
          const t = (0, CompressedJSON_1.valueTag)(value);
          switch (t) {
            case CompressedJSON_1.Tag.Null:
              accumulator.addPrimitive("null", TypeAttributes_1.emptyTypeAttributes);
              break;
            case CompressedJSON_1.Tag.False:
            case CompressedJSON_1.Tag.True:
              accumulator.addPrimitive("bool", TypeAttributes_1.emptyTypeAttributes);
              break;
            case CompressedJSON_1.Tag.Integer:
              accumulator.addPrimitive("integer", TypeAttributes_1.emptyTypeAttributes);
              break;
            case CompressedJSON_1.Tag.Double:
              accumulator.addPrimitive("double", TypeAttributes_1.emptyTypeAttributes);
              break;
            case CompressedJSON_1.Tag.InternedString:
              if (this._inferEnums) {
                const s = this._cjson.getStringForValue(value);
                if (canBeEnumCase(s)) {
                  accumulator.addStringCase(s, 1, TypeAttributes_1.emptyTypeAttributes);
                } else {
                  accumulator.addStringType("string", TypeAttributes_1.emptyTypeAttributes);
                }
              } else {
                accumulator.addStringType("string", TypeAttributes_1.emptyTypeAttributes);
              }
              break;
            case CompressedJSON_1.Tag.UninternedString:
              accumulator.addStringType("string", TypeAttributes_1.emptyTypeAttributes);
              break;
            case CompressedJSON_1.Tag.Object:
              accumulator.addObject(this._cjson.getObjectForValue(value), TypeAttributes_1.emptyTypeAttributes);
              break;
            case CompressedJSON_1.Tag.Array:
              accumulator.addArray(this._cjson.getArrayForValue(value), TypeAttributes_1.emptyTypeAttributes);
              break;
            case CompressedJSON_1.Tag.StringFormat: {
              const kind = this._cjson.getStringFormatTypeKind(value);
              accumulator.addStringType("string", TypeAttributes_1.emptyTypeAttributes, new StringTypes_1.StringTypes(/* @__PURE__ */ new Map(), /* @__PURE__ */ new Set([
                kind
              ])));
              break;
            }
            case CompressedJSON_1.Tag.TransformedString: {
              const s = this._cjson.getStringForValue(value);
              const kind = (0, StringTypes_1.inferTransformedStringTypeKindForString)(s, this._cjson.dateTimeRecognizer);
              if (kind === void 0) {
                return (0, Support_1.panic)("TransformedString does not have a kind");
              }
              const producer = (0, Support_1.defined)(Type_1.transformedStringTypeTargetTypeKindsMap.get(kind)).attributesProducer;
              if (producer === void 0) {
                return (0, Support_1.panic)("TransformedString does not have attribute producer");
              }
              accumulator.addStringType("string", producer(s), new StringTypes_1.StringTypes(/* @__PURE__ */ new Map(), /* @__PURE__ */ new Set([
                kind
              ])));
              break;
            }
            default:
              return (0, Support_1.assertNever)(t);
          }
        });
      }
      inferType(typeAttributes, valueArray, fixed, forwardingRef) {
        const accumulator = this.accumulatorForArray(valueArray);
        return this.makeTypeFromAccumulator(accumulator, typeAttributes, fixed, forwardingRef);
      }
      resolveRef(ref, topLevel) {
        if (!ref.startsWith("#/")) {
          return (0, Messages_1.messageError)("InferenceJSONReferenceNotRooted", {
            reference: ref
          });
        }
        const parts = ref.split("/").slice(1);
        const graph = this._typeBuilder.typeGraph;
        let tref = topLevel;
        for (const part of parts) {
          let t = (0, TypeRef_1.derefTypeRef)(tref, graph);
          if (t instanceof Type_1.UnionType) {
            const nullable = (0, TypeUtils_1.nullableFromUnion)(t);
            if (nullable === null) {
              return (0, Messages_1.messageError)("InferenceJSONReferenceToUnion", {
                reference: ref
              });
            }
            t = nullable;
          }
          if (t instanceof Type_1.ClassType) {
            const cp = t.getProperties().get(part);
            if (cp === void 0) {
              return (0, Messages_1.messageError)("InferenceJSONReferenceWrongProperty", {
                reference: ref
              });
            }
            tref = cp.typeRef;
          } else if (t instanceof Type_1.MapType) {
            tref = t.values.typeRef;
          } else if (t instanceof Type_1.ArrayType) {
            if (/^[0-9]+$/.exec(part) === null) {
              return (0, Messages_1.messageError)("InferenceJSONReferenceInvalidArrayIndex", {
                reference: ref
              });
            }
            tref = t.items.typeRef;
          } else {
            return (0, Messages_1.messageError)("InferenceJSONReferenceWrongProperty", {
              reference: ref
            });
          }
        }
        return tref;
      }
      inferTopLevelType(typeAttributes, valueArray, fixed) {
        (0, Support_1.assert)(this._refIntersections === void 0, "Didn't reset ref intersections - nested invocations?");
        if (this._cjson.handleRefs) {
          this._refIntersections = [];
        }
        const topLevel = this.inferType(typeAttributes, valueArray, fixed);
        if (this._cjson.handleRefs) {
          for (const [tref, refs] of (0, Support_1.defined)(this._refIntersections)) {
            const resolved = refs.map((r) => this.resolveRef(r, topLevel));
            this._typeBuilder.setSetOperationMembers(tref, new Set(resolved));
          }
          this._refIntersections = void 0;
        }
        return topLevel;
      }
      accumulatorForArray(valueArray) {
        const accumulator = new UnionBuilder_1.UnionAccumulator(true);
        this.addValuesToAccumulator(valueArray, accumulator);
        return accumulator;
      }
      makeTypeFromAccumulator(accumulator, typeAttributes, fixed, forwardingRef) {
        const unionBuilder = new InferenceUnionBuilder(this._typeBuilder, this, fixed);
        return unionBuilder.buildUnion(accumulator, false, typeAttributes, forwardingRef);
      }
      inferClassType(typeAttributes, objects, fixed, forwardingRef) {
        const propertyNames = [];
        const propertyValues = {};
        forEachArrayInNestedValueArray(objects, (arr) => {
          for (let i2 = 0; i2 < arr.length; i2 += 2) {
            const key = this._cjson.getStringForValue(arr[i2]);
            const value = arr[i2 + 1];
            if (!Object.prototype.hasOwnProperty.call(propertyValues, key)) {
              propertyNames.push(key);
              propertyValues[key] = [];
            }
            propertyValues[key].push(value);
          }
        });
        if (this._cjson.handleRefs && propertyNames.length === 1 && propertyNames[0] === "$ref") {
          const values = propertyValues.$ref;
          if (values.every((v) => (0, CompressedJSON_1.valueTag)(v) === CompressedJSON_1.Tag.InternedString)) {
            const allRefs = values.map((v) => this._cjson.getStringForValue(v));
            const tref = this._typeBuilder.getUniqueIntersectionType(typeAttributes, void 0);
            (0, Support_1.defined)(this._refIntersections).push([
              tref,
              allRefs
            ]);
            return tref;
          }
        }
        if (this._inferMaps && propertyNames.length > 500) {
          const accumulator = new UnionBuilder_1.UnionAccumulator(true);
          for (const key of propertyNames) {
            this.addValuesToAccumulator(propertyValues[key], accumulator);
          }
          const values = this.makeTypeFromAccumulator(accumulator, TypeAttributes_1.emptyTypeAttributes, fixed);
          return this._typeBuilder.getMapType(typeAttributes, values, forwardingRef);
        }
        const properties = /* @__PURE__ */ new Map();
        for (const key of propertyNames) {
          const values = propertyValues[key];
          const t = this.inferType(TypeAttributes_1.emptyTypeAttributes, values, false);
          const isOptional = values.length < objects.length;
          properties.set(key, this._typeBuilder.makeClassProperty(t, isOptional));
        }
        if (fixed) {
          return this._typeBuilder.getUniqueClassType(typeAttributes, true, properties, forwardingRef);
        }
        return this._typeBuilder.getClassType(typeAttributes, properties, forwardingRef);
      }
    };
    exports.TypeInference = TypeInference;
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/input/Inputs.js
var require_Inputs = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/input/Inputs.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.InputData = exports.JSONInput = void 0;
    exports.jsonInputForTargetLanguage = jsonInputForTargetLanguage2;
    var collection_utils_1 = require_dist();
    var Description_1 = require_Description();
    var TypeNames_1 = require_TypeNames();
    var All_1 = require_All();
    var Messages_1 = require_Messages();
    var Support_1 = require_Support();
    var CompressedJSON_1 = require_CompressedJSON();
    var Inference_1 = require_Inference();
    function messageParseError(name, description, e) {
      return (0, Messages_1.messageError)("MiscJSONParseError", {
        description: (0, collection_utils_1.withDefault)(description, "input"),
        address: name,
        message: (0, Support_1.errorMessage)(e)
      });
    }
    var JSONInput = class {
      constructor(_compressedJSON) {
        this._compressedJSON = _compressedJSON;
        this.kind = "json";
        this.needIR = true;
        this.needSchemaProcessing = false;
        this._topLevels = /* @__PURE__ */ new Map();
      }
      addSample(topLevelName, sample) {
        let topLevel = this._topLevels.get(topLevelName);
        if (topLevel === void 0) {
          topLevel = {
            samples: [],
            description: void 0
          };
          this._topLevels.set(topLevelName, topLevel);
        }
        topLevel.samples.push(sample);
      }
      setDescription(topLevelName, description) {
        const topLevel = this._topLevels.get(topLevelName);
        if (topLevel === void 0) {
          (0, Support_1.panic)("Trying to set description for a top-level that doesn't exist");
        }
        topLevel.description = description;
      }
      addSamples(name, values, description) {
        for (const value of values) {
          this.addSample(name, value);
          if (description !== void 0) {
            this.setDescription(name, description);
          }
        }
      }
      addSource(source) {
        return __awaiter(this, void 0, void 0, function* () {
          const { name, samples, description } = source;
          try {
            const values = yield (0, collection_utils_1.arrayMapSync)(samples, (s) => __awaiter(this, void 0, void 0, function* () {
              return yield this._compressedJSON.parse(s);
            }));
            this.addSamples(name, values, description);
          } catch (e) {
            return messageParseError(name, description, e);
          }
        });
      }
      addSourceSync(source) {
        const { name, samples, description } = source;
        try {
          const values = samples.map((s) => this._compressedJSON.parseSync(s));
          this.addSamples(name, values, description);
        } catch (e) {
          messageParseError(name, description, e);
        }
      }
      singleStringSchemaSource() {
        return void 0;
      }
      addTypes(ctx, typeBuilder, inferMaps, inferEnums, fixedTopLevels) {
        return __awaiter(this, void 0, void 0, function* () {
          this.addTypesSync(ctx, typeBuilder, inferMaps, inferEnums, fixedTopLevels);
        });
      }
      addTypesSync(_ctx, typeBuilder, inferMaps, inferEnums, fixedTopLevels) {
        const inference = new Inference_1.TypeInference(this._compressedJSON, typeBuilder, inferMaps, inferEnums);
        for (const [name, { samples, description }] of this._topLevels) {
          const tref = inference.inferTopLevelType((0, TypeNames_1.makeNamesTypeAttributes)(name, false), samples, fixedTopLevels);
          typeBuilder.addTopLevel(name, tref);
          if (description !== void 0) {
            const attributes = Description_1.descriptionTypeAttributeKind.makeAttributes(/* @__PURE__ */ new Set([
              description
            ]));
            typeBuilder.addAttributes(tref, attributes);
          }
        }
      }
    };
    exports.JSONInput = JSONInput;
    function jsonInputForTargetLanguage2(targetLanguage, languages, handleJSONRefs = false) {
      if (typeof targetLanguage === "string") {
        targetLanguage = (0, Support_1.defined)((0, All_1.languageNamed)(targetLanguage, languages));
      }
      const compressedJSON = new CompressedJSON_1.CompressedJSONFromString(targetLanguage.dateTimeRecognizer, handleJSONRefs);
      return new JSONInput(compressedJSON);
    }
    var InputData2 = class {
      constructor() {
        this._inputs = /* @__PURE__ */ new Set();
      }
      addInput(input) {
        this._inputs = this._inputs.add(input);
      }
      getOrAddInput(kind, makeInput) {
        let input = (0, collection_utils_1.iterableFind)(this._inputs, (i2) => i2.kind === kind);
        if (input === void 0) {
          input = makeInput();
          this.addInput(input);
        }
        return input;
      }
      addSource(kind, source, makeInput) {
        return __awaiter(this, void 0, void 0, function* () {
          const input = this.getOrAddInput(kind, makeInput);
          yield input.addSource(source);
        });
      }
      addSourceSync(kind, source, makeInput) {
        const input = this.getOrAddInput(kind, makeInput);
        input.addSourceSync(source);
      }
      addTypes(ctx, typeBuilder, inferMaps, inferEnums, fixedTopLevels) {
        return __awaiter(this, void 0, void 0, function* () {
          for (const input of this._inputs) {
            yield input.addTypes(ctx, typeBuilder, inferMaps, inferEnums, fixedTopLevels);
          }
        });
      }
      addTypesSync(ctx, typeBuilder, inferMaps, inferEnums, fixedTopLevels) {
        for (const input of this._inputs) {
          input.addTypesSync(ctx, typeBuilder, inferMaps, inferEnums, fixedTopLevels);
        }
      }
      get needIR() {
        return (0, collection_utils_1.iterableSome)(this._inputs, (i2) => i2.needIR);
      }
      get needSchemaProcessing() {
        return (0, collection_utils_1.iterableSome)(this._inputs, (i2) => i2.needSchemaProcessing);
      }
      singleStringSchemaSource() {
        const schemaStrings = (0, collection_utils_1.setFilterMap)(this._inputs, (i2) => i2.singleStringSchemaSource());
        if (schemaStrings.size > 1) {
          return (0, Support_1.panic)("We have more than one input with a string schema source");
        }
        return (0, collection_utils_1.iterableFirst)(schemaStrings);
      }
    };
    exports.InputData = InputData2;
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/UnifyClasses.js
var require_UnifyClasses = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/UnifyClasses.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.UnifyUnionBuilder = void 0;
    exports.unionBuilderForUnification = unionBuilderForUnification;
    exports.unifyTypes = unifyTypes;
    var collection_utils_1 = require_dist();
    var TypeAttributes_1 = require_TypeAttributes();
    var Support_1 = require_Support();
    var Type_1 = require_Type();
    var TypeRef_1 = require_TypeRef();
    var TypeUtils_1 = require_TypeUtils();
    var UnionBuilder_1 = require_UnionBuilder();
    function getCliqueProperties(clique, builder, makePropertyType) {
      const lostTypeAttributes = false;
      const propertyNames = /* @__PURE__ */ new Set();
      for (const o of clique) {
        (0, collection_utils_1.setUnionInto)(propertyNames, o.getProperties().keys());
      }
      const properties = Array.from(propertyNames).map((name) => [
        name,
        /* @__PURE__ */ new Set(),
        false
      ]);
      let additionalProperties = void 0;
      for (const o of clique) {
        const additional = o.getAdditionalProperties();
        if (additional !== void 0) {
          if (additionalProperties === void 0) {
            additionalProperties = /* @__PURE__ */ new Set();
          }
          if (additional !== void 0) {
            additionalProperties.add(additional);
          }
        }
        for (let i2 = 0; i2 < properties.length; i2++) {
          let [name, types, isOptional] = properties[i2];
          const maybeProperty = o.getProperties().get(name);
          if (maybeProperty === void 0) {
            isOptional = true;
            if (additional !== void 0 && additional.kind !== "any") {
              types.add(additional);
            }
          } else {
            if (maybeProperty.isOptional) {
              isOptional = true;
            }
            types.add(maybeProperty.type);
          }
          properties[i2][2] = isOptional;
        }
      }
      const unifiedAdditionalProperties = additionalProperties === void 0 ? void 0 : makePropertyType(additionalProperties);
      const unifiedPropertiesArray = properties.map(([name, types, isOptional]) => {
        return [
          name,
          builder.makeClassProperty(makePropertyType(types), isOptional)
        ];
      });
      const unifiedProperties = new Map(unifiedPropertiesArray);
      return [
        unifiedProperties,
        unifiedAdditionalProperties,
        lostTypeAttributes
      ];
    }
    function countProperties(clique) {
      let hasProperties = false;
      let hasAdditionalProperties = false;
      let hasNonAnyAdditionalProperties = false;
      for (const o of clique) {
        if (o.getProperties().size > 0) {
          hasProperties = true;
        }
        const additional = o.getAdditionalProperties();
        if (additional !== void 0) {
          hasAdditionalProperties = true;
          if (additional.kind !== "any") {
            hasNonAnyAdditionalProperties = true;
          }
        }
      }
      return {
        hasProperties,
        hasAdditionalProperties,
        hasNonAnyAdditionalProperties
      };
    }
    var UnifyUnionBuilder = class extends UnionBuilder_1.UnionBuilder {
      constructor(typeBuilder, _makeObjectTypes, _makeClassesFixed, _unifyTypes) {
        super(typeBuilder);
        this._makeObjectTypes = _makeObjectTypes;
        this._makeClassesFixed = _makeClassesFixed;
        this._unifyTypes = _unifyTypes;
      }
      makeObject(objectRefs, typeAttributes, forwardingRef) {
        const maybeTypeRef = this.typeBuilder.lookupTypeRefs(objectRefs, forwardingRef);
        if (maybeTypeRef !== void 0) {
          (0, Support_1.assert)(forwardingRef === void 0 || maybeTypeRef === forwardingRef, "The forwarding ref must be consumed");
          this.typeBuilder.addAttributes(maybeTypeRef, typeAttributes);
          return maybeTypeRef;
        }
        if (objectRefs.length === 1) {
          return this.typeBuilder.reconstituteTypeRef(objectRefs[0], typeAttributes, forwardingRef);
        }
        const objectTypes = objectRefs.map((r) => (0, TypeUtils_1.assertIsObject)((0, TypeRef_1.derefTypeRef)(r, this.typeBuilder)));
        const { hasProperties, hasAdditionalProperties, hasNonAnyAdditionalProperties } = countProperties(objectTypes);
        if (!this._makeObjectTypes && (hasNonAnyAdditionalProperties || !hasProperties && hasAdditionalProperties)) {
          const propertyTypes = /* @__PURE__ */ new Set();
          for (const o of objectTypes) {
            (0, collection_utils_1.setUnionInto)(propertyTypes, Array.from(o.getProperties().values()).map((cp) => cp.typeRef));
          }
          const additionalPropertyTypes = new Set(objectTypes.filter((o) => o.getAdditionalProperties() !== void 0).map((o) => (0, Support_1.defined)(o.getAdditionalProperties()).typeRef));
          (0, collection_utils_1.setUnionInto)(propertyTypes, additionalPropertyTypes);
          return this.typeBuilder.getMapType(typeAttributes, this._unifyTypes(Array.from(propertyTypes)));
        } else {
          const [properties, additionalProperties, lostTypeAttributes] = getCliqueProperties(objectTypes, this.typeBuilder, (types) => {
            (0, Support_1.assert)(types.size > 0, "Property has no type");
            return this._unifyTypes(Array.from(types).map((t) => t.typeRef));
          });
          if (lostTypeAttributes) {
            this.typeBuilder.setLostTypeAttributes();
          }
          if (this._makeObjectTypes) {
            return this.typeBuilder.getUniqueObjectType(typeAttributes, properties, additionalProperties, forwardingRef);
          } else {
            (0, Support_1.assert)(additionalProperties === void 0, "We have additional properties but want to make a class");
            return this.typeBuilder.getUniqueClassType(typeAttributes, this._makeClassesFixed, properties, forwardingRef);
          }
        }
      }
      makeArray(arrays, typeAttributes, forwardingRef) {
        const ref = this.typeBuilder.getArrayType(typeAttributes, this._unifyTypes(arrays), forwardingRef);
        return ref;
      }
    };
    exports.UnifyUnionBuilder = UnifyUnionBuilder;
    function unionBuilderForUnification(typeBuilder, makeObjectTypes, makeClassesFixed, conflateNumbers) {
      return new UnifyUnionBuilder(typeBuilder, makeObjectTypes, makeClassesFixed, (trefs) => unifyTypes(new Set(trefs.map((tref) => (0, TypeRef_1.derefTypeRef)(tref, typeBuilder))), TypeAttributes_1.emptyTypeAttributes, typeBuilder, unionBuilderForUnification(typeBuilder, makeObjectTypes, makeClassesFixed, conflateNumbers), conflateNumbers));
    }
    function unifyTypes(types, typeAttributes, typeBuilder, unionBuilder, conflateNumbers, maybeForwardingRef) {
      typeAttributes = typeBuilder.reconstituteTypeAttributes(typeAttributes);
      if (types.size === 0) {
        return (0, Support_1.panic)("Cannot unify empty set of types");
      } else if (types.size === 1) {
        const first = (0, Support_1.defined)((0, collection_utils_1.iterableFirst)(types));
        if (!(first instanceof Type_1.UnionType)) {
          return typeBuilder.reconstituteTypeRef(first.typeRef, typeAttributes, maybeForwardingRef);
        }
      }
      const typeRefs = Array.from(types).map((t) => t.typeRef);
      const maybeTypeRef = typeBuilder.lookupTypeRefs(typeRefs, maybeForwardingRef);
      if (maybeTypeRef !== void 0) {
        typeBuilder.addAttributes(maybeTypeRef, typeAttributes);
        return maybeTypeRef;
      }
      const accumulator = new UnionBuilder_1.TypeRefUnionAccumulator(conflateNumbers);
      const nestedAttributes = typeBuilder.reconstituteTypeAttributes(accumulator.addTypes(types));
      typeAttributes = (0, TypeAttributes_1.combineTypeAttributes)("union", typeAttributes, nestedAttributes);
      return typeBuilder.withForwardingRef(maybeForwardingRef, (forwardingRef) => {
        typeBuilder.registerUnion(typeRefs, forwardingRef);
        return unionBuilder.buildUnion(accumulator, false, typeAttributes, forwardingRef);
      });
    }
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/rewrites/CombineClasses.js
var require_CombineClasses = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/rewrites/CombineClasses.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.combineClasses = combineClasses;
    var Support_1 = require_Support();
    var Type_1 = require_Type();
    var TypeUtils_1 = require_TypeUtils();
    var UnifyClasses_1 = require_UnifyClasses();
    var REQUIRED_OVERLAP = 3 / 4;
    function typeSetsCanBeCombined(s1, s2) {
      return (0, Type_1.setOperationCasesEqual)(s1, s2, true, (a, b) => a.structurallyCompatible(b, true));
    }
    function canBeCombined(c1, c2, onlyWithSameProperties) {
      const p1 = c1.getProperties();
      const p2 = c2.getProperties();
      if (onlyWithSameProperties) {
        if (p1.size !== p2.size) {
          return false;
        }
      } else {
        if (p1.size < p2.size * REQUIRED_OVERLAP || p2.size < p1.size * REQUIRED_OVERLAP) {
          return false;
        }
      }
      let larger;
      let smaller;
      if (p1.size > p2.size) {
        larger = p1;
        smaller = p2;
      } else {
        larger = p2;
        smaller = p1;
      }
      let maxFaults;
      if (onlyWithSameProperties) {
        maxFaults = 0;
      } else {
        const minOverlap = Math.ceil(larger.size * REQUIRED_OVERLAP);
        maxFaults = smaller.size - minOverlap;
      }
      (0, Support_1.assert)(maxFaults >= 0, "Max faults negative");
      const commonProperties = [];
      let faults = 0;
      for (const [name] of smaller) {
        if (larger.has(name)) {
          commonProperties.push(name);
        } else {
          faults += 1;
          if (faults > maxFaults) break;
        }
      }
      if (faults > maxFaults) return false;
      for (const name of commonProperties) {
        const ts = smaller.get(name);
        const tl = larger.get(name);
        if (ts === void 0 || tl === void 0) {
          return (0, Support_1.panic)(`Both classes should have property ${name}`);
        }
        const tsCases = (0, TypeUtils_1.nonNullTypeCases)(ts.type);
        const tlCases = (0, TypeUtils_1.nonNullTypeCases)(tl.type);
        if (tsCases.size > 0 && tlCases.size > 0 && !typeSetsCanBeCombined(tsCases, tlCases)) {
          return false;
        }
      }
      return true;
    }
    function tryAddToClique(c, clique, onlyWithSameProperties) {
      for (const prototype of clique.prototypes) {
        if (prototype.structurallyCompatible(c)) {
          clique.members.push(c);
          return true;
        }
      }
      for (const prototype of clique.prototypes) {
        if (canBeCombined(prototype, c, onlyWithSameProperties)) {
          clique.prototypes.push(c);
          clique.members.push(c);
          return true;
        }
      }
      return false;
    }
    function findSimilarityCliques(graph, onlyWithSameProperties, includeFixedClasses) {
      const classCandidates = Array.from(graph.allNamedTypesSeparated().objects).filter((o) => o instanceof Type_1.ClassType && (includeFixedClasses || !o.isFixed));
      const cliques = [];
      for (const c of classCandidates) {
        let cliqueIndex = void 0;
        for (let i2 = 0; i2 < cliques.length; i2++) {
          if (tryAddToClique(c, cliques[i2], onlyWithSameProperties)) {
            cliqueIndex = i2;
            break;
          }
        }
        if (cliqueIndex === void 0) {
          cliqueIndex = cliques.length;
          cliques.push({
            members: [
              c
            ],
            prototypes: [
              c
            ]
          });
        }
        const tmp = cliques[0];
        cliques[0] = cliques[cliqueIndex];
        cliques[cliqueIndex] = tmp;
      }
      return cliques.map((clique) => clique.members).filter((cl) => cl.length > 1);
    }
    function combineClasses(ctx, graph, alphabetizeProperties, conflateNumbers, onlyWithSameProperties, debugPrintReconstitution) {
      const cliques = ctx.time("  find similarity cliques", () => findSimilarityCliques(graph, onlyWithSameProperties, false));
      function makeCliqueClass(clique, builder, forwardingRef) {
        (0, Support_1.assert)(clique.size > 0, "Clique can't be empty");
        const attributes = (0, TypeUtils_1.combineTypeAttributesOfTypes)("union", clique);
        return (0, UnifyClasses_1.unifyTypes)(clique, attributes, builder, (0, UnifyClasses_1.unionBuilderForUnification)(builder, false, false, conflateNumbers), conflateNumbers, forwardingRef);
      }
      return graph.rewrite("combine classes", ctx.stringTypeMapping, alphabetizeProperties, cliques, debugPrintReconstitution, makeCliqueClass);
    }
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/rewrites/ExpandStrings.js
var require_ExpandStrings = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/rewrites/ExpandStrings.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.expandStrings = expandStrings;
    var collection_utils_1 = require_dist();
    var StringTypes_1 = require_StringTypes();
    var TypeAttributes_1 = require_TypeAttributes();
    var Support_1 = require_Support();
    var TypeUtils_1 = require_TypeUtils();
    var MIN_LENGTH_FOR_ENUM = 10;
    var MIN_LENGTH_FOR_OVERLAP = 5;
    var REQUIRED_OVERLAP = 3 / 4;
    function isOwnEnum({ numValues, cases }) {
      return numValues >= MIN_LENGTH_FOR_ENUM && cases.size < Math.sqrt(numValues);
    }
    function enumCasesOverlap(newCases, existingCases, newAreSubordinate) {
      const smaller = newAreSubordinate ? newCases.size : Math.min(newCases.size, existingCases.size);
      const overlap = (0, collection_utils_1.setIntersect)(newCases, existingCases).size;
      return overlap >= smaller * REQUIRED_OVERLAP;
    }
    function isAlwaysEmptyString(cases) {
      return cases.length === 1 && cases[0] === "";
    }
    function expandStrings(ctx, graph, inference) {
      const stringTypeMapping = ctx.stringTypeMapping;
      const allStrings = Array.from(graph.allTypesUnordered()).filter((t) => t.kind === "string" && (0, TypeUtils_1.stringTypesForType)(t).isRestricted);
      function makeEnumInfo(t) {
        const stringTypes = (0, TypeUtils_1.stringTypesForType)(t);
        const mappedStringTypes = stringTypes.applyStringTypeMapping(stringTypeMapping);
        if (!mappedStringTypes.isRestricted) return void 0;
        const cases = (0, Support_1.defined)(mappedStringTypes.cases);
        if (cases.size === 0) return void 0;
        const numValues = (0, collection_utils_1.iterableReduce)(cases.values(), 0, (a, b) => a + b);
        if (inference !== "all") {
          const keys = Array.from(cases.keys());
          if (isAlwaysEmptyString(keys)) return void 0;
          const someCaseIsNotNumber = (0, collection_utils_1.iterableSome)(keys, (key) => /^[-+]?[0-9]+(\.[0-9]+)?$/.test(key) === false);
          if (!someCaseIsNotNumber) return void 0;
        }
        return {
          cases: new Set(cases.keys()),
          numValues
        };
      }
      const enumInfos = /* @__PURE__ */ new Map();
      const enumSets = [];
      if (inference !== "none") {
        let findOverlap = function(newCases, newAreSubordinate) {
          return enumSets.findIndex((s) => enumCasesOverlap(newCases, s, newAreSubordinate));
        };
        for (const t of allStrings) {
          const enumInfo = makeEnumInfo(t);
          if (enumInfo === void 0) continue;
          enumInfos.set(t, enumInfo);
        }
        for (const t of Array.from(enumInfos.keys())) {
          const enumInfo = (0, Support_1.defined)(enumInfos.get(t));
          const cases = enumInfo.cases;
          if (inference === "all") {
            enumSets.push(cases);
          } else {
            if (!isOwnEnum(enumInfo)) continue;
            const index = findOverlap(cases, false);
            if (index >= 0) {
              enumSets[index] = (0, collection_utils_1.setUnion)(enumSets[index], cases);
            } else {
              enumSets.push(cases);
            }
          }
          enumInfos.delete(t);
        }
        if (inference === "all") {
          (0, Support_1.assert)(enumInfos.size === 0);
        }
        for (const [, enumInfo] of enumInfos.entries()) {
          if (enumInfo.numValues < MIN_LENGTH_FOR_OVERLAP) continue;
          const index = findOverlap(enumInfo.cases, true);
          if (index >= 0) {
            enumSets[index] = (0, collection_utils_1.setUnion)(enumSets[index], enumInfo.cases);
          }
        }
      }
      function replaceString(group, builder, forwardingRef) {
        (0, Support_1.assert)(group.size === 1);
        const t = (0, Support_1.defined)((0, collection_utils_1.iterableFirst)(group));
        const stringTypes = (0, TypeUtils_1.stringTypesForType)(t);
        const attributes = (0, collection_utils_1.mapFilter)(t.getAttributes(), (a) => a !== stringTypes);
        const mappedStringTypes = stringTypes.applyStringTypeMapping(stringTypeMapping);
        if (!mappedStringTypes.isRestricted) {
          return builder.getStringType(attributes, StringTypes_1.StringTypes.unrestricted, forwardingRef);
        }
        const setMatches = inference === "all" ? collection_utils_1.areEqual : collection_utils_1.setIsSuperset;
        const types = [];
        const cases = (0, Support_1.defined)(mappedStringTypes.cases);
        if (cases.size > 0) {
          const keys = new Set(cases.keys());
          const fullCases = enumSets.find((s) => setMatches(s, keys));
          if (inference !== "none" && !isAlwaysEmptyString(Array.from(keys)) && fullCases !== void 0) {
            types.push(builder.getEnumType(TypeAttributes_1.emptyTypeAttributes, fullCases));
          } else {
            return builder.getStringType(attributes, StringTypes_1.StringTypes.unrestricted, forwardingRef);
          }
        }
        const transformations = mappedStringTypes.transformations;
        if (types.length === 0 && transformations.size === 1) {
          const kind = (0, Support_1.defined)((0, collection_utils_1.iterableFirst)(transformations));
          return builder.getPrimitiveType(kind, attributes, forwardingRef);
        }
        types.push(...Array.from(transformations).map((k) => builder.getPrimitiveType(k)));
        (0, Support_1.assert)(types.length > 0, "We got an empty string type");
        return builder.getUnionType(attributes, new Set(types), forwardingRef);
      }
      return graph.rewrite("expand strings", stringTypeMapping, false, allStrings.map((t) => [
        t
      ]), ctx.debugPrintReconstitution, replaceString);
    }
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/rewrites/FlattenStrings.js
var require_FlattenStrings = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/rewrites/FlattenStrings.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.flattenStrings = flattenStrings;
    var collection_utils_1 = require_dist();
    var TypeAttributes_1 = require_TypeAttributes();
    var Support_1 = require_Support();
    var TypeUtils_1 = require_TypeUtils();
    function unionNeedsReplacing(u) {
      const stringMembers = u.stringTypeMembers;
      if (stringMembers.size <= 1) return void 0;
      const stringType = u.findMember("string");
      if (stringType === void 0) return void 0;
      (0, Support_1.assert)(!(0, TypeUtils_1.stringTypesForType)(stringType).isRestricted, "We must only flatten strings if we have no restriced strings");
      return stringMembers;
    }
    function replaceUnion(group, builder, forwardingRef) {
      (0, Support_1.assert)(group.size === 1);
      const u = (0, Support_1.defined)((0, collection_utils_1.iterableFirst)(group));
      const stringMembers = (0, Support_1.defined)(unionNeedsReplacing(u));
      const stringAttributes = (0, TypeUtils_1.combineTypeAttributesOfTypes)("union", stringMembers);
      const types = [];
      for (const t of u.members) {
        if (stringMembers.has(t)) continue;
        types.push(builder.reconstituteType(t));
      }
      if (types.length === 0) {
        return builder.getStringType((0, TypeAttributes_1.combineTypeAttributes)("union", stringAttributes, u.getAttributes()), void 0, forwardingRef);
      }
      types.push(builder.getStringType(stringAttributes, void 0));
      return builder.getUnionType(u.getAttributes(), new Set(types), forwardingRef);
    }
    function flattenStrings(graph, stringTypeMapping, debugPrintReconstitution) {
      const allUnions = graph.allNamedTypesSeparated().unions;
      const unionsToReplace = Array.from(allUnions).filter(unionNeedsReplacing).map((t) => [
        t
      ]);
      return graph.rewrite("flatten strings", stringTypeMapping, false, unionsToReplace, debugPrintReconstitution, replaceUnion);
    }
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/rewrites/FlattenUnions.js
var require_FlattenUnions = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/rewrites/FlattenUnions.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.flattenUnions = flattenUnions;
    var collection_utils_1 = require_dist();
    var TypeAttributes_1 = require_TypeAttributes();
    var Messages_1 = require_Messages();
    var Support_1 = require_Support();
    var Type_1 = require_Type();
    var TypeRef_1 = require_TypeRef();
    var TypeUtils_1 = require_TypeUtils();
    var UnifyClasses_1 = require_UnifyClasses();
    function flattenUnions(graph, stringTypeMapping, conflateNumbers, makeObjectTypes, debugPrintReconstitution) {
      let needsRepeat = false;
      function replace(types, builder, forwardingRef) {
        const unionBuilder = new UnifyClasses_1.UnifyUnionBuilder(builder, makeObjectTypes, true, (trefs) => {
          (0, Support_1.assert)(trefs.length > 0, "Must have at least one type to build union");
          trefs = trefs.map((tref) => builder.reconstituteType((0, TypeRef_1.derefTypeRef)(tref, graph)));
          if (trefs.length === 1) {
            return trefs[0];
          }
          needsRepeat = true;
          return builder.getUnionType(TypeAttributes_1.emptyTypeAttributes, new Set(trefs));
        });
        return (0, UnifyClasses_1.unifyTypes)(types, TypeAttributes_1.emptyTypeAttributes, builder, unionBuilder, conflateNumbers, forwardingRef);
      }
      const allUnions = (0, collection_utils_1.setFilter)(graph.allTypesUnordered(), (t) => t instanceof Type_1.UnionType);
      const nonCanonicalUnions = (0, collection_utils_1.setFilter)(allUnions, (u) => !u.isCanonical);
      let foundIntersection = false;
      const groups = (0, TypeUtils_1.makeGroupsToFlatten)(nonCanonicalUnions, (members) => {
        (0, Messages_1.messageAssert)(members.size > 0, "IRNoEmptyUnions", {});
        if (!(0, collection_utils_1.iterableSome)(members, (m) => m instanceof Type_1.IntersectionType)) return true;
        foundIntersection = true;
        return false;
      });
      graph = graph.rewrite("flatten unions", stringTypeMapping, false, groups, debugPrintReconstitution, replace);
      return [
        graph,
        !needsRepeat && !foundIntersection
      ];
    }
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/EncodedMarkovChain.js
var require_EncodedMarkovChain = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/EncodedMarkovChain.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.encodedMarkovChain = void 0;
    exports.encodedMarkovChain = "H4sICBHke1oCA21hcmtvdi5qc29uAOy9yW4jMbQl+C9vHQtezqxfafSi0OhFAw/VwEPVqtD/3jyHMYiOQRFSyGmbRGaGbVmWndbV5R3O8L//43/+1//zf//Hf/vf//F//b//63/8z//4b2r4j//+X//1H//t//gf/+s//3P4wZff9xN/9tdgvQut/iaCV0MQNXjRg9N6sMEMNn9sbByMtoMOftD59iYj5Lsu/+f/twSjeGNbDUaJLv+Lg/j81of8zwxiVf6Xb3P5X5D8fuoh823BaIJrNhhNyv9yEFqb/+WAzK9LMTkYXf6nFQNRdOgh823BiHTQajDqEmyicyDm47j8y9nR5LdKDzlpJtMD5ttCUeXfe6uhqPJBrPNBLDkUc6WY4y76IeUblWEsJt/D5bsCMSZpNQ4TMl8oEZeGFIaUuxg7xDCENATbI+XbYlCanSPkfiQaxFt+GeZKOYdk/hs0I7BnwW+LwGB9sxGYhmgRhFEx8BxSX9RDLpVdz4HfFoEuNJsDfU59arB6yC/CHH7O4Jb8vov42+PksxF4Zc6tjbimJ/6tXWLgpEpjkpVfi7k6tmmw+WQYMMsa8j+P2ZYMOndwku/sHG7MNYzOd8wtXT5Ryhf5Ifd2cq431hJ6lDU2tdcRf3MgSQ4XN2A0kONF5phxiMRBDKcG0wQf43wn+EQYZ1dx+sT5kzdHqunh1tDF+FhNoxza/5zDcuGhEXE6R6OfPslpVA4+l3vUOAaZRiTmuyDxhS9pLT/IySwXYw+7prJcrmqx+VEK7ZV2mgFnBiP5bxryTWrIx2fgASsmohYegzAw6/l8hoYByyQ95c2zsaZd6rHW0MXhIMU8MxdwCCuL/CYMrPzHB3RY2PxEfpBTW85wwG0YDKSwJUple3k2vrDW7PHVUC5D6sl5y2FumcNs+QxWiipUd839w5Sw0DpE1msJ74TA8i3XehZB6M8Xbak3om3tanjqodHU3BSOk8mcwR7BPDmLYa/oudrRY1giQuf3pnOzfHW8srCN/QhtC73DkMtlfj49JfqlJ3B1xsv12xRqkkPPjqGZs6Nmsec8vuTxgeVC2FktPewaugAX5tiDRjfW+oCM+TlZIcTyHZQdTM5nOEynTwA9EdUcgHpqH6o3z9YQ0fZwa2n3gpntYBViqhRnY7DYVbzYiDshGPUcibklBcRb6hnIhfymXY+3pmZvaa7dwBGozkXuAB9Ck11Bmg/XktQe7xExD3743IX2IfRTtaliDmONhHhj46ow49DTEsGn+eid8trUc7jp8GSvm3OiTV+CNszx/KySS1H3mGupksOYDdynfGhiOUp8w9QJGLvKVuCp5Kg0psYeRiIicqmXvyIftPnTxl5pW0NvW9sCV4/DN69w2EaWddysSlWj5QQYkQx17hjc4ymKjwXoL/149wshl2KfBbe1vUd+GxdZfm47bVlPaQCruVkFoNWPWS8ljkHy0Ynhis33wB3sQQlXb+xdB4g01TXYsiXIFVq0XJ0GZCigjcT66bgtQCSFblZy0E1lncXHOTA9Ia1jjZeLOHdlDOf7KdoWW64a2J4DFe19/Vjd4W98ge1Zj4NNb1ybCsRp1YClPGbBJgAsjSbBEyQyRRrGcOPJm3OfSXPU4T65BJy6VkmXhyVGhd65thV0ln2mSsT3opFF6KWyE4tuHsWJyudyDscAZQUEoMXhm0ORH+UT26DC84A1lf3slYWrtj3VNRV1nH+Ygv21dpjWpGCtR1cvIqahXPJoOUbgScKIxC24OWPqlHcq6pzzPepaQsqFgb1FDrjHMBFXL+1z3xBCDrfx2LRqEj9CzIGuVCbL6mmwrSLOxx5wTVFqLGFKRJbkUzJHGZQ5PILogZSpkP7yrQCXjGnMBmS0HG7pvR4iSg+4tnDnDq2r5qbK+bmNRUozdZuLXsEBFBz0nAbnUzTOfOEZfO7O9Q+uD4SbmtapeQhiTL2iB71m1QPkmIwzGqUq8wBD56n6kBkvJLqe55qCMtn1Luzi0byDXDJvDu1i7IHYkqLGPJF7pKSu+9fHgcvSjGwHm74a20+Z/Q+kft3js6n4LJs0DagxCIUJqzD2wRN0GAQwx/GyjqRXS676gC42uWvxBB97qnR4bOL0eWK/75HW1iA5cZA8txCRFSFD5gFIjIA0ZcErcx+MpQUVfBce7Evk/tinyE01H9FXp6SUtRk1I6AtIQVDN6FQElnYNnG8N6JAIZRqyX8FOCXUam3uZMkXes/b1pAlYGiCeAN0zpdZCmnXRi8gYiA5CxfbmiXTUYRSDflw1B4g0QmIrNWFJkN3FZO2FhcWE2HEDRRMQOHXYBxOLIuRiAMdSU2OGFIcSjckukAglCMXIxEPf4F6LZL6YKUtMBRFJLjv95gOV9hPRODjEDku8z/vgEIufNmc+XIdZ4k5TpwDXkhuoXOvW9uR5QjJwaJ5nE4zEVPj56zm9qxISswbWTcNXGYuo6v5sCdpEx1h3JagCTmsOdP5HFXQZ7LzVqySo0f/OhMYU41oIkbPM+dV+FF9AWwntk/jWoMaY82lDHRNclcQIfLFkdsM4QSAPd/HgD8GsMoUfxiaQKk5ftm7XSL8p47tbExsWagwl4MqJy+TapDT1yaDZDAIhc2LCl+qtzTjUl7YiGndO4i2+DvL8NbVBGo/n7Rj0hLywCrOv633XthbnFrMdsZ/y4x/h3qMXDDK1YEgMY1F3EKPqAZtgHOqR+STdRirWFNHo8STjH/p4iZNMf5zzQa+RH6DEW8wI5p9bBzWa39VkHng9DzmxAQH1SEV/SczShNf6V172DWljTgRXSnkhG2CZe4b24vHyNJcSogptP/Hc9U7lIP4Qvci7b/vH1oTqrNcpaIVKLLUw6KEaLBZLb1GiDPiKYBCxnke3kNnwTucpv13LcS22gYpAw8VuVQFZ0IPRLOXPf7cW9DdmQI5lhD3MR26ImKtIMMz9bb6S//x7DANPau1pfq60XjKeR+0sPGA4CnKu7z/rnjSWCuRZnVhuJPkFFiY1a7s6+fOdUHXQa7OzQg50Mdy1zCxY19h/XepicZCLuJ01DhMIZdYdKudLj7NE+0LHQT8m6OGabM46GJTW1GKFIBWiEiDsfEkY+evwZj6aLgt9TBu8YvGNYVKJuohsCaPp/Fk+qWJoZvKP+0tsSWyEBPdC+g517euba3B4lye2S8ywvGLoZcDGzt5VzP/PTVk863AeRKmPstEnYM0uW5g0hSkyRGu6ZHpYsKBqRl3PtXam9oPxJ3rBcWE0zQM9r0OomGH60YB6ZytYdqm6Ps15i3gzm0NP0EG41k75Thxj2YnVQ1HyMm5/iH1BNfSxYa5PAMOLtT01nUx5hbl9KBrgEo5Tl+UH+6s/7ZoEKtslJ5yp2uZp+1PvEv578mvRb3Y2XNulR39HoHfxdlw4pRI3su0/6eKACf1AtomNi77btPuNlIcZAEwlBaB1aLYNCSgRJXJh3kYHAg/GoYptqeHT16qgtuqZgPSJJgQFIg85EwM2ma4lcFkigoEMVelvofMdwWjju06jhulS+ApjHHAh1QMPmCudIiUSdY+9JD5tmA07SpwaRdpmIGAA+1CA+IHQq9DU54/ZzR1MXrIfFcwqtgspEgb+PxI/gc6uWUAQiNIYxYOFSDYLKueGb8tGCW2u/fUQN8nQ0MDKJsB4iAhELcvSQrK0MceMt8WjM41mxlhuQGLSKGowWhtBfAq5PZAOQIOx/UG5vuC0apmB11w3xCnKKoh1CT1VIosgWiKDcwzOY1+uTEYAQdtNhgD7SLhsGE0BTZA50yxhCPYnVp6wHw4FK9Mxq3XXa7p1peAQs51bJ/wGrBUs4QA3EwMBSI3ED+pPWXdwK4K9ODSNpFpGqjGZQvf6qk0OsC9Jj+aEx4HnsKEEP2lDwkFXIUVCgYKI3SzNHSYOMQEHZ18dEBAYjBnBYK1c526ejsLfpHqQH9Nw93Bl8yZZvIngD2l9Ayz3SWEUQH3mSTfJlDHuXyLzZD2i41XoLwNxEcYN2lG9Yop8r8MmDHn66GE8QSPm8CVV6SUbOqurTdr61ZSfyqRoy50uUc0QbrUz+kjWmB5HBRRp6c1+TFtFPvKNMEs3Kla0lQ4IXToSjMRYqpZ0tQUHrk6CBR/cIqyl2PDb0sZW6LrcUdvLxgTGu87MebeCk/oAUMPLBxfJSdgbTcLdWicXcggwupvShQ4paCcS6cZkt9rqfBn39jTEEmov4BVDRS2yIIxWg1UerPYag9jVx7Gh0Ucq4C4tqRYTXn0QhRpF3pyuhUIRs2DZIoZKXhywL4S3T/w9Q42umYNQ/DCEHmw5eOQnS6hYEKXg2ffqJDr8veINNPK2c/QPIFOgsg7FAA04BgEuicEGj/n+MmRVGyz4L9wRcVep14X3VtRBwoCBVCJKsX4+GWygX5Tz7hoj9wU6eHHJ9ewhoKewUl38EQ7K6PwToxVpcZvLIscpbFLA4y0Z1hVk+qEGYxn0D6XYavH/aqr/d0bR3z2LcuguJibudrKzIHUoQ2luN3Mb5MZ+DdVKNMe1uhTlJIwGpfmCj8u/KM0WxmU781YyXfBIG9ShYG7yxhqIdQQxivqCFq6MPPNpRDE2snzLjIXi5Z2nS4e3FOQK+zjM56jBwbeoQbdizu15McRiZ8g8hTLwTGLprHaf1ifpbkPxNdU6lZIZEKPoKrxF3OlQErSy+x7ZwE8MWAFQE0xFDtUZ1+koniDytVvgA6tLFRcRXb49PSZdBUuD+14zwcMHCCJK5X84lRAESFwfg3KJu6/xu9tiU+ZNPgmXpxcHaGrbux9b73Ntgc+7VT8rzQSzWpRaSk1i4H9Yg7qKI5n5Ar+/YEnpEZ/ZEuBZPuY66xs0EQwGzUPWbPIxlOiz768mbG+F+a3jpjMNJcpVNmKYqEf804xDPti0FSX7iXpXPwBFjc7BOdjZCIvVpw0sSvH96oaT7VD8hUV+KS67tS9hVXiMJrucwnznaW0iqnSbpoyVEgY+0zHV44ER6+w6vA7NsFemLimzAwsj0BDeq3QM6qaVk0VfEjLD8dm0VK/zOpaV0qfk80zqcvm3Qsci3SJAH4M1OmYqEE3eZSslyPs9AL3cF8n2JhJ4Qyi1E5Ob/7USajzyQn4rjAada7OHgS2dYqbXWr+gfO3CY8pFUOx/GoIQ+k6cmi6dGUo1ePqZg8SN3P089/E1/3snVmNtHU5fHAkagyEqkIHijhSzxD85e8fWHnnuOIUVbSvpT/LwBSshmp3k/tFxzG+kfPdQX3whS7Ec3PXZ4EDQMjkGnma7shS5WCO5FlN5b5wwhNgTmlYvwARCwUSPIB5VsMgCxkGLdh/nArIlwUudero7xT0bIGYVDGEpQYFoAv0P5GTWjrWd62Jm4VXsR7NMQBLSg3ECFyRfEH+zWVyETfXkQLmk0CIlTJm1DSHtvOpWGeEg+8MR8KUcFBpG8ZNjhC0oGdFRILB6KOJQ3iSALDAquQfKmESO3UC2m50o4ckyh5J96afagq0JrEfhEXaoNljV+tfH9dvcPblPJB1rWIinCFEc/2HqdmSoe9lbi3RZ3lAPQ40EytmX2bSejmOwjzFzknDujlAWdI/3KIu6IJo/ZCqoNBqI841Te/VAqJekpOZNzKLrxcbgvyFRVTdXR4feFhQ9Hi6UxuVxgiax2AhT+YgsuPOdjJg0AUWIr64ZIHyixooFYFAS96lEYqZT2KVLpwNKOOJUIF3DcpuzC+lBFNcxEdwh2AJroJ7JkYYjhtq4FswvMg/cj4up0jzF3SV8v+5D9DvVWjjqFEXjXvzsOsz5osklpmTUFruph0bd0c4QrU21qfWx2R2BK58IEEjyzrP2PqMndBxWEKmGZegI6dSXs93nvdFV9B0eFH0sLpR2ZTAtUAQnZ8n1X5RDMerH8sT9dDuT8prlgLjlveG3cLJUy9nO03UXFrMUQugav6emiqqU7qb5JBy6srBlTMWoKMyYmkuqKiKtX3/cuclP0k2TGuxAsLUNKmqdUq5NJay+xufsJwKDO3TXqZvIwxgDg6FVLp0GBn7v4fvbAu4gOhQmZUHNb+zf68KF9eXebezD8oCA2ZBy4ga+GtTd2K0NQD1YPJpkWWCOc0eHzVIw9PDjemvRCk2vxPSXGp0FEAQbCohfxoWLEKqy/7o5pM1nJPb7QX4zfzo+bkvoJWqqV8DCLDb13PK+Ko6Kq5+iFP7f2sXdVxVQb3jBoJgIRhUoe7cKKFbfcUVQyLfA+tWGEuq6o0r4qFpRzn05fGU84cDq2el2B7W4c1j0XQLrHuH6zWQLZ6QCpU5k8izSaM+xUSp0o7Zi/21H/j07ZFGzwNr5Hl+O08t7jvntpRGLeEONgmRDcRSSEGpCsckqMgM0D0Y8ZYOxCgWfxCFtDl5aaVJT8YKnVCIfMejCrKeekmferXFcU0Ei2KiYXLJl+wy8AIafoaPcqOJ1sZbkoRG+KJMbbNMQLHJRdBdGLbaZDsMoqm5i6kaYow5lCr01hyM4Fp4P6MlqFwG1iJGZgqZzc6ep4qSDRrAC1sw9ePhHgZzkt5sO5iiNTgjNBiVJ4Xe5RQWCKwHPmcKLDAWHbcEyVDAViaZCHwd1o04Wb2D7fOEt7ii1ZAfsve1bTEni24ENBmgiVwW45NlZIJGjSZhDLgfSMpQOMKR6FHeDZSA0OUchjiOnUc+J+GrvbJra4cPcaTit2E4m374nC/2p9NmVc9ASDDvoTOCii5HYipJkgg3OgDyaL4wvgup57m2oo7Uj9xVQAvCP4gJFL/cx4xIvhGXr/luM/CbMJIJl/TVhfJC6GnganvotVTYFR63Z21mcvxNGzQTF9DStBabYSW5nquWvZj1Ie0VOt1jzryA69fR9K6iqTmKw9yEEG5PQHe+wdPWdCKMGF3g5T5nRi5o9bT/EBLUw6x4MGr4PFnVfWF792O2LX4n8SCRNuC5L4gzjCisBr35LI6a0bkADDAeKfTOa9uymobSQdwtXWDnIzPvvIIpQa/uK1sXPJkvDPJUU/r0BUxCTZqTvqJti59FxBS9pAgOzyfnNI8z0ykKT5UFkuvSrHNmKCAWOPWrqkCT5q30c055P1+bgsmg+gflwfB4RZBFO8Pk/DpsYOmTj1iLqXEtXACuJ1gSkYJSxo1g5CuNbNf1bYzNNQaQD2RQJep8Qjuh7PYfdTkx4YMlaTWUo5GFpuiiewy0cOWM7eDgts5YS8V8ciJyhvLzdHhWQcuB6Io+6OjPo2aZdYyGXUGqgiFNcDNEqg6QnlUnEVLPcE2RdsBTTWWP6qG+oYscnuXYTk/dLMBQ2L9y02q5/ppQhBC09azfQB+bKIGe6tUXNBc76qSpgzXUkqIVHPTM19sNoUcQGs0Ltnl1IJoeiS1dZqd4gJcER29i+nOFYq1BLjQzYt/PdBwC9KaBM3XT1MydncYpFwSyvQ59R9ZW3BUvJbAXtSGAGGNkz6LNyixqQ+8lg2iEs7yDGCAF4Kl8HHON6HORGOgKMGvk8INz6c7HPjpuazsGLQZKkgCkaebpMVDsUvWoNLzDHE+rNFMUEaepYIxn7OdkVWvORp3pya41zJ0dKD9KQNMsK2MpDifLfYBL0WpiSMSJFlssLzDNi5R8Zug+Y8nVbP2e5hrbynqOdnOYYD4CXRwFFIApKLpHwLsiBTwAPzzDAAARdYTchffaCXG6txNtyYiDLgY1CwiKP1gcwEmz6lrzHcexCbST1NIDT5Yas+HAzOdxtTD5gQhAV3Vri8QTFzTAF3lusBLDmk0bFnvMaoUmxQ8DHi5ug357DmnclSybOmureNsy1TCHMp2rnsG+KxxgO3W2rQiM89JhZzqM5mKNE53b3B3widS6Ca+LCaw/Ncdqs7ly/g245Jr9JXialWOuDDVpaBrmdsRDKjN/7H3+nMlvTX+Vf/LyeHQ43e7+B/AVhwlzfj263Gk4yf+soZO2Axs8msF610Pmu4LRmnYNvy0YaUHKniS48hZ6LBrAmPyW8gSqh8x3BaPxptljGps2KLmbKPltKO/nY9p4R411Y7AADj1kvi0YVbs2dYYCtXHQqaAODJVONQnjGgBABKXqmfHbglFbabZmJNUX2j/Q/KHRaaTev4YLAPV38+d1b2C+LRglqmZrRkk56BScKDSpvDDPgP2FAJdP091w1o28X24JRt2uPxoDDqZyIXLHAnU+bFcoIsm3GkiaHjHfFIsQums0FFOAjny0ZKlrvFOAXxC1ij1Ovq9paXYrD6QrxdIAc6W/hlaj6Yr0HPjpCOy/hW96hfdlXrMZTvfXQk95/fLBJ+P3ZdmlD+5wpAN8Tb/8hhfiA0VWtY0uxpgRoh7AcydPeXJFefJA5YYzj+Ad7lx8Qeh5ik13Imu+eDDDUoQEVB+LDz0MeHFHrag0R0kcTU1qOgKL7gfEidBVDemVuU2OvNDG0pF4kNiFx5MsF4ECTsyhFv1gYe2aoIiT43aYJQ+hnVnsDycfKIn5ZTH4WeD6acVcEfjzi2uAILtUEOIJuA6+GP83dDPGIAGERdHrc+UcLdGB1d1KdMjHD1/jIF5uyL6CYzjsQvAnB4TPOWygWcgYUobc+4fYyGGQ+HzOxJhZHOcIS76G/8qGCVj1rdLO+9VcKl4sXR7DKumGNHX0WpMeo2cHYZgQacWscIwlDqPPRJGiRK+DyQLkjFQUSujnx8qPZz1zjct5wOacpIpDb8iRowrPWYpHSICLl9CgevJyxX13/gt2T4+kckXMoe32PudCrck5xswqEv3J1GSNtBNDGytauEEbkoWp/VckS7U/Uo2s5CUt98EGNVf+Wqfp75xPPtDt8qsTuxCwPyOUkIjqSkgcKZ+XILrnkMUiT/Qsuxr0jkyqhD0fxC8sGZ2O2Ksb0bPzqBdgKsq1c7zZNRpPihs9TXtxCLFSkA2n020Gux8Ax8dJxoIJXmtDBWyBoGRCbqP8hmdFUtyNAEeIPPHk6Amzs031TrcsG0WQTCUPs5une40eZvHVKweVSEMseWvWaYe/Tf4mZY4Od7I6Rt4YkEYgagD5NNTFahgLU3wSDxX5dMWiRZrDwl2oKyYasF8fIkfHVMXu9DsalO6ltm3ZbLbE+YyreNBlr0mTAXhCGTxXZc15SstMMdhyaUQ+EALEFRJuSRlQgwwEMsGLj9qPNHRBeGGI4B7KGhyU2z/13rl07PRsdoIkHsXfhUPJNtSQ24/PaFxdK0x6Fsw/aj5FhFVUXZDkVm2gSHx1o9pr0qUmXj7Oxp5mp53S5hln+AoF3QTvG+rk7cZRgeI40dYJliYwd8oRYOXcfBMHBcheofRTg3XoVBLHK1COCihpAiG+JUgwlTRwPkZ1jfCCx4VsksFnhZVV0jj3ww1ptkh7PMviy9uEqlfvai23TgNOvIplb1pX1V3mQibYeTz9NMUcPK596VOnQs62sx1cq7NGNN75Fx85Mo7DqaeWQx+HAhv9+9zdjRlHODSm5aKfQ8yzxELlZOezzexB1bbPLbfbiz3eHm5dd9ZgahXaSU9i3epXifKkHGtuQhEGFsqnWvgInSU6SbiyWcunGtQ3PQpvCaU1Qwgl0AgQLkloSgzhOSkCw4lzagMbYi2z/ybaOrPzv5jq7nVhtO4rRXai5SCortRbq4VHiO20bdquflW5v4p0yMTcJmEjC4B0nAUtnyQzkEAx58FYEHNEeGcO/Niz87ckKuvggbK2McdNVGzfQIpyCb0aZB7mKhqd3HZFrCdfRKPXnzpZVS/Dy1V4rVtAdyEt5d9DO1GU4voFR/1nT43UHDmJlg245dRZFhN3mAkm6Co/mZHU4gEsrgAEQKI4IXYYienO56YOI2tL3X6YpSMrUpKfOAGW7nCP2EmKoqbJ1/PMYY/WMhdat4sSHKGd3s2YjXFMgcWXOaQp08KNJeZ2KYrFmOW40bCnrw4XGdcafh5blSFnmufFu4WNM8sOS58rZzyHn3o6vOwwT6DEnQ+USiTdxHboZLK2WHa0hcGyKtCRSHEh4YegzjVjimeV4tOusT3FZEhHrEOUsPgGlxwzxUgmuaWTG+x2BQ6C43ZjPi7C4S5e755YUs8a0l5NVH2QT9KwczZdsaJuiI+4/s1HphQmGD2uw/wg9lxm4QqDUxpZuqipsuDnpzKGdwzh1Cx4Lw1+Uq7wzTZMpdBOEOn48aF1xLQSBbPKNVDMZ4MTjixhvoaNv9dEm8UCAIG4AHTqnQZ1TDNdwUBBFyylRz50vnhQejqQb/+/gt+rfSuIkTk6pNzR4fdWkEVvGoKirfUaIfBEm2ScWVytlX7fnlvWAw+Ujy9DtBk6L0/0D/wO4FdlALSFT6T4wL08xM5gk5vDJeaeEABc1NmwOZ2Op7C3updZSNLXS5GqM4vT6WWYQlGafZE+1VtCveZaHyYNVUdu/ZKGdLaGbBhVj5kECt/0FLpV0VVZbCKUAgryKHpyi54LpeKFUb4B/NECnB3N/FRDmAxoR+Czg3rYrYW9rYbMcyF7OCLXcojUDHvrxSmtXXciktDQSvbj7HfLMXRkjsOunhAz9lDFQMUWm6kJt4q6XNPFbNa289i/qd312Nb6/hzsYGoLa5Vbs6CH3iuTXENeuetpCBp3PXXwlnMZO954StCYdXbiQRELbMzS62lCD1IkO5eiLLx1wZbFOgj0871ceDpNNi8xXt/ddCjXUIX98QI7kSSEjIMCJyUWI7O7BKywOXEKBDXaeXgD7KKZPY5njNzBkbyXkXR1YqVzywy5L56Sa6cwcnGj4R2xjJ7lxNT/nxsaYaBcRoraT51+8HWmi4DGFpw0cpUnEvIxwRxBKG3cA/z8MGXohrYc3n+88OI2Hm1QJIQolYV9tdcykXE6r/EhhU4/6/oQO8ifUe2EkvlZsQV92WbOu28FmQQcazP5MMqXOlkox7ZRQG/cap/jDJ4TD/VL06QXaqwdVu2j0bE0zuK2XGvAvkYgGqmKPWGK2MrLyULdcPsC51VRWM5O2xmaf8EQ04GHi0cLFkcdWrs0kDlbKi5FEAoUVNVgf7MY1hRwy7bOmQ6mbEUtg5wnMmjO/5iYteqNuk/CrYeruPRrAAVdEeV9mBdXB8jqToM6o5cuCKUA5ibI2IomdzV2XquiGUy30BnS9ywcq0LuFzl2vDf73FhVWA6l0CGGRRTitwPYpwk/N+cQNIjVp4Un+lgLaP7TugB46MSIxdLgpmICzIlN+tgFEq/pYlLNNDrUiVZYRJnyVuZ9JEiD+KfiMnBWkbR4fNHYx1tqJYgmXkiq7WkO6HAOdZV+TR0n780t1k2fJ6TOcKjlliXuL5/uzBOWhXBuwtFdA1hk+P9zOwUl3/BKjNcWxeHXRNV7lmdufUMRUIrERIa/cVLGDTIDMpFZ/xJqJYxAb+yJeoMx88wC0qcmdtWkvyHYTL/8J6cojyfuxPFIHBQ7N4OWKfCiB18oPmP7OTcHOlx9zVdgrW62/m964O/ultOhUM9abaNo10mV+qVwqK+dnpViwu/ZjYu9uRyjaNzgF9ms8IpyyQfiRt78QgoE6T1CtMNOQ9tC4aiHz8ClfSGmirpyYuo+pG0quT5fYdmXVlRvkr5E+x6HrYyUJ+yR3ujaZdEM8VPQ6SLwWiFKZvFFeSXcjGrXzPaXxOpdcYuFAKgkGFsQdeK5bY1UFp4xawbdQuDS1rFFgExpwU1BK1JI8XYzh/GKGJE2v4cv1PdPb4cbdkiBLA9lycmeOXK1AgHJ3Yg23OyUJ0wTBHCMHOuhkDwjeNY4tdaBHc28PqLHIBGMFU0xdLRGTkH8eNCwPAUYdIL1k0u1xic5MA7AhoozrA4CK+dUifGd+yHaL+c2X+OtKSwadYN+V3lUI9B7DLZzSanWM620ekBmgObOhNyYEMVpsCknuDTD0R0dVmRjouev9Kyhh16/3MyFDu8lRGNs72ybOmzpLZ6GaDX6BpmXXsA3g8hMvrksgBLy3iGaQDsMwkPUYJUm12cm42hzsgjUyfYRcksXQxarMaSoQuucwF9Kc6RZAQF8Z22wqdElBnETVPDc4EyYhTknHuolnQPXu45vaqT/cbs7c+DH8PCyjIzTHDwG4tYY632xFJJ5zercrBLrLktGibN9NdFe7NPCxc+q4sEOtX8PsJcycxBl6T/K8HjVAgd7sZDz+tekuTe95MIadVhg5IaONmGwfyGiJp7z7GgHQO8Kbn5wEK6tRfUtWlPWu57ffvgS6zZtAPmiLaSWfeosQ6x8kfkLFZop0mVGvfi96xO1NwxtvSBsrRcxSYMOoVYGcXvClbXy52uwOdN3sD/8Z73hwWpLo0O3RD992q9/BDO8KRKq+0ykcVjdF3etiuNXdRLW7mCNN6xynretZ4Lz18yHl4qhv5g60uenCFy8G8yu8fklHDJpT2GKSKub3j+n7Uv7AG2LVl1Bi4Z5AgGOIg0whA6aVEHURWoX5eUCoJdWw/BKpBqvVEM2imGjX4Z7YgCRDFCqQL8o2iGeQgJSMcCZSJRfIiMt4VEsdRLsYEcvIDgsAKJAtU9FhWHYM+R7huK/qNWenOeG+eODQYfeQfHPWv0zO9Nx2CavoalTCA2Z06+b08mOrni2+HOYJuCQFxfv2qg7VKAWJXPnC/sOtQiawBxoqGXEjxTSp3XKel4bdtt1u8PxcGuW+BVtsgcMYUMMpG2d4CIP7KgWrPladydH6nSZzy9cJAz+oTri7J8ZFyQAhEjo/wON8iLTMlFjd54tM4Oo1prW9c+/96m4E2D6olJGPaw2DWncb8lRiBnGyocfnSqaEge6puY5C7Hq20+Fm30vFslpe3a8Pf1Mx8r2O8G1nWEOv+kVLgZ81to1F7s9QqHgZgZYs8D9EBjz4j0HsZlyMIZUjFxAqyklUT7dNCk1sN0g8dWkoTBZ5ZAutgrV5w5kZghVjOwVOJeXsy05sW4YBUqhqUAp7azUl5t+0xC3T9VLOSxnkVkSVs1/IeLjYte2IESeHThuJ534nbzz7nhYdeTwrZnu6nSrti+TcOZsO/Wc26Mfrc4+Zud9e8eI4MFJqkfavbigZ+gVe4TVvSSo+Ap25iJ83F2YEF8AzRkIJ7brao+uyIxmi3GcUPoj44vHkkoIO4uGw6LI8RMNXqhDpwbv6SlkNYSmNX2ALVHfQverNFCGciz4tysn419fCchi7vAYqu6ufKV935zeCjtb3XARLrbnX+Zn8OM/WT7JrY9eT6R6AH5y0WheKqw+/mPpC+fv7T9xNeJSoR1K63p94bmNcGzdwxDOoVtpYj2Laflk6zlX3DvwBAudGqgBMko10gz6eTlonqZdearH+lqUHuQx1RAT0NiNRY1Q4Za11+i+d96Ar0oEXCWb4tn6eCc180rgUzSPMYzXX4anZ0I47Y1E13Nge0Gj8KDWvxBM2sZ+Kt54mWIlxp2nTb8mq2huG6HECw8t8skDsSmrIgmfP3JpfWFpa4yOklN76E9abg/tkCuQoiiTcuqLI5JGe0/9LKX4CDkpOXam3uyko8oo4Syk1hC1UM/h9AllwmcIBUkNRxBKqkDJcbw150oqKRUVjLYlpi810uPdIg0habWON1gCUdz8QsNm93AEUsVTWBdNtYSHyImt0CkRrX7Y/fY5xy8H21YHYEjtzCR0Wh8kmKTCOFhoUSx40Z8zZfBWjw4eWEDPaDdjllp9gDxjPlvcrHqGrTbmrwI5yAoLZZ43IOb5+lS/1Aq+KZQloSUTZLOBvNLlr0U5YzhDJ87yVFUC5mRIKHcAXPCOh2gcHg3ZuQiPbDRxRDJUy3c8+dSrLa6brSLALpWQ5g7ebRylItX3uoKOsbZhHKfnn8DBkzurTCd++T3rmaluqxdyWojak7GJeXivEhB4AczgauiVnBtbykZYvgT+FdMQ+ncNRbLj+ZIKUlvUSfQvAjC3VgbGJEJfQtIi6MtuVAKKKqhl/KnhUBuQXvSXZZzehU3dNaU28aX59zn5KNu3LR+V3lwPD48moN9YRZsLBc5H9y0Y3DZz6sX1ILKsWtLocHdulEfoMYse4ds9AJYsaHQCze1rP+7hesX9s01dp6V2xuxP4AM+wK7aGVxp900Har2h0V/wzp5ZDc2hniv6wuh5zFb7c8npfDY/MNwqHGnPdT+/2PvGb6VvS5TPyYLHdPrG5RlzS2qwpiM51AP9CXa9nvlaz+n0NCQcARKKhSDpqKzuwohincj0mHCNYNYyg9K/9jc3BdZyeqYO/WvrpZMD3qvBaVpCCU0BUg5sKd49CbttT8drMxiL6d20nAj5xWbzq8CoMA19MQ/2dggnJ619w9gvL0pNVeIAJtxV4WFD1mOy4bi6GEmyw8u9FfrVvSyaP6TVD5uxpOC6v14TynLGObIBotBF1CiouzvCImMiYpKNkcF9FNABIMXTUGWwCnVkLhgdwHC5wExx3r5ofy7Qeo3Y9nl8l3yHwP1W36LcLf087pcX5fXUhw7k0AnDTWl9PBdciFeEms/xak41Kzr9HsuW95AecUtTspA8AAjwv3gs/Ljb0wVzpYWiVnbwYUgzfaJs+WB65uAwn+tDbzidAbYLtSEkvInzgnAoAGIbWOA95mZPaf1yS1/2ehm52o+I7RPCpi5uvUPUIayByeGIzXGER1b2HX677piEfnmxI44fakZS9yZt85LST/pxvkg3SPe+amds6MFP0wn0kYkCEhXp3F4KxBsfhnwfMFZcnHtiMPxhmku51RTJSQG6yOPvOVyD1b1CbDr4hJ4Xz05f89F0uQZ2Kduh+i1dYnRrzcvV5M+6tUhFGvNcqJxOU1zm1xLXkorpgrpbF1JqLCWmZQYjRt14zN9UH/4eOzJ5byO6ft1SqQZctsT3XI/Y72pKJPQjuTGuihN2FVHNYirOF2+zkYiqo0bTghbEL8qa8H0wuRlZTxmxUTnwOFmVgf73tMHvHRNh/cu31FQtCQ8WLD0mv5Va0rHVLSIVZu67mbbmeyLTpgxe1CyBpWtJ/XgK3fDMGvRXmkC/fXmQUQtt1xwaQ0B6iVo2EDEMud9NCmdyOKfp4twQhRMcUW4IAcAIG0h8UnSeUEBDwM/Sa0haiUkQbgwkWgU/JIuDH3eE5ET49Rl+I8yajbE+vP/J8XlLCk0uNuS/uQbJYR0i8NjNCVBT709THtmcin1wpw1zqIdunKcJNMR14eeT87EUeUIHjoHP2dVi7eKkaA9GB9MfDCITRJqBPIt4RAoZnmB0mUdtwAdRZUpTwD1o/k+Q2G2oPRavuHVUQ6XYTsHrZEOCWcqTa/l+foYpjCz+3JzKPvhx69pU18fR6tct+iR+lM2+oIy5lj9cu/nIXgXq99TE4rtDoYbc6sLaGEePhKJRyaFkAzmZXOgYX0S80hQy4CKNOt5msXwWuEATqGuLgBfvciQZ9wgJ2xNCrCTCQx20lVxX2vhWss4z4QpLNLQDu3Fh41DSeowVzdW/YQBJOjcswlRu9qMwNDKZjonqyYL9CZSRHSUr4/SSN97OenDP6kCndnSO1/4tR6sSvxMn7qyY6mor52xqyIXerYMgDHH09LV8/8w5hfKH9QetBw0+QCT5+fdvYA6QTwgHhHxuNS0UZIaQv844KQh5x9iZ57nbCjepKj308ES7lkYEstzZLLq8THv+SmgE386ZtPYGRD5RLGM4kyoC2qhtzsmvszyBzTy1cb2jsHI9IdOLWrJh2RN3Xbp3ftpwdBStboi7B9N7OqhVzDSkW7CWGZah+Lb5cetwamurlV65xPDFGu2FsYPwBDMXRhHTnmnDdqtWWt6rc+2J268eR16bhtpsn7byhit7KjcUG8BzCiZ+KoZkSFDV5iYR7Oel0NQAM+YckyuOaNmYjcmkkL0SziQeGdMw3sS9/noyD1jrY1/x7Vv79cielrO6gOqwup0Qcm5L185PfiFx0mqQk6LomF4gRoClRUAI9L8UHysfhKokppTPshxAMGK21tIESVMmzOJfMthNe7sIf0Z3WBLP45jz49ZcPFm1jjT95uBwqYpNO8rYYc1ojUw/OMP8YE6eYsvTuNeEGBt2toXzQSMnO5gq+7ypyX8EfvLvjnVUavk0G9U1LU8iwO4puelOWhgFQ0FC+JIYeEMgEo1iWwU4h+T8lE80Z3HyTXrpVPLk8Ufj0glKk450QOPOc11b6W6UVnLJi/tCFaStameInNbwZHo0mvw061Hh1cCycbCnwsZEFOBwFzFovNl4WUaR0J0vH1bQdLXsh9nh5SidPWgn/aODrKN2ah9/pBUgR13aQe18yak2tVP4BL8xDIRSqSNtxzJdhHFtdUoOmPIFMZa1lHILUJZrp+mo0JQ5MC5wiIOSA7WzWxAsJ+UVRt7RRvW2zqE7NZC5cKS5S1JHumHPvSIHTazI4EepC5GT7tlm7sPzkcM6WbEpn08KOxdK86IApntlXHBxlrmTddY+JuHK/39Vl71MCNa2nTgS8/HvgLlxLom0d5BiweAZ1VH+h1Ez2jCMniw/gy09sMRqcImBHHG3fLPNcW0BWcpxWBb5Yc/3prrZLgZ88jRgTHWUBVZi7uROZlsPMEpD7h5rY8ZEwBpxkjnO8mmUT6jkaUh9jk1ouNzKb6QcZqGYtuW3ztvR9k8SnyrNEy/aApnDKk2G4gq499TreeGw9vu09UC92q/O88c6NKzjaja9UQhh3N5u4omscRO3We6hMnl2cumtofLRDOaL+xXra3V2kCPhZyfnahrkGzJ6XLdjcNVwAK/mZxddmGZrFo8YKI+1bj6F8gs6Ap/hYmnDPMkt09CONhwYewdYPc5WxRbLs5C/GbfyU3TGPbhP1DuVbvVjukOJPP+xSZBJURry2lv3xqw5IufC+cUUiJrOV3fq/HKGNTh9jMsxRkBfbpac0YvHLCZCAA5K0AtjGQcYpYv5nttaaj2eZV/caee3qt5GyGxWjG9IDIp8WeEp9J9yvp6udhgt6c3GtJGw+XxxjcGdFt5xZ1GEiaNkAr10EKpWc7muq2hDKGnF3YbDwwemmZDzVOCeI5nlgEtHWyzZW4ZV546Woz6svmuc4sZX5/CFJl77hgJojVYWnjElSzjOAk9FjgYukBAP7cqXLoMaRFMyxd88h5bWM3HEABXCYLWXHcDk/IB4a901A7X1FfzXuQiS0Il7vyP875CUsU+nP/euyS6UTl3l+tu5SnvLqw+5ZLujgDqcjMrOhEC/F3Ods9yWQsN38/muDLNUS52j/bgSDSSJUBcKO4Ka7/P4vAfSwlzpMt2CrUIrul4+ylGLJ1uP/0qgmU+es73euxdRfnEF+8OqArnwP3sL9PJEuMC2HZXiR4EMrGJAlEXe8phH4OrOJjw8ihdskaKF+BCECwIGcYXTYAVbpSCgWIkjcDgizQnfKI1ttnUja0792t/mWhcphV+zopb3ipK4Pkt4DpI3Ge6RgPvHMgiegvwQHALyANguQ+QzxjNYg0cMZCPWFyHlYGeYw0OdlsfO55dB/tLgC2gDN5JfrA/y3doooh+h/fKvXzUVH0vFRoyZ/JbGpeM/R0qW+bMBhLWpck/PDzVMGr9Safy+6QlR89G7gVNbetMEMipWh6shh6+EEQgbMEmXTS7uH3DwgkOv1rhocSf1VvTvMSVOdyc4YRWniWpwfzLBSbUYFTH/sHdY8EC/Z1Qi+v6uwZFGkXio/hnUUzr323ylRnld+7yGhPi+CGuqL7BrQK2PNacoVkWzUfP+P1YGc1BloBoJFW8eh3jRXxkQ9whscDmmMDOUiUWFAeSOBArAv+AfoMQDhMlNNG9HMFWO55q5Yi83F3280i/HsSr/ZI6c294emi1dnF9r0a0xovbIHslWsSoVB2ZjImMvgD+9/jVDGP1eQ2fWNxQZN18Uz/SnEEv/uClOF+47EZM3qMXK3tUSm/hr4MbvGeBuEPQpMMB/6Rds+l/ojUONUZ8YQhfa2ufj6YtYFTENkYv7BYoc+WWmhQxmqlI5sojE+MJ/1mUoBVqshbuS8uWTxuO++V3oCmMGbbDwNbbY0xk1ikTok+LerrtcN9VQaP+B0zs+IAKVuqH/ML9oCaLfa9HWRfbgRr1NUkj/xuHrzcT8mn5dTq1r3ZqUqNUsTeTWotLFuEaY/1YE2Qu9RfS/B1DwXiisgW6WfzQhU/6vLNw2uHP2RMNRm13PnQSxilXSFPEvl3kpmEYcWs1625vIXDRMbv5vWAzJDLifFmmE3z3+5ytMK2u0I8ApNLjuailgMdNru4b2a0CAQuTLYwoltfS/DoVfC4FAyOSgvpiJ3iYRSiVqo9+/oPIoqtPM+uUeBKC7Kw12+F6/nOi69Oe+2RpUL0H1qGyK9MShelQPwpmyIfeeT27yk8ZjOM6AAzoNivWvMClroF+Pu5ayXPx+Wc/z+fBJrP6aFNnJUj+VQNfi5U274GUErxpy8NwbxZCJBPE2iOoLnRiigZ/MSaZyPm+BNYR5Z27Jk6ZUoKGZp7Jc43l8DJondNqK/DG025RQYdIn8Jhdrh5oT2z+Aln5GxKxtdKQ6ZbatBEtNkmao6BEBbh42uoP0twm9ygml6SWXBzIDQZTAtBBQz6HL+y0YCFqpx8AwqbBEyVmi3+pL8LxO6Coeq5eiI36i3rvpM1rHkUq/Sxvaos+5klNp2pYFX07o4GwRvkEemjZ8YoQsVQFPKdIqUhG9dSVLDbW8iA6A8sKgvPtNIOkcxufQvdF30/v4BH3uqRacru+Q9h5P+7c/hIhtKHefcMACX6vo/wsEkqinw1VBc4xovPhp4sxaPGrHnXYiaePkeGU5te34UfFcOlcVenjHN5H20+pNdiqNJR2donuokhgrT0p7TQHdj1cczyJIqOm+FsbvHMO9gn3R5LfdSq4iBwgdl4g2qSL09q876BsKVNSrSV6ZJplZSc7rPPhEcJ3L3bsxe6oAj+nFBuyr1kFD9TaWYrA9z7ww2KGJOceMEIlyNNvzQ3elZKFhlwRlQ5sz3MBQxORHKFUS6G2iuAmjyjN98YITnGv5vwXm4BH/Io5GsvpDUZ5yYK+ih492C/3PVX1V8WNju3EzFpyHTUNDUKQZsxU68STxQ1IN4bOWI5G5vhIj8eUKiJDcwTgOMQJxXz0/IwKbmdae3xcxd1z7D0tvZqO25e3n9JGgIOWlq1jcapipwDQOzFx2UB4b9y7/roNs3SpIi4eFUEXhD+DbqcG0lsuZsUotDRB+AufonOYPuC+KV9HD0DD4yFWKWCqcdzyHMLuqKD6ZPcAGs/IPW2FNdQtvcRDcReVQyqApta2Ic/Z1VNkE9QOPSsP/NVwGsl9jj3F+wkhYl4ZfOL+UBwsZxGB5DPDfZbtP2zUgubdHHr7xJyE+weY0qKVhz9OKk29cEC5w/FfZ4jn5yL8T76Yi7ghvDltXBJPO7WQfH7a+PwW/Zroo9Ev/V/9O5qt8rKk9dNVu2tnTrRuxYo/tkxyleNffbJscYuFup2Gi2k+7wynvnSCmwYDV5vMszLp7q7IuDpl9No3pJG+Go/4ACyMzwdSQkeeDzwXMI30p/KbdaWwwokVuSAoBCUZx4t0igxsC9U0hSzxmhha5UGC33miZUpU6elE8JKl8W2tnIHkccPrr5x5c0jlZ8kVx/WE9rz8PcUOhlmniXpIdE1mJQLndTOacMFV1JUJeAmnYrjOmcHUz0W188PaPW1QudTiHblNbvF8zk+OYEDXrjWkNRgtgnyr8Ncxekw4GTpFTxx/c3mOWSF3k6IW/VZT9pVx6pigzEwJ8nACdD9puvmnqeSorLEX8s4F8L9Jrh1le2fWDS2qGzP29cWLOJwTyIQxMTqr3FLlpKMxdIxcdwMfwofydnDRDpBppEW2nwaV+XRLDockGrh8ngkeB8fc9jd2sXqy9ZfhwXaBvDFjNJMZnd1d4B5tUHVDGcZsFCc5evLf/Cy6kmpyYognjUMl0do68shRpG1inhQLuwd7dxkex0rw8KTLwnrxfnB+mD09jJqgK1UmCtWPWUMN7JYB9gX7UOnQyl/PsPjlwsVVCosNefiFuDGowRSaAEYgQOAWOq5pzzyeClP7bia9Z1u8aofiRorTTi9eVsWIOD5s2NxBcAW/8xRXJdyhPYi85hV0TlZKN4RMXPc0pZrOEZOLayw1aMOeTz9jz5VdljMlfPnYcgn1bsqSVlSukA2atAJ4nIzSPZdvWCPgi+cG/0RPOR+jdgNWRP3ZWUSaO3vZ2JhgzFAPnMIFwQBpaPexjpbcIWF0wzdonE5FiS8jQ6CAwHYuAIt1U2ym3kki7xP1UhvJheHVbkP/xWHdnezYqxqr9su+xMVODUXOxiTOj1b2xfT81K7MKaJFYB6GYPT82sBVKyD8KNgts1aYtaapJMzvIsexc4+cxhexazO8brddr1h9r69vjccK/ZHUYDeQtPpclYH0dFMl93Rjf9KY+P59h2vIEnZjPBt4aHFhZllLnMlWD6dVNdTTGzM+jHqMXVxdzWVI6pzB4lEf7y+hQG4NoZ7B+nThB3DcFkClaSen+Y/TEmNpt2wpzAoiYDrV8klqhDxN/4D596Euyk9ln4l3ZN48/j56WvZp6PeLCP4TGJc8TXvyjSnymbe1UUkaZ4zHUQw3kTGOMRKU1TR0TJOcGyc43B9QX6z08lfDxNqDwIkFIIchDrPRQFAoAJpkYEJUkHwFwZbYWszXtKer2W/niz8sDrtEeoMvqtzdBI5QDfnsAVwJF+apm1AdaUTiQDbBT4vO5KimlF80+etNmMc2Xg0Sz03rf48/mNysQj25qQe+Z/6G7YiIfHnn9MIwfE/TEELoKa7Ji7lgWi05G854aAmfVM/8PdzjN51hN4gNM/i86Iz8Xb/1LSeldHyHPeH090POAxPZc2BDFZ4fdamVKtpaajBYyeYXdAw0FBEC2gx4/IBxG/ZDVmhfkHutAAQKqGwKFO8AKB2dITaWsttlXu8rGhNKV8cEgpdPIHffiK9r9zcdofHnTGGWAUzqstVttSRLu/EKL61Ks2apFsMb/CTvUq8OW7qEQpLANI8GJwpTQE2RJgtipwEiCwLrgHtqyhrkCnB2d4doE+BN4H9Src4uYityziNROjiqpYu/oGvyLcCFWtirtyr9stV66H9XF5rwa/a+8l6vt0G09fRQNPznhthwDMZ5Iu3v7qxXVaDpEJimxPTS1lh61TSbs0uQkzNrUedsdXT4NSWivLfIXUttDqPMgRpzoP6T45i78HxHEXV1GqN/j2Jn94F5P3AoX6tzN5xiQXwNYmI9aCnaxVrSADBMIeWOmtWO1iJBU6HPBmLVNDmL/qScWSvOxW6HgEWuaWEr/w1P9sfgOsBvrxW5taSPNhY17C9H+a9hMr75i3FrxpZlU2GLqcbfiDsbN3Rm3ZYqzk4k7qlrjZ1w2AP1n6JC2tQ7i6bO1YUHfg7kp2fK96wSoCqBdrkPfWU7GrDp2LQvRtMSmlpuHbz09NjYCljh9IweuzOIYRr+LdpxHlo7Xgh7iYseeT6l4ZHyYOYml3QEVV+3NZXkHifIYaekO9/RJXdzvmsE/hzWDa8dlbY9cdB/Av287s/sR0UK9MVeF04LPfm1JBRTxYnWFVbKToAEmaXtvjghaioH39Bo9Kjrx/CNVeNt5PKvgdoOAHXZddvG+TCOkD94FENVO9LVCqsP0YX3nk6JjxD5lyKF/Y1yxXEWrkgQjAR8ELJvjkIihBvmz0DkH6uSRIFTLRB1t8QX8seBZ4QIqCjh0Fv0l/DsvyGUbXTt0BqS//R30JxFgi5nI4woBdR2WISRDD8TCaiV6uDLzv084LJUUrXB5NeWgyp8ZDsvpDw+3QEVYviqhJa6GbEPW8lJwWe6vzl/5tTgR9NO/v/4qodKJY5OcJMU80MnXj3hlpK6oyJuZWmrbFGtC+lC6+N2gLbpqCjZlZqXt3uwRbJLN2ScE9dmxcVgWVE8OREuX7yXT2GGTIDMKpEGOK+L8ir8nI2aVZQVJ9NwYIbJro8A8MNipfiE6YRT1i3pxeqdZy9Mk0V/qJxptsxNS1C4nXAyb4SPh+9LMzKWRm3ZQ+SkommJpNXkwWxPom5Nofkm8HdNsY6LPEXA35g93BOaZjhRGqcozovxsyRaywHiglXyDEANh4hptfMMr/OQO6cUZm6dPeaTWjWkiuo2oIpC/5uEJzSOy4dToST0pkH6QGUT1fhAuHl8cl2gMhAagEhLwalcQy/gQR1H8qCs4GOAp53XQi3Yps+dRsBNuioFyYnD71ToqNhO6ISP19lOaild8M9gujT1p+4LlgrVUpgVWsozWJIUPQc3LLjlUNRJnk6tt6iWqzLS3MhD8r4daMK6/uExJcXwgfIUdHU7NQOwrijTF/imoaFXfrzK+piOzzmnwBUlzMWTFMeLqtSWQ5dAZ3bOJXthgLcXTfri4LCaN0s7MIKPL87WzmGy1uOt1oNCOGGVn8IGR2BSC39uh2NO8ATu6nSvmFlG184+bUv0nX6UQhgp9rinEhT6P2iMagc3XIMaCk3aAjXPlZEvt9owx5XDACoOiZo8aijWPDt1c+UTJSctBIs/lL1/b1HZ7fRF2K1F/YoOqdPVIdVzeYoPkbBfjix5s+1rSAJyDewp3qmanRGX2/7c+UBnLxI04uJyMUXbJB0f+ebxm8X1cWKfp1h9ghf8Sjy8GTkuxIZ8v51aKzdgglTsvjg4wnLwsEB+LMs5r8KEkiojPo5WhCj1rRnjUinu+1CHO0s2FWMLswkPzpVZZk9ehT3/+ImP4J5KT5iXcphcjKua59XQis7bjVc4JpgOT6smz04X+cFTy7yY7wZZQtJhnacRL9KSstWEwNOYPgcXrJrnxcpgJqfNENghTgfg9rMX1N4IPD29ofpZzhfaVwx7VVO5KHx8BmVN5EBc5TPRQfAopyGonsOkHolJaESXM5gvNXvORAGDeGp357vmbGQM5NBz552D3Mz8gF1nAkl+l5V2Pr9c5ZtfSFU6+naAMWseRymNsEHDimRRtXraJWKQJPAM4+Em8JrnQWlMYRmG/Dnwh6eDc/THhKIqxNvgVF/qKfrwmOeVv/3iZyJbxiaHJAGh5fxLoAGDPraZAy1sHWjcx2F7ghk0QKaocE71QMA5ueJMl4RDTpcTzkzgdAN1eofisjCNSV3k4s7kDDVBs6YoOTpu3O6BJjXaZBcJYGpkrf7ij3l1natD19r6fVrS6Y/NgquqKqSGLJbEyUYpi4490TLTcKZ55oG80zy7vIKLL5GjagB+QbOZy+edwsLFYZTueDxq2CwBH6XyLY79pMttQAIZDgkUJRSWw5MwkdNhr9EUfMft9q7CJxwegP5zMaVsQ7K+Oq13YZZIJ4vJEQ43S9RTqKfU+w8YhSwMi5Mw5a8S6DWgrMrBOcEmRyyM5rgcgQggYwpEM9vAxR4GD8YXD/n1kHyV5Vx9MpqNJc/84tALLGGjSCx1wRugJ61SQzuWdVNssBAx6OYBKtEoj/Hk2VMFlicSnYATk6slxYyiOUSIlKr1RB8wRQ3Q3xZW+jmw8E0tDcgBA9YH6spjOMneqFKq/OrOJaGq2LLvHmvR9nXwfd8AUSjMRNO82i/2NZE+gUD9ajYFU5yaHFCYD3i/YFK+pJdbV29sNvfwCa8+dEXdje2U7x/XV8tFzBot7Nf4T7fz40m1uT3Gb7un+zn3zqhSPrZ/idLQ5u7j7BZMKsNc9ScixQG5Ul+iB4hxRxs0mWdPy5c+ljPhqIzbKXzkyxTq3+yExYtreNR5f2c5oVkC1sYpzr1bPg3nT86sJV1sBHBYIjl5FvtOP4cJHi26f5Q4ZjUwde1M1e3HWVamjMpzUcYNMuYWVXwLORL5MzMSIRQqXg1mf3YgmpdRvd93PEKfuRdk94mczlrLa8XDyktU702c7FHHr3e07G/9n90LxHpmUO8x0mt5om+B2wQuBRmG4HI7MumBZvdnxeYMhlUBQzJFojxYoAJ/HmsIPcbDY4mYSJ83NhHFLiNEFOTCfJMFyII/jynFm1aDI+bL/F6poZWgj+/mQY1e3B7U5rkrxuxyIK6oXkzV40UZ+hos0ZWlGhT1mY0uNuyt1S4Hs4qz6gPj3q0Bbbfva+kCEKwEXVAij3SktHCHoEgCWQBWBMs6CgOgxHplzePWR7DeaibnumdpUymvYpgAajvtGDg/dG7nnJZqX4eufBIGR0SiXnYv5bvQFbz75cyUaNXfu71j+j2OSOoB2S8cGukvUvOralDvwZZo9nXDpNl3k/umzmZVOydNIHHj10vbZehtHdcvE5DqYHgoV6jhvyYN6h47/wCGc/D5eN9KxKQ+lWnz4r9YNoPItQK12C0sjHvXV7cKwD6NaeoElhMSDd94FFUT6u4s1NIlPr1B70Ky5Fh86JU5DcSRWw6/px5Nf8PDF/NlDWJgPm4D1tWVEOykB5AbCT+fvC4tUmfA4XNcvYj/hYOs+IUR3xNcCyE2KwIYMzNvYk2A9nEtnjymNLCI1IaK/Lo8vNLt6qg6l7WtNQj4kSZHj8fQJUHoFsKjwOLYksLU4Hl1GgoSGnyxSCVbB4cMR8CiOycVUotg90hrClM297OzWi22bhtlG8WZFi0IU4txv3w01GWc7w1tU/CC1UlaoffhzCxKH4xL3OJSqlJRunjOLjqYp/R9b7/cPap+RV2qbj10X7Q1dSbPTDWoNsWxdUhjHqsscoU+QJ614JT5rCnCTs5SQnjU01GXNCX6MdzgcDlRDoMOCHpnlyY1qABQApcosqkoJuXkXTUB7zrkvq1WtwZKmdqw5Yto+Nyl6GEL5Lx40004wmdE5zrvuS4g3haihcLTUMSf58DO1aMSTcdQW6yxLCfQYwMcB+uHNSI1Xkx41vbqrl2I87jFXc1PwpHjhj4M6Wt4mNqhs+NZWsaUnmSoyU6QvY8vqJYekP3r0dhQYpwsTS3U2/MBC+JxzlwpQbR/O5fBxsZB0gM9cBgCTCWvEt+/ENx6zLWMI03xXOA8t8x6j+fRo7C90/euk/QWU60zUfpruJlLUdFfV78T8PNnsEUHL61LkRwan1U5R7lnTelnC0iMcRCnOed2r+n3ChwN0YB+tDwXWLoW9yA6CUmZ/NB2Q9N6AZYdi6mPbjUML+Vc6GQ3I0lnNrQDc9Tkq5bJ1yzwxlOBysCDqq8WijFomt75WQw4OrwSIqXHky9KTdCaBuzVO74syvc8yqC2tjXn62H69rLYviQKdVYLoMC7PoiZXezx+8DpYzWk+HiE+NpW+/gmLSV9NDR3O+/bo//EBeOp2JBcuVs7dFLeHh5jCrs2eCfwlnPWrvnwi8W5ynIFVyhuBX8q1C4fu2Px6Yv357FBht2LjFC9byoO3kPgu70ZuLtIHa0NqBsCQqwh6jiwEv8a+hdoEih446nRSo4CGElF9eVpMwsfQw8WZgjw+VxsX5UU5+tz1KDJeMo9R9iftUs0GwIzl9OMNg2xM9cYTbz8I1OAmzzMz9DKPGtwSO3msIj4Sv9gHK6HWKImuMUL2EUDlR8HLk8okWQXJMDXH1RXT+TJoYupctFse+BPHExPoiTZdmhFzm+8RFGbUkGZZoY4YOxJdzsThrTg27Ay4NrAz09PggF1pDHU+OQUBx/2fTM/8eB7BbPzqpej7HHm/Xddnxqqm9fBYGhlaEvzgcMlXSiQK3gR/9gvRYo8SDPzz0vAkm3tncO6Ve/cfmPggETUG64PjiX9m18vzr85BNXPX0AnTaKexe4FaJ1OqqGma63GbtFiAWBreKWLQDE6OZVNBKhvT4doDCUTa2RwoenDlA9MqCyBGs0DbrY1FNqTRVRVszMYpqQ7VUp41yjK1X3YmLDcm3PKZeTdU1crGxX9PFF+oyBXVXr1ieW3y6OZb4/7t+JPH91Nvx55yTR0hsaNEUMZQpGnMpmyppN+ExYM+tL9SSrEKPkCxdWcZVqMIGY/HqEdo9TTAn0A8XayJ9VkLlRh7p3IPOLWNGRDZjbUs4QL31IkWU423bnmcY4AZbbUjap2USgfEucFGjzKwoXX/RRea5Stfy4Idk5gxL4xFLfSD8DP81LOJ4QPyY+6S6OLpy3nbfWXDqodguDaRXw0nCN8AIocHJqKObe6FU9DaiRAbmf4oS8jL4vHMLlRXJAJonKXGSwGbZFMKSGCwew889WxaHbvtidfJss4Xc9bRDm5falG6g2JJZm1ITzxSZpwJs0Yma8nl3Z6KM8xVrimGElPv347zPxeW0SyCDM4/0RP6Ky1bmWl22G2BudSi84Ak8UByOtyH0DL9LPsgypqqrn/85sGSyl0hPKtXcDa+Fzcupc/8sWSI2SM3tACPKcfvbOX3thSnZ+6v7scMg25zOn1lB7C3KlYByVwITXlBjBET7IYCj15WICI0wj6JHpGDXQfQslG8e/RaxOLabprecA5QS4vWIln9bU2oSIcxY1uzy6l1Hx0669GxKIWY8JTlXk9i0rtVOHOruGKDA6W4nYEhatDeFFVwQPNqziOcgO4i5HDLQ4O8DgBgTBlHaHUY5qxdGmjXNqZna2nA7EuuPy5LFPF1st4KLGqHaiL/qbv4ol8IVYurr+zz9nMgBW7pfWDc01fPkzu2hoFOZijvbegSV2o+fNUbfdTfpTnfF3z0i5I3o3C3lp+NKHqCyl3vQoI+vM5Xl8C09zJHpeunPFjM6dryRCstgtsJyOG7z4eN8g1et0i6A+UdD7cA9CRT8ZeF3Xp/PzX8DufJFsvwEbbdrFoHNpU0PkVNkTWjh+aU1tNU9ZdcWSOiJs4JVgPxZHhL5y5Wa6wEkGwFhhcWyBBf0dW4oG7GLuIc3MXL4SH20R6HGY/OcD9NDmU/GkohU/du1AA1RIjrr2lfQzm1WoGpos/6Y+VOiqo4UuSH9hwAKvXY7K1SLy/vRaRu0LSu06/a7Q/ggxPOk9UlRSOIAnqvlFhD8l2mm1xBRRY+qwJuyJbGiqsJB1hDxVL0WgNyQ0oe1gDHZk07YXtuf73gcTep9T9co9EgL4tHyb/a6JSerp7U1hCYzKUu+FcNQLhLnaojmjgoLWzVMsydEWKkcBnQ4E9+nTN0jR2Zx/dB9I9P32U0HrTwFCr8GsqQXnvF7jFrNOzqh14oOZPDAPVGmas1qjXkI5Udo9YhGq1YfRXNEF0n880mg9F/6NhzLlMGHtktlN7Tr1D0bacSIyzipx8YZMAjQ0tZwOw9giPRiNM4gDlm7CGFIL65aTvlvk9qzqJ7x1JaxycppKbpeyau6qf9TvZ3en1L52MV1V8s89VHSXdtMJA+iE/ShWUXvc1clPAnzWPwKxZVOao5jOH9MzwXIHzYEjze5Qm3m2I7RoDZ8nCd6TY6/vx6v8w9a3pAM9covM95HtSoPPd/rxfXpxnr1bG1qQbYjJ1l5b2LkQPos2gedB0yJrZvMGmwSe6gaxGjAQR6j0bVneyP+nL4d6k6B/Wn6h+OPfLPaHt7wrK1HfJ/fIaVtZ+KE+mnib7ZR+brW/WXTjHttuM1Hawrw+wy8ZH/zCcUyAZwjw4Tn/1SQdER5OLkB/A4eu0Gw09cqctFHFK0F8qzorRUFmV9qwRN0gx/hCO1X471fAbYtWohvQQN6aQNsAEL0erE8QbYtYhvPw5pTGHRjyHotNgvEq5Kphtcqzr4Bjjc+hTzqwYXdM3OAety/dJE6OW8nRp53uYCtcm5xJ4GS0/YuH09PFVKahqYh/aAW6sNSvzU5tokKAWHrRWG2i3beFCxaeP/tJFL1BGXeZFs9csz97GIOeIUm92gI/m6EH2nIAPXRuvOAF3kaZ7M5ifaMPhWWshVnbGjjK1JeL1HXVhOgqQ2lFYaiHP7eC7Cuattjuunc5Iwhr8UxA+NPeFJew50frCT58B+VKUMpNZJwEpJdico/Sl7CBuJ6OkCztkc2tnU4HErGmoFooflw6XXFxp0NcQSvlXy+PNzWS3yNsTjk9a94U5PiKdEDyoIrRRmDLFEWEzmtejQRan4brSWkWruRhS2vXz71OgWC0bY45wPYnIy1Ji5/Sqd34i84GucdE7knZm1h8HSm+4agdffdv0GEJx1vy2FbJZHWprPj/WnvsF6Z2CKpwttC7ok4eGnD20fEOrqUeAdoKi0FDktqaDkj60tWF17iFjWFTonz190+TjTbfES3Nld6H00g2Fk91QC6d7AWulInSvxnfORGfOTwG2ig66Ugaa+T7XXXYxBraEmWiVb0oQcfOzcL2Pg7MAmTC+gEc5nH+MkM+3hSjXYEo93CcB0yuuO3Pfrzr65XPZ7CqQpUfhnUTbnyY4+qML2FpuIzY0EbPryZIbz1NTjF/MyVNV/MOqBQub0Xg2qS+DAyF7QpahgRnSCpkZjX9OLdBP+0tzhCa9M+aqGb623VXmg+r0lVua1M2G8fVHVI3a7FEvhIre02iwFyp4f+GXeMX2SuUitJl0JZ/vXOUhi8V4HI6hKDpjbivrUJJwJcjCzj2u7Avihw/GdqiQXm0tfYq9mp6s1kLZGZ0ZV2g0sfDTc2XCHzCKMPN6R/tUZJ0AjYiD58mZ7w7TP6X4JmL+j2369s+r70jPejfk6v/nhcMwN9vtYLuc2ej9RzF4TS0Hw78ynJOH4x6ooB4MF1BWgfeo1TzqMsHNGInxSxyGIhH6D1/cFQ+iXXb2RfV2wO58JtVqDPr9U60zbfrlnxeqVUAGG9spszYczCOyimKe8WexouKcLAeIdrNrut6C47BjxLdwemkWzbCxp3ZPoTXPARPy0pbyzSjC6LjdILr/JS0L27NaUKfH8QIE5oR6Pl+fZ7OgdF6alfh11W2PosetwzDO7rnXO78QG0ZuweDYc9NHAayTMk07Km9mTizLZErm4PBfQC4Xw0bv9P/mArahBgi+PsWv3Y9d6piH++BhFrWvEKWlx+EnwJWyjEdhIcVd3niAoQmMwzTprAcL+qPjNrOJbJcbpgShV+4tay66f/yyrEcPnYd8L5b+6bxR7NEwYydxxhcPtKeA/u/eYlYAnR56LedB+fYC5OBIbmgfKebjr3n3MNKonltbj0GNHdIXyV5tw+traHE/XuG4mnX0BHgn3vWPN1cfk1Df1xxwbS8ZkiKXO5DFrfmXaylz6qnwATtNp7Ct1GQtwcNYSNnGoghGxtQy0BRl4/ozOYzcrMUeVFtaW/xeDc+1RH9LiOx++bI5RYwz9CGmQUfjaSMcRksnSMpPSHAd8MrjC1B05CB6qhD4ojp1vv4aMMbrfLHtJtNOA1XLP39JCfh3lHbG9sFKo32u2LfvMd7N3zvrMx0y0mA0Pmv237QlfhMw6VP3jmhKoBowAyBE40wfxX5/6qiwW1agFqI3ylWfc/O8HDTDqFAf2mrIFA4a40reso+bW1axND+1KUaG7oHZ0JjSPpcCiCeJ3uZOcqmLPQ5bqgwT9FAnoRDwNCCKtE3VwLDGCRsXEB/HsEu4JeGr48ZWW9S5wfPDuDl0gnNTmXA9R0+roEkH+r4mqSM85BoVHcOFhNhd7XqEPu2u4zc2yx2s1VjPIu+Se4984NO7XrQm/RogqzRa4t3xK4gOzbMbAN4GO2MaF06pD9xuQwEozWmNmniP4IE7GpK5RKV+OwexOdmSdMWbtuJ1xzqMXcYkPS2VR91RFpMpXYoKHCvegGDoVWFjZ7BNa6GC9U1Hqzpj4rEk0I6s4qkUKX2q3S9nV4Hmo33KCjzYQ7Mp9QCTFtUxqodSeNTTscbNp3WADHuoOHW5SLR2MVfUFSdd5ErMdWpd0+OZNYxOv1SGhruyoHN9udclVJ516ZCxEjMGnZuXMvb1xzyA92/WkQ06KgbTdn3i6YECRXhPP0RapYje46B+XUMr4LBhxlIeQPjVnPNELhOx59a0NINZHTgOjveU4k/nFlP6305v+IZYta4hmNyG7JFmKMmkKGhIptHntBwhUm/y19ghGEqdmhy6hrKU0A0UvBASYjPlEE0lOi00fT2Gl3BQsGmIxc9x4Sqa7c2jr91Y9JVDYDBflCZuU6/XsQ+t7oVO2CMVwLXg32NQqD0tgNfb8+caqnuefPoDSXEpfmO3TfjOLZansuUj3MHVu8PZ6dHdsRg6dBK94pz2ZkBWIF/bzgRAxw3IFSxf3KS/ixNS9DnBmUiSmADTparnMVaYGsUgwmO6JaygunqIw17lJ3WhqXcvvSLehEPmxr2dM1P7jzcb1hTec677UXR5ysgZavaSDpprrxAHl2+0cG/MpVeEgqZAvBedMIaILNzYcGiYke7If4U7cqy+NzOvoqshMsLanEBTJlwbcoEN3V/V2Bqe05iEchxmykVpUGbNVMeiOU4py1Fe3haq8XMshL0kWXji/DK3VlN98fzT1ELMziEltxV48mKppG9Ude4YnI9NiCFPe2VjcZUQ/I0DNvvRRlJ504ux+1KfD0PMJXzCfCsAYY9pLqqrBdyXz818bAYZfPB0fPGm2FLZfGdwPijKqhNtRWXZXjylNl1RHDSDvVmwsMLO9LzWIbY/STOkgxc+uorVvypa/6Euq4hKDcvmB8omoYt0Zax1zjFZ0nJCiTNsUstkTb6MFhzlzxcNfaU3TzprLgsF/9DEZhtSV/28pcfaQjumvVnGKp+Yg2lqeOl/qi8l3pv74QMBLq26w+ht32BjJR839C7rEt0MIe30iXq9u/qeuvOjavo2hHbgfnqdhrBsMoXf5dBCxnMIDVg5OvwLfAuYBib/CW8CtwBpcEoKkBjNZwCeaHzoqOwAnVoTckcqFFN1XC74nZlEFcvys46Dx2Dyqp2Zx3p6QBQOSi+abYeiMHFOJTMxYkwptGxaqi7NFefiVIy7JEiOzuZGV3aX+mhPaXYXAZ+18+gdZB+b/NMf7gtDXHX3rPsa1bj0jOLWbo1Jf8ETlqL+aJ48tZjjmxBfqjav0Mw/h9jwxjdcewnnFJH4Hz3WYXY4t1A3BfoTVdUBip2KchosR0BitZpCxfK2N9Yb+ni1KZfQGTL9qC+5/Gkd2pl3rb1iMeeKqJgtqyGRc4AxYemkFCv+ONdm3AwFPoO5gg/5RSl2mNecqNWp6mkWxFoKh55YPp7ahctLJfm7cMPQTs75uIK8YaOn7eQxynd0SU90wwBXXlSsBgYGcDDgw8zWWeR2cLI3aQPcXwhUEyzVUPUU179c/LGcxpcm7RSIdQzVAlKV8d/j8yKL7/GYAcyl9q+C6stPnkZJ13u/F8gYD7cwegPs8PDZ9O92e//AWO+Lao5vyV7Pf3wFZB0ykM0VVvSzebbDtnLaVeZP5UORxjm5+gr02Bnh+vlMDRDj8sUcfpCjGBHjfvovvOoBe8L75Oxa95HNK4zgB8p52xLb3pFpLiSea0L+La+nkgycwBKuRo9sATBH9Dj60MQs0jo+34COAEwRx7vqOPGizCC/mHa+cbCmLgn7c1KCfLT9hmySV5jZptIgKw/KpwX5Lr+grC8zPJ1rArf4/thcLGBKA42RKFAXmVZiuQKw+qQUdo+ypl4F2v78Wk936cN+2ZQ5rPZgSr4xJo3/Nf628t5LPKybBbdshvDP/3Z9n53UeKoJgtpwDN8TdFbHTtFr6WKdBS7OCzjyzhFPDh6W5yjbqTik/D5UDC3Z9iPITvBFLrBnKgpc+XP+YK9TGzX+mhLwTZnbDT5A6RohhYGdeGc6PUl98dYeV3T3jG+6F3E/sPkQ69tm60lbMcjJIuDpxeEkf1AZT2CTEiLmkQmgAz1LWSsQq5c5y3rNrc8Nkx88oPpSt61u1j1nRV1R0xJtbkuCusdiW2lQ/9ix4Ne9iO1k+maOe2sg8VWwDkCW+pF+NnZvNodtIJ+oCM9NcxmrBLq+AetIiMxhNyJP2d61ru7vGfepm78cuLlA4Lgb/OD+2rDvyxRZ/M9KcH0f1y+XeOAfFXqG9kWPx4YnfuYkUezcKWTfi8bwe5Qf3jxW1t5YZj6pNUf7JE7/tZP5YimD6u6Zds+6pz4lw1dxgZzvdshN/O90gnK1jhP+MFEKcSKfBEAbdcASrqIb4ZAU5Ta4m3o4sjJ5jLHYz9mGLzH9nHnLos3aI7IlDtQvGQAaSR0d2NIlqNn5IXo1e6PIBH+ZPQJ8IjjLDlCb8inMAkRvUp262+Ih9UWcbhuklhxiNHjIm0Fpw/B9DU7MGeaMGj2VQWxRLDndYKl2xjGsGpyMtnSBMDBIL4D94hV5L5Yq3fHX/vq+0WvRp4bWmt6shzSFXOJJliI9K/CjU123gFqqcuTlr8z9sAVDJdjCu5ofHQ15SJCUIajOUq8NhC6Vw5Wqf74SWNjRlveL8YsfFW+GsLD7iw4v1QgdPzMOA/A/cdNL4ZxRRrX0Tq6dRGY3VKbgyV4Qp+xl0ey6k1JAOHgD7WFzZD249ujJcNsWFlOCHxThrFKkkmnzg2Bc9EO3u3wXdoE26kgGxO/IelSDITEXRw01WEI1dAKKi25D3wVjE/I3NU+rfHpBDkifG7pEVzSnTHGgwITT+CFOqgsWYaiE6Qdmr/kclEifKHyPHFYWCcnGWvEsHP0fJqlH645AwtpV4RNryuqWaIh/Psg9GG9LQ6JDzqxecynCvCS3d7mSzyER/ZDPjnwNJ1NQKO5jkYNkodtcrs0AIAj5VJoPKtifaJ4dOseNpn4o4rVYlSVUXdMTaveMfp2JO0pBdrXjMOlc1+2OhIwuhJHWsR2IzCepONNTAT56LrjhoyM5rVhbWBmzXFWkRprxan7JQ8XYATFqin26j6ztD1OCTxsrn3UELPKPS9nFQ5NmPVXg8Fg9z3CThryk10ouY8FTah7KDMCR0g7nQOpOUXHYlSdcF/0Vp+bnXOOIzHcJtC2cdB1Njt6YGB3zHdXBjtT5nVmd2ZHLWiN8quCLL8tZr6NHx5ZFOgNtc6lNDo6kPTdOLVEhAS9eDePUnCVyfoFqenp80hzE82I+xnAHM73ybTQ55HhCPkaF7CG2tN85so6rX7cTMOnouLJXmLW62zncVp2n5/p7sidaflSrhq8qxOnpmnYNgVjLqNkrEIiDZcUz/HK1avXt7Fpd2GC8FFkd0dMoCD7f5wSF50zDdTfmBYsevp7VTCIVrcO8Alce3+lKSWvdU/iQ7JAiIJ9m1je/Dpapc1VfPX1SeNZeSJjpNpiZ7FRAF0si89KnTk2YlLQjLyaflyNeHYmxOs5IvZ+S5TzakZoWmOqi68r/zDyN1zBs4P/uxQDXLryxnRpMjN+o5yVMunVhtK2HIv6pzYiBKHpEfATsRYoW3ajXP9lkWTskyKcn7igw5FRU6IRkOuBk+bwEh2UKkHxXvVMUxX2A6EEP+EwJ4Z5S3qaGyFlRbywidFncwkoZwuXjO6fml85h8UJ1dM4FMI40U5LRmDGVtZePjBXnTX5XT2chNsTwaTNlDrRX7syoCZ2el9CHNb4/JFU/C6qDs84F206VZeKW9DRmSGlKQxrPJqZT56bgThO0GuColvIXGvGceBtsNwPBMMIHzZ8MxB7ApRRqk9qAMZe/q0v5mxsMFiPUZCwejwPOnTrGJNlJFXJFRl1/VDM9xIYkWtO6luUWxNjxHS0jq9KeqrY078i5priyYUGEsK2zJCRgLiWQoNQerR/iujj9ORjm5n9e8Yh0sy2vOz7gHs80+8UcfjHYHZWuF8+RWaoM5/ipurs+wBqy5tMbAxrPlOP4TuAEvNBvT700nTbF9gUgDMiQc5eroWQaadMHET1d/P+MLcvecjyEwecQMfljH4oxCJYRWh2NTv3eQVZFEE5CtTEM1/Wju9nHZo2GiZfEY/qA4DcRPsTon92rvLuVUe00dhsuHmznUJOrUYwc595ZezMAzVOxtMpfDAfayEroIXHl3JY/7ctpE4EhwHQV8AJDUXNl0fKVXpA/wR4EdLsrs1WKOno1+M/NnqxV7RROzq6fBBmKzlNu801RqTfE6J6b+SgUWfDty0cDCnKfY4KmxvkmwQPRQ80U2KRh1R/z2Rg14cCa3z2/TYHIYrhDTieU0bvx9EWUaqqs65PRTTMsSwddU+B/usZ1TdB7c7mRi9Anb2aotBYj1mzlASgwfN9PrdypF2TIv7wwJBa4oZjwQeIzlgaPmCUUVdgb56g0BMSNpXpg0eaxB+EsYHryDfTi7bH+z7rlr9iy0Kk/N1Uy9mjcdGGmFH3X+/loXXWqAHIhbQyIch6LeniFu/he1YWjMIUqlOICjLpWPta+fNJO/f5x3Rs7U7UmAKe4NeDffNmrTNuWquWUCnP8sJVJ6ghpo3fXK+d/Fx8dShnX0F7PrRtr7uUddaYwuD5Xlodx5OMX02DZ8A3eHBltn70S9fOfez0YsFVKSudKcHtrALmGnCDXvIPCf0OLZ8d1ndhx9XYKfUdrg2JcPLNUZps9Wu4V/505pDTKIVtF1EHkRPNNU4wXTtgKMN4rrM8Oba7AWvQHjiL95iN9WGKsa4zdO8NwajkDxYTaZb2C1kmdrU4W0HZv9rFnOHrxzLMXXgLPCQ7PyOttCy5C4S0m8M+jgoucT+Rx5prs1JPm4VSLr7aJLMBC46Npeyy7IJyoWCVhrAXXEsEYy0aANIV8LTuYIfzaX+Da1CJJz2YdzXqKRCKgIW6wecwNxypwGz0O27mcYB5vILxU2Knw3MtlaBWEYn9NbSfvKWCF9W+QZlw0ljKc2P+FcmEN0nJSTfPc1jBmmgQm+bJxRwDKTr5zF5YEv8c75e4wQ4gl6sE6DjP+hFp7qoHv2szj/jGe0q6Eu49fAAAq7jXB4cqgthsxtnmZtF4B7bphHve6h94XyZkeji2rLT/7zldsLd4kDxnd9TjbCvp582Ge31WoifgYrskfKilcTITSVYr75Z10uZ4oXwTdfpFe6uHYL5dn8OvhjVYvH9NVQPZw7Jd/LVJTH9gdbNDSZS0tpdLr5AR9ayza8Gs6F3lP4NuvZ6ueMmWWKr3pbwyn7SF2vYxPF0Y9JBemmepJ0M0F9oNWvwdY8KaD6J6NtWNsuUJW+BN1mk9f5tDrVceaKWvcTHgWXVV65haCVgyqDwP/5JBvWyyblMMEeVlAU50ZIon4jtT5kLCPc2SqOZL1oVgrFJjRaQikkoGNDy2aOCuTXFi1iW174iINvxTixf+8DTs1oT+nRXSkiJZsu8CCIvhMB45dv4Tfqso1n6nVmLj6LcRA/clxUIJj1X5REEnxBHDhFJpPh1/Tr8p7KMq4DrxAaZfCznG/2GNoQ/tvRj6BZD2VYNrW2jRjJEaLpYUonROa3dJTfQ32bvqsuKlJSGLahktdEQjUM0algkR56u4INSlng2Mp4GpIdOEUti+NO2LflTVTJ0apiw/9VRTpiyvALBi4ll8dP5HWve5B67o6SbXpLJ+mWEjTOesuTI52VIBBUrlYJB9QZnsYtrx/+JaN14VGtheB/fKfl8wvwkfjsYdjv/zrUrcnyHbh9l9ApnfBA8zFLziwpW7c772/Ht/QI3h6T7nwWPqHzRw+TrL/huj2SXUFuPuQhLmOHV15Z31JajZpio6ahLkURTLNqD3uhzjQkh6MO7MzITD3FiTysdKlj7x+IpQutfZ/rhXjeov3+U3ssxATv95QR/M7u7U349F39NoHAvD8s6xFn3tI/4snCufjMTSUH9dq4BAdR/FFjBYgH/bktLKADTX9y9Mj/ncCSSTiSCbqaKIocLFFmL3EZGe0KelHx1uVzTof9VNPUdK7R+crmDzXSsHXy71++efZsnNSf3CpJC33w9Y1VO99F51MD/slnSFwXa+LOlrXTmrF5u+E5hoK19CMWTYE68IEOPdoDNBjiFzIU2YnKvRRyJj1HTV9H54vXD5vSH97hDnpVd9n13zhBhTOXicDMt8fGzrr3hZ/tDfe8bXx94+UQWD4CyEJX4Rm6r6whtmMJy9kY3PBdlIBgk6GcIgm7dBhcmeF/CnhTY6CEpOym+CE19joLj6U+hPyFt89UekS/9+wpQ0/rEu+67H1/eWepG47/lnRoiQ/dmjyw/a5PrYz35ON/Rnsvh2PPPxJV59BvSw6tu81I2PZvCY1fZleDA9PRYRW3xRS706LUzuCcesyKPfxkVJdoOCXNeu5bX2cPcCe89Nlmbbpuc57DUnnfnTeq+r/hoZw+vMHJj15oSo03uA5+kVaKj7oEx95zJjOQKco1WQn901nmXy+Q/B93vFzVNtcu//7DgTol59G7at7124e8XOeZt1qjnzOC+oLtce96evJQb50Gh23cjZRJteBU23lZGNJCpFZPplkORPJi8s9lfWDZ5+FtUt+z5FBpyEyBqUwTdR1Oqmn2VkY/XId6aU+2bAY3Q/dLoTz7JRP6frX9GF0v5yXJDkPTkjuXNq0dwWkV70obKoFI2nODhDwDDMxztZYW2NQHeLvvM4JYNnZoXLaNuGc4Fj3Qe6XBwH1c0rqT1NgvLU5lh6WTY+lL06T7JuCoQd0IulQrJYuMNipMRkCdrurIipRcTv4BcGDkY5MsFx7fpy5nlU/dMu9N+ndsv9cy31u2lNVi6oLYDU9HtwLpPBt32vFRHI9S/5ZHPIG+dQ4GuJNDJR8DlsPXzKDPYmd+mPYVJoZF2sVTnTrcPtkzWLscC7ApE9k+ktB/QAkxbpH7tpEPTLF/YjIXErE+Gv6ZXmPTLvG9pN8GdgN2uUA+ovp0FyNUvPBJR7Kz54HWzqNw8/8yapFnv01ZaP0qHqbLmNI2FOOTCuvi/aRAowrX8ww0frGaU6QAWQ/NTPrKwafPZn1bM96/XIyY9rvyXq9VW4QP/7jkdY9UfbLPcvkD7FSvqbRXwN+6FzEPt7/HcSvK8FsbdueaJpIRKGmmJDtL47a/ueESIhWhEpApIvAQDyFmKJpQnMoz7fYwOS7GeqMCVY27lH1pL0AvBKjXkzDmrMfuUQIWOhUhFm0Z+gLpY99AtLWlbHuBAyHGh7C1U+UrLBTOWj3ejGt6az2DNcmr89OvW1Y3Snw2YWPSRj1nS6sDajEo6pnofpQ12hsPW0NJtit2rjbDlJ3T8XswhEvtx79Vc8vnfJ/LwLxWXsiO/eWLzjG+ObTrZ9+/qSr+d0B1yG5H1ZHjFfni79lEKXfi8paNda3s3fUxq733wJ7VxEuO8oheuaRNDoECIy5IflS988eZTGQ7u7wWNM6xAVDmpQDS0qXtsHGo28Q7uh1ZevNXcvBPie/tXB/OsGrUDKP7/sr4o0vpyP5vsrscGPYo+67B2hyLkr0HVsV+YEzwir+TE97t+4p7Mbo7SuBfSewjN/5hHuUHZar1Zb+aEzKlVgLrqHibP08AIkSONwIHG6ciSc/jmoDwiNRRpiCr9CB1ZJrvJg4FJtY6mZIZKKbRV/Y7hSB+g6PzyF9amq7uAX3DPWzAALy0Uf/0PH3ZmdpO67/XvTTYTtwOE0/mmzcV6jpf1PebQP4fd/l35oD11WaWoWf91fWFttD1nL+qpdC6UpEfrRHbUmPZs0/KbYQbrwSP3zicaADxLo9HE47fWBFLw+mEKV0k3NPaThb4utbxTgu7AVMB/p9du0e9EbPsD+WO3i2021ZxXz07hcjsCEy+sfZbUBbFD/DWacay3No4RKTZKma5uZTdgQdqaHsCU4ls8M5x3s1mblYH1YNQE9k3x6+ex1AOCq3PvQD6eojs7vi3zN1MhcGZT3S+uVfT01qjaGGgI0fz3L2xOijmnckdU5EdF3B+Ut4tFcmKPKxoNOqnTxov2nq66a+kxslPaMrA1C2gI5J2BivGT9bzj19Zv1OFPit4k7O/TLMu4KRIfYT9cZLOIJHxsMMpf2FqJenz7s+XuC/sOm/ii2q6jYbesa6TwuZT6B8de6dIi4fkUKHlgXiLY6+wFdAheaOWkE+s/VqtgJT6xcr1uCGTjv5s+nc0tksCUQvCeXB4pnGPxs4jJcKIS3/sKa8eBz2jfqttVU6KoLkcFlUbaL0b2lh7hLLs+0kNftxOL5/GgGmJsDZoSYxRU6v7IXz3fif/nuvJrg96/2mXcMfHB7tcJGXCE1tj36N4dIogmcC0GPiPGJBNz5lseTiEO6MDhOOWMpFUmJk/IyAGqxD+diU+wPC6Kd893ujenW6htgpeS0im3QZ79HCNA5Wigw39EGdHxzgLBOLS7zGxlZcabPT3H6dNKryv0dWNt478PLMGIGIbvyCfQ++7+0cusx2r7V+msy272uGxtYgmDfn2tRHVKsAF6VpD2sjNZcmw5Q4oYw97pS4bxM04PFCw7Bkv9BJey1d1o63Zk2fkC2c21HjtCV2c36E7Ps0panDVqNtzr0y+vMjYgTA7ImA0OD4VRMJMQ0m9+Nhvlt6vuOtDtcebo1f/A/sQ2LfpDU1XZETNG95jTbm3gAMO9fIIMZuQYQsiVaWCO3wV0PP/Kxe1/juOtqUAOJaz2mt6HXkyCdGX+Hj+gtrXd8P4cakA6hvB/FrTFIsxVF4EOjBKXxkHXeAY4sRqQus4yifMqbTc44+fdDSL/9cf2XVduie8tpSFVsdh2s9zeoWqbqQoynzGmwbTpow9wFgv3wvJeBUauzGo43BEA2JAWaQ0ThgmrQYw/mz4s2TOKNe+G325eYXMsk9xjrU9QnxUfz3zGKkww6a6n/jz/zBVkex6x4kLV3ihdbWFp8C84VwB3R2fD3yziTLdqTsllm9hLZV5iXGXBDmmKOBWBqSBRABiGiYMB+OrR+1+vQQ89cHYXcdCpzaQ38teTIXZHCajx81xCOFWOsIMkNkMSD5bb6Hi2DBmyH+2l/oN1rqJR0aIj6vtyxlyI0mxuIdhg7ANadK0twVWUS8SeUl4KD3oXWESriEMBMTc2Q7ne9jwbbJ7ZSx9NvLMR0dKPa0glR4Z3AJix+8AHbsXiTUolkRfIPBDhty6GWQP+1+wFkQM6Lqzxq9VJC0hjr/Nf7PFygqKU+GrCd91htUCW0+DftjWplVu70iOO/CLP5iKQLIO8tzddFJKHCNWPRH8kW1i5/ZA1HEN1sn7doZYxrZyi70fx19ZYntE3+IU3n43cOqMfAVrx1ftDk7jIq2RcNWhzAPZOgfFRC5p7W8/Z5glqnvtcd8rsJ4gmCvgTbuIH7rYFHtgB682QgWrRcbYczWyjunziKNA8zwMBDrmO3DUAmbaVu0g7RW0zOaDx4dihfZzOJ8Km273pW4DaboQRuzjcly17m+SxWTGuqFUwwbqsUoYVB1FAUX5JhQi0Htp62AYiSHAam8yB/INjkYvcKiH9GEQhtlPLJ5fptjKL9SsSRFlwl2hjW59EYZk3INpVC8S/5p/F7Lmr9N+FKByLmCy83jGTN1uvoL2EDCldCJoR1KuHcbL11N+8HxahEz+Zk7V/9aITyEsVbYOZNgBb3PETf/P3tXtt04rgN/SA8EuP/TnPv/j5cFajGtxZQtpeOQZ2Y07sRx0hEMAoVClTaz+qJsiGexYn+iuHC0AxKbQ31j2tN/9Ec551x1E0JH4K6l/7rDkOVyU6eQ9kHSC2qjgl0fn6ccr49URP1GoUWlWlk82nLmM4V0Fy2+eN/m5e3lSpnFqyZcVCFca+oKq1ff/pXgR2mhaU07EzBt10UHqimdi+coTRxVuj87l45EZVPaSu0/oNCQKvMRAXLSFKaWLh3BRudqysSQjlBgSOkTJIcnkQBLXrBPAJ1R5+PW6u1Y8OqdyspkKYvtxQl6H8dceCOdzvSPWY4/pHHnPvxR/aUbasVORUPqT/drN9iHBAOrcsGqCtw0JQ5v9/aKaOdkO1zvcjtxUHl009Hx+aGaulWhHfCKNsonOR69/N+M4HjWD65BOlXWG8Yha33EyShQKcYjxe2ToYbTdg4F2TtA74r+U8d5F+ZwSdDOQMHLqDyC+MOJ9HwGkWio2rJ6I46iIFlRtuGVYJRqY4NpEx9yMmkJpQ2XwVx5mYlN2CfAeTXVx3EQuHWW5zw4aqaYXMvS0obt4etsVssar09FvruJXPcN/Ho6wuXc1NYVM1R/N88s6J4xQtLmUnZ5oR+hG1JnMlvyMD53iEG01G1dyx9IPCo9aADW43WR+gTMAqeA5hdPjSOaQg5GGDLWWUyQDEMJKfWT7AajGUQDzZI40xG5cwbqsEEWk1HzxqFFiyOJmTOTHqaDvuovWWAJ3jZkOsMbsAvOtZjvrkwqwji2qRrUIKyskAOUtOWsXQqJrC4pxZPBiy+VtJVhH07QhUlAe1D+DrBVfIR9ibrOEkfF+Yyp0d6w0J3BPDtk0FUULhycftrhtbOVshYTIBnppZo1a0bLOzwOdSsYlM2a58Pmoc6eRUbAS1hmukKQ82WyOrQ90rvVkH5SFDyS1rqrOEoneTvggOUt0WQvigFWiLxy5qGpqzr2WKQGSDSBdSbLaUgQuOldzcK+9Gj/aWa8p8g0ce7IXlvOmLgc0YvDritOrinaTSbLcJY/5/JvqlXxLU/0bawaipKgNiau4m2cSbLpzo1cy5rMPrnBg82MgDBh0CUFIPj5De6wtSgZJ4Iuk75RSTHQaidNOL8HrlLpOn901wtqhabdJvLEcJg1tdPxryEVcSAAbITiNNaKVKXXgS67TV/m8S9yU8xY9nST0/3WJiWuaIXKJJlBBSF9s0MmMnKSqUOTzvg+qjG3XKqIEfvZCKjAGmM7Yzl2W2KaIRuekfCU0kNfyeoOVlZMAA+RKyn55sloPYjPHk1hybLJdXbLcCJZ+pdVrX1ravjh+IN0lwW4tAD3R43zcfgUrlFXzQHt0c8Tjnorcylc233c++UH4f9zAWmYfUMUA3u7GiiE5nA4Z/dsHKE2jwZNCVZQxrtRwE3zGvDfxZHKZ5/bWbpkx1SPTKT3hrcnIvPTU9Z3wvGtikp8Q4LZ2Do9CA36MO3xpYDtK0M9zbptXh+2fUnjP/jQOmHGEHiiFmSEWLf5nlIcNDS9y6s3skKTUl5qK4KT/OfxEdiIBWlKsesXYXMCvxN8Rnk83yo0r7Xbhd+hcaKxR9RTXkspGQxnDLXTcaxxdgesXk8KjTpm6TE8BQN3AHlB9tJ8HLSsvQmgE9S4xmRV3cn6PXrbbyFKR5sPWjZ0eRkQ+9/qcH2WpWh/bZZbsNvYu9imxbbfai4KSZ0QrkVVVFdfbCsEvyFN0heZ4dLFB7QRidWJVmiGP2HCwqk5kmYJnY0VQS+MUjDFc3HCnLU0Rqn4c2rQU9KjgHGcB89R1JOADaE3qpUZiaqRUi/stPyiLESjbJTuSfB4D5yuy2GqH6xNHazqshNF3XSu9q3cvkn8bxePiwwZVA/IPzspXcu9DGyDtMCpkAsgho4SQaImJFueVupEDQ0qsEANBGFkIxAkUFR8mVyjX9F0V8AyQPceaf1SO6D5kS63h2RLF/vh2Ur3iRl8zzDkMyxkQ0lCZ6VkgVtM745/eN5LLn7NvJf6Hfzkt4CNDFaD1kEo9CyrN17UPNT85tYefC1h6TMgP6yFOCCAxoBj4SKEs00cedxVKkCmjzf6oGOjxgtvATN8VeaLnefSLxcvPOsP4RjqDUl7WfJlSV1p6HNPi6ypLxq1fnlJeMGW5sFJf/EWklL96G6rfwHR25msf6/Ro1B27SHx4CCo8kw9zKQrkLoO0FLLFV4dXrHwi+PYfo0gzocemm6LAWPE0NDIf+YvVmv1NKz4Q3h0p6b2yz9HxVadslHdkPk3QpPXf9MxzXu7+NbGPR1MKxNjfhB19Thf7SUVXg+4frkPlgxnU+GLeG3Qg5lN41gVOTU6LitZQA3ZeDk4cWMOtcgPhGiVG7wQbazCmAUGtlmJm4WEo0TyCE8k8ZoTRk7AYj6YOizzmvjVLPUf9F8OkP1txyB11dhhqqdB4oIIl0F/7KO4fled2yxbok5WoMWzEB6aWqaGBIdC6N+ml8NWNDwRnejtonxMT4bcJJ6noZ8sWpYW9YK2GwrJo8xEKNUAR0lCEa9czDDAG5ie6SZdXpd1k2cxZa5s+DU3LAjI4mCZlSNT4tEsNzTMNg+vEqIdRrukFCMUndyN9NVAZ7AA4UY/bJHwmnQiowibamFczyKl8GTd/B6T1gjz682N+KTqtlYSLPaGPvW68dxOFbA2h8g6taLplsVq5V7Xseg9QgwcVOGXkqxHazdrw2Rrd3GS8FpLSNkUXNr7Uxa2k8/YhtLu41fBTH4nKowt/8IHsXNGdNtQQzr+fkMkEP+qfHZAfAP5x1T6j5B410hsZFVBP2qzhyiU5rxvtVBVolCazXR/5uNhR6M97PEG1xYVoU4G26wfv7acX7MFNTUkP7p2rtKQjGUpHFJljPpDYzag62IG5CeCVbeG5Z/IW6HGjnLgQZ821eByRKX6xoiwMaU/Yx8SWpUWcRbwXCPeN9v5MTwph+6JDSH0xHuJF9w9y0PMmhBEp5y5GxLxX2eTrFTGWfLaSZSYsaypmoLAk4jE0CgvRcwKojCHVzYrVUeJEi9mD0tpWSF17V6KQRVHUdz7RKjXk3pZtjRU8G55PKFIRecc5HHVL3Naio52O43TVs+h10UKF3/SL8+P9Zb7YTzpHZ578TL6ExHshjSwt6yohbeOXI0GFAVIZfTM0vh2tAFyh8oGeuHJb9gpVpg3bhhr+xP16pG42aFB94vwCdq30zCRWdWHTkGCwabEA3cp6Cmk/jmVHTbWITvZtJjQdaNQ0aLiEFg8jH12CjE+ZKyG06szvK4CahaCMTLE7RxgQ3m6n9ujuKOjuWEycWJOFQBfzqnRfwZVljJifVD0uyaK9EM/GZ9Q1rzPhY/7bsNPxh8N/OM/zGGgcVlbzZKKFYXYW9nON+R5HN0GDSsdZzGdHyL1GiLGbRjC+ToHEsGaYXdjoOoaR9dkE4XgNkOWAKPGQYLOnoFxsNORRXuqR6ziHhVvXYG5OrTo2lyl2baTrcK6OdIC8ETBBgRjTLVPqpZMnWZwVGJIpeQRB4yvMjHSRV/cWeiea0SWFWwHG3aYjM0GpfDO4oNp22R6tN6PWk89aszbt0WWTsZWAT/adho/9/MYlp2N0eKWrGrhNfI6j7xWOXd7BC/1st0rRodXKtgU4RYaMjpet1maJG1ppCpkLjG807UDEvjHYkqvpYNzRtTKNbJgAPAFjDQdsywsFIzvVB7PphM1wCUZxm429aZZACZIbtvZwPQzVmpk9PIq7HhEP2Z8Y/GrjIJ1nNTVaskOe10ZGcI5piHJjZEIWERaHleBUiaI9Z+Xw0tZQUS1CrJYMeUChyPNyITfy8xtxAXSt8QHhAgS8ph2ooroY221jQOuqJVViYC7ueIuUqAd8jn7/gQWkH9v4n5pD/CdeiDvrOOUvkbt4FqWNtD20azdyIhNpq1iL3RC5afYW1qYRQ9nk5seaRn9oBPcNQdds0DW5ZEu6WrmzCTqOkDKO26IG7BKD9Ggskm1QDDAB9IvI4rbaKyiIjEmxulF2ct8j0eNZOkXmcTtlGSmTEEICEbctRUouFZJxC7Uku0KhqdT79lBuzj7ZKlxigeb/boFmCiAJc44hTs9uiM27bRwa/bizBaSNz25bHRWpywi5MXAS2JZWGr0VN1OrVeY0wywADC7Qy3zZ5rKrNmNxQlDdAQbFU8tEAPST3+LE6y1lqZ3WxHkZEXKCsnV1jEHUGDnw4GQOaRW5vnEYcGNhP8GbZwcQREnoH+CAOae3p2e2Na8X6at/ZLfUILaVI/cP4YNppHNRM2G1p1w072wvPxCQ3x1P2iJHLuMHcLOLbCZFSlf5WtBoDU/JLwEpo9sF+xtUoktHV0/QqKbcpOvxgEvSzX1sCuXmyAHP5Lf4z19iEKqdkACszVnQC+mZPwlAzE8NpV+GXYYN0Cy5eJTbSw7ItKskXC1ecsj45ig/U9G0ydIuaEhzzFidXvbJ1wiUHIZ+N90GHGZjmwOpFKEEJvtdjY3HO/j9Mdw/BfSF5xkt4qHNLSRux5g2nE50Anqo+t0CGgcQuxVSbSw8mkhbtY13HvgNr1EfOjEwfhRhfXKbZhNbHzJ2zqRCxCHYQNYCWK4cExI/9WaDavBY+PEyaq4jQA8tZgNOzlJQdRkvLrVyFkk4y9U8BoTOHxDjAAFp3BD+Nrf5UpVxtrvAblbVp6+4O+Ore/BYU/Py8yZIB0TMY6mIBIIBi7cefwcnYBxGsPmCBsSjoNRjPeQzJ5h0m3wp6o5ivoeBTd7bcdkxvOQxtOL/wSWuyi4EJv3X2AsGfV1/SHZ2DWLWrroovdlqmseSu0hXUw0GUycT/TNHzyuO0bWlO741l6xcu9pXV7elxr2fUuiLWksGV+BPw9FqzilNyHc6yz2AY0g6F/pGIYFRzQpITrplEb5GCvVC1fK9/ivaSj4s3LMrNEPszApZZI42D8WVGdF8IncD+Fu3BXyG0107H8ZxNJ9hvvlulPlyoC0ZLjHZCvgIpZOMDRWosKjMm9SxwmFEiaMcTE9zw9GpFOFcMT5q5wyoqHEG7Ne1nXjjKUq7FHX+IV/19EcfN83aRSnYRlxrDEbPtQPPOL2avUkKH0Wtu7psXkke6bQ8Evy5u1ti+3eXm2dzU4MhSG36bN6sDbYa3cAsLB546Ko3ZOVxRuPrRc72EApbKEtTTJEwU6zduNKR6xUMehem011WRu6LPwq0/HRgVpodb638PnEiOkB2S8XUvo/O4rd95zEdPE0xYy+h3oko7u/kgBnOsKeNTvt0JBiuL300+Fr8h99pkqwIVbhhbdsRwYz/5lmN/zsiX6SJtONhBtCvEnElMla0Li9kKr1g/J+GFxqNXwKWrEBmPVtUpMBfHpDew2vZupSW5epbXZCrD8M2se4C3TVYUs987UakepXSSqV8rbfUwF+doT5rY4j6xXl7bXwx7EY9XuCjnxfQ2qItT8JF1D27ChVD2ZpwmyKkDoxXYzpRDEoyvbf6qB3s2zhyXXLzbD8Gp2U5Y3UC4rehv2WLdNPg1lTaJtBCfoV5F9l0RnOm9Dch8OrOtq9LKRhYpYTxsY0R7xCNBjrpS+PAdO61BpBTt14bKf40SDWQK+P2eSdaS2+OJRdOUm3GpZnItd5E1r2VYJCjRYPh0lCFLh3HOq2Aaw4K7kA20cojzqRvrFiKxgEF8ImvsIHsN5isi6jkeLdpS9ETUEmS08aMCtY7Efjzp6MK1ZTw5BNkuw6PZty0LEoCo7COdWMtyeyRT+zr5y7rf0o1/NjjiVN9mEK4Etd64c/+Lcojf5112p2NNv0XSpaDblkR78RIBBnF/taaLUbfAQPqtZIyNt8CsYhspjGDvAD4hAWUnUUkX4v5y4sS9PZm4IHKgvYLEZOmw0INZud2zl5pxyHSywCw5acnu0v2QjjOt1IE3VL2kYbA0IMB4VEj77U1uFDOgu24flkUiiwHDB4FcScfNTJn2EV4BY1Ze1TxSU8K55OrrlvPpKpoClpHfva0iF6Fney0BsNTOGLrGI79Bobb99Lg8N6ih6YGSG0SImOSxSnEhem28ewdIdYB3Z/xTdJXCkcJJAMo6dIRZIWF8pUC1Ek0KK3I8wG834nqwsv5/k/GqiK7FrghT6qhgTW17/JfMRoEbDVQx2Sy3E2v/Ki06fWlfwsvybY3JR2Zh19MN2huq5FHblSz2aql/2RDszqGa5CTvRD321rfDsj4bBBvYwiIkrSq5nR7oFN5V689GUuy0rZkJszCAtAYgCBSejY5DVZ0g7N0/z0DZ0F+KBnPxlXsuA3/wJ+T6rdHAXWLPi358v9YTVtVO/frh2NmuP5+6sFRDBL9nOgf/2RKnaiP7G3e3KVI57YYjMNGW45vSHXBl8aNYJNQJ3kWsdJi6nayb5sMF9zMChhpKyUhCBkC8cPfIPUF2qgSnCaxIqEEpcJHH+Qzws6S6iwh6QK/Ed5MHb7+zvekj6tmhGYOUXOJ7R9e3RQVFK6b2BcWqzRBhZarx9bAFNFax/f/olunVF9ikU1hJPr2xnF2gnOsJTqLB4XQZeK3D7XaryIdhtxYy6iUx8caDrs1N8lSvnDDOoCaaC+x3Plxa+LMuO2sNH9IogXe4tx8KL2RFcrZabsh4WWvi2t+dB1SK9FY9e1H6+9cHb85QgZkMJ2dKw7CX0G1Dga9BygMuFSAaDSFCy0k/rWMSAeumZyldNiXSmmgFVAW146YOCiy/oBW7+caIJX8uIjP2T41ZcKs27PeVDv+Q+4T8vM60oyz7FhbPXy7xDEwEBaR51RLy0YahA3S+isI8CMxefRwdoBsCTGkzy41E9qBR/plMPEP1OLatPOruVajZvfr/Z5CsyZ7nBipbVsMX072oy88c4mYbFa2Sy0le4hz0aWKg9KKJaFORcBjD2p6VQTm1SPIHMnEgTvTp0L4pctK/0HTKI4WHkH0NJnjrNOaf0Ds/MvVyIrfcRsw8djEO6DzzQIJwmtBrp9ML/QBQkwvcqaPohnYxSdnXrnOaQuh38V3t564zR+/Db8Vhn+YQClw7ydCPJ+AwbD0QDMXW5pEElKP+iqvsso8G7QD0LGHJY1Jjv48uCFGwquDSN6wHpInYDBeBLhCtaDB9PB4jtbUxbk21EUi1iIa5TBFyFmBKnXT6wsN9Nez1s8h9iQa6HzvK4USI12lKA8ENflm2ii0E2gXgX+MQjzKSZAvluyiIF+lcK40KS4sFNEuODm3EIgGs9/MrxHmnLK7GSNMlioLt8UiBh/ige0ZBK+MadFIWyAgqf/20qqTIoFLTsWQMbdI3Od57YI7lg6xUMQ54Tp4+wmmzleLFb10Z2kq9ZMTZmtzKWAeuC+q35prluTr8L6Q0f7Es4Ukx93CE7yW3h4uBe2PCFLpHv0XUoGCxsZ73E0sxGfDzk1VjJxPpvGlIQtrgM86dK4a2hR4teYaIQf2pC9dvp3qx5v0A33izcgtASbX15QzFhW3B6mp1v9XSkKF18XkyFcFmR0aaQWSc62A8+HdRYI0hsEmRy6Wiq9edj99AvDmMptLtkjdU+Udd6qs+hwyPx6tfQ6ktfrdZ7jnX2ObTNvRCubPHZo0ANGWbRPv5NAZcW+fx9S6SWbOnlFI6WQ9MjJC2DxC5IA0N6WtetUicGkHAbpRmZEWB8LUTaBIN4tXH77qa3xb1jaf1j90Z1b04xuSUrHMhhHep5mk1Yhqr2XLSQ4U4LpqOBatDhxUHoX6uAH6Eqld1Aw8/CaNkgj+9EGhLkHW7+8pa/ml01d+kw3pcBCTGfs98srysh2OVmAPGQug0m07laX33cSv/OFTjbLGZvmqFKxb2UxXdGQxchiPwpzLthA62myj1BDxarcYHBujyMSOqMdoFUv+1qEqOOlvg/EVya9HpANXeJbZ/LhpvmHEryFUUyPxZZEzm7A/y7Vc9ZONeIj49aDNCv6FyyMeX39YPzfqDIANsHCgtWywAATD1XybYC/gCiTykErJZ9m4cPJQn00D+KhWgg5VRDzElKx62z0y+dsh8rd0rol4x6R/bIuFOkfHrzUwcF+uRBTjFf0Jux7pmxmqkdBnKSjhmLytHhNYFjoef9BNMFTbWi1EwHLaQsDy4pgUHMwEJ2HC5wWPXp7wPsv/Su/JtI+g9+3/FKNbGACiOUP1KH+RBjXwXyyVav8W9lto0VBNH9J8PHl5qno6dwohe8G+ycKOVsXay8VkgvGwftn6jrb2e/Jdv6OgBvRBJFL+OMJb+5bN+QxV3Hq7U39RRc2+ivMqqoSI9VfcALyGyfHTBc16QmY/tqyrIGRkCiWvEHAL1cw+mijXz7WMXBXpMEtWJo7QbApLHlMja624LBmR0PCva0V/SctLD++LHCTbfvEMLKTwqJ9p4UdDSO2Q97z46kssrFC0Rr1tYVXLS8AhIFkrCeq/1qc0rSI/ouHTVgkDr63GP9Bm0Ayrh3e5IaEp89GWmTHYAvy/7owRYALfsPQ9gCt32U1RjwIDI8v9N0sJpdiOuFSzrY5VEvdsu2cW4hY0ZLu97aN8WaIBRtDyz8bO1x1zoAUbDsMs9sBI+xTeZMzGPZJZjFDrWhGpkFTQBhqtQQJ4sVLJvUh49ivpBDizl9JH3FHTB2bx5zsFkurEtuS/dbG4m8q1uFiy6PzLRSoeOCq3sDkki8CWjdiAacHE5yYKY3HLgmtGf/ooKcAocCyjYTnCWVmkZXdqyAnMdlwdPPjVsRQCeweCiOc4163M8CjtdGnJvk34t8UPJhcKYRQnZ0tlKdZKRxsPoqUK2TJWK4xS4ZZcS5JkanzaYjRmUYIRfto/WGOJO/inrRweY7FOuDpQock0ulN1kr0mA3FRDF3JEk3wpvLmmY1sIVgb14Yd2ZcUp+CAQdZkH3fKKW9QWLBwq82WDQOUpijBdgzGDWzoQztJoqNx2F5Oi210ekG9hFAaaddW9soOLEVlWWYILTRqkJIal1oHRL2wbVs3Gh4tBe4A5QG9KxFSLKWk+mbGzrPmz+u3ilcDvnHFxqtHUpCNbQQRLfzuxnun8JXhiWPHbw0ZM4VhwcoGWBuRGFmPMYJrNqho0Hlzwu1zpfEa32qxt3ro/i0lMV2XFnbTqmjb/8GG6YY/vBJ0sL7J9VyfSiX6F8rOb1WtuO3WlM6+RstZXdMO2XR2mURgiUsxZCXByxCm7ZSDhN7p7LxLCZ8YqJO4oSbNw4EVtJBlYkT9Vfq4W1GZWhxONgsj+yH2s9mIHUXQPkQRJ1ZeasK3loB/UgYHFYz16pj6lvZAZ9633I7JRjfjlBCTziX9VYvUuFuBpNTKAIaSL0ezUtZlL24i4PqaKGN7RXBQPeGlVcNAQa04c/igFJmX24YvmipiHQlUOmABwg8ZXCoEqysRuA6BtnIUwJCscijM9QcpqhwQubxTsovb5bAimpPvJr5BH5/8CQ+EU0n9PO9pXZmKOxWAQLdODUEC0wZtggawr5eHXpkF/rTKZC8+IUi2Wixco8iUecHB0grw5NsA/ypnAEPTFwYXAowRK0CzmQn1FFcrnZ+dr0TI+GEUq09cZDyGYyKGgKpiNezE8DfAiZpI//mCQpVmnYQAy83KRS8+CyQAiSeUpuBOib8GbKwITKdChCYQdYKcNrmbOengG4BX2DIKZIbyQfioLaXmYJ7K91svxFuVTdXvp3o0nY9n4DKXzp8YiYAxDqLNJ3lhgwEMQNwb1lRXxpISsFGmPmniMLYLt/3iZCaIigaSVikx25yoD2WekmAfb8E5ye6AIlFyQdrdS2VSbw1HZGElHlOmOpq+WMVgcQaoZ4ARRggKZpZIkbJJ2jkACBuUvFkDS3mxmSs2C2gckK2mlkfZI/Gc1OaOvRUKOF/vTVfWcz2+IOJLqyNOm7wbRsg/ldXnx+KKXBDAh/saF26WjEociIfY+rOwBBRQ5E4q+tUpHvkKyMGjB4zRQfCE3OWoU65StuUYdKpYUWVXFyO0yOfTkonA+PJHs+w34GsOO4NV9ZkCH1CNeeyOAraNgSr6/VtUEqsggk64NGjyolWoPJY9ZvF2zDdShug6ZhiA/riQRAFrHOzk7I7+2qjNkcEKanNBXP3IAdrDA9Zi/MWo9uk43Y1FDFhnrb8xqDI2D6vu7+w/tAZTlwwDXV2yt1f3ptMSwBfCt6eLLwGGOSZ6J8oDKi6ghkDLEWeEQImg0Q3kRbswqF6uacbj5hP5igd6Z3UxJ8MkmNDiSjcX/+D0ZKSkbUj7k1m0pbw8yAvO/ZZcW00OOIYrp8AEuwUQH4hRPGe1NlVlIqtGTRfABiQa2gNd11XiN6w8LSdHAiuFmefW/fUTZoHHpugkiWBxManD+iHzmua7+7pn1RqNOpLi6AzcKZpJ3zs7ZtIqcjWyCqoplNdn+JVhjeTnaOXFWqAlhaLKnOxw3nGQ09tvd4JCxPrIsMcnVZ8Gx3PqXbmLHQ7b8qR2FFN63zCCBdm78KRQklslwIls/dWHJv4mlN4djHgpyXtmBoiGdwuFotNg7ynOS+QcAl7U5B4oxLnJvtwelbKgF0VTbcehtyQsfH9R+GqxClPHNrbeCM+2Zmy3ek56MRfn37wV/XKOM8zt721HgQzsDLBEY+7PF7mOutqOy5VsXBKWap1SXJS9bOwpoRNYwTAEloCT0vHsxjD92+tP9hTdGGSlhVvdiCx/MlwdLDCTRLMC3vB6Rq485NbujiBZdJN96okzZCf9zRgjJcdBGZ3ZSiOpNwcwWbV+v0m1HZ1ugaTHNbq11pLzmyRdnjBYaf4xPrketvjlWduMUSibn/Xjr41WNPTAcpr/tbRuYl17W0QmNYsV1OpAfs1OY96CF45FeH6QRVEkixvTLpIXydG3O1Q2manGeH9m0+mD0Thgki03ZixKeRIxh+8zELKSYjZkgkogEg6ua1ZyhP3WOtdyIu5fnxJerxgqB873tfy8fvSTgZrDFu+i+YD64Si/uvh1y8/LzFzEJAdDPy+pp/eKgBfrQHbnRm1fsqD5tPtA1KqQ4FNhfe0GzrKrUcZW09ony0X90R0COTluAXQbKbPE6sMzvcKsBlsk0LJ2hI1dF7iiDYFt4KSddapCVb62gM39hqwGbx8oiqCT6Mw253PTp5l9ef5rlXFYQyqztx0jOexc5WGUC58zQkbPzxa1sU0pkJWrD75aS/8i+ETM56NJH+rWBR1El0k0ljj9C1OvwshqfA7v/2yYksneM9aDcHFJfRbhhB2Unm9Z0+8rGdgwbYQbQt2JlS93Tb0COyXf107FAHpNfeYbIbSImJeo32JSMqnx0E/LY0baSHwNFh72rmoI1kWwfi/VDPSZxTWzPcM0sh++Mvekv7QI/7kRALkN7QJb7+sm7hRBoTOUrt9w/w6yH6bflpWg3qXiW/tKxbj2dDhuKZmsfoI+rUG9drOLtCOjTs2Uj6RjtS6+xe3NYhdgA0WDGQ8Re2cA4sGV8/oHDpgz++sQZZ8UN/72baId2tOsdarmZg/YItadURZ/nADqPe2zR/K5XblImAZd4A6KwIHb6yCF0sZrpd+zUwtfPaozn7UcgRDSKU0FpoNXaej1whXdBVc7PyJKOswSVtc4+ujXX8k61oEY6/82lq2fXU68l1Rd0Lh4jlI2yHMPzi5u7a5iEQWKmhgqECVNkCeNlrAg6EK7AS9IOBL4UCR3Zezw81kp6s1bN1Y1EMgEimfURFUF5cl/s04O/92gY8fCFfnQzsHCRm3IbXnIpriFESWgBo6EbQ1VXwLNjAUyJq2RgLRimdJHII4LqUX1NABhHuAhvIMRysIeGTx//bp2wcjuKNoKIj+2/YgwRf0/tGkZ5nCPOkvpNdKX8HZCFjsWp0Mbob5G9QRcDT3mvfWmtIeFZm6vKkl8DjJJr99tq+X1wtqQ9kvhZJduCPZSvxBE8+xoQU7Wk9ModUfYMYMz66IMy5d8biq7wAbWQkjGWp+8OzyOC+1i3InGY9hDzYwSFYRqSA4STtiqkKj7Lre2UAf7/IaaywmpByKoCnGn+ERXCxGgxsUfqoUt3XUsF5klj3jTDMfREeNdKV/FaIgKyGDhieeSP5ZGVmL3w1OrzF3yfqYc0+2SHQ4nVv/OGb9EV3JjCxe7HUuPVgbj66hsmdNWaMoFsxqtkXKEk11dAfyYsOsVUoX7IcgMnwGwuviFgGWJ7KRGyz8Az3cJccIhlmEAi+dZhUerFAEmEeoY5UAOwXrsv3N5TFk5qxCo4juyLSYi6ITo1xS7WQWv3onZR/R1HSlU4rFEhJ/VJWG3bBo88Jz0bKubzJKCy1aK9fpXPCplxMbOBxOdfCa2xO7c4cHU5E4fKmLcvAaJ4l0xrQzhlj7jzJPbrZOCgwW90ipMaqQURJyFEnY2PUNoSzMn04jHUW0WEmIuWXK/kIN2e4dSEUMPJkDcE0NvGn+ULXfAMJdM74hG7pX6EuduEDCEYuqNjJjdLIXke/qk7Q5zZRtHGsqV7Xap4DxIqSuxQvChQ1X3BiPypD5ZddeD/5oG+HxL80HgVr28a8m8UUtE1w7y4Ab5kABzlWCL2qAKSHi3qa7Xdk3oWlS6QssnIhwFPkMKFopI9yyche8eGXbAIQxfZGgOumepnzlsA4qhpTpIy7XKjuOM2FDmdq8rqYFSyon5QKGXmExw90f8jfNDfmmKu/lj8Un/k5nXvdITLPrNtzAxyAf9qaGyp69v9dvRtJu8nuh5HXFtot2DXmPbmjsmexgZOSBxnjNKTTjpqpKD1ZE9NOvkBUPLhVDQPzSwehzByeTBysG3Tr3fIRZIGovsSF95C3u6QJOHMf1z+5fU8CrFnLNh32e8+2EkFndBSA2oi2QWz3O8ysa6kTk9djmObEe1fkfzNBkWhXF3pZk+4iz+VHIBnCVDtg27IGM6+L7qDElf6SudW73u+j4XMtufj797owQ5W2GrG1dQTRLLyM5sMy+6KnLEthRza24Dzmi3lvDd4cQwat7rs3LNu9t1pd17ehu8AZgALAgiFewy/OPKrxaJFRSB6+hjYySA67JA9Z1cDylBt5FFrgAzgROSZkENkmKVIvRPhyP0diBejLsufZNKYPmYdpe/E0apm4KpWylQLYehixtrRoCANaJPdsHYZxhRqlsIJGh0k3I43fP0kmDnMHiMqrtYtaocmVDAAWCWZSgMG7gzLI4mqmvxQg2jqYnT7ZibloOWB9Ti6dMhF4nJ3dm0tE7sH65ei3uM01v05DB6EZ9raeUlpkZYmWGx3XFUlCjuCF58TpGhnALSi7zt5Qk3Syzg0Qmk5T4sDjhXm+QrVd5fFHoxPciZL0zfwJQ0jq0Q1jj9eQh0BBkthH1CISn3weKnSp5KtYyVgOMnc5AptF9HRZ9mORntglF+XhIQYZOLUhHB0hcIeIyqUQddVYxlGflNOsoT0E3H3zZjVTeDrokKOkFtpjOQDoxfWNj2+njnd7oaaIkGx7pQ+oEBQR8gFSqwFhWL/avBK/FeQMQs1qRL9MZMppElEDVCBkC0HOlv12szU7YTyNWVdbdvrKRL6yfppDRVTzKJ/31dg6o9VQUgGEmSVv8ixG/uGrVrZmkt3Hqq8AOEHJQuvUgQedVPcpFuGYhPGscNSCm5XFcyGKCD8cWHY9q35axzmS4x37dn8cStvv36BoCn9fAGfDi3O6KL6Cqg39ocXQbjxC121mvhyFBDby1lHxQW8QdoG/9A4e3oJ4PC+TYB7b34pSlbng8lOb9iD5Why+74vHRu8bvbQ98mLZcbIgtu84G8/qMkxzm69MWjhIu1V+Ce8K2t+ecD2zsOlrUntjRrUv7J/Y7bEMu1d7fjhssfVLmNnNu9qXhn2MBNdZUYof8zNkT9VWhP9m78YcBpC+NuI5ddrWR3eRD11RjrwGn4xXwyKbxFXCPdS/YRGL522H/G10ZKdkWqUErItAlH4AsYQPcyxK4ndAD7Jl54FSApoQIjukMFE09piIs3AJ+0ij9zh3whTkQjeruv61cZAjI1ssmqJpXLrBaobzMBEQR34L9HIMsTQhEywy+jE6VKpR9vcF8wRgUB5YrVQWpkzL75S764bulnrdf0zyQv7j/1KPtrRPw091K1v3nepar30a5/6u2pl7jM+OlzYUJ3xNxn0VE3Aq4IPyk7EDj/kYy2tnImUeHqiqAQrypm7UY3X9LxH22pGK3MAI9ZN0m2mL7fqdAuZIyDQo/2JPXszK5kRYF9GYs0afHgUTsiljYaCZV+hGzbTW9N6ecZ48o78WIoCuRt3SJdBKYPQvhfbZz42Mjhh9u3cdNK+2o3cLfsHEjFa54Ebf4zVx+mOrI3aCypYtf2+eyXcv9FTUeFSviRA6YilloA/nI3RgABz7BFmLTjWnaETWHOoDsmcDiUtaQaDGO5lkmjaFi7sJgsGmA0RyQbAe5N7IQFTBZ3rwotk09WMzUKSKtYm5088H9tsxEoC4m2tgYMC4YCxTV3Hon65CtSTu+goBqoJ+7Ujc4wR1QnTzQL7WtCv1MijTdYqT5CxuqHY5sIkHh0oi0ypvOOmgm9jBmhMxY1PPKWFbohMAL0qBBU6OwjJXXvbCbMa0wmoANoPQRTn11FHq/zRKNdcQDY3v2a7VSNJ+wCDaeAfuRi4hX0buviUv6bPXJrwd1RkBrPc6C/V+INr0heOzXerbuqDPRgeMxAfLkjL7olNUXUf0+4x6Y9aiJRWNFNkv/yiSYgl7XaYUy7IZaaZxmvm5LEAktcAnnQOX2hOZnBwhbuqy9XtZ+EkeCOXxyUMdnfNOt78F4Wffyq7sgL3pLCvtRUE6K84K/DDygLIg98CjUmfkkhTtWgIABqQ27JNpwRtlOebYVQt8WvUqJFIMVhpX+GzSEs7oFVfWzugI+eRrGdSpC73CZrmtRL8D1ou2chJYuk8iNnVV480kx8UszOS3sUQrtpHw4YX18Am94ZWf6lY7BS/Xa30dN1de/elv002B2qkezHjeH3WhgVoViPXhn8u5WuV4EPWj8Iz/ZV1GrIXgq5TakD7oWJ4rjVlbe0Trjc07Dns4ePaOLzz5ou1HNlTT6M1I2r5751humYIf3LNfSVPsXFg/F3LtHY4/G6ni7NRS19j0Yf5eYgFpXBPbXNlZ0bTT2WOyXyqDi2yFTCp2e9muzZLg/6ujexNfTYr9clRHpp+rFDn73y6/qpakhc9df/xOaX/t31td/iwL/fhBTbAfdoQ3hekg6AbAWkdZwIiIeZi+0mp+UH+bl83S2DyB6TwP49rAtlrD6KdvPx+on6TvP1x6KPTzrkRe+F4/prPFvmaRtLMD841T6Ce2iiMKGtP63HL3yXmDMboLEJ9kIVPGcTRYCL3947XM0CykdxTPVJjIz0CdVXWcP9ssva+OLfOa7cuxvZIHFf3O203FGvrJSKKOw13bXDsjcH8+B97EQyLnO0Lp0FxnWNI8F1XpZ2O3InOvBuNqbTvr+iDXXR3KxstrjrleCv2a21nkHPRp/hHXVqQf98jWdc+1mXdumelZW6vQoPmFrs4sRBahNI2z9UsFMFzXan9n/XGGINjaia6LXBBN4s9MoUdeErMk/S5h7/JYO1PTLx3Ol2NvmfvlbO6OlpXIPyX55MzfyXf1Kb6X75ff03Uet9EMi7fvJ/XJhcvWXResDIyz0GO2X0wKR4YaM+rAX1WfYTYWTMr8WvXxgcPfjvKlLWBupsVkxht0OWZyG4K6mWnwUv+3smi7Qmm9cIYiJxZkteFitBUrRKv/6wdUpO9n0VVFMswB74gXc4MyQPhzjoCHQ7kjcPZzCB0mshKHGC0dqr/CNLQ1ivyU2IF0wsqJt1DY2tBiu3Xos6mRYpkU3snJLww6WPaI0Bag32cRV06BTuKc4jCmC2YCPF7xDWNshPdMOGsbVVoJWez34lMzJqvR8OzDzFNkplq3aeYPEAof141qvlkFwOVGeot9Of0uz2hI+u81j26G/ryXp4bVhxSQiG0VUhYlWrsDM0zstr/ZQnEfvJkyzWXKPt91aSWs0C5NzcUM34yNOMqirXaSDcbHbwfbt0QucnDoZ184sdK1Bpw1U5dlCRT4loPyY46DrjkUNwWVxKSEJoJSjkFZMlMcmxyUjDU1uk8g3LDYyT8FzgOlMLm8b/mxFIPCOioWmnfiy6+RZz6tsaZOVgtl4R3PAfWXcS3ng8BG2dcAJQgaepVhG5PRiFH2OpdIRzadXZzxv0PA0jThOJEoJuQ4HzcQY5z3Zb3yfbSbKekpDlQLG5sKtGeV8O4NG3pDGJCyhBohmk8HtRPlSuQgQU0nN6b/gdDrCUpCkx5aQc5z40LNl5LJUwugUX0brVMakP6acb1JWSmlIo6x36Zu59DGLUI5SiqW+QKudpMTBFxHBdbMWvZRw+okbx7urCS9n1A2J/xuzQU1DfStRgytBw5xcZYOVjqn01ACn4+AmmmN4LFGsk8I7FUIgP6Y8BGKjd2fEFLg2RtzOOWQvVQkpgye2owwSbj8jXYqfAk7g5ebjgCviZtLapyGUW1VzJlBFnGj/kvZiXoalXp9g9NSenZHSPIosxV3S7bJvYNd3cv0hsnpXu4OO6vnVOyO8FjJ/3ccdnGTujH7rqajzup2wi6t7kCrgVIBrgI4oXsSYE3mEq44N8sAmU0OYAgl9XDoL05GqWQl2lF7SoB5Cn6jxfXDsOj/YlJgs0E6WCp4QqwF1FM7igAMTtdZSMj1jF+HDd1P6UdRA2xJ0nwED3AlW1+Kb66bypCT+Ud7gW7M3vcU5/VBA0Nh2ItDernQAdGK6Y9FIPW+GwOUzcj/hZtgTo53H08y/hIkmHJzeF/jjG2OKnGsHKnfrasLJXdZAqUhwK8GhXhqfT4PwPKxIR6BNjaByeS6j5luOogt3Lx15OP5SIAmmVSLtZA5KebuHA+ijnbn6VueMDuAK8eSGEhKv/clTSaVRyQCHQBnk8UcjUVSln4HpDAGxZBOmsywVTzavSrJSediHuFSyRWlSE4VYSw/d/CMc/MR+DvKXp2N8K3r0B3g5cUNkNm/ux1EdcoyVfKSkPEfwFO7UGOXAIRhj2wcgIs6HlH9ZV03nMu3ceXpdBL1XO9X1ey0RJOl+MTGM5aIePA7I6EBf0akLMj7FjxE0K/1rUjsHGgxw9OhT/KVsSMwiJGlT6wWygU9tXUTT6PFlCuchy7RmexK9LRb5qiLnLWGf+YGvr7rKM061A4mSWk/fg/CUPE43Z5EobPqI3PWagksONvj6OAGtcEJmCAFTlvSPxaBQPpuigyeEM5XcHJGtgKBO50/Ym+bxlJLWgyRb4E9mfXI9jZUwtJQ+4AOkU7ezN7D2h3Uj+cTIP6TquCdrhwA6UHal4k3MuSmrFHMl96th4CKQYksuKH7dzggRANWKxFTVuEYHP5oemyIbCMWE1VOJwgJK6mUCSwMQy6n8IXMQLNOL+cPyht+UVf+wDmIw+JqBvddnFgl1ieWBksdaOEx1MYQvwRGHY0uDvovYSPWOmbAf0AmUTPCMNO8hU+3Q/5NLEYv0NXVYRwnH+aLB8hu9mZk+yaOht306BzHbth8cV8Y2pBRMmrZYS7jVclPzWPYMYUBp+ZKAGPHOyUuk+iEFhVNjKkpZBEwkjEl4oR4FTE7QqnnZDef5Llre65CIzE7OiSWsXplYiHaP4LOTEdMQ52SLruRHpknIEvqYfVU1/CDMKSu60Jz3BqxCTWyHaVqL1YGRcu2kTp5C2FghFwQ7poRXjY02V0yoXRknz2zutycboSEg8f4d1DXetxG1JlQGy6s5flWk25dwtTvxLS8cqXWd/NsmLMhYxRILWJUH9zKEEzyP+oR9FDKHOzTcFaE7L+uP/nAl0tCQNL4le/e30NJNpGofzHH0kmgoeW7kfMQUBYRICJeQmksqSj2q52UIE45OP+v5vQnuT0eX7oLjV0vwVm7LHRRY9AEF4MQ4+IdT3s4u8nLsOte28yWoKdFg+OIJXCcnW7zY761c0lLgApPRmPANweBLDWH/M72klt4Xa+8preETUSDUgBeX5tVhezh1IukrWDYt+Gt/kyv1Zq10l+b5qoLrs56ChFLtBuNpkjvBWyMOhoUQhvmlG7BBD5IUyftl7LsBGUZZYkw1AfbtAd+Am23qww3Esm9RC4/Xtm9WBBBwDGbTStPfasfieO6qSi5Y24hE/cZCnxnn2lbYwO4PxYcqR2gb8OFqjDLlMq3Ska8Od1DeDrbA/UBtCjoMmWxGYNpa70WfyaaKUad6USQipNDExD7Vl1hB4vT/9AUBDFyXOdYGlafFZNWkEzJqYcpyXZ8avoa48yGLJazTHcsisxYLDv5D2W1uWw5aIv/vsBEm23Nce9pz9jf2sw8satOjsqkWwa6AO47uWKilpAqT9yeKadJn1kRs7OqyTaVHp1DuQVYT2xypk4MModpSZkrnuvFyvIvy1ETPA6ACfpWblewKyreqVGHq+u9dfjv8QqgZKgo9MhuX4NYvQ1f/ZB+jVA/JftkAF0+OgEK8NlVG30/xpvIiFKttyn4O4+ZJE0sbWbKfV408JnPyPzJGRNhlAMdQSoIeNug5HouOoF2HWvyQO9Gl1TLRbE1VDp4ff7Jc7J5BrUfj78MYOfRk2VZQVmHe8aQPSghXBWSqGHql2NIl6ieMhxW/7GYKBBwS08VHMLh+HzIqo1HFHo1NsbrJQ4YeGispiiBFz7OG67QATplwM8XcZLmGqMt03koFpu32pcdbv1y7BvPxGLqHZMvQofk9fcsT17/PX5oaSC9qB1UpzYwaWOsj/rKNps2E2aCPqdW6bVF2nao+keiHSxEc18Cbxb6VEb9GKQyrxEO1fAn7IIRIMMAAjQNHJ5EY0lBrhFQyVlZBz4BgMtSTfVbPMRBZIqH2QOMmRIwojUgr369TeXvq/4FQdtzQbiKv7UcwuUnRhvVCbEazWORGI+pIdVsFcLgQJWaFXogj9gyjzptYItOdPgLl2/SCMKmImWIk+1mcwhYmFZDvGhcUobpDw47fly6FJQkidVbEDxdNwlFLSs9Gl7mDixALUovbzotmrZSWbMiaktbboUYM2qzcH9i4ZYdKuLjV6boNotgWRLRbTukwnetOnFIJ0TKt84lil+RWzta1/BpL0vqFlm2RCv2GnOD6D/RhG2VDQ85L69MO736xhMna1yx6/3hcp9GOrBSVbBzKLics4YDSFHeaoO8muyakTBzslNw0tlacl0N4Thk86+ru/y0m/y53uPihyzW04v1S8CgKvrl/uQ1yJNPVkJ3SBoMqJR2nQTk1QjxNB7YRPWRT1aoSdpFiVmePVtIPyjWjgjhFWFH+5/QnJz6oKcfhMBT7bXgw08hFeO1mNGPQ6yG0WbclR95eak8+Qp3UjHiMIqcbkpsxvDZCi1BPT9UGlNMdrqlwTgW2rYsiJyefhTS2SMhYkQI0Oa8FOde0SsEk9beXQkaSU/oaCE6yEQ13yA3iJHXgWjPtxJTxpZVgqSG4oRmJQmjW2WU5V91oV0/HVJr1AqhuWf44iPOxJAktIpB12AM5yQ8k3muPt4zLdQ01vRy75d6SBNfaT/7ghIh769Zr4l/xnOKwYr33Gf9Z7YPN0GZaKrO+N35sS6Cnn/5Q9dv0i2h1FrCl0WR7CpKYFfKnBibObntFcftq/DRFGR97cJcC2jR3TW7vzbPuGs4YGtmGlj6wZ7OJXEriISWPqzaBHUSUlRg9WCFWUjYA8H42uqLUso3cTIYO0KwWgJ4b3to8+8Qf+cXz9IrrDei1asGR65U9oVTK6oxqQUN2amT9hqR5KhlSbZJuaQoGJ426F827mmLJa5Goshr1SoCIFOQlRAxAWnMtMt0IG0bJpMREC66kwtYliyJaEeojFovSLM1NG6LNsxzWmFC41iVUfgSvlvLH184FXiWfbi96q/aUPnEw8In0UE04evlN6K1Z+of4kPENWUXcfqbGdR3spxsNFbxZjITE4q84o2iupLg0WTvy6p7qnXC0df0kR69niPNW3U9uSFt7QzQJMwcHeUXgRRm2DuO15pjBBE5Ga9CSY5ktoAkUVHoSbVHor/HZLCGn8sJKNMIiy462R6RGmjakNwTjT1VBdMZMXp/Arp1pB290Yd3BkbD5g0b9lG5zcPJvRCldg17rKB4RLMKcjBExajKg2YJW69G7VhRJrAN0EEWbEHMmeP1JCIWdO+YnlNGsQfdVXajdziHNe7SIdYXvT3DHTGgncNYesCQbbUgfIrJKMtyylbJRDNPGHB3GjnZ4Rc6irK4AEevFRS+L/esTR8p0VroaMGw/xs8Ij5ysjLihXm7t5wiQ2Ak0bMQXW4ymUM1UqfaCRYLwSUnCw7+YhNYcxNWYyY2QJuYo6VnWG9BLLGZlgmqnvjEGqAULt1km9ztv/8mPVos440b8UYFv8JNxuzjmSnmkqb6cLuervh19Ggqr32/620cnfb/Bg3RNz0n/el136LG09rCFTXfdyvA0/SH69JJxLpbTeactxmdWia4uiTEb3GkJMIMZ+DXkM/Hj17BXIbyrn0b9U9I0Q6GSBDDLP9uH7iDfB8HTm/7fIVFcv3emtfrVf5VPXUeVbYgu4jZSAXthFuWkpOWx2gMQVzkmKwRrcaT14Gc4MYkUgNHPjRTNTqTEoiV+omyaKC7rkVvpvUSHXRnp28qmqFQ7u0Rk1uxWGwQAh2Eo7okRo/PUANmqXyw6FxRdiEIcpzZPU4QBoqYWETC3hCnsACFbIUQlEa1AlwcHUpCdEMu0Z7M+xsGk3Df1bNMcsQCdHpoHm/0OgT5kIt3Dj64A+xfxdaJniyG0M3xzVm3V2zCaxW9+rL2tONjW0UKEeS1CyBiEkNi2szR/oBnZxT07tetO1FCilOPzh8GRM1KMoQCfXAnUTmpyUzysB7hF5GBhUR9lzD1y0pS99BtTXG0bHvvLLTMCGBrhAFSh3ikWPMyvlfglM/xr59c2M+IoXDS4VohAjqPcr4HJpHNZbhdGM1Ui5Cd3cYx0A4/UFr1Yw3+4cNgSXWTLuDxjRShYLN61EUm/ijQiBBOQGikdeyhwRLR95hrx0zaVXt7VdteCcSd+dn3X9SHhaMV0eGf2VxNFPnQpvGtpuHGL30qF9MeRHKLfsPEEWMnv/0RH+CSpQ+/wuBPhn/rY9phrebP+FxhtlSyodmAtc7tEsDDy5GAd/dZ52R5LWZBMTJ2CL2m+YHm7hT2pXx59E8DBHx6H9Nan6oTge4770Rxy+lbSmxHBHwbWdSF6sPP7gNnbtk9bGDEx9uqUldU2AJ2E0R12zp2R/1fxj43smWvQVrAmDtVVLcu+2P6VBSiZxYjQFmAtcUvGcMhKs2n8oC2eDA5xxBwIrAYtEIb/2l/vSm3EqC6u3dTFyPIOgOUgdoMMk1BAwgBasE/upEMPg40CuEzufUZRfkM5J3oM4IHhnSOj9roNc+6yc42F2uecWlsrmPhOW2tsz30tXXzgY+lYG7D+WqwSAnac+Ko2nf96ktxwAfUDCajNfv3C+gRTg9h8TU/7ob/ceu1dAFszUor/puNyjOWmIQhr03CKEEPz7uEkC0AT4iyCSaSvAk+s/h7uqvsQ2t0ofZYRkhEuBf/MW+bOUUtqUjR0ibz0NtN4VMi1DI0u4YgwxLI8FrNNyO7yJv31U1sDGSGZzWAtE7I3SjquE7Id1Ku6fnlj1Lr9nvUX5Dg4OPeI7JeKYd+O9tsVHipF54vd4R6S/3ZF98cuoeBzQsvSrJsBU4qyFUJ0pVzbwnlRJV2JTpzSWjUk1NYvMjlMJR66V9CGZdcTUcilqAXkwQy2SFUWP7BmSYDssSaBIhmMvWmFR/t6cNn5jq80NbtZ66as7aKgArynx2N2FjLdWq3zzL4mCKs9DhuKw7UsHtrk1TaG2pWF5SOrUPLm9T7xQTg62/eymup1IcdR6H3KILtgkPLRqjHh/J4M6PUAJnWIwwbmbM7ANtxpfU0lxbVYR1znsfX+Nc2Km3FHZgHqbO7k8K/ojl34GgiRevf8mRRplGbEZZUzrGSLbrkMQWQQgiQGIX22LERqRwsHQbwo8mKYDdiChInEobRaOe7lr1FcoM9mHxt6TTyOP/T4z18Y5641jV0IM2dAp3MyFGwxDbm+OAlmFXPep65E2z1J0SoNaup+d/3yeipcz1+x/KnfXfePbwv9pjres/rBAqF0m+k+d40FpC1E2U3ZfaTegkul9i3V98czGiRxRPmHgWjZ9z64scwYCioaUQFSoyU5iCmvS1ucUo9g7XeygYAfrPdy30Nqa0oH20PssLMFhoJdlBRfAUYr6H8h8QP+HxRXGYI/PDMTQOAyykEPo5wK85EkRtEPuz4VaSrxueVkBQNVL0fxL9jqjZ2L39ZQZIOL76K4vj4K+BxMRULYaWnUEN6KxZK8QMb2lrnBWZ34n73knqOI1KkD8Qour5PeFnSOwtH8w9Xhhz3u+v58NfrCNxzLNVHaoCM8O9v2exMHMjiFWmN+F2Q8FyzkKG3VWpjIu5ls2AVNOBGy9EPqRLCbAj05a8VFEpxErLNAhFJsu72FDhPqVqPFQhvqp+Frf5M/6P0eYkPkc147iWgvTt4sgaPlj9nVtCp64KtrsC+lJUqz1qqXTXljYW+Jtl2l0LQ2vTWASUaVAtuihgAHF1bz4j6voYKjOa9bxZ36gKm09I7Ljho/eqJCsH6qlN2k/aXXlQe9AutLQ5R29mbWPoAktoQkfqjZFyAvz1Xhy2J06sWkUGTsdRZeLsJIuAqzpi3nndf1Nu2RTxfVaMStigK9oxDH18kyk28odvw6xQgpBfR60fOGwaBkHK46FLVY4UiAsGirWhuH2aSLslEO5HqdeGfOliumuHV7hluTOeI6kJ8EcWknHApJentUpJ5Auh23s46yHgqQ+FizHrW4R3FmM1DV2lmU1eXxYT4WQnFboJ0ExdSJQ+9FrTeUy0MHoPSeKjI9OXSbI1m5W5QoiXxD6n/EG+5L4oYLzZ0cPREPwKALdfCGFfMBnHCyHR5h2A5flfSKUOxGxeFSgKUCJjhY10i9nv6BEKDGpALFk2j3kpil7EmdEk3zXT57+6En5ESNcMwq2TLqnLBMadjV0I66jhunEwdJMl4ehLEGrjud5B5H0Y1y453gxWjSyOGkIdov//lRIQomuYuB177Eg9lJNYcCgnrnsbku0bQ0iOWNcjJkuz6VDaxUZRk8matJZVv2HouZG4+2b7qojMOJ20ZmT6a7eLwXJns1DJ+MnFJXpSFz9w3lLT/FC6bUqDXqmGUmZSsx2EaI2UzqlnhzEwOXAPsEoXoHn0XkU/8tKD1EISH/Pq12aacPz9KdoDEnwNcznzqjoWKMboeFtN7mRC3D8m/eBhBDGKqc41mYkKZsI5bA7K1EhcZCc5hqpal7dgreSyJkmPKPVUKoEBVQRUOM6ZQL4qtLiJa4tOrbsWzjVuVSxZ10Gz6U9NnSRXF69cnlpQ3/2fHMJQnlpIAOf/j115VOnU95KXrw8s6FK3Srr98Yo7ofS18xS1mCz2vVUB22Xrt04gqHcQQeW3mch2k1SUHr0dgZcxRDPPneWiVnm5bphhaAPGQ1PSd1WBxR7/GgNXtq7ZNsg32ZYt1buoD6Y3hJN+wtIVLogkzmJUsj9ViotNWCSmXGqiGqKgaBw+LwZinPsrRbDHXFelDtziqef17akAzZ+Yg7agRORJY+oSbMXXXuhqJrtmKiNd+P/Ima7YLdZvPJYUaXO/sW85Tg2sHF9e3ry55k1G+17C2ZPK6JDlwVMYsQOoHiIcIiHB9UWBuxclS69FC22uFa6NHbgsoPzJz21LP0qZl9BTS6oGuDfb+Wcg3t6PE6qAhsDqWxqCaceXELAZVjdA1RVe9oK5O4VIuxnKggOQeZnYyS1yzaMCRzGCMfw5CF8XlDoz3TgqWvaAx691AsDOWLfLhgsaGkROjT8bJeYeqH4B/jmv7bIvXDaOTQTgpby+/FyXdVlsJIVCDJDHViAgyrpeyharwvddT92phDi0W4LyFQSKVhIhhKxnIMR4shexltrU1k3orqT7lOsSGsfmPUkx2cNUyEMIUBEVIYuabqvcrYrtDi6OukATQyPjYiUcOYM3M6Vw0az+wuFMPo1LUsNu7BC3OrQMWNLtfKpz+GwSzaOLYcHaoNJs6JVlDb2A67yd0OgFrBFFCPDxYMlMmyBZCTKWUFolDlBomZybRFi+PVNGeiZarjX2aPdcdJRXa1df1nqfT3wZSZjW+HlqA3FgQFeVTCT8CQEPbzdd4oYiVovTCfoiwVaJ41nfRs+y0ug6jYU2VsHSaVnBpBLW4+UT91WnvG8DpeFfmuCBnzGbBfygHZhlh065EKqhIvXIUo7MgqPKp879POjIZ3R7rvya4tnJrPSuP7vHNdQ8jnVjAJ7x98ATcRYGrqIPO4zuEXt1rSezQ27EpNschbAcaHe62vYNHxJVzdzJivix8IiDYTPxuqRggqBI+Vf3xl/GzUtruD2EwSZ+HE6fNEk7NqlD8sklrEUgjtTPDsWsFcFpYQSlGCydWdElhyy7tJ8vV2eFgdgJMy1jVlKixJC+qsZnhIWa8gQxPN1wRQQ3tMt+u+hGHeKtrIe7zFmSv5uLp27vbOX4rqMuxFL/fK+J0dNb5aHp20XZFhto6l8pTILP61daTKVChDQAb0TpXyl4M/dcppAZssYumeXikIZ8YpkZU2jM0GoJkK076Yl3qjDGcG4q/9Va6kbDR3R7ymLljOwoRRDmojC4ZWNlOxNMpQndNqhNS0F4yXsbSTgt/J7DGmT6aDMH0lFtbHNbO6PYivKeU/5GNstONWer9JYt30SPypmo11pxw3VSq85HK8LONI7X380+kgdXOnfqkdrtLPJEitu5ZhWzKGDAyHnHDPop5pk6zGzTrmwWICBtKZxea2EfQxeBm6OwV6ozC58YmVcszR3nS3me2XC+U4+bom2MQemi3xGtV6xZY3OGSB9lizXMgPm8JLiqeze1qOYXvGA9Q404gX2QZRMLuRZck0fZZwTHd1De++rAeeGBV0CoCwBDxYT19JBWG2IQulU3ViJMmSwOIO6ksn+M647pd35hv6x7GY8qyFvEIPypYa2YKzouIlAzVVGsXT++1vD8a+4/KbAGs4TvWQbDJTql81FyqgG6beIP+yScaN3BzCWg3Eiq0s1xg8hl75zNeRlWURjsyS/IyRceqCWTy7VZBhcsirscZgLchVQoQ9zPple7dslS3jD3Yt1nN33mkqAHHDn/vrdZ/BfDSnC2Yt4T/tnmm9+kLvT/QtoXcuTcVjqWtbaqgfJUvClI+eg69SE/yAzNUnJm3FH7sKJOa1CN2zCsGR1qQ6kQ/J6m4S2lhC1CJZAf0aI/r1phxKGfAToMRD0xKv8BYg7esM+OArIEgfqAqvS8JOZ2iLb6BWBVtQ62ne0S7tyTOXzzYp1F27W+Tz0zIpL7eiwmC9rLNM+1TslvY6vo18l5zWHnItD0tOxpC5WmmgJkYbdKPF7k7L70vO+sJm8ovQcrWVhKXs9JhXndPL+CzjkLWgnOzjT0hQHF/dZ8HiL1DNO/mGWhJ9z/P/eCzTLxdbIz+MnRpCU9dy/0iTOiuNjPa2YbS8rdrNFutiVj5bckP7gZEQoZArwhDBYXRIepZ01+mhhmUghChEk4JkA3v7x31e+6dFXGL11rTinzMLAerFIPn0Rv6jAVM7Z+ntrulQ4Uuh4rT0JVZ0HSm7VIqqNm4vQkLcJj1277ONtgn4n5Fz3E/HLO+d3ts33bwjWsRXJK1HgdCG1NXsOrzEnphFgMbkfFDFjEHxBamGmRw9AipK+AVzIjKFlDUqwEn3U9wqbPqfm3kMdV2J2hHHOnTILuXgtr8RvWTDH0kZNcSiXWt8pMASnfSQs0EcC/2qMUYWPxIvuJRc/BBQ3ZewHY4/kSVm7x5MJsQBRYso13Svdt1s7J7gln+tGvc6J31oZRNtOzkoqJ9oNSHwADpUXpFEDeKnm+TH4srmXnI6BKOBDZPOBREdae95834LwovV6Yb0G53cHSjNtPq47V7JEStCLTvTgz0VAzsnFX4L2LumZrpeea0hAax49zcQ3f1p3W5Ss4aH95MHTXZbZTlkZ4lQPJzHqZVY2nZ86BNpTV8mxbZmnHa6/a07aOkICvp8zuBFn/S0WLF++UO9F2p04rnrir0lF2ezteUqqDlloQk74vF1m1sMjodNnRtUx8QfOSzakCQ0o1SVsxN0gH1+MkWWdk+U/pYySL9Gmd4+1MyJF6GzyEGf7f+mXdm9m+punRf85IJ7OeVvyCrpJ5hr0n3p0vtj8pXRu43Z5Je6hmnte2KGdGu0nosx4xuypidnN8LCZjYPZiij8nslPmp9gN+Sc2JGqSNMKuEvmQp60XePg7ZG7AYFpYBnEmAKg5UDKyZgXiYys2zF6x/8dflu3iraP6znNTXEfOB4O7oFWrUBICrDtWgnay6e8FYWISZsY+kou4B6Ur2JUnh5nz8xO4AfZF4dd54TLkvSn0wCo2JqeUzMkpbEGhSjFZpoNVWHhlVQFsa8Fxf2cTAKk+P0UZNez9jBxyjVvcgPp+SFdIXRX8pcJgRI1OkU7x6TwOhQ4cN1CTMdpM7tlDX5mOtPDj6+raxKyaoX9ZeWbmIuv1GDh7LSmuv0qR202cyeZV3KFPMafhkUfEMtTjuTxRMLMdY3PGm+/ByU0iodhjYdiZOTitRZgBZkkigV/LyWHOGlKh4CM+lavbynvPeUUISkP0b/p+9G1/R+fdDzfTsB3468HLSJMBxuBovwt+c1uD6ECGFCToW7g+Uu5j4YSwcDI1xIA6dEBn+UANMHwurcWJrhqUqLp+rMhPB7PnFTdU9HyY3ej54P85z10TXkVbiWzyAAAkDmjQD1nAkLdUtr4PTpCCrftIEUKRNtoG05qUynIl9nbmiKpHTWhQx0RCUQPpQBOS42g8vYcf3DlxRQXh9/vFvz8+I8NRFFeaDKw7Ks3hvSBDH3w6KBxT/cZpcln9IOeVCJWRmRFsLMx+SlDKhfsJCvOCixdkoNokPkTGxA7fb4xGEnkZRAayVCFS6FQG2wvda6Kbh2k0kI6/OI/Bqe/RVrPVODwFfB9QUXIvbwu0OzhULcWwB39n3k8p3yx1zxne5Uv4ztjLnp/m9wuMjwMqCCvvZvqj8MPrr0l1eGXTuVHIc1Jx2Dx0lz39fdJ3qoo6VSn8prs0ZlVyaBlBe/6PS596tXE5fOQHWj4H+EZdFjm7f9hJNZLfxQzv8Uvuh6bJfiYkX4+Npz9Mz9fSIAvcfPoR+sL175VGvT9qgAFi96IbZiGiQyEuQruwXZaJPjUg5IztI+SGnEslM0dRRgt2au0HIGD3/Ildp019bGtp/8hEFfVVBEu2ie0nllteVc7ZhI0ypXfm+M9SNj2ZKE3e28utLQZxxIIn1Zk2s7MaQZZJFKatGG7IHbP9PtUCwy81URGPtKVL+g1LuK78QXtC79kO6p9uiQtkdYqrksNfYo7BekRvpHs+CSQfw1leKHc6YN9QMvdtZ5wBa+WBr2wy7X7Kldmc8Wugr+Ss95/fKr2Cz9FG5aU8K8H4v6uo0J/z1bqx/uccX1WYSFQCMby24wg/0TLQfzLKozCXUdNBmk0++FhVu9VoYQfQBXgNwnRI1c7EduW2M6uAHb2nV6PH2lBmdKvoTSnxJfWDvVgcCmwlCLirgEo085jKD2BWVfIucHZ/BfeoId9U7IpGPAmyFiuYh1lrNwWDpSkA5IzSm7ABNNvCoEwywN1sZF3ZXq0b/QNzjaseZI5b2zWDtibM5pTpE1y2ag6hCFe5HZsaJfrkSiznrhJk4LVa9Vv5/wZWj19BBraXXJiwgrhMtZBAjEY2NeKhnnunEUky5WhvP2bvY/en/jWnVqaVvHq0x4HzoCU35WbyxMTju7WKfVLi/V2rBDoanqLUzXxmks6uaOIPfuvIip7MjSTVR/KzE3smiNSA4P9KFJgubeVLTa5cajT7o7iFV1cLJxPSTbk/GZQy6uF/fegZNJn5yJfOkst19+W15VNyXG73Fv5M+mkRs6qCzDjWnAYXqkPbckN64pUQf72jqP46/7of6aBXr3m+5o/Fe8u84Fs2/7pAjZ8zWrhoMHSebQ+PKRyYC1aDPkoQnPBnfjH7Us6ouPp7ArP5Bl/jthdyoyQ2wH3b9fRSbFNg0Gg2Y3u2komjyoUqzK5FrG0DRMWpmY6EHHXol4gCz821eVBr32NKOtvWeaWgS7fOQKjndLqrxbyqlWxBtg8opUVGnbEsySzWhbyKGUq5mFtMjFt87bqSkyL/dU3tDh+pDIE2w7NZ9bvzUjprwQQA3yAB498m9VG2tExMsuJiuABGgJoaxOP30giFCJFUXVqihyboes8CSku/MZt4dEfqDLEBpyi7Jr93kLoTXEjJcrifGTrSTQ4pAJEiTjjeMxAUFVN8r/hTEAzwMUYGGo1Goz9sQm3Hu+Kh8mGWMbKsU1364fPxNSQJRTgwg2pyA0CjEUwmCcQS5zJKrOsw6qSxVRClc326tEvAgfhQ+HKxpOvXVsvRDKfDUpdn0sdy2t7ib/CphFXb9ORPfKlJ44EX1DspN2gz/CbjQWRi7SckCqyjGABWFYdjXzRIV2axOepq5Yq6DpD3WnYzgRVnzy8RsZsWDRq77K8UN0zt8wRLAvq7PrrIZPLBQxaW7YYRFlvJn80bMvSRztWKoEJFNRBZNOA5NFcXuNaDT1IPLMCrsO2SDdAG6anDJi6gawA6HgsOFocU7ZATF0eCsKHj/lr58VFAVZz2R9v/ufjrQKAckejX964f/DmLm1WyiZe6Ezmq8lGPnUq67nML7wswsnm1nt7Yeh/emT7gPfnFMtI/xO/p1QfS0PsK5QdcOw/kVGoFu9uAMvMyOlhf6nx3G4lyaWdyeBuQtwl2VWfaLXOJm3GnKlup0zM5X2gf/hD/E5rPaOktnbUnrcEEHiR0U7KbLksliuGWIQYJTkSv3gBgqvWY0BqQ6ZQrF85eu6ik7FU9WLmrcjyrSU0ex6aQX/OOFLeIFcqwJzo07eMXRETHn/ePbJeDPQiWw3/djuSN2Odot3XXwFfaIu29Xt+uX3ZPvSjyA2RNgJG6s8LGwdrTHhBmFHZ+fiqkLMRGG2gr5q5JTDmTYnu5C5rhPLD1BuFNIGL9X/Tk0f6ypx+uk6r2gEG3Ir01t0weztFAXoZ+FP6KHO+kZHnYk6I3XTTGh65nZOcP941OpTN5tjxTBo3VXylqmeXX6us1MgE9pxf1oPWYRMaiU1ODE7r+qfwenba6Se6pRglnJKT1/0kFfOlnaHs0S+4kjit46nhgRE/mXLvlNAq71Tysso8h/+lshf/0sr0lcv1L8dpqAvfuv2SXi/HETbv5RDp4bquo0a2o0LkEYo9bHODzAX1zscZd6uzJ83u+oM3d2v3uUtoLB2sDD7DzLCziLaTee0/+33oJN5eq1YPaX8J4vhD4I0bUu1jh7q0mKKPbof6tiqLKxU2dB+3MTNUJvJ0rrTqarkmfR3vJzWukZG90TX0mUWIojFcUzOjBLSsBAJCtt+ZMd3gtfLVhVZC5zbjuoFRKdWT/zXtAX02e6G35Zv85JjSNxq/gSkbe564XBZK6q6iH6/vBmF/q62ljpe1y+VUXgknzUPXy5IlMH1eUZbgTXDgTpMBEv411hsFE5kzGn2aywVOJXDvqFj1IwFXBlOp8IedV0b+pJwvsxTnfzXwM7x2q/mkVYURG/xr7QpZH8tHLPEnO55sF/+y8aZvyYobezdc1PwoBs8kD+GvoQGVdCEhf5lJDgx2o48RA0gkEROgnVeuzBDVDPOng8UUzfiaHJztF+Q7vwcNDNrsJCOVGeZpXxdT2xtG4Wg35l/ZnayH3VrOx74Q8cu91qw0RBj81sbFN/9wFqk06RyLM6bKRNkWGw66XRca7WsJ+WDA8x/Q8tem95jSx5Bg30Ttl/O1EDqZXp9bxO2bFH4e7bW6DNSnNuiMbCozBtBB+lv4IPxvMAqEf3MucvUIZimzl36pTzpksn1NcXgh79Ov5YgyiYbPG7163Zb29tmec2v+fbLS03lXTSRbw3HPUJ+p1H3yz9Y6qraGtlMp90otl/+kEbFb3mLVQdzaLuaIZe3rSjvcIkHgqk7+LXsVFvRx9VFgQ5QwsgOi+xZWMEpePGr60axFZHJXreDOPj769T024QXB4IQOnoG5mhuGnHrFKxw8hiMnmKURgqtDvgqSKCK2xGL0ZoV/Sf98u+yKSJAu1Pex0/zBwISBUZguwr9vQKrFN1RDPAeCmKP+ihz2RG/Z2BFtwlVmoa2orf0drOUXBAvdV0pJ+firDBIXi+JQ2/pR/Byzp6WlZxkR87Z6P2Ya4ZtyJR4bY/uxEdYS92Ua6iqZeIUEQqTXvKLIXHeq/diCiofWhiEakvMZtrnf/nTvjYRfk/rXn+IS+KA7rrxF667TTfc46EbpRrsrNVA02Gmp7ianFSgJq/jfNiVBxCfwBHflxx8GW10Ni81tBiwVqZCp0d5JyXK0VbFc3TjIgsv96M0woCUgeQpXspdsVtxnybSz48yuq4eotgr8DubRTqRTfYcJeiPgXWFKmVfH7l2PWMdgeuMhSNzP2GZT8L7pMrMTVHGZ7bqfDswq/6hb8AAsuzo0TMFFE2ZzZNguzGUDDSdDlw4AfEz5kQ7GJy+IreZW/LbE5KvVcMFmhcTOi22BkoqNF/3HqbF225FK1nfSCrdCMw2dHkDBfKHiVW6IQ+y27H3DXzUmSmYdG3Jvauaag7lCX9XW70fcYG6692F5M247mDL0oyifv8In80/6it78wulTRdwQ7UzI+K4ZgeJeasSr1cImFap3sEzhmT27eXkDVDsoXIo4Bct8QgLPlfEIh0EkbWXBQXfGTlkuFPurs2NRnAzlHAbex/IPEEj1NjEKU8FaEehyM5ORicDh+7HMeitE9G2g+fThlJpdp4WD4OsBVSTlJwaE06KBk+jR9ljdOmnB3p7qZzOTDwrEYe98k5/FqDrTjB2hvqleIN9DYAdFURanQgY/2sQ1M8ORmfb2ZrlLezACkAlNRLkqfO/+sTtjAPImXgFF8SiUxYdJbOpLBA/FVA6a8+bRyX5/YjTW2Qs2iJtVR5mel3cn1Dj1r6dY86srTmzhSsBwGQlVuRO/kh1SOhk5jrdOF7R71jMf8YeLHu6PjZkB9/H7rn5fFZRm+sGi8yuWy7e8a247ml68XsdGztB5D+cDdBbP7K5/tfU3dD7pZJI8dOKiMr4himmYOHg3Au5GAp1znagvU9TnxiEmzqdkt5uzHpC3uBYnVyCZ4UqBhD9+iWkVfdoGqIR/tDtmQ+nyQg48BMAcOib+MQZq/624Qtib8lornN07hqW639Bav8ysljfkjzWbwqyxJhZ+aGOrhyH7I6Xwfk40mEh0OYfe1LZvXSCXvAf+GWtdbq07c1DWwKtgumksJfVYm2FHsmpXc7z0vQxk94HStYqxwp3WiVI7zStUmmr02c9VA/Te45lA6GyL3A91JoPP/fLSrvYg7Ip/ctw5sP/JCKpi7j0Sy1G8EMKm9H1MrEthc0AagCLFIeC4TFwRRXy6BefHMxEZppowkYPLsyEBP1oHF6X97oWRr9s5bjwj5tk6mYTjYWcsWsajV3TgO0RKnUk4WI3qBYnaL2203rbvDg1uMzIiRt8nRmuIT/YCVgfn5UOcWI/sHbraY4emOvg547ldNzmFy8Gmj6m60G5cRTHDwtQfr9v7j1Nv9yIW76DL3LoabItSR4REiYRnaB5wXEecaOo1EMwMuAbh+dQ1AJ1WwvyUycNXKhM6l4fNrWGtHPG3uoH+g6Wo22HcprqmFfx59fL/Ud28s6d2ag8kSKZ+0ilF3T/3M52jXa7rxE7oR5JF2obhJe/WSkjfbFv4GUqqN8heq8iz6p+NjeVAh8zX9wepgS3U1fWYzrE6oNkyO0mw6bSq5lSnB4Oxaf0SBPn3Qgz70MzqlO/WoWyf9Wb7cBKqfvj9dX9frnr3XUqmHXjxwWzKNBkaFvc8bDd4g61+wr9UTd+TciCgWiBsD8tujhwClo0bAi7YvkrehSeDlRP3f3l8jUuzuE+yQfYRTOAsdzFmhb0PU7btmIU4ncyv3nrL8m7NlcbzF+967P34jAqFett0/oSRpKTF2ktX7dJ/6AOYQ78y8pG5/F78sF9Xu1010ozVYrx6OtEmbTrENOl4ZkOyWJCUsjNxaGYrBR64qW4+ONX6bePWHs2GfP74oanVOR62/ErjmLt1I/3QGcE6ug6/Ysy6TUkd7mm6YsaE4uug6313pAvMYMJW7VLIUZHsvQk38FhmX5wp+4ffy58Qk/KmB8J3JV1Vjtxs17AiFJnWdEH8aIQUkM3WJbfyvtRVlO0lFWPT6EdP1raa2Artd/2JJr2hJ4/zDed8/qvATr6lla3+sQ7UW5x39a7eBvudYLZyyo7+czZOuftqqizHxZkl9X50bWT+dZBEQSLAC5BclpWoUkeks9RgaaXJchxJD7eUDYMNSIfcTWzyzVWP0xW7npd/Pj3kyIPfBOit9a27Emrj7o+SlWX7tJ1/v7PC7yGy2LXvnyl155n+mdFLpdpEfcG4tr9nzOQFIk5beG+7YveMFzAVw4vf6TwcpZxUVwWgEfokXf35QIxFzDUry8G+Mf/HgctbOjV4LUpMFNFrMgETzPVgifiYXFjQzmc0oxpFNtT4+oHD+ZqaLbqhfWT91HttFy1My7XYYskBN0TcTPi8Y+4qVXvd1ZiyACrBe/mjdnBFGMGo7KZkZ+OJg2zJMQc04ncMkmz2GOQrMa179DT/QSi0RfFv5TG/mf62VL4qofjnXfj0q6OL/uxrgNsP2wPvFc9AK/czZ7OO7iAmKeR/cQgtO6wWw32rSHA6tU2aIl693jlJx6wWXcDJxbBnWunPovryjyiMgtCzWAZtVet9C1sjAAShhVio6YnXupUw9GCZHBuBU5gCrZiJEm1tB59bZ/YZZmvnWibY37y8431UTIBl+FC197wd8CNeyRzS+OEfhj+5A39x/qL/G/2HE5w1Xo03kqdvbfMvqKjqD6D75nfM7WTEO/XrDHSFmCVaeabmCIcHbgmVtgisrenlpqc/uEReVd669mtX/41oeWVEyU3Pj4lUUcinvaRde5sqSpZitNkzmluZJ4vgySWXb8s44l5BJpmP8xqnfzFW8kbHs+9p+2X5W1xRIpS5omdsl2rms8iklRvLhpU5NG/uiLk7sDRL7Xt2p3uHeXqTSfQdayoqnMhs94goWtblGUhsfNY+uU6Bqu/AtBx3cOtQbilvhOJTkbamdwQb0Vxltbb9ZleP7lfUS+wqmmLFr3YFlF8VTUZOxDUL5ewjq4LyR6R7REUf9Vab+Gy5b8GmCR9bd1kRM/Jzf+5P5axjhZ448lykMhe31Pr2Jvqlo/UuqHmS0iH+LKzmToHrF9yvvu3o5syKPvSUr9UhCzfqbNWmsz0trpfLoJrrq8rSfdTvF/eSZh6VnUIl4Xli1zaDZD65Q/pzf1jIvHpYNbeNe6AFCCaSUPUmEoHNXiFxQinB1sF+bCKGDSy2DgESarwjAlmCCwv7ITJHNJTlBLTzWAHipS5zXbQ6aPRSsPlLT6XDm9Y06hWQ/NUKqaGvOjpdoCW0pvA6hR7wpfHIq+4eIkMk0U8s/DzrVDp/zeLz3IUzdnR24sPV8C/ZFeo619fzJ4slQfIHyp5Eu9tmT2/0G+tVT6VSXG9yLx0XOjWoHlhuWT0oO3WvAcJz/i1LCxvqHNflZ/1TxfF5UDUdqPBy+Ku9F1bS+vtHIu6dP3Sho8Gufz1rcwSfQ0NoPzt4c0iA2W91HDbsRNFy5Nt8dOkliiFKi3rk/xSIYrUTwIA9HaAub5dcS32/VrlQu2IVx2Vb+uVRfeHkpxWDZuvRlnSdiPpKNbJzrEXHYvUJZhVxJknT0wgMalhBYgyHZ8iRGeeBOjearR/mWaP75OeS6N1rdF0RpaQTyYp+3dyGkQm2zU6dAMKKBIHS0lulYIVs3qnxok3Y2f6ST2TVFg2WQgy2hTPpiiKXwXA9bTWp2i/Siug9w23Ii8U6lAw/buj/FZojpjbIYyb24sjWDTBLpjEaWKER2BvUSDDejZIZK3l2RlVgQsGl8pV+0sw9E2pLjSk1WPurxUjALi9Vc8cHmFWdIBdjkmVpAJHQE0pj/fqziNlp/Cra4TSrU71gLsOcBkTZ8pp2kvrsCzDO/cUUmYID5ZIYTChANrshsPiD/5dLg0yFftk4bryzQIZAaMpwDRACCAx80W0zLmcn6NwAvDSSWoMPj1GW9w19dJf1aqyaqc3uP3O6LXVJocnup1z67lACi4Os4inSQHqRPhwbbzu3/rb0T9uC4r5QW9F+9vmn/asxcFq2zlY1yCqFeQXoC+aQ10H6efZFLrPEKcAgTYxFXmNHGan5OfN/HTCBujGr6cUB9+Vza9GTJ7wDWp4MHp50sHQYOoZLWV7pxSvSk13H1RfhJ4bns7YdAzr9cSd3J5dq/mhVPRpqjL96Ly0DVgDEoUkJckKxNHAtFidnGo/ojV4cZ1XCn34THon8mxXhbulCX28Ixt8XLP4IBZUc/1WPHwX3tED7s4a2fYZa73iW9dpvTQWwyHF0h+OoopNCFJNxaE3HQG+bYC/UQoetia3kpB/Nfu3J8PftdbDLZ/NtvOa7k1Fa3G+I0DOnyhBzddH4bEyhTNt2/MwdrMEBNbAib3Dtr0LkLK3VeenCE7AAZSteHxBY4LSx3wAJYVSKaghWiGCFOnT0WNaS+lbydIrD2zz84k1vmlgkLL8ISXgS2LuYR3sa4YXvcH8XPAqT1TYTfiilVAXfQsljD4A5gY7RpxXjjwIDvCj99jJnakyfFKRrcsF9vrzd9HZne9572t+zLdf2/LOGu328NFjj4kNBoA8Y00pH6bkaGZtwFfF59rVvSe/nvx+XeVn+opZwxc3IaS08+lCDnUGNN93CT+wDOuB2Fcpf19+ZN2RwQZ5qu5h3ciAPQZlRy2QkM076ms2pB+8ET5/TQFQEP66F1jrl5Mg9hpfN5cwA7uMSr/8c8p/F8DoReEvLwo7jbVfroOK1Ptx+aBW0EOyocskv0yLZEKp6xdlHUtvrNscgjf6LE+hOkC7wU2/9ALkKnrQ6WBu3AuNhodMSSIpyHXtCz2RHUhWVrcDbyO10vJ1LUdkT6qdt/SVIfwgMdxOBiV//7sh8hAGvwgw8UyoZAHY3bwH60t5MMP2KekebanSr37nlv7Ovd68E1G/bj/a/LGjo1jLaQhIILO1S20yt9tLS12XPyj90mhrOZae3LCeqRPp8zG8F56VZSV/+PnPUloHpW4AfW66eXTZF/46PZ2GNl71/SK7kF7yyI2pEHNLXz2zxNKHWWNlgCWJsrJicBJfajQ9/i3Crz47+8y8SS4t/dp2trPMe2D8kr9JLwD/bSLknVtKPxQw1/XZn8rcRdcFiS8LPSsmERpNs3Zqx4eQZU+UQxbyFKVEL0ul27cy3gqv8P2dRc9u/fKbRIh7L9JMM/MFvYjtgne3TzlWB/+lkmLfr62znNWhb9lcK79It6YpuizBnulQbh2HdMm7jsP8266ulKNVvT2+7KAUTwo1xGx7LJ4Cep7sGoUlUQ+DYyv+iU6sjsUFamJyD/Eo+bgrAv+GhF0SWBpiSPG67gqj/7WVR+5EXNKwqcVOWx8qGP8n45rszinH/ziRrjaseq1267HIl6XPv8sa6NXaDSFovvQNQ6eSpf4Ux+vAyT+9w1/cVfClSVB3+5S7GpIXi0FOmKJzuefHpaX68OS7Wie6vtoj1Q5tZe1ebsSfycnCbky/71iXvw7DJzw9lZ4W3vhkNH2Ft8RTUHE77Wj4t9/e2XXsLBbXe6uY2zF3hinwW0cN1I5m3O0F/do4go49dszjF7w2kqDXCU7fWnjetMz4sNHTdA2nx6Ubftz/rtwYN/J1+R9dnJ68XsvQK4zuz8of9VXFxgZbJG56elmSWyVXA4ag8XMKTm8cN33GTafES93gjVDrMFxLl3hToUef+Yyv47JxU6bmWHsBWltE0qzPp/zD7JYcXCZIVAzkz6gRjPmwnOvEzn75PVSHYkJBXRe9rd3zWLTVrBxy3gaTgMSjD/wWv+wLq3Do96hOpsPef/TLbwBempxg9Asy1rcYPAXuZIKmNkIUkEiVW5ARgLHpcZxxGulRnB20wxNFENjPh7XZ0laryYDua1qUD9Xt3HoEAik7yEYFmdLrHof/QLyxK9322o7XfTAX71w95Te97lvMyXZ6TTjokGBf5H0pMfjTszrVy79+WcLxYAxi/FG9wyd0CV+d1dVnedvyQcs2DLU7biJrUyujQ6qtKQBJNHqI2g3BpSbG82BjOrrTJwz7/hb/KYab1rHZKhvalGidtU/1JNpoDXN4HjSlxxQGjqkJpB6MPyd5GKjZYOTo0n8p+FQKQhUHTnmSrR3YQYc1PU5Byl71kPmxYEypsdlgRMBZlQLOD6xTABL+n4KR08cYyCPJ3LCHzE8FowrN1o2sUvBZMwagHihiNJ0eK52H1xEy1v2Y/rmtiJb0OFfBOCphpgBMv4eB0vsyMyhgKZ8+no5o8n1w8HPBaLVtt6NGAGLklzIipGlSrQiAgazP/9dRNFx7yPxUMMK0odVghLCwHQMQewNgi5kgSCVxCshURxJzD5kfC8aGVy6wMkyUsh/YiwzY0eT/8GedglPh86aHzD+Y7++O+6PrTORrV2VQCqSOPUK1TphCjmHnk/6vZPmLIqrZMOgYQKZhsrL+pQdtYJ2mhvSV6dPOCCEmHE3sAaMOIYK1xMJD0rKgmZcroh9SrYwJZh5EYQkzfSy9bvoiKywnP0uoqUp4RnXu8LWYj9wKAxoZp8ISEQCeBQUG8TuzxbX4zitpd9zECk8VJjqiMO98Udzb+N7W0YiTRIq2i9CFe4SX0g+Gpzg3byz66Zl21Wz5E0KupnM9LpbPtAW5FscvDakMTH2yxjsd/5/kNHFAp9DyKR+lROTHD2syuVi0Lp/Xj3kH0puv4imaYugtuQ4dekoxepp+W5Ar0wf8vOyNxh3sv3IVwtoTszTlvwYx/v2L7ZClRl+LSk4pOaKsbOdpNRg0u9hLRkSlswYLeyk3xEkawBq53emcMRG3mtWZhGS8kMgAe6tR3wnH5yOVTEMfdJb6TD+NSBPYZZOQTsQNM/ckdKmKjcM7nVJtQcogf6T3Nop/BBCOkZQgUhqikIqQ9AeNQIowt0lnWsQnMeHQGcqrGrilyMReKSEMgkRO1ptALsGHoSGLLli+E6EQGtjLGuoQw5njiqLuJfKlScahRBZZZ+kUfaFURK44zHCATByqFCJOah7sj/h8hgXZFebxDld8d69GwWDjitTsCj2GOKUZb2aTdZJI0/qMJViJmqoux3CtGJzsjBsjkhmK5xrYSRv2cM+BionAeAAjaqqEcGBNj6d7Ot3sqjmrN3JUUWkkQnPpnl9KzwdYmB2xvZ97uFKJjsKZzKS6Q+C1mQncD3TRqYphJJbxbuBk0kU14uabjIGA5fKGo73yutyVmb3KX5xrtHT3EqIboVTKKEXz7Io+rNl89OpULYoj03nP1/b5Thp4lNbp5HPYdkohk6JqCirONgcpoYCNCRRg6tdSQQU6kpuyyDtNBKAfFEWyyzbop00PQRVAddIT2pSeK5YMn+PhXvcj78qLx2pi6rTSIebcDMPQ3N4/5AqDT6e+bTpR0uHoZNWO5lPoJFY1BQxniHEMLb8lrlo0fXPP9s4kqkCOqDsbXCpLoZcKyCEBPZ4XCJTHdiujQqzLtPZYurNeLDmq2JflueWLpYiimhegkoeiqHNFEptPQ32mII9dd+DSY45kuCDDaBkBAjYSNbtJdTSj2xNkDRTJzrKkWjKbp7KaYvd6DWzWExj/50p55ngQEzY8l0650XvExA7CuaT12w4pXborkHKARzEbB+HGCqY0gXyG4pqaIy5SGiM4ZUpdvKAEabBKQtANoWoODRqkFm8pjEmKJk/btcoyCwqqyzyGn31GDMwZ4CmEDjxdS90y85sesHa6GU4vkxGti9gb5LDT6YjwRTJh4JjWl5V4Va1syywVONdSwzqU5q7ADuWRR/iZuGp7cCOeqBtSXCxriKl6RAjh8Jr348HCwjmX7hWGqHkWL5buOM2cZCnMVzDrwPbJa2lX4NxafPBQqOVU8+B/lg9cqZGY5iGaIKwyUwZEVld9F+W2c73evnRQi0E+SVykI0lrcTzUQv4AK2Rq8FmiBNMLnR758RMOPL8AXh++2Kp5DGZj3VEWF0lvsKin2GHhmoxaLJMtbTqynJoCTKefxEDCTiaAU0sXT+BJvieeaxfRC9CybvpZQJFrKD0rtNqrUuPZifee24UNn0EGbLu23MU7k3ZOVJQOPmuEIsS55iYT50YeFfMUmzrMcEL6tJyAavaamGCEqg2OYjyYzkHMdvLIxfCWDSgg/aW7M5hJn5MiKXRbje2Z7FpgXGgD2no5oLSRSV2qXWTHB0W6TM043WjQ2aG3RmE6kKCgmrIW2kSTnuVoCGO2CPqlwAxEVfNRnHkrD0GlMNibIhNwaUQNh3kO59INhTh+PsD684zInDkQTYcKLo4jjfpWS38EgsE8VnXCNqEZGJpyECbEU62sg5IyWQlNpZzaqtelOakHhxS1mAynoClau5loWeyqUVRCfZpicEbHzrDgsOTR4+nSOQsYuQAkJyCaRgrRw5NSGY/Oa6qsrZsHsqlSTqU6slkc2SnVPcKju+HGDCWTflOhHucmdJpIe9BnntgpXAcNkO3xc+UliJ0LyClamn6g4pTb/oLelMoWLZkrxc5UmWBs5wSgelt5wpSAgrVCn+TBmidGJQvf4Rmw/HQHqhPmrm33ojCVtJAkRc9pzj+hGMdphFE621KJHuzCPIgzxyCnJz//+VVa8qUOZDHvS3HrzNPYd8pEVLamj9W9Pj2mM77npkunvlNxq4TNXY661pvLNs7IYVQl4ReQgS8PtyreHL3UwNtyRlgHjtl5uRMdHXWI89qDT70W8dQ7QUEbqJEe7Ps9wXoAVC9QO65HvSNbelCnM/VllauVyLWaMcxnrGg1bZ0y2cMgeW+18oTaeSy+JqwbxJ0wYnMCEHUfLv4+FPte9QKtmbeYttjBAeBhfSroUPGbLDIWZUkL1aWAcAHAF2iiLnWvPg4ePQm6EFCSsWZnU+8CoVDMq6C/o7EP4erIMS7YvjrcVHArYCNi6SeQBrBTrL3bvBwGSvOYt0GxSI8tiBagio3ZNFonoK8DJ5rmmnMi9JzQh1G+r0m0RUNkXojREDnO8kwiZPd/9r4sS3VdW7ZDfKguOvX6//kUMSUZYQMydq59uHjcffOsIhPIxcxZRuFciTaQD2vtDcqK9ic4X6ANmsaJLhEcb66EpS9/6sqXDOx4C+mdOdmErK/c91tc2FSCzVkGHyQedAi4aCmhTuOglEBZ9bhW4GgBVE+JSugrtuUMYy4DCwIliCR3DLMw/Of2ugGv4Iq8X0p9sm92wKHaBDK/AesokFxfMlsCLRpHU5CQoA+TLWFJKfGPbATy3jEOUbFRlA0BbnMB54O5au3PTC6+ykVAu92WKUOp8QYRbBwWhn7BZSfexhxwbC4mIVtCbTtRMslxrgh7lsTeXEyzn9piZ9JuKVhDvqJbBopYZor7ULSR2MUsoluuxZUvwRfM4kswiM/ovOP+XtLetVH5mbQXo6YQhTIyUtBZpSEDSupyA3OuxGm7k2G+xSByvxoESE5z+ghmOCDvcY/M+eJr/9SA4bgWKUkOqQ20caRCENc84UgGRRSpMXCyVZqIgnb4w0E14azXinGXv3DvriIPZg0XiO23+HgOOxCgJSlxidtv6pwm7fRaT0OJXnZJig0cBRiMOOjqMnqMVM9dGJMLiPtbGJh86y2aIhHmvr8rf9AlmzD+UlJMD4e33JGcpcXzXfrU7NBFcSFcGe+rbsSHoAwQaUKOw3ECqi2inCmm36kpRKFx60ODS5Ys5MY8gGEFQg1d4oC90yXsgp/bHkdzbY9/i6aMy5e1twjBRPBGm+lJFwUKYzCVtk8B7KBpaNao7dgsA1taApQEUUcmOnZ/ag/lBe58V/j9SHL1C0MiU8UsQP7CZpEl80PgUGRYNKsjHXnyAL5KcruASvWIA91RcL32v+1Hr3+mcJeGzoBsg3gB/wvIE082mFwxoFyFyosBpIQh9s2m4bscdoH45DLo4r6bIcwo5K74SuxqhAl4e0FBf2ukAMEncfWLdFVmWk3CD/VjSsxF35EAJQpRYlW1eQJMoNE1TMTNAkrYEPIXpzKJ6EAz0XmtvB+/1f6UTdEQGNRVGDwVXly+1tK0Ap5ynxjVDvFn8nXE+JnuLzemBy4XDnYgkKfGmgWzqXW2pMLQZ1SiVhpi2mPUCLnfO8C39Q767eAftvvGHoheUMlewPjf8UgSCwDttGAEtAcNP9NRNqKSoiLTK8BbAFA0b2QJyxWL2MtU3EbNLW0iFskotbj6dkJ3THvynv6dwvvz0ZuxeUuygCtdXcqdQ4l934gbMPTTwu4PED3VWY1KPHUwizgXFhnwSkNRkwe0hAb0Krg/8lPE0hq5g4umY1VoadEu/wAfKy7wgtWdIxQWHgflJeF8nKhR4nXvI+fgedZcetw/pjgn4M8yl2JHApVAJK/S6XkIJg0gKTiblL+kkoosT5ZNIC08Ke67kquYJz+GS4rrt0RUSjEFTgqKToG0szbjGuDfh60w3cMIY3E0xWxaBWGxjG17FdOGklLGXZpU+jb2Cr2fuqGZvhuhW9Sgmbuwf+56PedRTEHYCAOgnqrkwM+nl0uYF6iBfEHif2qPGUfrgjSaIuiwoXwAI85RawVUSLOz0RyGi+SuofZnKm2tiM3pIJktYtCAGGhWP85CpmzzX9UM4izhvXT9u7/qwfk1CXG5RKf429AvtmUUwwxsz2BnhpM/kHiG7npzxtOOvB4NjxDjYAEKMX6L6CpB6yiVh78XqCn4kiJ4Ba9QSO8bYKqsqfKffkP0Y/WElOKDhCjY6NDMgooBFEDwhPRTEr9AjEmC08qgw+nyQxVJGnG0Tzak0KnPBTgmIy2lH3emDRa6E45isFZD39XQn9qC9poS7dDmtswU3cd+GY5+FOvHfxZ/bD2FZmUeDrGZGmtq9UOSMynqOBKijEB9q5UGVBUdSBBtKTPSAZPWKlbdfy1jECcaw6CLFAk12Axlzj8WrxjyGuVTMh1yISCouvnWVNzdjT2/q8RHRVhoKypTHWe1/C/+0VXA+iyoq1/9yw8Dkiv/LLgGpo7k6+BOH7jvZc3x7hauY+K/i0D1sysgVB5ptEAaw4XesQI6031Erg9/H4Hud/2/S58NfR16K+PXnorI0lqbK07+VQSipf7VCLRId4aWuDUIDWLP2g3N2+vDn0Wg/VkyE1ziFMUpHPcJmeHnMdtZe8XJv4pAk342B1oaWCDqEoXhQRbjQiJfVfhfRqD/WdgX5GczdOMNz1sSkIamBfaaRP5ZBOrfRfpL4AHibm55cTAweuMwe304OQD33EE0RKsv3MS5/afBHQSoZrraNWCCffj54MkhdPfG8vnRdRsZHC92tqsws00EEeK0QQ9j2lib7lWVEkHZMZSnTZGHtkyYouwIILvgb3AxmpTcTenCuZ6KsIBDcTuBgSrZ7Age7MgtMMyqB4ihW9loYX6PKXj3pP6W2pPiZoO4KcGC61x9/HyDszXcHOyijashaO/18IQ78Fo65kvl5dT180D/DwwmWBCUKHC6vZWaltJGMkPsuj6eOvHu9kltNsNixxCMCux8JazdOp0NI7g2IsSnl+sxPGV5gLVjFp0klJtLlO/c+sXdnRNHWEcuRUXJNfJE80gzXPE1MSgov+uexnbu+iKfCEd6U6/6t1o9HR3PNKO1SpHWTaMjuiDyS2I3qdohZpvShRg9tec3+PE29OqViAm9Pt2XJq3pKN3+Fm8hK0trOrR6x3cYAMXMKUkesGQdf5NhA8I8Gf+VdxkpBtgEpEUJMoOK56C3soNaEcPFrDi13QloQTXj5b7yxDFiEB2hfwULGptawI1ueNfNbco/qvUqLDnDRdaOqrAhtaIFyVkUJifQIVmrsEPeoxurL8L/+UI2YtAbBsDY2gA432gBMUZXyzL3LetUwSJ8HBhGXlT749hBkgl5JdcCKnHXW5v2iW6/KGK8itW5uQc/xtp3yF/LMG7MPeXd9QNVeZzWHBqPT+6aAMjiwUEcdL1d0iP1T/c0Ex/2ZprnVDtWL71HcK4MehdX61y5hRIp0OvFguWW5O3NLeVY/GHsZKnWukR33zR/MPOJKqareyY4y7ZnYadcwswAjAsoSLvPB9d76PzxatvGK3pOLmeq7si1G81ctdlartsedW0sy/03n0QS2mI00IqTe7f8XS8CNacxPcoo6SSJ039+K7kslP5A/mroeOaq4iaqZx2uH0SYatXMjabBccTd2xt92HX3N8/D57rPpMyjvuLrXFk/ZoIk83zsCcH6IWTiQrPsyYliCTfbTx3zYZW5WfRYVEbpw6vYzPBkduG6N/dBbswdX+/wLUzy2p29qt251a7Ur7w43i/njbiqXVCC5Ijl7n/aXeamGUEQ9+S3wJUhLbJKdPjb3RZqVengd8TufGi9AaOgJoyuhzK7R3zSXwezk2EG/QKGy6UOfagewH6w3kOSciMCC62ObHY+QcW0rQIDNNyf64aFANKVpZramH18ZZz5z3Reor8K2ql3j9ZnoCoM7a0bf/pb74KGu1c3Z6cOoC9KG5OgdD6cBNYLKzyJ4SBplwEgEPKvHasbPDn4KbPHsxgv8MfJW6WApZBlm6KJ/FyW25ozEp25zbLjNh0BMqS0HSkJiqBEN+OtD6n2z8rDXr7WW5jQS1cde1cECi1MWqgtb1sY2j03/MuP79zwUeu0E3d0VY9Lxp0LnvV2aTVquY++uNZBffMfvKAh4LS9qt6pGwLTZyFix1BaKKBoOqCInXJPYHrBAaR+UftEHgb5qT0oyUIyUHIF7hfQnGlhHXunZOp5xex83gEcDsWpK5BO7MTZmDiRFQkypuuHoQ2Tl+YeSDRHIPWRF2AS1+b7YggdUaldluIi3so5Odtb83cHEY3CJ8C4BeqVabhVOJHWhk6n4AF2y43ly6/n3NKXRPclbFxDhgY8DqtNvch9IWnF/VWzJiOCGTnKxTsgSiYstuepmn4gj9OeNhEV4MB0HDao2u2qalcyOjUZ5Y418rfwdH2Mfjz1EMpLueNcDomkUobmTxoIQG6Mbt2ts1/+OfyXtBdbbDVfE8v9KZ3rBNZ76S381y247IO0lUlNb0DELJojQKK1v1slG3fomVGTEtFFwYsR08NgGLhKMj2iobN1d1b+WLHjqmTnLpKCYFfT7QHS/ABL4gVjiBkzQpLau2/e7wKyZ7JhU7xgjYbwseytqei2NN55eGmtZvkXa6yRYXnlnpN7oKVsrU6w6yAwHWAyItA8tomfpIW7w/+YVsyzz7bjKx+2GPE26bW0AkxeYXVqN/Q/Tflda+7FYa5/0RDFU2VqH4zPrxD8mxzn9qBPlkoVz199DVvTtVy0f4KCMfZJLtNvV6BTTN17fspvd2YBlxRX+qgEIatIBU+4kRrqf4IK8H+CS+6guIrVRTRiPwN10mS40AIZCm1WVtzP5tLC0QmYbsDljxTPPhDVh3sr1lnRiw6q9UAN04d6XjHaQqH3S0IuHdOT0jpt5CbD9Tf6KkEpYRCc2gAYLbQV7DF5BOQ2yXKBwH2oFaH5jPcDTySfBJrSk+aqde8MAd6dl5uhpbIRwVctN3nAyAEjVSOg3XjyKwmUOaarp/332Acen8XX1GzHN1U/MLGnTmFO2NKO/2cYDQDLcgMe7olvnNE6e/vdozeGiU5IFQFpEeQ5aDE7Y7guKKkzqOy4/ca4qcBgKvkiUbM39wqrSm4Noj+QNQlWqakZveLIDW27QhL6kgBx4ZgYGP6tHodwA7BaeROgQEuTHUDvKX89AwAhewA/0x53NSjnkaXmlcQOXOLl7pVpEhXx6PBJ9hkLaQGmBO6PNl9vNwUKkQg2a5mFaBwESm/rw2ME7s03OJz3Brb0oN4qvC6bkOlCoIa2hVg4XCAThbZjY6/0y2HccVEx0bqv4ThZow8mGLulpO5yVY7F9ibx3badZP0mfqh/jNMEzWGhPmvxMLilojaVcgJJfnK2Mw+tlPxPfMJMOhEBSO5Zi+5ip/OWALcJwCNIuVvIh8A0FJ2HN6xNLuEmp3ha8+WhoxZZcIODSY5yroH5gAIiz/GnCdYPpn2vAQr0kyCmEL8HnhvjMUiGNm4VOBbC9ugX6SfnaaFZskn5l452sksyEaSPLOL/SDABsYFOKNHaAe84eNSKvaUhLTaLhH4imh9WiXAQ0M7RSwKq+kmuss8a0DJjNxoS1pf4+hI4hubwkACwrEJD8KM7juUlJipJlECPwvWmog1s0PDsjj8CJtZLzmTtcvFrkLk5HAwhtQlbo9ADNF/MLc8d4omq1UHGcx5P9Zg8vKwICY3lFtvI53ge4sxTnGL3FdPdhI5CnuhPFMoeGjHT3Ic9Y6UL6CDNtG8RqG6LqI3Rd8r33YnWTe65v4g9og9mGBPNRptpSGw0rurGCFZ1rgYCJ5t43RINwsTjapRRixFiCOYHr6PPLPQDifU6mhgo2++VSQ3qoQJFrZoUe6xgD51QStDhxNbVo+5EDky07jBIyqb9pQ5A4Wr2XlpZogJMO8jsaGcszFW+JGb8wYyiVunCssaDoS+YMbawaXJbjWwhsHxbMWFVmMy08yznbBME08pxB3FFqaNXqzfdJi0XO6+7zAE+BglEJJW4wPMZraRZm9Th4ZBKc/wzkRRpawT4Jk2mE62+p9HV6dicZNIqSaCwE2goGqWaPCD+pE51zgRtsM9k7Y8V+GNqgIg6EalenluXgHkM6s84i3G+fmb4ZxsUBG42aCkiygkMjiIFpa08PHJhpitXaV3LVIbY1sSvkdSEWMzSBnlpj4EisAKwzEFqYJxTKLLfMxAdi5Inu/SNP98LM937BRvBYT6/M7Xvg1o19w2XH9qkobCQyCQB5jr0YyOJfbrIS+l77vbZHOx19cailoZglTAmEhxmsjZZcu8p5a2jSANl+R8jijTEVJCGo6V7ERkG7IaBznhSlWIjPyqhcFDNASOw6ws+6GmlVtw8tT7Qp+TqvFX/tRTpkpRtM50+WdvC2fJU4st9Dx7R5HjsDuDs2nJTO7gUYoBltbc3V0ZqC8AwJlXsKcKcDaMq2d8nyCiUL8jwwMPKFQ+KyRTFA76OZXbGe63KzIyFDRpheDF6GiqHzPkGK0XHT8cByOL6pRQa5iftvvNthorOQugM8YKSWYaZ8jDQL8rofwMF0nRydTSDl54pbS8mcjTQEb2RIUzSOSGolekem2bLxh4l0ijNxTN+AkQja6pBDvp7gB7eHTsoxOS3fuwj3nK8y+U9iBocBzh0urn7FVXLcLDLtNREV0r4Pc5+pIB5mitiGYi1CLtkHA499rUENxvq8MXngr+xrYEt6KYlAVnsJFHNvC5RnJkGy9ME074/je0LVPb40wOSP8c4CjxG7peso3hRoLFo7vcHFW55Mj9FjHrf0j/n7A8muHUHnenyBOq5kaM4jr8B2zLoL9pZl9iALTP64/IQnjJChjOuwc0dVQ0ZItLGDMdHH3E18By5A8geMO4sIVXeaQuXH/S2Rkw1tRAgn5gZmxwa6iIoZDfkRsfFZUBQI50gLjOW1Pjz0ph7ttfGeDh9A3QPZgd6fFWePqd6MEdc8qzhsbR05e+RfEEIwYuB6/xkjEX/NQY6UR+8g+cNHKLIcXrZDMo9XM1O76LnSeVELm/kli7yQlZuqAu1zLL7ohbn245aD6f40kI7L/4CWpor3c9PmTJGeMOXUm1wehCdY64ghYAfb36yWqnv8VSyNp19nQoiNMazJmZZfyMw5zZXFz0XgIluYI56rDTkxQOApCpvpanXZ+EyZzqJBb6RRlFD4Yk4UbNjL1N3gkSj4ZCOLGa77lkpk0hoPlEs2NCGWC4lcKI2PiGhxk69RlejsDZQuHa2xUT7+2h3gFm1+R6jaXdsdZzCGvmQRBgvyi/SZBohWiUJB4I/opn49iCSiKIzfBMpF3atw2T15Kag9i4C1Eebi+j0sfE8u/A9MArvjq2Ok1l9van20aUpKWkci9rM1JNvc1mtzDKS/zVbXW7mQPpU/FNHkioeHtMPfcgx/wQnxysna13M1IYuHhi8Sbt50iC3H5mUcHQM0L6PuMMndEcJzROOCxqTPUleaGy4PeCEhYMW5ksdMyCOCpMdhrRSs6yjojpqr8JZHgesgAM+rygRw1meo2m4Mq59jU4D8IvH7Ff0OsaIq3CsMYGIilRbh6kIx+Y4kuyOL6XKhqGyOLoWQy0owxoWgNjCnKV49HZSu3jAeEbHsG3A0tgIwEzdRT6cRfNNbjLo0vgRsNQc9mWisxzDxNxB8yiquUrHZ5cJkCFWYs/fACC2fbkI4M+k4JnxIX4RFudY2fLrco7h2BOI40V7jDJfgOPMYrlgucEBCIeDRC2xRHlYW/Xq0VAFmizw8IQxB0AYzyAgkYsDcnoiZd5aEUiwaIKGOUmVuLFo3xNPHcmWp3MWSY+h7/FtJSsoEZf1ooztMPfZDONMzJGpvPs8zbSnKX/rJteHzn9Ro3yMGrNGmWKiqb0qG5QdbARDBrqtLc99cyFIYnfHVIbHE/+wXyv0yxeIRRFAoLhp41AZ2F9nWX2HSnnF1AeIGJA9pnVLgA8j4WFXoJ3iviF36Sl28bybzgVHzuFrBKfcsRkqbcjxOMLBl7d5ShcsNnyNrb2wJnY4i5JmXFR5ecS2Nzv3wK1Z177zTAHQwWrZDAQZE+2zjroEURxea9slpDjC5rXdIdXqAWH5liA5dp9az9kUUdZehiVzM7OmTARYCBYrMNJyvTqliqLIfFSCsJIcvjz//tkxvB2QEiQuUBgEFQPejfVsPbAWbO+yVygQhisaj7Ww7AcNoaVY+lJNoZbrZfGkJxtY9TUeT13W6NOv92Zrp+aqnpzsunL93UyJCg1O42sUqBoQJCGI5iDJxU1RMNElhwAKLv6e4yW07RwB9EccbIDtMFzyocdIsdsqoOFGHnPopdwokBkW3GDsy5wdWCufvmdi1uYg2CrHNReBFr9Ny6h6YtnJXYvnhAtyUa5zjGzcrKslxVd7JTFqo74hloDSo6ZKenqhDteTREKIlPnMU5IJWzTM6hjsI6G991MgOtnAdIJ4an9JPgT5DoFWLPnu6jS3xk3fc9o+dnG0T6AoegsSM4llMQ+4HL2VGvR6O6Y/JmW3+cfmPEx8N94jCZVJQ6agOjjPonrdfxHZub72Y+J5TTaYCa2vmZfvPGD8b+t3BlJlHO2cwNuKXDfqDpp5iwZK1buszmNC4ONPBasq/84swlJisMsqGbZ/ENfVW2wzvajsd4S+E1dGFmhD6RffKA+WA8Zb9YQ5n+iJIPI/bgJc6jFAG5pDNa7W4FYmrn/mRMP6O6zYuAuDWHPYk19nnrMqPVlc1N0SPPrtRpRLShpNG+LSdOWC3ip/w4pro8HIS2c9z5Iv4PtF9m5PLC3Emp81+SWo0Dd/DBn87e0nf0T+1YdxD/mrgWd5K32ON70+/KMQND8bgrpuwC0ZOfpBNOH6cGW+v409+X93girY9WG/oOivht+zPemV+/6zVGh/uwlsyq9X+vvPQjD9bg/Yy/Fknrw+XCX5b+rypKDs9eHvQzH+bj7UD7/Th69j14fJ8Ntz0TDqMmn9gxxsJg4Wz6QXHmFKn+RwyhAlrqLccs2Qg4q6QyXd9IKJeZT7NJPw6cvO5+8y5+7+82/mq7hxyVsS+sBH0qOOrNlQO9fpWFU134O5/ooPfiv87ubpx3XjmJyO3V0GM49RN8aOQiW6goG7DDTOunTE2zhGTqpp+ssR+NzcRU+w1xnKrcAgGweTnUG1pKNK8BgevdvVjf+jbt0HWNfIni66o0bDZQz8R4eNd2+F3rWf/kAcy67mFj0WO0EPU+483cTVbrFJ28mF9VcYnb8IMRMd1VtU0ZEtXrrPjdt/1+Vc60tepgc/QGTNZ/6/6erQ/3Tr+8kZ7Ojfv+Lv65EuoYcGrxtOdQmSoWVPOyvxkMCubuofRdf2J+nXf3lQOscNj2k3EOfPv9Y+411tNHLzfdflBvtPDvzmXTDpg8lr+6v9g/fMWlqXljJ+ObrdgU71geXCFVR/sdPSh/vxU4lGzxZm9uk08mZK+SDUvkfw+P9Y0fzXT+Bfrxa216Hhqc7T3mXv4P0Rrpj7n47DN6V1ijQ7VnG9YWXyPvn14u826u5cf5auNf0fhJTZCpbwtDzZc7GZ0Hm6j4VwdzF4tvjdUI5Zz6g7Gv987Vv/eaoy+0dJfXTUfLj9PFmb3Qfn421KrwVP96hZXtiIvw00/RoeYZ68Y+aM4TYxN76cSRqNMfSzYqRfGMRCpi5Uw1yZr2r4x4v+Z9uKo2u0mQ5/PEBaP1LnB3GSBn8QU4uutpsrk77nrj0nyGuSvD6cOP1+oDE54iqui9MfZLhNgsuzCuYe4Q7HXsHqy4OgJvRWotIr+FeVxN8XrsOuTF/HpT8IKTcis80DGEs/3RF8dhCHQButLm+2L+pFx6tOsdJuaaqrLYfz3KXt4xqx9i4XhauJ/zt+yQk1yRwsYm3d1bYQC2QnPvRdz0ZMt+At3MOqZRZHeMXYv4VE7zk5miMtvtn7VS2vmTFV7dAwesFsu8Lsj1kbL94gfWJOnABJrOGD8dnW608ZbNdk+Ved/GfLf33uCLixa31AuGr9Ftu4wSLY992OxfSKuFO1Ec5fD9iDj2Q/3BZ/EvQ7Zsyrul6d5lnZ/Kgv1hWK3wkP+jeJfBvTdtI/whMG+d1G5cdBRFlM07KG43CEy4DF/+A34f/C91d6fqtuKdP+OGFpV51O60HUQTNX05oNBhlYzsF2zPAKRpewsHV5XwXYchs1Ln/NnGEOOnDZvPr5c7RQgxGaBteaFsT0X5tKVxCHD7Bugyk23V4NWWkQjr/xHXE0qDB0y6ZJFyxONJ5HNJdFXX4b7tNMlfQtYZ+fYbqDX5T5NMKTPdOkwQX6meKXJllojEOAPinRWg6YZq21/ATETcKfZJppw3m5BJN56Vk5GqQk/yOWW27tow5F9CAGWVyVT6V+R+8AsSO2D8B6eRha5+D/q9r63OjmVXud69POhrdLGlzVStb07eUbunA0mq6FqbUbn+I+JPMeiPX3BMucEP/zWXx9oqMvUrVXojXSVOYiq5UfBP5i680x8iQUJWF06Xax+ZqpKm1LNpheeiSqYXWg1Wg8CBPQGiSRbpDDtxyaA21cWwntAVDkFL/H8PpY/QrrxaKpEoquZpaJh0HOgAMDv06vLKvvaIYIFhhfp5ub60QbX39dKO36xftX1gN++PwhGxsdjo1oJRy/h/gfjxWiGDeCUHspGPCGleoyk1wCvUF89Qalb0AUaJ34tbFhgYmsEgMQIy5ehsg7+5Kko9rtxeP0V9JpsLD+LO1IyEgd5RFLn2qiZg4qDRP9jnMpqLB6tNJEwQa05JLg8LUwpC2tPj1PIpooesDDLTlPXgbRJ32LWdex+uM2qMMoF6G2HZPefvkmMEu9mEaOS+9+UOswOr9gS6balu75GIZqoTcy6/BNDf6HPo/0a8OmOG24HO5LK85ca8ifugitypezr/Y7wY7Z1LRD4fBAftSeCHvi72KI/dRG1KkNaN9AlbWvZoX87Cq91nRKO5orF9z3DG7HLvBaxY0RTCyvKcuYb/k2JZlnOKRZMWEK4pGLrpvyjvKfFa0s9FipNlYy2b17jS0YEsxwI/qrVKZL+FnChbB0TBbW2onW2rC4zLcQsQ1Ca+UDbLm4mAqw28b/w9y11EoTfflQHirRPYpYwOTnbiTh4oH9VKVc/Qz4NTbhxYbjyTaVoZjUsa7NX+Sen7oAbexlh9+Yfyy8Ptr+Yin2Lcus8Be7sMjx0NXl5dREJouIKikq2y0esSzn0dDaall16CoJ92R/1RaWLqy5i3HDlNfYZJ8BbeyLs8gNdqSrm4Hb02fZ7zHQCseO9+sULxsouahkmrflyRVWtaZ1/CK/rEy5ucI+vHH8eCeNNRbfN1mNw6jWoPg8DIHlYe9/b3J6OAgOCSmE+tcu74QODNIh6ipyv/Qh9ONcu9ysU5F7BYF6NfA5d6zI6YSx6VsgAwfd7c3GqtbVQuSrePGUEmms12PLrem9hruiCnK8+72rOesluN0uN9vymDjmAw+jHT5o4EcsFvplLg1KvMNx6HWlaiOZ6IhPNtkTIuCwgi8vMelbzkjNGRohJZn6QHgBoQZpEkL8Pdc8449t3dW6kZGdu3Q/bu44K1dcebvNIure1vC2RQblhDYe80UaaFkgjQvzEoZDjQIAZhDvACwkxY37kx6X8unI3ddcJe36cPIP9EHor446fM3NMBzLXhuzEO/KWa7CNAswGxyVJ7AVVBPBrjgeBWN7SMuTYmj9Pc7LtjxFXrArz2a51G6FeW2CYlQaIQ8mb9xumjSz9QPABw29aeNrWucsF3bAnHzIXzPGaXOQJ7cGOmGjDGwhjscGTYIxFYg615xpIihx47/xfzjc1bqYKwcqoQ2jbFDiM/ilDL7qgaNut2bH87CDA1PpiYL3rcgGdbN20RjCi6GhQHkVsbdkgKtoC/OTUiiHu/WOMNHYDXxLmBxbDLmwTixHmeb9YcRYS1eBsWaydQdxMIQxJFkFzECdtF+9jcCrtPzgLFGR4w9Ra5+8Hdqo5RnbtB9eyYxuB0rpvr8HkH0Mj73eiQTuD/GGyoonTpYfvdzYbp7At0c3pfYzXt8PXM7mzSVa+UC2SyWyIlDjlpnPA1JlKbgCFHl5ESX+YirDXvmjkInMb/9MOiXUWIxods1XKNktupuf836z+RLL/ikuqXq9lnxf313608tHifRvKW/H/iHsnxPZPDto108ddiWt2fsf7tGFRTBVYEN4BnTyftRjeLHWSuFURcgVJ0nH71H/tMf2i2v8imbfC75A4Ow0q/iKqxvqkZOFIpEouvNLouBacB5ll2vlsyJJCq/ojaYLKXpspcONzXPpEME0Gj2UCC/GfJd8N8XRWCdCQjbl3rLXO16YHMmvMnd92EO7zac90gtG7mOYfk3HvuwtvP5ttKnFFqi04gbrb2WJIgcYybCxR4Iyc8MH23btPFjIwQLiXrJ6+QjCA1NuKbpgXBqc0bVjmky4TkfAPbMGYA93YyMJ+t2humTtxKcD3E+eDzQLjQezpProG2ihFuMVni5hhw96KJ5N8S80Wa639EnY74qyZKz56SgLKJWlSbDEWpb3GtXXl6gLXgqln+pGUV0ZZVixlnc74nel/voSWjKHBm4qNBg1WA3zDmj5NeXdL5+G52bV1kl4ie+oapHXHpPAy/FS3rG5Rf/gAEFF4GF1hx8dLvIcf2217PHa12JvFktYpluZfa0XVvR82C2NgAs/q8xhbODmEgQpzX9UR/C4BgXMcWsQr7bgX4H8/O+CcaB0YACyK/FWBoGSjRylBPAn7oqTfxWBzv1sKiyRVr55J6IbGgWllL3SwUktvOLkXwGdf5cAUlp1kGwSQq7026W/5QBB0Zh8xck/i0D7sweQEns4NXn8AoItETtpcMPcUdWb68OeCFQ/mwOhHGMB35ASjIC0mC3Ln1hzxcm/ikDjflYiGrIPgRJ5mtnP89dWLvRXnPyzCPxd+ysdRXYPHxF1pHcb8o+MveLkX0Wgzr8bgY21b3SFLiIaNf+7qvBfR+CeM4j27pJ2OZnWVdJusNgHQcO0AS3zCM0wRmDpDeNbhqQYutoWEL879+blB8xrSnJ4Xvcs4eyG7QhBiJ7HlwjcewgVDphNk5Zlf+JIcp7JbUlfUXMy8ksU7pq4DpR0Gwp4eE+8KON1v9BqnbZCGUxxMAAC7eZEAjMH9jT0R3TiFh6X+y8ublRvUwNKYQdlWMfLmfRkvMDIC22l1t8E+VTfILmt4yc9dZy5s0CKT4q1rjhNA/ivZDqKB6HYeyop5k4ZFiKFRVfaqDWAJXsCDNTw7HaH57s29tLFO/WGQZlwZyr/RUeKWzQ+QhtpMU3Eji/UvHu0ts6YvbHkiQ40ojoVAC8UZaocOpA0VmHQkDs4z1HNHH/DAcdOIazGCnbh906tYKTTRa7emAO2hOIckZ12cU/XjDS3cMz9nik3IH+YWBlevruTWmbAlHj8ADQU4UpMCKZgsnDCnooV7WW9cmqs+Nvypt1zJdMgTNB+1lGyLLHnssHI/EyB9M4kmK7TY/xIAQsjTSr49gKSku7csVG3VXjYTKkZD4CMeFHJz48ehbBBDkkvGdaeAvfD7b1rQQ8MgTmleurdiwiGa19pRjopyHk3emm0a1fUd+Dye96d3mFBFuJVqs5lsYjeuOsEhZp+Rt3SNDBIjBpmLOcXAbB9qumuDnCaPXCPCvsg5dTlrQbgLY8J1m8E53zjk67p61QcLeYsma48TQ2GmQth5MY6hHt475I/YjSTp+JFrsAIdWYR6XEoaoaqr41LRZH7pSMbyceTrE5ztUAnt8ueq3ElAhX3XdDmMv3+75JApWcWL8+0o2gJJeoY6k7faYO/XPeITcrOyUDmPj+LXAvnvyhp983FVNZ6wlfffuB9i6GwbAUHSH18kEQVJQ03Nv3t78IWTf6tGuHlE3zmBxazJJkKK2o9qnf5h+BrS2ktb2scx7spUm7ybM8c7FZyf8ImVZkZMw1u2yUIhUJaeu4hlvQrBbwhI1lzSRacq4Rcpua41DXdV7wxb4id0KFw6H/LBMXdI5snPV9ryC3KJBWR50MqcS2iekMixJIuNJzaRCWI22t6zuwQSIn+mtP+QiFTuhDHVW/YEM/M1NjRfnyzxGBS58kt0ROpILGmClnUntbq1E60EVUYwV3cUsFT80NVXWOuSDrzQtb6nfCYT/xDxIRuK7AMaK3cfYydMlyM27o+0l1J04/7KzwVwYKtvOobqXTIjSQwMppvkyZj/przz5Zw9DyQcavICtcXRtpVmQvFt7mf4Ae4XUsQ88AOo7B0tlpGQKoYGt7pm4AcfmnqXtLFfmsxjpRqTaJ1326ZPZdVdR1Wz01Aqzrg9w534wLzLI0Ku7TUMw3Wk4fyH/CLBtsec7VOfyH+o0n9CpWHH2RF2a8oy+K7izbh0Jbmm5b1baZNbLy2umo7ZYUCtCCYGm5F9yWkOPw+TJa7RJsvJ4KTqf2MHvikYlSKtZUe9PuxGxCIYb2I6O4TJ26t2u6NH0/0myWdGzgirBFivKUFbRIUGN4lvKD44Ej2MaA8Qv8QdtA48Kdngp8vUpC+nMNOjp8ga+6Wb7bLYRvlzHiNwxuZRJLrk0UkJWhu4pbX15HZPSiDdQF7H/rrpI4IVTjDwyvaI6qr8rXlPplVVcNAj5bh4xVWS7vsR1FVqr7QRZoLzR2DXBKj+xEgaUblVgIZY39Ou9xYYvUSCpM91qCk4K90dK4um6FyvCcuJK/zCd6wQNXBu7A5zJhyQbTnLepj6r8acPv8Q93tPOl7nm4Hnej9tUI6NwEFYtZSXeIMcKT/NxoViMxUWmPyY4+0mlzeFbUURBHLyMm2dc2DRqqpn7A00z127KO2tJsk717D/8l8zBYcG3ZzbmPtHTeklXWskMdPLv7LgBdHtP360Zaz2QCp0676Ab27IT+pZldEnRlR+n/61fk5tMFH3545Vha1utqqv8IK7AgIf5dU/kiBNz/ZWGrzZDlr/JPTit7xrb6g4N5RT36cT+AjRILw/+CpZvoBGtjBxypBGv9PSPZZfDsq3mzwVFfVOYtiKU41YMU5iqWic3PAkDraGGl8dk5C4C3VWkEU3VFpU2NYAMNKpNLfi+QuB+UQ4/fYIMRjamV27THqucmEKBqlgAynQWMn4bce0vHgMTrDJTW32kaus4Cv4FpsyTBStwibKFhWAoSLLyAJPFHsfvvFLgQB7RTOw1wdQNIeZ8UACWZHgdUoJHEDXQUP3Xrtsa4PCBggVbAVLa8jKfLxDCwzQWTB6Thh7hUYFyV+5zai8Wt2WMkc7KfsBuo2V+se0SsWRtDMgxn5oiC4J3r/pKXdZsSEvicSX7IswFr/qurUnYR7Vsb82x+L/ESM3h9+AwaCQQxfEzf6YCetQ9iCa4fK5tep/tbYWcNC3vhNlLuZBBA1VDTdeenrBGiRJsjSAmbElVbH/9snHVjbaRm7esV50GgOGTlo2JNbP9qMRci7txZuIFiVCrXhS7yD61Tq5Nf0RtkdjB21Bk7KiE9T5Gq4MguAZLFAxMW67/ZV+UmLGX2Ww5rwXzU1140VltNCHnkSPMsNxw4VE8ZiOo3yA2vvYdwHkUENHQzui/Kz284O0KWzyn9NuvH5mAJcWvt/GmhzUOHeQMe+tB2lwJc2svRQc3bq6EpzotkEQLIaKLgSNVk0+zGqON5OoO5e2omUgD7CrRVJCY0pELTUCzD1NGtZMrd7uNSc9RyGADy3UQhcBFJpN2z5TWCXFtq3is7NYeda4ix4dHFwvHSaac9HD1woIsxExVcM/4mWcdAITa4Fvkc2OKSDJW/D21C7dnZIkjf85KJH0lS9qiQ5dhlJOIYkDtOXz5afakRiZqqPCk8DdkxB2xj0edD4wX7ne7SQtDk4WP15Hy/2YPbORbWj1KhmtZBNxMtZv7ZSbVmgBs5UVJd0Mgfk6/CBj7WNh4Odx17gW8zljjrxrun62hLF48mvd41TC2bI1L9uDliLlM400rMIWugeDxDo0YzpKkL3zFMTOOEKEoIsUzIme1kN3HdDj99xq0fJJdQpND6Ry5pkMrRFHChJiazuBLgU9lkK1RIIXQvXJWK4u3svaqYH3ElRHakUbhoj+V7W3Sv01NAze5O+x8JZhYPHhbBdhuTdU4uU2hz2jPVIvAlrAdP3gA+OV4kzmSMWzYiZYRQVgac2vbopi5R3tLQ0JSIy1CEShiv2VR69VgttGxeiEvj5HoBJmyDYxcZI154+AGmHn4oA3BtWQ0kPFxasjaYIJs7+ipOzWt8HNClDnvx8P9eMdA0ZXRFEdl0ZYhUl0a2IhbelaTBv+Pg7/Cf2IiO55Iv0ALCGPzS0rUdapP0y9pT/YDTEilWqCvg6cxtCFSnGWbJ/SvWBxGovUVeNnkWZH4FrpaYaxq+Qml8aYd26SqVtvug2WwcgGYGlLcUHdQ6VC8cIODSgiBnPwgWj8AjB/PLQjmylyKtETWZIjHQC1HhRACG07Oq82sP9T99DtTXqmGWFWf/LWOqdQZXM166kXiKmUgSVzizFHzh7122OrhmHRi/4FJyXKOdK9REE5q3PwfoJVrcVIrN2irHJ+Y3vzb+qqX4c0dzYAPinzdVUu5O+h5ykD8pdm/WwXnfK0uJELpdFXnuqjlkRz1JLENna/VieKQzRbZF5hzofIrIYOLS/FGTog7htyo2m/ALbHbuuwdascUdAZ5fnK69k5PG2nWF8RWN6B2lT8XuMu481POvbuaHrNhbDhhp2czVKywErLVpnvsorajlOeMoxkDxE4OykKEw7EHTqj+m8aoSKX5Q/tVOvFJNH9TdzaoMTPK6pXxIw7ljArP0RKSxF+YZE2UU/987KyUruDNgDBrlgWd6+jZbemDJ6Ale1QqqnStaTwtR2ndppTO3IRCWjZpzJnYLNBQYjB2tZVEPLW1vACrykkRQ80iMwFR5/hi0yNgApw/QWZ3CTYUwMZC+IAUBmwBMW33aajJL8NRsb54+tjeN6K1b+CUt5CAb/4pG8wTLTRuAUplZ9FkWmtLXgKLMvglmiqnxFLoo9x210PBKKkfdaz0OHEZX7m3uyrwmpNaitt8Fh0+S8gdDPcX6xCbdb06jU5ujuOOQvWvmdnKQMWTGyxvXc/E5K3/kHELO53wIb9imej40OicnlHaqiYYT+4U9jPBY4xqfv0VHT4ViFMjFu8MHQ83LCqZxPW4225iYpLXthUR737ehu6wrHmEqQtrn3wUZkjW6vNTjKa+rHx5aC+kXB2TVexKaHk7rmtVxSVlyP957Kj/QuNxv6Rzso09GbrwkhZ46Wr/XaWLFyeTkBKPRB+LUeOaIvlzhe8Jil4MFSxaCOgbLcYBzlt4koQZQwCzQH7dE9ni2nJk/knt4cQuvl87DWNREmw348YaaoHthuqROXTBc8VpaiIm0z8fLU9W4Mt1mb79nlHMPqWLXKK9HjnTUEYWFoVRyU3eQuJ/A+FUTHleq/8FYgqJcEVwiOK3Y4jm0Q4jLL1i42d4a7c+hqvG6zuG3fOOYlPFWJ+H68g66QToOcsAua6RbANo9e2ywXqfIdx4jlgFE5P2jJarsDs2OMVeZH7g/rJSBv3CTpCeRzKjIjG93MLY0gKBrPmBeMHgjCUcyc9N/exZuELHbPLrBM4/8xVBm3qKTzXFWeJDt00LB9CUA3l7cwtnJW3k/+CbaRTVh2/I7n4uKSrLo+nPJDa9RZq6CLDPtr3iTvkGT+ySL6fFbmiseT0/fssY091rLbsJZCh1+ZwoELTTVZ8eI3r6fvrqUnz5Zn18iHMjiTBcKD2JFHHnHLZ8VIfGl5Vx3+pPyqfD+EXdxZ0zy+5DbWJ55XcevSbPa7l5/jXrRGTYBSP5ahxKwCmeQWyLy2WJCGYSuxfKNazerQXNnrl8woVvOci//9y3rhSXsfrF/T/C3rW51/Wzkco4OBxT0okkDh4zITE5kCHCfiVB+GLwGjIDiu+pGgMWSQaQBVXFp3eUDzSGMEdsaLurdjAo2Ey+ByQDtU974Uo5LwNeIIRVYDntHhSSER4AmuCIYuueWPwS3A3YH2p5m0XQBqHGuRdbf06hnnLJnfR1t24bezOfZhQNJagnqxyADVFvpbcNxSy+r13XsfARemQDyEusvvMlgnZagtcei49yWphSxexCSosyXENDdpeOPRFFieGo3d9DlY6XEC7VNeOY6WeLQEloWYMIMHBhJVJNRZkwuPV6d57bJKPBKBjsBLS5Er4vJdl2HcA2j8ms37LJjKsP6zmiwWmzqCtjVjBmc8rEY133tp+XK4Gop/BScN8Wf3PmXKkDrnCQkNBHqWhECgwhUn/ywCf1eRJQagbKKEHPmb+BMJSHXFyb+KQB9/Vq8RNyWJNxK/PCFBcpB1Vw78ZxHows/Osp5qz55wD0eEGbh4gR/dFSf/LAJ/1xoSK23fSESOgWcYkObmryr8zyLQxp+99mE7IWQ2kstwYNG0Ms9vnYOuDydGoHa/u5Yhhi7ypsdlmCx+Aeu8tjH/LALBCP3VCKR/m4QcbsumegLiD/MVJ//RjXBrfa2TvXA5JzegVrS3oqjOdT2KgfZLa15IY7autEzomaDU9tlmp5qkCVRiKQ+afEXAGhKYF895Jbe6SB68p7pCblQg10Q/woMvyytQhLrc5k7FTLnKJe4xsMiZuEHMTwRWUu8opdKHtdDGHOGQAOYeKQStWgZC7LRVR3KzxpWvcY5zrk4vccBz7QAw6xwvs7lzhRFHuWVNLWXK/mEPoxfOcPmdJSKgCSl50jCCvX3o9GyGr4JoFOMXRPhkkHdqXARbwfkQ6m4gf5qLES4GEmonyNs9UirxKmQnz7GmwfV0Z3KpjnYnYQNH38xYauRzQ2ntBnlPt52L50gRDyvaDJnkjJqbqgyiOAMLdbV5mSVKdYRKRItvkX1fLVv5HZUsVskUS/ED8QRrITHo9PIttt1qCagNX9VYFinf6aflAzqu+zjswsxeDCm4DrQ8CxuCU9h6YTLR2NSIK1A2e6pXvjLO2QyhRHk4O9JPl46jKZF1c0CSvrzkIpNEbINOp1O5Bj0Oya/DeYxwJN3TUWqSwWJdFkQfT0onpUB22IFHd7lZnp9rKGIAXYvbKLa+5n5R8z2ptQVNkyCNQ/P8JnySWFoSLdmIxrcBOgcdzhuLY4MPR9XzmRtlgPQOxnEyVxydS6yvspeN66s7T8CPVS2MXzX8xnvRfPrgcp9IZ6BpQe5Cyn4Ue0gtKaU8kmN57zKjBVTekZW00Vc4neuGAV1l/twbkUTI4jnRftA5rbd5SPUBOy6F7yO9Mw7j0iCDOJpFcLX+lZHHx/93ekN5zqT7EkHv0Nkczs3xap5PDR96T1DqKY8z8JoTb+7iSi3uEl1D7BNLGnGgZ8suAh9PUl4XDVbi1tpSJuqi0TsT4ZCQ0tVY/0VSmlnPPdFoXy0WX/zBnFp06Inpodf3Q2mLddN5zz689fLs5iSJVn14uALsZLKvrIgiZVhsD7aG+nJDqNhu3Vwd5Sl0Z3Y7cWWMepraZUY0FuWP0xC/tm9D2zPEKmtu0oMFdbjNCdbpcO2tT+Y4y/iel9WhWTLWOuVgbncPc3t5gy0Veu1zYvF2uaXBWBRL8sCI7GNhXMtMUek1jTsJrB9E/Jninr4f8qamuXRZzP+Fwp6h35KRE8TGRYHvs+bqYHwzxZrS9K3AR0I12lcavBgprKXxRP+Mtk1pDCVsLcd73x41sqsbPxdV394IiZVn3o9uUY527s6X2bvPu6Tar5kmVU79IE0dYtr4MFtq4g2bnSXE12pyzJSevjP/edt1x2sNcGpRo3eFXLOcNLqmZ5qqm6hlAd1QUek26NF1T9sduqpYRNGUMFD+IoiSMOtbmwMSlg9Ae4RlvDPJk7St7+/E+Wb2XNGsv+LnxA8b1rI73NjMek47Br1L69FwPizderj8jJk5BBwkzq+IO5VB1vfh/lbdkpi97FLTfE8KOvRfcnkdw+drgdxPL6ikOclBxxkBhLTMZfvOtGsvcvO+uLinTwLJ+HwtBE5twXmzxTxErzasdXjoH+Say1uW2VGJchTyU1Y9ez3g2aYOgTLCiYa6UdTNjxgf28PiWJypMQtElBMVCDwPTMR8oCA5fH4WSNQOCImzVwid2T2FaiLXXSeflBNnhtrYCp9hQ+6WA/7OYFJBTOcd/aVyX0UM1lS95Ud71RqspCpEwLkR+4tObLKTupC15+Yj24cp9wCTzeOB14V+8+3OKrpeY6orotoDkMRu80ZvoWHFsFxr2P6X9rzdetso4HXzpVLU6l++YIoGH65e/FRgLUZtCttHhoFdN9O2Xr20uxuq6hHtYC0l8CBQR8sQczR4GxmObb4uA9quIt7yzRzrr+H0cgXRiUHUPMKA1Xg4aT2cwELFs67vd+1z28YnvT20Jvp4EANOU5iqCjpWMsZ2ol+Z77eZEdG/MEnCpLL9VcTOFd/vb1Ve7wrixo21xcpgTWV9dZj6hA/fkJfMRGP8rO2vXPc8S+OxUAxjP1tvX3Xtf0iV/+/Pgqtt/OOnvEQ8bDjM6IM7p+u88ncgzLf9+7pk6nQ7P4Tbgz8bHfUzD037jDtpXm1T52m8C/fA+99OhAGeLynf4FoIHVOsDE30dHM3ZBDo/wvfpiPvoDRwWH5CajNWT+kEvI2l/KYuFdVjkZZo+6qz5q9hLYz7N36Z8Y9S/sEwUaILDfBpZIv5XvR02ZKm7NX3OBUdk7qwbvWDnLjRwV4pVwIIaLdb3dgTbSxDbVwwaWmBhv/IFueEL7tJK8sAOJKDrMTlqRNkeKTHX3r9agnbBF9OKXwJFJcV5bg8LDnLQ3tPx1lgRKH2jPByCBTwzyMvy6nEjwPNN2AjmnAECFRthqQS9H7DHEjK+u8h1emD0VL+zbfI3L5Z4ulKnpR7yhwGWLi7mkO958DYTx5e4P6yJW9NtVXVhs/PoX7hlFCvPm3O6yZXa/KMHrYYNBVt6zE1YCLu/yHiwQWEVd9zl9H6mO+l9nkjhIyqqgDi0yqrSO0nd56a9Fw8gJPNEfkp5lbXVFl2DULB5EmNs5mde7kt4zQeU26YNzsI26+nQhwQm27B4GiJEt6S6fo2vMOmPEKF+kviJqmDYaM2ZnQshcQ90ZAWN5904D0gxsGej1KHqCDcOYHFcYWl6sM7msS+GK10ywIbRjbasebIu4+L8/BDVDoZLxbYo/MpzPhMN3BZB4reoRvgvUtfU6Z8PJZjslrPz7wweFbAUhAS1WNDICVtznMiBVo/CHJW4RFSoH21SPxTsZ8X+9IBlfYhWhGEKLFTshO6H+7Txf2aEN6nCS6mhofy6GRy6Y68gu0P0Aloq1zpji2lHh2tzIPhJRiOiyZayOOyy0Lyg8EGYtvZBDp4pocAMFnlRUK1Cha2AsyyeQ5DkEz+nnbnmB4w7Fq2a1VsTY+vxr+TmYeJxtAiWHCWKFS+H1crYF822Khelvtq9sTvOSA6tEca2jxaRpn1zkk941Fqpcfv2Ld/R/uJuOgYPZfD1E9CrWokondfYy2N65JMss5XG/ei4WfRhBEvmHeEIDqzLwnBcGxcy3oDLlnHM1WdX91t0r76FoU/7pv8hECuPQ3QbedsEkEgs6Ab8tR2zmqmfbZtaLq+kktuS8Br+woIvq9d1uEgB8tOYSNmptolF77HqsvEY6LjG2bpEPXFHo2yR4Ziv/SvnhPY9xTECb5KnIjMDfRZSVkSZRqC+g0Vsxz+LohhYpKjXV0m29evN5qEzU9p4WjDg5KmsSwtQxs9iRNkcNCXG34svR/KKWF42EGB3aZ9QJOG/korOCZZC2cxj0dxMLpAnwiWygulgdGb5iI5fckd5oxdyOoHb4NJ9+KJ0ou6Zf37q+CL1YD9mvTlj70TaUMAx96asfmjXM4rUUpHYBwqGMucXfjXKCiyS2ooKUVInZ2wTW9o8fW0bjcaofzsxf21jHNJl99jq2XMQa/gdcNoU1NxjpRQs1Q28R1/9KZRM6QOkKBWqoUlI80sNF9grqmZS/538oJtC1TMdzJD5g6U3C56nSQ1UF7wjBvGx9hS3M+xaWFN0ccw6ydnuNWfhLxjIRns9+BWdMoHuy61pVISuZDOVQMcHZSfRJ84X9cwmqwCrjQt1w1RYGu4q5FHkGRBGRimjjhddFWvspBts5RRbRfg28bHbMEO/KD6NHQ/dshSxpi3dBij3Gz39DVYOn2w6zbrq5GhkJJp6hIQAZWUMbV1sdxCOZ5Y5eZad00gyIq6KD9D06iIMG+oKDFbZWEd2SchZJXty+v7FVLJaX4tW/Aq3LUyW1s2ETs96EOQ0tfQ5LRxB5OX3hjZ6KzM2zZnLq6YpzbphrtooCjIMxPof66HEmLBhfhGUCUDCEO/KFBgyH6WenQ7b/nkuLE25O1So8SzEmWsRCnSjJYL45oHuCipUhd50kd1tARh6gTVXAuxcI94jdUz2qgS3pE/LhvRtX1wBYDka/LMsf7YKr+BsDU8LRlqGOPXcnmdyzMCC+H7L+xJnj6odSQyuKlWJEBw2FNTNsT62ly/4NRa1RV11EOZHqRGUCrvfx+g+5031Cdw77HKndUl24v8dn34G87Wx4Nb+CIvUG2PXXbN1mVX6G5GV30unae1/dGeW7J4CQnzVSaHx39qLDGNad1TnRVNZH17kEh9cj5sHJa4XuRrE1d/Vmpb2jpcV8+D+GLoDWtkl3M7riIxfE9qMwfPunYNwfbcdFuCjxwX1JZy7nPh6hgVEObikEZN/1pPiXnUPOTK3diDroYbfduwZ5ndnrberS9Opd8pryuUFp8F1g6BA3DTwgjWsRREGHNhUQIcrbWP4xxgkW070QdBvyPtuO/RhrP+2IJSrTFantOS5a/iHIO/gohc7ZfNsOjxRL1KGFgqu7v7vlq/fGEjTRJUTDfc8wlietHbIXv2fit/SJna1nyL3+MSbOPJURJ4HPU3WSrbObhq5hdImIyqkhXNyD216vQ04V27OQ5se40eEkieDIJArfbEXafH68T7T/l/oLCcwkYBeygsslj2ciqpyALiZBbl7riH21YGtotwe9M/8n36kd6bSnCvlxIuvuhVwrh0cufePbz+npW1+y8T3Jx8AMjVS67zQ17oUjemb/sslwb2pXrfyC6pu3L3ejTQ2L3niX34nAz9++w2cohKUH0Pol/5g1EZNxQAZG2tVVsQNWrIpKpSIpGIDbLlxlHzsAYqFx7XilNX7rtmDGiigyoISntLr/ZMup03YI5DIXl4M2W86lLpgLqMi05JovEX1umJHhQpdTJKIP2lG/HMnwTGJulnquFumrL56En0X1VXvTcfrhXE5+ker8BW8aOqNxONX7MYv4MuAJ31yw1lSeHA6UWwHbkMsNhZgfQI/0Aky7mVifWR9wYL0BuJKsDEJFJvcaUxykCNHqdFJGHq/uAEpIVEYEhHdvDhdELO1XUxEbhLezuHW0pPCdPZkuUHdenMZ8AtycArhEVBOyRrHIVAxyh/5L3YcZcEbgXuh+9Z8wpqQNLIr6r8nJ30RChm535bOEGDsxINwC2mjIclLBFPqYQFMKCAXc5dY6xP5G9bbLLg3kPJQxwkM2moWFiAqaxI0TMk7EYyOk2m1w/6QQevKsy5iCstfx1JGHs7RQSGoQfGtIzLpaWNwIbiIo+DkuK3A5QNMDy4aeIHzwmhJgSevlz5n4Q/LiHqPAnIpaPBVymqPqYd0XjH41I/qwWbYeztQZ8CacvffDYcHB3eT6hdgmnl83VV+ssP4yLne4QSzlc999ysG2QcylEAm+UJrWOuKrOCDu4KmX8VjDqEn6WWkZSK3g22v6B8QicFhFX8OWVUDLukK2T+VTBix/mrwQhhYK/I1tKQd6VfUAUe48/CFYz/NhjN76rkcnLE4hBZEBx9TJTgiZGNb+nFdRSMeX3YE4zqh8s0x1BHUGJWMsoCsJuqNIV/62d8fTgvErP52UBMCZprkMeArp7CLyMWa2VmifGW9RUq/yoIk//ZdU4M3CuX/4F1CSOypD8o86RbVFeg/KsQBKLnR0MwKGj34QZsoS8CudBAVSh9C1cl/usI3HNYcTgHXdSLkwcjXAlB7QLnmcKnDTIzQDoSWwJPTmtjEuOoh7GyIR48UIG7FQE1WI5BTjdY7PMH0ZBABNh0Fm9Hi5cohleJ0FZT/jBlVAugoSNJRXrOrMFgPXbF0anK+i51zpUN+GXTUCUAfVRsBJvZ3xp7MQJcM9LOtJ+EZFXYT26Snv3X0CTSbpFki76a++Fs2KHusP0Qn5KGqmsRpNN87XTeX2npXLbjwN6DJJAGADRZgXXF7oOGDSPEHAku6GkJsotcfmeiwz5Z7LgBxYXhHIHlmQCBRXALIRt/kx1SUCih3LRfDJSs8WpLZCU3gt4AophjGoLCcUXWmQWP2BXASDKN6yMJ007kPBuVDPMwiPEUJ9eNRYYgiByWKxVrjzVaTS4ZWIVkKBWSaF2MszVUtWx19xQh9MyzYQiLxFBmUnWe6ljNmGaHFpDxl+jiuWMDKc1Y3WmSDcGeyCNAudUwR3o1Nn0tF5XsVLKIjd2XysRJaf02stDZKGKJA1NPasgQWwUUNaTwNe9+nlQO2ksahBNC2pPpL5Vw1qTRmHhFz6leF2J6Jqi2+ND7DPCVkgea6jiE7ig6W97Qkr4kd+lYxczn4ocGB65lOf3QmfFKsqCjbZe9twgqOAEyK5WOO0g7LtK0O3g/OqTLfvj8BtwiiJyhYsz9ELTWjdDkpgIhP6x4+9D30HobPXfUEIeVKIoz3aEtPBALAuTYIBkSWGErdcD2Z+ueyO3V7NF0Ve7KUafmKE5lpVS1Sc0tFnd+4K3GsRUavKSR4yhM/hlziejjXImJJplFDD8+pC+7pEBAYEbvYu6UH1s2/c6PYFStTpfux7lTnni+aHZGgcYNIsDnurs0EkNUSzJqOQPE0/JFrVDaT7QAJBFC5xw3MNfU2rTtVnyJyOKSEb34q7eFGKskcacNsT7wVCZ9r7+IHfYdHFMKNwRdK+GgKOpWqae8340+2EocNpu6t+jaf3ZLADubzDeZ1WpEuLV8ABUgxKC0kb6pmeT8Xu79sDLIl2fjH+B8e+GbVyd9lnTWOlwfxNlif23UyOl9sFLmhsHoUcRkeE5R456luC75K9mLwH9qu0XBdJcrtRUJqo1izYOze63rHmSNQWLAeeJURgnaJwH8Aq/JRYKj/4jz94Klpuk+9u6q1TnleqtHtm5puaDBFlsFNPpVJhuyVkpX2jp1O5WwZgSVrwVDsP3HfkM5GcBxrIWoKjS4zECClmK2Xlf92WmpAYrskxBB1hPXl7rLDW3pzQplX41metHfvMyLnic+9IQ79IiNuc4z51KwTDcmCYyMoPqKSg92wY5Cs5j31ShzT5ijBgHPfYIz020IdDWmKJncpNT1UN6s+Epa0mIHa7XyVT6IadZQDneUwMuh/ew1Vi8yEaExMATGEzGOJf0Nj73C+btTjv6YBggNZbq0WQrCWbqH9PJrOTV66jMHXq+X/CXS3ZhPNRWZ/Du5gOGSrK8V1sm6Q3L2T9Q+c9RUT/wYFkVZTw1cB8byIh6MUNQPq0tJOfMJixp9EUtNdFeZppKI1LgYoGIDgcsRWj9bXmrXSoaxNe7EkduR1gmWLw87DB8vvNTfzIHDb/SOodBtqe4dNEXNG8CZHTrq662sphfqJy7RQ9uVfxfV/EeUOt8RVVCVLbURF15NpJyoebdlaFfIWlakmk4jZojgvSsuszTvnBJ8bcmzHAeX3Zm4N9ejourGyFjwalmodmTDlKTOaGKbrr3Dqe284F9gSF06mUxnQF9v04NjNQy0uaDItaSKo3bbLDnxcdup7WyCOF2kJBYALleXHBwGTK97Vk6MQJgq/iQYOfHQjBejK545IBqD6bDCHSNiuArlqX0XO1+b+i5yuBcOeSc+7LbaLScKNlO039pIsDNhJrociIR3Tl3aGOfB3KEvLWCoUWcXPWTowXFibHy8Nla4HR2YierKVqcShlwPl6DGhkynscEqCSnb3jr3lQF0YoBj8VTjFlOT6bjOIlspjX0TmrNjExYIYte29fJB9z2W4znT5rqS6O3apNq2vi6G52rIMwhw36XGpK/S/ivIlKsmpvAJcP1NRh9jDr2A5CoWDwkKZAqxZ8rjsgw4L8abS/dq7dgv6A81AO80KsxV+c5FGNMYUk4oYkQxQB5GoB+mfxTLwTG0t8stw+i8Wo+9QFUIhAGAhbBweUoWHKg5pfH2gH/m1FEM2i3LtzxmLuHezFFZL8D6qUfBTlXZaDu03xjhUu6tlB6ub4mBadRna9HW5Wsr9mKDpcG6Mwuu7yAG5W5Cpgm9GRpCtWfpfhXBUxuq/2mif1yr54Yd8sBPnO/szR0rmzZfQfhnk+Or7nt9MOpw+vPFpNL4JOul6truo70KjK7xSey9DegpkvSd3KzNv32G1K7UhJBAd1EiN4uzHQhe2I5il2X/T0hJaIXvkSjm0o4l8Hly4DdsI/xc8Y9gKJQLcCqmXNy18GuMwpncn8DRtIzOvjSqwcORsUw3KnJBAi/O94q0d8RXZb5mu2GOGRptWfVmS6MAsQ4Qq2+h5EwtFALeKqwpQQYULqCgnx1a8XgzsrGPzYYcvVPi41uZFH0vb0++NduOmbhG028ViC2lYGheAieU9AXLOOxRGiJIO5qfoeH3gHXYyEEzGVkLR07AHluVCH1jCLaIA6slLdHPTQnZfM+YcDBs1h1I2MKJ79wjGHFzvtGJd2Uc1zlc7RxDNxaz40m6wAObe0ADE1cOrsTifRFOndBInWzTjobaOTP87DklaMAycVoz/sMas6fviv5rWBjah2MZZ23Ft7gzE1almynz3GocevxEAlcCGGnpMkQiiHh5Ib8QtAfyuUgBdEacoLuvxnZ6DI0MkchI9JnbBWPbIQaSEApwmnad1J5Qd0qzayr1e6ACgcgo1chFnDG1JRpVr4/sTrlXZ+7hZGji9wyNxoVj6uU2rckGGkgQl8t7mTwbBVolwDIB6i9gTswtBRIaLBi/oUKV14kLsEvlTbWWYv1BGR4JqZuvy6ckyu/bgNsgBBJKi4Zoqn+OXsbgy7lCN0gx+cnElmLfihmR+yd2z8IuAj8I4RbLV5dU5TNJOyTvlIDPYCV6OkoEWmdC8TOK1TgSGk0CRIax/tC5PbsI+z0CDcYddEy1eaMBKv+0pWGxvOwT3MQ2aGq89gS8Q1UoIMcIDZTeIXiMjFW7t7W3EsKDywRlWR6ITRLE8u0pX8Z2/g226qXP9SUumH8sPOMTV69aN6yehyaxTWiMIB5ilVAnYpeEKRnXQd3dlm+6fJNIT20/F3gvnON94Qfoa6yaj+I51w9oaAFHPCW7kql2BL7ysfGkKA/VyhHM5jRNVTVtMcVC1bw3lXIdPNrfQ3Q7pkRBxkyEt1gN0GCtsLgs+YoOJKk5OwX0/sAtZIRLB76oBag6GRkGc+uXREY41tvodek2bDmgDcV/X2EuTS11tKk32PoL8eMt/xNoQoiGBn8FG6KbNFBse+6i5AlZq72XFmos460ZbjYlHRg55fp0/8/hUZ1UZGnTCumsn3IwWbW2MDeoQ+uHwo7S4+z3wKAOZpF1c+uXYeYzl7fFZ3k1gg1E9od1cfsiPTe0NWilz2a99Oury1ZdYn9pLGzE2A0gTK9IUV1o623K26W/Udrzr6FaHfTxWW9sNBODkg8aVTxOphh1Izm3CsuVzJLqSE275JvpVzVe6n0z+ravwrNj0BPh5/BY1sqQVkBbNdsShKXtswbNBqTikiUzevhSc1oo+IwpyUNHHDNX+cTcf/aQVN3cXuZi4f2YZcwDETi7J5ugbfiMfrVrOIpMSeZr/Bzd2a7xmh0QMNs3rIIDs8xcJyTrHH0TRVTPr7WSkFj1oJJJWl7gJ7ilj95MoWoRYSypJN5k1vedjtJRbpEyjEiRntks9aAiTKr1AH5OsWNY3wSrvyYUTD42Zbu0npmAdeSk7bkicdzhWX8zfm5nQ3E4aKxkzNHgmXvO1OwnNH+dybXD5kSh6S6flilGCA9OzuAsavmJTpBrv0CLXRoZS7Nnze0ejDfRJcOnk7J30sOwC0+AKXEphPVxifQ+lGGByA4ILgUoeqWFMg0BE6yKo8rBKwnNmL9o3D54bIh2vThru2I5GrGFkTlrJpqpwGOpwFMhq7rum2O/XvPdvRHr7SpQiZrS+Bha//PEgrut+0JAVwMxaVEB8gwLMihBNbl7PsgdYlvkI4KCAtS+pZrQxvUYSWpoYM2+w5kzp8nxe0CR1h/DPfig13U9ApAYyMDFJsQhN+DMqWaDOCquxpB0IO/MwyBJmExgfe8GJVS5Cmn6PgDbVYpIYo5zlMTUz5CHvg0HDjs5A8ED6IRHyvPGjNusgscY2CQBUuE2iNmTKzlHYWMD7kr5tJhk7WxkD+09Tq4uR3pCZZKeul1tBvtEv76R3wnS2e/pp+2xFiaYjVbE1RaEV6VJtVzo4XIss+xJYp23jeyEDBVLeSDnXLMsAs0znZw+XSNjaIV3H/5zOHNDrUmhz0JubHUXlCaudgEYKB8c++LG/kXG0ZaKzyU/OUgbUEUgSMOm8lxkhGh/pyj5VWiRNkarcFf11rhYnTxj8i24ieJkXfrJ3i9xUyN6RxqhIndMTcAECZKoSzWetstRu0k7hxsRvwTCdIoiiOWJvcvgb7TDQvmTBP9nabGCxemjLYeyUmxoHAjeuY0IOS7eCTv4addg/i8j/h99zX82o5h0kNxdGir9PfRuqw4uEp1bFy/tEsYyTEmK1u7ELuBgiUMmybJzgsw4KnmF7aKBf0p5UHBCqBCPnWBpd0nNpfI8juYZ8qvogIHWKyUMStAQsQQG0JdUilUgztLAKBtDZRwIXG4LVPT53hMviXErRBzxE51ZMpxXVHkgKy7C5Ch5NGdUHS8ZNlKhAptKr2Cy4R0gAgpnUofXg18oKKMEh/MqgGalZQVUSOOm52mbrecaqmxxlP2W3XU6dvVIG2IR4gOAER2jfECX7qnB5tzcuo+NvVHijQKvvwimRhIDFMfhC52M0BTRBKXa10gowW/HYBERuUhKz6bI1OWgeFnPKI84g2GVoFKQTZKOlGFx964dPPNTTAAhD+KbgeFPkq/1ysgmA68KvTkmhmY6Y/WLTf6wTnL2e9BA3h8rLCmodRQF2j2WFFV+sCMlU9HDqJfY+/vERz0vgD6Bq0AUOYRL0nxYK1HkKBEALz8rZs+aokkGHZMX9YhA2MgL/EZqS8PgAYqFKFMiQiTjVNItWkqiw4PycgxELaTscErBdtJG28fWFDDyIbFiYkxwT2DyrmkYppd2rvrZ9D2wn2O2xmFNXzCylFn2xlMR2sa4UfDDPvzOLq15/0R3mxMJaRsiLDeRQaDepWKoa6kSqTZ2ci+05wAKi1hfYc1JlFj7emwosZdw8Y492a+Jem7GSyF9DSvjWI4xbx9Yf/7C7JFH0w8YgZ2vo0WnW7/l1q15c0YPFM3QolLbweADcpaLr48byZ5zd9rg7fc03+lgAdxYLJHczGWQ3QFqF0wR0c9yVMs8jbX0xBs79wRIU8AGeCLVXi6YOlcbYqeR0hJ083a5kruNtE+j/AlkJzT7K5MXjzpMVEBCpx4GXWxghz4SWuzvOZweQ5Ft/Axyx0P6DN9ce7OTd9PITY+ti6PyW8dqRH0IKwAy+iXxCRKj592LX4arhUIYuO4CIllApOiG0dUM/yayHIs0LcyE4TeBiBjhNLf+toOZFBGxQJZ8S1nS+uDmUm8IQmJ96NqFPfLyMKeiIf2DlYMXL6Ka60sd+94x1fjAcZbSDuLMJDpVghOyT22ZWmHhuC4ixyDoJZL2of2BZoXLbx5W8ReY5syd1q4fV6iAx9/24Nn197BrTu5rO63qzD3bCDEdQMurJsXWzfR8oxIWKC336QGLrqFYmTYipRbhOOP6m9kS1A3D/AxyhIp7ScmPAfU1U9KdyFKOP71qLyklcqQPXA9F0CEwH6WpmDRMqJYYRu1qXc2CF6AbgGledZjFb6FCS+gYlnf8TDuio2w7AxFlpJN4AHsxihavWKwLJBXzuQ1fyKsb0Jvo3hVMBrqEP83MN5JGcOzXdOyKvCdCCzk+iMW/qruamCXTUCUinaal/cefSg13teo6Wh2AkLRNtn1ywAZ/jJr0NgoYgL4pWYgIIlUvfxZR8K3BzwahKvX1uGWcmIqpu5b9Z6NEizOcnHDJMU/EU9vrEPmXHwYmifnV4LOEx0qXFgnXD1dw/KuwMz+rDm7qakEYi+aMceb6sEe862cVeVONvBqG/v6314d/kPPy75bafp5vbbm7ct5Vbf9N5DnZm/IaYK7Z4h+GnfndJs9UNIPjsknf/BUc/yrs9M92eHpJencCCfpq8q6c929KreS9lvuuUvvXYbfnHGHVJc5/do2PY4I16wu1ZgNa/zYchN5FUphIgHPym4cbMnlUjrqgbjFv4NEt8QXvs5xJ5oqYUzPkKkr0XDDYpZ6bgzFkH3SPwvBQA+1gMIc0T3/ziaPEsJEz8QqzP28K+3XSPSyj76YTswAeTxPw15IjrSCuuiwR7/JqWUdGgcDoOajOM57kFUenYqzcFoJyTFm69339qGY/1GbT0jlS27VXti4X3GI1tr+LvcTarcI7VeD8ZeTxB6nmTlfoediMkLu7yXV38ARJHL73YmalDgk8UhU8QkwnPrExexcL7uqHzg0XvU0hMk8cU+4WG0+htHMktvFVjB3ZCIz0o6KtHnsevcds+0lQXRahf5qN9NsQ6Z8Ypj5rTjmp57fRA3CMlyy1c5nLwprRNm0T8eDseEXVH3HkNiYws+PL9S7a0oZMcn+YtSL7iy/061KrnoXtnAjElbf+coH/MuLc0m/3/YA5re1vvjLjY3LflO72WSJ+/ckmYvTIvsLo1K3ka6OW/bnrYw6vewgO8+p1vAfC6WN9lrvi7H+WQ36uFtPLHdKDEp0sv/yTyNQ7X88oJHlto85NbM/VJl6yPNYs0Nmkt1aeM88mw0ZneDIzuK3j0br/cnuWnVeDf/YuIq3WUG4dOxvKFO4IxAKM334hjGMb+KxKWr/pXRHG+NzTzP8uNvUvuzCztTR42eKYlWjOx9y7u7Spt3xNnuht6Iec65/8CMztti7IwT9vuvQWpd3tb/nf3bLFQeDFYgqxk+iU0oEK3QxLZFln4mndyOtwBdVf5Cr74l5jl1CyE/efvcLR0KloZnqm0rsfTshw32vPnSkWbLZaMLWjhboWWD8+SOozHvOo1Y1RV+/1B9Iw+v5a6B6WUc9EX/Tr8f9NInULtS75NlG4Z6V54wpge9v20SrVhavd+psPYRn8nk2GdtnMn9FzdUUoFD3X50KRu6h0zsWQhQr0mRdMl+i/cddoXZnov5LvffuzbOauu2Z5Pz8WQX9+SUS7FZ5tQP0zvb4HS6+9R58rU/3J1Weqy9FPdhC64vn+YSdHk1/TEDeLaOoWgmxfiKUL2nf2fvQxUp6xIvSu8NwhFqSf3XDCw21c3+8m9GfKfkMw+SuY/gyZ9f7K5rZ79WeP+q7VMgt4b7gNpqcEnfRk/2l2LjyGGnjF1L9IVS8Cxmwzcs7TQ9dbyJ2dVVPvIgqtEtcVY+cTuP7Pvjhz9osa8p29YvEvm/9/uE3d+Xr2JMF05HGn+NF3Aal/+wIAb0a4UJCHBw8y6qtCtxdOCe6loeU3aRoHOBzlDA8XmGxEbDysga+LUKOdge+VE6dr+kO4QPFab+h1pQX6419bTD2ouir1PQ1eNgfjKG0rQWequcrHSQPYRIp7uDU3BhoyJN6SY5XXFz5XA1aJ6r5x93CJJ/2fdcNGDJrRsCm2gZLVkdL6BtEBLyngcsAodZD6hdZviQPo7ZfvCpLTgTZa8BfKtCGzsISAvdUc5Vldzf9PZdqBdC2S5/PcDRf+si/TVn+RJ8gxHS0d1wB4z/yhm52HI7TATeYrwxMMNuiKpjBktmvZ18MP84azjKURse1+wgTPvGtjYNfY7jz5XW/vJuHQ4WaUGff3n2sKhq9B1KdjfcxYOBq8DiEDzWi8pSJfrjeAvs+Dht7iVEWAK8GyreTD0oGqrTUzKKniZ6DnZDP7K24gULztLqa3wWNLKxhN/SFbu0/qHE9LOy5+j92MP5Z2gtvqc5AxxEgqz8qhamQOcdbI7Edj5bKLSwFQDmHpjOhLIEK/7ulhJ9VvLQQlzT/c5Rwan9KjlAYYjkfqZnK3OrulWLqx0lHH7OCr0WLeZw/7TXRtEU6bCt82DK8Y0CbO7avU99Ch9Tuw2du2efWOOJYHQ8P60iIY22yqphp0GKJE+lcQGpelBTeOys+xmmaUj8QUlLfF0RHFVKOW8HxxGrpKC7/OUFNVNRtxuG3g5fqlKc8e7qv8Dz5V9ZszYv0aaXPVXnGlVuzRecn+e7zHj0GZ1s6T1K9wVUXez23sArG6vmqoyJcxkQjTU9+L/8RZJqnzI9D8VQMSXnVkO5bjO3Wlvqe+XAKdh5eO6yXjzp89t9ZbeKUQY/ZwAVNwXwNHwDbw2J0+bqA8ak0TPzDdPBjDbLvsqG3IApakrGkt/Y4WVkHuUzJNGjVNoPzQ82y/mUa1Gy9sykrL65LhbgeoqJBprumbrBkHOrpxKgdfVqPhZVa+NQvWfMr4JnNpfGBt3t1hrScLYs6f/kLg/fTpZuePnvvLxZC9MHo/iFZ9qz9zPlR/jk4fXPiVfVOMGwtk3QDfoqTpxPZy5uHI1DPd3trfXWNYSdVN+FRVJC+yXjcZmFcrytSAWSavqe/ZrN7eHNUr+kSMr7qKdQG1Js4HELYTv7FtWm+LU90nenmvDZfTM3F8cwTFodEKi5m0dF7pbtsU6cBpZmfHtkXsGwTjPltKG+X/9DSiL4rgz5/ulDoNJmXWgu7zsRhM+prhwB0DFKzxCKhavJRgl6V5JZm6RGjx9ZQkZmuWqmMi58ZFBq+uS7UdXds3ESU16yQD+IEp0160MAhGgg0i0t8FQjFGZod1mVXxlkrJ9LmxmD2+kVI6rSnDZLrxt+lWBkjtX3sJ3wt3fE1XFA7uFdYLncjCk2lwL33N3KaIluRZRIPleucWVQM0PwgXRAH9FJL4Lfg3wrMNVR6fcdJNe5YddwO0bb3LOsw0vhjvv70i/V9ZM98HZbCXCPuPheE6kWvt88af+VdtWX6xPQjrUdLkHUR6G7+n1fLpWFVeLytKoQ4e/5U3JQSc8fELd4t5snkrX1o+Nyhiast/Gkdpx8ao9EXYlROaANgUlxP4rcoA4WbPT+ry2dsVL5pFUMio1BXbcSPIjUvqF5H2VkCVfbVq1e6EdOaj+Zq1qbZHGZmrf7HSBKMj9rQZCjz2sEee6lysJ4434mxORAH/c4gfwnsJb8AVybCdxhM4gvaqyZUSi5lnd56uiKDlOZQgaYKYilgEuRl2J7oEZFI33oRuqUW/RYQnRF47HKWnMLFXqwVrvwfG8HdHjlMkeOav6c91tfVHr2cUyC4/D6ZEkZWozT0u2qdFXaY1U8a8kFfPkxOOmVY9xcL4V+fSSxr0+jANXfgv2nx7mXP9lmKSeq+ObF/5VcSJbuPzRchFv7k+fJhY/R9lyNIbfA/0+WB5MWtmaZnYTaBNTSSnL9XhYe7G7TlrOHI5gYE29QEwRhD6SltcY+uA4bhyT3hG6ytQXj/Kgdwj0NKTlmw9ALUzNaC0ekMfxB/rsEeTpyuLXcTC/xZK/MKE/D5Uv2Yncq8O4H5cHQAn14hzpI9YjkSHJB0wvU6lZEKJoqduM0G5yLaavyB4KWOtYsia9jivldyfZP3j5ZL6ap1z9zwRj+oVdkGWfHAh7Nsg19/yB+XhLZn+eE347NKdYkdFBLJQ1eMLMNqLGN8VUtbH387YJjouHTU2JFzXJcLNcfFWmtE2V+tLJEWNjbLlslgYSJb7QrKfEFgkwCFaEWORPYFr3Kq4ZWywcdDFEtnZW+Jy0Bv+F7DbNnI9xt7a4U9B3FLsVyC+ih8ThU+zjGcN0ELcEV4LHe533dE0nXszERGJh4GSdsrPb3lL8L6Hq/z/q9WNyT+7TzTyI6xZLXjIkAIGbma84uSfReDvLg9lJjaiQqQ4wfJeZSf9y68PJ0Xgz0KnEHK+ftTsfIyut11z8Vb/WQTq9LNVuGpZiDZCqEtBw4FO+ytO/lkExvDDVbhSl4XG7KtUFOG5V5z8swh0P1uFteCpdNVxEcUyWwUsrzD5VwH4u4djylVpnudIiBBRMjcpTXR9OCX81M9WYPCihANG2pYkQvWRiuH14ZTz3ta+Oup4naRP7jstu8xMDuOWs5wTHttCYiP2dPmd3u1QKQh8iGQ7UaHUcRBnt8RSpFsCEZzipgu8P8gx7S2adsAG5osBdCr2juz8GinaNnCJNgO8xZLf6Je33D85gU7B7pxb1Ogc5buhMdgde03oJj75tlgb4kvaEsm/NQBYiUVelhLnZpvB2kjdXGVamzthc7+o1zYRdkPxdGM/s9kCw2LQKjFKqnuoqu4SK7q5XXrdXwphXZr3VfdMUvAd+1BdlNhzQSMsSFmgF6If0t4PU1XZRMcm9r4OlWRZ9O0W2HSt6KSFoh1HEF4U0neLVg3OOEhEk8Z0AzXQXApt56pOMbt03+PF+dEMtQo/4jreFnVjRFoDVdgdQmgiocwRltqnDxxBXXOKRfQCV8InauJJyHFAJ+3gPcSL93AuLERkhsIobG+HvoFCHr2vkR90WV2YW68VU5MjmmCxHkkvFUdNb56sF1URR9NoCnmIFfkOvMU1RP0BhVFkzcZO4ZkzFUGCK5bf6Ek7J8ntqhUEU8kQoWPRlEa4gUpshz12anMTqZnPPPaaqs78kG/i8uAfgiGOQmtjrrofyprI2Sc0JrtMcRi1QtcnUk/IqDYtr9AhXeYh/uwOvXXnrpbn3EDyVdO/TsntjbOsNa6ngDbN2Nglg/xHqc+2hknRDiLc/J3cUYZcJXHTbQLj2ueJRsIkVuGKmHN1UrnHEbuPF8R6dDtqeOeMgI8/lq1jy2Ql88UhhldSXGlZANnqOGH27pqXRfK12fmDteDOMNBzVLVPlj7aLMN6GEUO1Pqh7e2lS4SZJ9KNffYVZCePZpbqsn5Ry9PjsOUedH04mJmbXeeTd02SFVlHEjpD3xIuQ3zv0vtkqPmqHnaFO7bNwV50yzM/iOaO6z/wukeFtRubaU/Ei3rQRpTx3O5QqAlY/oGYhjNF7mqgYSNDOblkDNUQLVRmy2Zvxu3ZA13RczIcpStPW1qorXf/sfkcPUze7GU+6aSbhhynqSztdJXmfDisGfiq5dXaUT2VH3oXPurqqM/tqPspPQyhoMf3bBmKXB/j9eej2HKTFeu/tLwM1qwojVFelAN4UudtvxluhXeNztBHu2uXeG4PzROWMdVUzfQlT+rvmasopfabtLESmg+eRPkKdMAgLSNx6W4rZ7vQthema61clky1u/P73l7HhStqzjysf46r2J6w/LnOP2avzJ9fP8J+mNEq6OKlW3fqu6qWrVCWW5Sp2C7zEEaL3TVWf4OO5c6tUbOsFLyGSuKKLSf/9oBdz3ypZUKusAfEcLK9oufc8cxTVEEs9mSyV8MG0OLPxK5Wj1cFmcz34QAwxUWuoaHDeiOGsVn6SdBanuBxaSUsEb8qJTEpkfNvl7QdSI5r/XMuksPJCui+S13rvYah+C1jm1zq/Ue9tU03OfK7nmWcHYMhjse02gvBobreRu5fTpy8c7hw5ZwzP6Rx/2LWy+v7cOvg1V7EvLiZ2adO1tvnuGda426BMUv1TPoBLOQ4wxm2P3ZnwTIXVv7kkT5wlrd177MmEWOS8neI53w7Rp0zejlisAgmUSkfgtj2crmAs/0nt7ghduwVOydrHDgWMPug6D1s9Sy742EHPZ43FqTrlBiWoH7uMY8P2wIjERWXu8l2p7Z3mwhNpSt8zmx9npWQDUXRBeQ8NCiVxPPJkb7f+s2DtL7dQtuuoUmd1mPmr7pDNrpOGyffUb+kR9uNB9jt1zB/nb0y2l/tAXaHgjZ/oEI77ijHPJeerFb1M/VQPbehfUeDXc5z4ccBSyZBDACsikgZT01aqoNsYy6N9v8JtUadIPIJHAJ2C5HbzfL9RY3/8M16QgLwN2CPWP5xykIdgcxtuvF36haoV2u07M/eBd3dxJi+5wxsDpqgY7fyeHwzWAqKpioA0RRvd8s57C3ww3Fd6KgGbOWoKmrD2BeUt8dlrhc1HNAoD5wTLmwuVZ2V+JRp5AZAdcjlgeB9Bj1jQ/so/HOUJ3M2ywnZWlAasyq/0p5+Via3NtJi05nw0mCMbWH5ruAwK4MkILt5Uq3keySs7bGDVlLrS60htjDKYvAW5pqb0NAhiV+t+bWy5hE6LJaDkVO8vceZbWNU2oJq/VOeV38S3MaatM4J+Qn0dsNJcccGXF/E+x8jQXWQfzYvIcJWrdssoAl8YyM59SxYP5K1+R7HsoP2Ly6uR/LASd1zfRnm7mYt/Qjn/lHXwRHrqvtaPC7p7/1ivL2z2kJq1rzEXftXyW/IZ0Nuy2/hBC+AcKUL+5oeyOZjPZDP64VSYF8p/qxwwdS4kgITNBWY2lE5X9N6NcNvIbC/iYFte5W1B5bJ8TgWKGtf/s/ymT3beWjhKzRQ/pn+kk9tz+Rw18czQtYhZLzgUo8VeSkJtp26gxXY8iT8ldJQ1g/l1XQ3V4MXZekXgBEjJZFibGGt0iQgzl9Ayl/b7N8fbNS4vq/Bo14wcwcJsvvLjjpW9LzLXwOyc2dsx++XLWbfsvktPE6/JmU/WwL5h3qo5/4dvCXDvxXKmHLf2eI8FO7jJAPGQm2ljlEPMS8O1xs+5TsoTNF+j9u0PVYLg984vwrNMMjU5ud6pyQ6lklQZ6IlaCto1wpZNnWOgQG6yAlP6dWS0Le9pEeZI7WlZB4P7xKDlipivjdNtjBArAYbDPD8G2CFBifOYwGRRiyd3YHcNd7FrwmJGA8eSvSW/pDvOkOJmx09KZFLhIBo6iYGRhbrZs3DHvY2gClxqRxusgzy7y8etiH5Q1I3cMjKO1zeatC6VQm70nS5xGYd4DfyHxW8q0p8ZDZBPi/xEGFyxIbKlwkAPU9Yr75ffLPj8H/1Qb+lH/0/L2+bLy22nwJsTTUEr0iW52vvP/gdhO9ZNRw7sTm7pTnhl3tHuIW5McA3HFzdnZuFfe2E5qb4m7Q8oH69m2o9srZrlq7JKq17gGhfwa5eudaEvKqeSacdgpKlAfya9sucO9ZtvH96duu4MSFOQkc22nLz7jCzvfXWfr0bcGFUPdHx/ofAjyKF5e+sjU+uoat/vh1BlcL3SDCZY43GmvufRUR0iDw7F7uRV8DALCbgYL2IjrilfxfZJcdYeqlc3YqRUV7ImFiZCgWmEQdc9MMilKtTgCMWmowW44TI0+4A+dp1vXNOfc3ZRB8EtekQNy7GhqBcuJMRmOuqMPEc+BZHeMORLjb+SZTZj0LDRv6UG3bR/hQeWxB2dnyZlXynb8vcb2E+C6BBIOQgGl78vbLL1IrvMGMBAd0+V4qId+RXgSYQPfZKgJsQfpLok4zNvVaTRel7Dr35WE83Juh2ntShyRJnCgBTxm/ulGd8XebIWsAJoVFxhRmFRZD4SdwjSUDZ+1zzJERi2wAGtfGCjYLCBCHBaag43j7TrzStBdS5PLtLHzW/D4Ajlb8H12aObantRhvhWRlMVZiZbH/tsojUjzVFFs5aj08wvwJvGhClFV4f3Y1bfw/aq/QS0YZVVF5v+cPGak3tKU5BfQ1D5aCTr41bCUdUXzsyf1KhSOvKYotsT1z9SFU0R+6SFsKiqwAAMzkWUv/cKqY+s3hD6NA1bSybpQiXp2w3xkm7HDDcE0reiztF+JposMemIue3iIqR++K440oRyFZrQ7QefjhtvUckSTBmIbW9v6m1+pHenS91VjefX4VqfoZrcQf3Lip+j9+zO/ere6UYZtip2rB5A9VPL6L61QvaMz23ThjQ1sg0BXlbzsJYK8EdhD0stWZLM+My/IK8QMUbqLVMMpAqMq0rSqPUn42TgNdrgfxLNw3zv3/TSOoix/1UTK436WkkDOsXQ3uZ+9KGG4HxtzXcSOud05z331NWrVbHCuu6qYd5sBzTXajmdiZwETRHDSA9BEBD7LJ8aboCgBmw+1BcFimxwCN8wwvKgywgballE1MtZDou/doKIlNfdUwCU8m9IIdRFb7mv/LIZc5KltorsX5OArizC1xqe8ufJK5LTunHqAH/s7V0Jlq/5ua29Kpe/bbIYmYWBScugZIHg5xAN9GpdGVpFOho1GOY7zSN4Iy4zmGRbrDpwJafsh4GWtPlo5Xd72I59i77eypPYzjhBtnIMljsr7OoWLtUTwMW62Ej1EQyCgV8Frc4yjMhviuijIm/HVHY/ZeoKh+DJceWxxbvbt7O9RwMKb5vNjZvycjlfhAPFcMTE6KIyzdLGq9Ek6v4wbfVNmSER4ygP5QncyLWKhGGu1KJaXyKWNBxnla3TGkzD8xgtT7zrxBd64hadBLMz1L+wJxVCrezyA7Ns1UDh8b0Lej14e9HYvO7IzE539TMVLWWSDox+mb0FSf/KgL17xZK1DN2QIhDAifE392o/1mI8P/JCAzqZyOQBJvqqqsqskKgGdpfcfLPItCpH86B4pQnPCFx9dH+lv8AUH59eC5C+btFmKGnxZZT4KFKQIXaXWHy7wIw/nINJpJIV8isFoN0dzt4d7k+7OG7qV9OgEoYtkrQbZWTfUXIv8Il/Cz9F3J65f9yI+M3dOUVIP/NGW9rS+0uKvDp9T5w7M73Pt1hgPGJ7U5DGmgC+Lqhz06MNEGpJol+xvLjVW0OacBqs5xQDA9mTtQWwr2J+NQy+ZIwPLsy+4UW1+Gj6TYqwVXdlA53N1smmlMb7erfzCiogOfO7ssCde7RB0Gwm17AMO8CZS265NUVLaei3cbfWCFE3W1ZWrz4OujmJSH5+tN/VEaRQnA8vJp85zOnDYH3enFxFQMxGbvNGPPTEeQuPOfZ+YYIPN2YuguDM95IrPWiytPEBdLNz+E2nghGMFklntOFBtyZnLaZRTccnRgAp4V9scNixVzWYCdrFbi6LbNUXlr/4PYSpLvXUqTF0x0Ja14RwMts0Dl9tdL0cpjb2liJOzPt4jvLa+qQMRo6XYXpVKxH1RjRQ9cSHvRN6nspDm5JrOPs3oK0dCPhoR6Ojrh3Nk5i9ZMrNcy8E5dbLS7TNR39SYJ5dFAKT4hWbsSM2ydkLjsXqV2uXtunloeiZq8XVWfMUD2uXr6KV0nnsvk+80MYdLd7zRh4ksM7/DBThSUp7dUkFwXxpfLZ8ZQZerDkm3tgo2y0v2aP4JG5BJVPbYjrz7ni9GspcLqo3JoNpZ1I0+SBjPlJ+pP5zFZTwi7bRVxz9GJx2Wpr74j8PFF0BB9c3fG5LGSQ8/PjHiattW/jUCXsstjRHyW8po9hXgmDDVpLVNP5xHh12ONc9qfnY1P3xsGktdongRWXoU2PAt1hK1/GJ02XeafndeGT/0lb5Ksi5CKMk4Z3xS76OPcxELdkU9411Ubf7WsU2/qhTfYbO0y/jPei1XH/dPraC/4HH2CHY237ye5VakMvXwk1Z8wTrqm6mx17QsvrE9Xe85I51lI4tJW06ja6cgmgVfo3tWdReB2w/kIUQnyVusX7sJGTM2Qa3kDB5LmPLOGNuVsB5TvR27xSJQXjaAibNKsI9P/Zu9Y01XUcuCF+WH57/xsbVyl2MAmQEOh7GPLNPUw/aKA7QpZKpao7UNDpe/veQlrmSsPdqWIkXkVVv/QSXq93rl9AYEET13R66EHAyO5DNEaV6/IQT6ud4cxKJ/7zzptJOZQC12ogWVouSnO/1cdXA1gc9/bvwauSoO/2EGGy72plsU7U7DzHSGESqjRz1O5Bek7U+VPq224HYPyggZMPvL4D/aDctm+vyJC4szx6a3nUkwX7HurZKgp804O5WVMwHF2PdteodFLrHFmRRJAr8tismBpn88q9rXw8c9abW3kSCZ2hYLrAY2m0yHMT7ScrUcP2hs0pPWhfBiL/i3wvyH3obKUpIKVJwlmFvE0LJqiqpwvtLXvu2WOflU9g+r0BY+fhU7xzWMh41KQZqy4vnow2ziCQ9I7LhnGA0rHweSrmG50jDaHj9lRJJ5PjnTfpBmRZETxt+eAKyOu9FFmAdqt69zVCKAuPSjc8HZzmRtndMkGd9kavd1sjf4bNe8eobMMUdQ4rtWniZepkP9zloJ6oaGHjVZ+bzoHxZgpm54FpuLIQPSglcEJAb42ccq3Z7+52bJE4zXAJ3dg52XkK9aQ+1lD1N5SfAZ4kUSwtqvNn47hnK4gnAvTecqczxJ4Lbg/4z2CbFPYzVlePL/cYHXBrhZm7cWV7JSOdNfR7YcV/GjD/51dd3el0++fXPtyBdsLFfgpIvYcO3Xspe4jeG6W27ypzSj6VOVOGLGegb5mrnRylL8P/hepdqb8aECcPoc4YL5GKtiFekiqF8vfMGd+COQalNxJ2nuAGTtMMwZ/E2sdNyELR3Yv5HjlP8cfUvezyLxNISnWqy+omJbtykbgRlK4/FvTn1cZNJcjE60zVN7Fgej3C812/naftRX8DCVy3EA1lx2QW6sBQ24qQiQ3Qds31y5FGcbmGhQOmGahMaoBm2lrlJ+jYgpFQsAUXHWTnk8fvV+Mk471T7+8juSpASMu2bWkx/iz4f4rUuWQvlcVXBn/jYW/ADaZ6MphTpHQQtzDxZPH+VCw+q7eoAj8ALkN5IPDE9G0nM+555Od6sF8zJ3THTtHsl/VxIlFOOfobRZii7lFDmUF9CcOEl3tFxVIH5e2M2oenNN4yXd0ow8GfLmFxhdPArQNh00xPGgeCHWImjRTgl7cOahn/NSzfeNBweVltuTirtqp8YaRN4ZbaDfNZqD1whQkkAHweOZpR2QbdfhSNxPZJufQtxzvLBk01O9pUf6JAZaJgPh3BG0ieFjk20SVCJOIJI6bD9Y4+JGjuw7MnGVvfF0E1kKNHURlyfZDs6c5rkZdqA5eh2W8eGZzfDHS+pjTPB2Nl6Xk1CQtOGm+i62ybynLhPrbRn5gMl2cdEdptJOWGN9quk0m+0Kl8xKMX2qQl3EqE3iaYAdnPo4r7wBu2jf8bXT56EJ1TwJ/aciiPxt0PD82xAJLlRvmrMejL15Tl3wkeydt+DXnp7sMBJgX6bHJHlWB9zC1PlwifSSisB15M5Wug+oPA5fKNj9JKlw4SB8F2Gxec9n4q5xt42BZdY5k55vxO6avbSU/l8Gzzt3FbHBb8E2r9EICQGchl1hBCmsiJbleSVEMYdTpQvlSLpugTPE1q2RSt029n8CIswDRbGzaXA0Cwi4J3qLxC3kbROxftfkyu9dkRuZ1A9n4NcX+qX/zUyDOsdMUDk9W5O0N8/5Q28mBm+YDinsLXQPrOfeLM9eSsuAl62v52d5MUrr3WfbLEsKIu8SqkZfeonGCON+1nLR2Iw9BTwj0y5zvzdCl2VAqyFPdZIp3i7Y4ay+bvQTrjsXPDre12yrSGK7v2mmQulWT6VG4Yf3YWMfAvFfTSAY0lGpPtEozLYVSemsLOyyh61/iJNqwIJWyn0PjvSTLHCCb+0cPZd/R9q8H38Av23h7ytlfVYnfwoQeW68Zt95RvyaUAalO8N8dZnoV+x56ED758DU8wHKO5ZbvS7WXdn1LSeN6Go6tbQVJhWtG1Bj6Ka7t8pECQLGym/Rn3uM/LsUkqY6MK9BQPykpw9drbjPkJMHEMVVKyXKGBGW3OwO89aDzwRy71UWws9DtOJUL63UDUvcCgHp61kNYAqOuBtK+MoNeLa/c91L1wLDfEvHzXBl5OvYB5W13DOZxuPGg1dKWso9FBpey2uhdvdEfXI6RMd2mZQHqeAFvF9DYtlnsAxzhMkjjOeI91YCcccN68u4IIR0GBL7IWO4ZjlrtkXNmzs732AHZTlWTXZAdkl61A1yTj6drVXJYTQSsprwmOJ2f8vXLet6a1tCJrhzaUxPw1cRSPrSmUvLIeo3qk0hcrt+3LZW2HWB45/twoK8dvzKvAGOBOeqv+7rrXdQlmxpoQ1BMhr6BL6uZOjrNcT7eOTwjGaVwbno/irTskWXL5HnkMsQfbp7R4+/sI/q/k5iDM1cu0bQDqC3XYLdqZ2QLbgl+l1oi5ubXTqiiQACz8stp1FkWI/B0GcOcckXwCTUlyImqRZCfarq/RnWOLc2r3JEQJ5iqtHQDDGfZJ9VF8K7/IjUGxvkPXIKXvETYob54XuOvTyG4Hf+RaGP7hISQ3nlWq7y87TtmWLsBbCghppKlExq2QMSWMdOhfRPLRS33WYMoFjZjvZIAabZAvqKHi+m76bL2VLj5tI7qFrwEJ7UG5tRUNmtTgXxUt9dvOnDS5YimA7IfvybVqm2sd2sb6qHWWA/SLBLAkork/Nm8dm/Vy7qH/1K6zMctTb1iRx1LOg8D2w3JBesQieV4S3Szcefc9voDOHISsy/JIqo1KikBkPPeYUGqwgrF+W6lmuNBm8M9jYS/SKAvLahQWzKh+SwTJuGbQQucsSwJI1P2+QCUdSwrnet7NbV7hWfIElF5g2opWcWi/6inUkMJ67nnWZ2Du1hYqFeg8tewt2H+ykSt09TcPmf1Cq4820krO7PXbtBJJ//3LemCTex2rX0MSngeIxpQf34DOXPcEBZ0VPsh02NxEyxewZpq2HbroJmuSrXndZiXfoTJ0onaFjoJ5ijpECl9hwxRNQySNHll11sS/X3NScS/Rl7fm8voElkuyLqghIs8Vq9asGFHUz2pSxlnDNoMCjv6xg+9bwsqHHxd4tNgwRj9o4KbquQSFhWDr4J0p/Hjb9ArXOyFcEKQJAYULz+0LQ8FHrkBbRgXDCiex5QUPxLg2hBXWdbjV7C/JcxMnA9ao53xkaELLnwKh+EqmvlpAGEt9zvrVwoBjDPpL2hFcV3Xhz66c4lrxEjqyiGyYZA7lJTOe8+a1Lvl3dUAS/RbyRFg3ROnzGR5/FXjxZwNP2lqz2vvYK4fn8+YPAs/8bsYLZHd5OhGXS/pXxdLOsPs/y3d+ijytk90Zd38Xd/5nYcSJhEq6RSQAK2dw/FnY+d89Zf3EkvXkyZ7Z7i+lVX8WTgkkCdhpsO/XnErPm49lu58t7uykDyCs7eyLfpXnzTsmcmsAczTnPvh7JaYTR0kLWki6oWzZ2emXynRd2X4nt6LQuCqpxZVyStuDggtWyP6kQix5u552U6oKG2fd/m3+my6eyuTvXWWwCxu7e1Lfdlj3THeXdjeFTyhXXgppZoW6weEhKQ+wkwN9JwFaf+w8TOZUUn0rI+tG3202z5CZFVwIsvSckyeE+RXAZvTpgHkdHn9a5WyqAjQzSrm9uBAvk1P5bcTaHYVUOgPnvdT1wGUVNx9ZckUjD9e20m4mx73SOmBPQdnsxs8yBNJSjo7jE7JOSzJRX8FoUuS2nlXuVCZ8byEvs/G7X3ObkrvSp35mpe+vbi5c0nazsqob2fSU9kL4OJVsJW0IUiV962mPGaI53XvfHTWWeMO4fnJdFy8XKMPaKsomcHYoYG5sgN2NKKq/oaldqIXktBwflGx2LHefFfLHSpzbPag7e7Txbui4lw4sNypm3RieODVltL009mZlMVu2MXZHBZuzMf/8Avk9pZH0SGZH9bVeGRb5q0NMTBq1euQm2ttPrEtN0fXx6gt2T2idRfQHTrpwPUP0Cyte6Vvi7YxbxYn2YAc3J5VMWl4omZyytjvFFet38ycLuYMnEVPOU+3z2l/28dlm1yLOvq7zZa+jIN54xa6crOLmRlAjzb6M/5ze0f+GLops08S2LyELHUcYfGPdWAXNrgjxzuuKB4xdbZAz0N5ahPv5iOvtWnwUYO5mGOju+lveZ0yY4S7dSaNratzRQUg3baSoksqgfmu36QvIKdr1XjJCQla49RtfWvg0bdoRQJBZ9sjuYM/AbYfhW8wcmDEta3+HzaIwVP+2N3bsMsMJKf13/KkeEjLv7K2cHv7Gj7zJLr9QKvk5f3kzx+sQBkOuseOp5VXmUB4dso82vc9V70+VS/6xem24mbtOly69Bc/yuvV/B0135OALDV2vpbm4T4vqSuSyQxE5nT3c25FtP1+6OOjgyxxX4wHll3Lh26tbwfY0Q7L0n00O6kpXARv45LmfbxDwcmgVl1ZfO+S4/JmBPgxBHpXqlg80j295zKMWcy6dieu9aw9TJirX7CM/j3btSg4T+3pYtMKZ2t9hdnEKI41oAKDiTetWRpvnLS9j3GI+AacPwJZ+tsrN3GW4PujiRe12RbXprmuqFxpGPBrONnMpHYWEGEPq1ZIUyqIWxFt0HXTyqknYQq2zSfyOw8+dGei9HNn7WsvuTrF0/QU7udy8cm5CxUZrt57oQhmlCmdG5pwfzWSyI0MPWjaOT4I5088HIIAxmFbqILs2pLiCjuQGn3z2rLI2hrlREWeyc013uwUMTYDDgpS5Q6H9ZAN8IA8NkbCiw7tw2jpWETuZQs6WcdqXbwJa5tRylfOOyZ3GcxTy7v5ftjoaedZC9m7X53acZe5aHjoPYqYr4sJ8kZ3CG25ecNr0vEM3duahD6SgTcT+EcleUmEPDmzdw6WCNU7AQzTiZbTbxTPCPsQw+QJR07gnzFbObPvKLzyS487w+483mG4q6j97rnvLmsNu1XYI9XnOeywV6tNvg+6wjLBQAYcdCdgCFqquUaVDIQ0r/xeqaBTTBX6VIbBLGXTqhV8y4C4hwzxRDdfLJdGO0E6OLjBWoWi9pfSoaukW/u9Z1M0L4K74b7LkOaZaIXlJqA4Z0sCQYgd8WP/oEVYlqvLOkZvZ9JyQe0eI+vpjLiaGp8WiNS5dxoK2o049Ihh6tXnSUi4FwvBUvIefFzRPIVQMCNwnlVw2lpPfcE+ouW3lQdu24PFKfe7o3cUFBk+GEn2gDLK90Kkl18/41eRrpLl8ifiF69MYxFOpmSd6KOZ73YKQxtlzZRviJQHOmd8SVQf9DCTEFcaI0PAUb2zLfXsOUWTTMMxSkRrLtHSKKqpBapW1xNV9kcm6nc/g1FAKG/3lMbFbmgmYmCA1AtL0+CF1SJ9M8W6hWcOV6ZYCyz6N/Sa27ZqjgYmmgxwNad0OThif4hf5X6SDBhgxluWVyfES6hsueKg01Dxh8UaGQnrNK7nAoXZbMEd7CbBlwju+eLhL1Aeu/w+HEZ/qJYMENw+X+iQ4MOqTBFh8OVhkULg6gnLpa2iEiNRQL36NFm9wBlOyPa/3rT50G7nSTT6swaa5r6+rM3+9r+da9rGNaFxNmQUnOgS7E8S1w6QGXpNihNQ2Xm+tB+rjuFL65pWGqN/FY0jfg8XX8/2gpTx0Fm6vEbdjk5YbUUsO6vzTrSRuPe1sKlpzBPjDQfEcn+Mf8KbEq15PNcgAwHU3I/vhiVCl6EEE2Uc6h8ETz8C0F4O6wNxm1wuYepTa/qdxQU2pC34JEZ6+CFhzqW+WBGcW2mHhHMJ2J16TK7FPoyOUCfBOqMejWg3kRjb1O2aD9fcOX8MNlnjMqs4u8UW8L+kwiJqFF3Y66zYlq0Rp91oA1zTk1B2CU1zUt+lCh8OaDUF8i5j+8qTLhDmd8t8iWQzuzoKLmWd+8JtA/0DvAWxe4YkcD2RPvduagZA0I7wn2pCYujmxvkRWgQbPh4O9BmFCzVgDO5KYkLcVRTXMv4fLAje/Y7lnucOUJ3tKiZOWvzpYbvPZRG5isNExsNVTdgqA0vwt1UwEd0KIJFUEKBNcv94SNObLSOcVBAL0lNL1l4MdKuAy7F0GMw6S4UoF5fha8sel4641Je4gAdeW92uQ0XisS0txRSNGVEKO9h6U49/EI5kiBYpbNHkJqnCiIsMyuSaKOtZLbHX1RMpd/y1SafnFGbWyUbcZH5nNxLJMwfGUhjopwFHH1DPORjR2CQ1gq8ZzPZ6yZlDTnOhT+ybdVjeOiX8IM7IPZg8vExnldTj9wLM+ohQMNWCNMLRiQ/oaU07nKiR/h+qrcMLwqGbHPouN4Wsq6HSQwbp0g8SJFaeDJmhnzuZ804l6QU1De4fS7MHV60EsVwHakcsdyaDC6P7x6L+x4WTezTWNcSt3OiOr+1covMPNOqZljorbUex7nN1ziPdf7/a+IQU9e9gxUu7wKq2jlUTXAErlUccbjk3vcpavgR0P2su75R5tpI69qIbRVrZS0UIoTApsV5y5plMuMgvAqVf0c91A1zUj7aiOCl/Fq0Kx1FpxBg5d6alSBrgLJVZh4RZms2rZA/ykLyJAWXesfnZlGRu1//A0Rqz1BEwS1VGNHdmWgp5Oe7Wli9SP9cSe0bcbMq7xWIkmezC7o5miow98/TSaycQNZfHKiq++4pYVXIB+pfH0nazvZvRUngg72h8OMZxNLWLqMVMKNG7rQQ88J4cwuwsDcLKsq10NO/z6wq9NGwbGXazbqCKQ5GtiR8IxT3W7xHbru9LRRXnqvNmIS9wYOl4mm0RLfWI8RiQBEhb0mVgODRyxDklZeg1Uw5ChlM0jqpRt+9vOW2KMdI2OiDVETw0+HD4OcKSGO1SXaglLE2sbEC82Nk3UoEhk7bzCmKLFlT1cXRfT19Dk+u/6MkgdyjJgRN+q7GczM0EpmBXVpmTb7AQ4HZY2LPBlU3QWip3YRGQKurIxzRdUn0MQX4Hqj5i6OoQplkZqXHHeYSGnle697UXabFhcJghdUxyCI0RkEm/Y5CcoAfhidUZihL6yICXUFBRgaIpnKvVVp5SEL5vdPmDEgneAIGlJiTAOx2om/jzAp+vfJ5Rtm7zWfY8cxdievjJrW/xRfCIKGCesGMC/ZqdNs1XMTC3OMEv4UYElVcdiikjMTcSffVSph8CBhDMdSHSPMyeAYZcLTyrEJ15dVp6HwxSsnnCJuBMSq0UkhBrE3mOWgtzoEvtEDABtCRi6Gdghhymay1wb+Y1W8eGLfGS9OVb8xLAEYuqbC4QaNX3mhpjDCKCvjz3DEOnxC6lizEwzq6CAoepFiRsRFwLDgnoBwdeAtJahykhNU/WJCw2nPacWs6DxAjOVfqRlWgdnRcddtCSNIM5JTVF/YxyPpeA3SfqMGETVTNgOM5BBIpkBNfBiT23IVwY+yzu0KAU4wa/08/KXT3UPM5S/fEHpo9Cs2KMb4FbwFviaudkxk2C7JCM5meg9Oh8VmTyJt513oFSw6ZNWvOsgzXIjLePrNATBYUTIkYojnHgSG3iEtZdeJ2PQjwFpwuot2CQOOYOkREHiteBdTAdwrQTreRcx/8j4jeoRC2cRa0mWqxm1FuIFU+Ca2RIITqb9aZ64qF/xiUqy39OyWTk4a81LMCig7ECyR5VkgjIayWqcCKOmbAufrFQNXA+WTAg81OOBg3AbLVE79Psp8OICWK4XtQaSZZFV7x1QVuFfewGeElvWrKBY7TfqjXo98zCtj5BBEhblmNQHsF1R91soJTuc+vj1Qv3/aMlHQQPC/k4gh5rR7tWYJ2iBl1UQoLWWZnFW/FVwbqvCU87+e6DGg4uLS1CBgBIJPqh26evhWJXbuBVQ8mBmRJI6LIEAMt50TlKvbgQLln4QtCoh8yPQo2aq243u266/4DZEDZaPJOgTgTOAtCg65g0ZlFwPshy6M3RsSosCcSmR+9pGvdEYfTclDnwTzZbaSF9qeEb+5CaIWr5Hzsu996fft8whz2a/Twor2eUqsHiUSIfsYfC2Dq3XVsGzjL+5N+b0xaZOpNx5AAzVUU1tXzNty+8NKL9x/XDTlXU3sqZ2lmWT9cWk3THUyqXcetw+h69d2rKZr7WTW+7GAUEIw9DWDON9mFi0JwKq5B4wZcbZ2dfM9Y8eZ3kZSKrlxin8JW1LfBQKZeD4NVsiT7KRbX/9yOm/3UoT8W2wv4QzBnZs4YrII9bcTokCvyf1mPArfMaVzSPPLopdCxmrhHYkb0zmTutf9nHAGz3brqBWItQvAlTJh6WHkbCL4w4cn8c8FjMFCDlllpEqh+WxPMu+JzdO78mwszeFFQhy5nYS4/ZImH6PhJKccNah51uy55cK3XfgBHKrHrCxDsJIpnwPCn4QEJA1zS1ZkELkJVjPjo+0uoU//p99jHAuxZ19O/4ynSdckJv6eWhIO0xVWzLXklvof4rl4qTDeFj2rmbfBtTXlEtXpog/Tcu70uu9Mp2zb0utsuHjlbfM7k7Fbug8Hiq6yjFZkG0e48/D0f82S9TdyoztVqeXXcK9L8yWNn5fJsvh+6iLrJ8B8o7gm0/4Xw0n+f+tX7/rZiGvYU8evJwh+S+E5Eq+lDNfnjf/QHyeAXmG5r+cMJ93Mqeh7vkWsy9uDcuZPc8Y+r88zs8l4J9+S7wJaDoo6Ht24D+dQuVMiefNN2TIA0I1u4xAzyrxDMN/KiWe5mpn8P2H064zFM9Q/ERifO9o+4zMn7K++MePbDn9LP/7Mbn8eRS+Lyz3pt5ByuuMvfPgfl2V9URzzptPdSDykRB+trd3BuFZLl59fNQI9Bw/nzdfixWdp/NP4oJysx/z7wShnMjNz9Bw3GEuw0rLfaRVPmPvfIP8h5OW8zA+b168Ce/P9Odu1smI/cde/7ZVgx6w3+M0+aGc4LgsrWpL8eL/P5bAZUPBOK5uu0EexL7W8SzSoYP45beI9By0gY9LYTrfdePuS7wvLg6tTqDyN23wO/44LNP9LJ1rZ1DuiWZcc0+KtDVIMA/I7VrDmDfaS1EHMXMJ0I+CrK9TJ1Rq+1p6DQjUySH7pB4KHs466RL8Nr60PQdsv3QTjz+ElfyBk3FuHeIZkT8/4ngqq26XltPWxk+FpPjTEOH/X72EPnTPysx2zptNwWZNeFcQWuigf4uS9DFXsmXtApXMSMsebQq2aW5eUrdIdCqzOZVsng7Q0/VMqr8pu19eoYinmEiJTlhBdVMXuCs0W+wsEM/Erao+QVTf149hIXWZnGSeCt0O6cidw9cfPRe7CH15g42LPfY2XSJsJ0/0l27KUxR3J+j7vims2K85Ko/VrOnRSFFepwalvT/VcLqOfPgZApEdzwi0gy5rooahKQ/gDOSyA/zXXOrmDIG62XAjKf30vS7VNodNOdPXL6evf09RI9ivYXse1Nv3ZgnRhsl+3BJx9duOFM9GIUwKpSOentvnseUHuDSESeH6wcHjyp/3T/nloCm/Ib0vP4i4yNsKrI8LX4SzF/jpw9TKWyYN8U4bXHYjuCdk8lP0lOvAkXLHOayUp+zOfc9atnm6W/c9poD22Cmy9LOKnL47QqFebR039ZcK/XYV/e5zJoRw+Vj9mwJfkPLcGi6mXr0KnCJd4lh9KhPhLgLjcOC0NGufnhFD+dQb1hLg6we709p/Fuku7bBt3+Zfa+2ZnH4e2ZV3Di9fKf2WcK47AZHfGi4sg9J9gD/yak+Rwq8Q1pz79AvMFzWE7xBJGtpMzzt0cy3hoe22uid5/yjI3N6ohHF8+FBMef81fao7auq9LKkcnLBZWCnOtjlwdJC9soGsA/bQzh/H+4c9s3X7CTLPp7TsgvM/irbJzq+//xXelvYvr4H6/v6KtKMPtYuD5/zFJ7412KTUcIRXfMyX6MN4XoZc2w90Dqb98n5+SNlox2z9yXo8bzYeid7/TX47Q/KXbvw/e+De9KW/I4FjH5Nn5V+sIeTPi5M25c0fjb8tCfP7PIJL+u0tw2RpD21Rq9l0qfW8tcC8ZdPIH7ixR20I8DghAgvXs7RZLtjwEvY/wKLr3VwBNFDASbYNyn4qEmHJLg7TAxdC5lIbK5plK/lJicgEvPW1EJAufKYn04x3ufuKN7+NYguuNNsFL7jQtU1wjkxwtzWUAkPJ4/Lx8vKao9MuuPKMHNyB8SX4IpoOtuObEqivbUzma+QHtkWLU/46voCFwoKv4S54kvr+wF0tn8tx89G/pGj8u5x1nzEF846JxiE09BLrJT0rz78SrJOfbWf4pq7ZhPCGWH0j8+g6Y+TPou9nCVE8zZDvhLc4xTKiMJ0x8mejs59VjY3kAyP0prQXmfrO+PiryPtd13HLRBe5alqzf/x/0bD5jsCLP4trhIlih9grXKI6w+7vVnZ+t83l9o3jTnucFvbP4PirsMu/29vGKdwC4c5wZru/Czv/swzRwgXFQJzf8aMz7P4l8UybTgni98Y7xk6BVKh53mCHhZlAVcXSRQ07pdDtfXMQMYp8k/mFZqYOt9peCgiGmE3IhcOQMIy6tunpSDy1gT+wfHB18V37xgphr0tnhpUtwp0td7p0HScpQ9DNe0bS564yL4jrurjIHhLjKM6VzhD60P4KxqIzdhLmpf7WZ7QLzHnaa34gw4w2Mal4Dk1mLVfTnsnH1tmIZ4NdhkgJO6Lm3JJ+95zLKNjmJp3kphLpJhzEXro2zCy79krlxnOQBaCQ9F4TyLByqqISpmW+yCm9StDtzS2SzuPpAzzHRGi2zHll3IxYREbsx8PL55MqF8Zp3+JOWAVkMZ2WTe1s1y3Zu/Uu/oyct67g8K2eL/lmWeo6IOyVLFV7l4cuC76J7yFxundccoyGgLT9q47HoZ3XDfanmXw2TP/FTX5EiE2P+K5u0yUeA0emOOnLWosXcmW10Oua+GpMySkJ+eYE9KzO9I8kLMKNou5rDPK5lbIgn7q5HL9+GdKL95WXMRIWxe4omc25lPLeDQPLoiRNVazMlYpfuUSJrNEDZTMr4zTVx4tvcn5EfCn0vAWs55UtgYGFcJ5t76+D5KZC8WuaoIsL5w/6dboJDwyPlz8T55F2rudlK0v6znrmGUB/uOb038kBuuHFhMfrVqso+CEdqdFL9iyePhBlfnIAkDWw2t5krp5y3EukQdv6vhEilLvb872KslN6lbXm8qm82Cnc814O6bRO1UDGPm1YDsku5QY08sPhuENQmw5lPOuuFnyWqhhBqyV/+yU7x3LYk3NOKbIP5Bw7eRjaO5WSTEZy16FU7oKEG6dvKtSyjjTIIDZ8M79ArjtwbJ09/8c2r2VWQFxcxnlS5WaESPzB8kiu/QzvPbVON1ILvdTagkDGwKakN8jqnD3+myFGtkvc6OTx1c8kbaV6bTOK1bySfJyd5J9s0QnYPDVxXZQ1AkRolADHzYybjJN2pJt8xsq/pR9l1+CCdz21vPdgfqGoH9HIcEbf+4choFXYqe2aWWRX4KSbAUMJByTE3LwxEaggzKPM3amrroq5fMnHIsefeevtPVq5In1hyC4jlCORX039csrcIO0lmhXtyzDdCAqG+l5reaWgqJR00iB2gAKcp1T1Fh3VcYp/tvPv5X/IOoNVlhXICNSotYx7CbSErEZv9sIVGfFeyTWTh6wWaXENqdp2Sp3kxPfSzDrF474el9WCe8SJ/VRzvzz5ddcMMllGtqUf/HWGSXPoynZEesg/Zzv25ko6zrOGeySOqXF2c+zIYavAcBWZfo1iotGVrguuV0czgyPViSm+t9Sx06heHvU37h5aJDd8n2fpSCYq7fWhueK+Ps9db+Coxwftg53Gk7z4Ke6QfXqPkQAW1vBldwTHlOWPyyMuk3+XUOkoynNG2FsT0zdxDOyn8K9XcKQTDPhz1NLfua97Bx3lIVFEtr6U+NaXcmeD9lrB87f7xOIvIUH5MlAU1kWMM1wYN3u+NzsbSJKm2gZEyHx6ITslQ55S4IRrC+zQVLI0AqzAN4zDeDhSG9dSstI+rt7GkArefg3z0h3zmCmLILHU6S3syuN2GxTLub0641mqqQRuGdq2Us1BGmn83BOyinU+OtRi/26q17+GtsDLokCW1PJpAGZy47reM4ZwsaHGgBEETPu9Ygo0KfO1mwOQ6S858QWm7rf+bMEkfE0syLFYcP7z1YzQkUmp9CtHViDWlGeE29/gh09IJJ1/vSjTs1mOUdK9HSVJ15+V6z9rOjpBKefs7adge/P8DvHee3hwV6ynn2v67mKPRaEL7ozCn45Ca+yORjhf39m6t3aRUpz7mgrep4Nw9vKQtfXi1MKm1GrJXeDUJRReL1Bd33ToJ8jdS4BSrMcjpYLHqJesPqSnXja/X5/Foe6RqENgsHSLw73F1KKqpiGHOjrck3dPsbHyci3kglcLBzxTTLQR8PjRWolRObTUZ8ezgkyHJyy473RKZ/iU8UFq6+Y5jLaWUj3B5R3qcfGcMN+bw/wf/VbRPO95xA9DzOsgim6kp199IuFY5kpn/P2YNPKzE/ORhWwcWRLXcXh0HpC/pqc4VjqEtYbyKNlylZgg6+SIlQWI+X+b9OimBLbUDAuLky8O4i5B/Zmc9FmlzJphjgSNWVMqbQwc67+mDwjHQifZNa6CNFJBIjty03lAhT+6GKWJlu6nOXNReYKZJAWwirI5aSEHePXKelB4llCohJJcXK00o+0HGlG0epmTR3lY/6VaXhVseE3X2mHgbXK99jBvSmCGNoRLPb42gV1nW/hTbaGsaBG+xEXedl7uBCnsOej+r7ci/m6KVZZbxcvC36xwCxPmXc9O3Jdj0MtZ5P/U6qtZNpclpmU5YR8lRbNnyuLiHm0qSV+zqHrQJ9CZz3cjaSI3X7EPb7dI/byckabZ1Xa0cKpdV1rH9HB654ZyN5hHAXuwe0zl3Hz+qcN/OQoNaTkfKA+aoRgfwLTJ72z6B0qZ5K85b6Uc+/Fwl+vupvn4RiK7vV6Obj/ZeWFxFNj083arzGnuTqM7nU8YRcADNqJj8FTUry0puBdQH6/PSZu6mh1jfViT+G9qJ+CZqOMBgbuwJQXjIQ13ZBiebOqfqr6W07GBpAGO2x2c34eRE3eH2rGTdXiNlZ3d6E+FYljk57xClhuAfFOGBzAPSZvL+cBG34/0PUnx4BG5MixnDe65Fhi3bnMENclIKvFxvQFpVRZ23gyKujcUp1PzSYhMv12g40Ib15dM+qNNoCjGPrHEsekpqVZPwGW95Y3rv257JNkxDI/+e2iKB/egvxNnu7+WKI++uiTohuu/QEJkl0e03DgOkZblXeyf+o1KWd9D15Fjnsl5TVeqSbnKXqzB3hWH8dfjRNsHiv7R8o/cU7luyINF6S+TFAnmSu3XcaZmLl8vOGzN2WoYP3OJsnTKhGx/2w0U1/g1gII9lk2WJ3yz1tOF+bDtfMrTj8nY9Nlpq1mp8o63e9SAfVxhkd6piJeT9YNk8u1r1ubcIvupunqFiW9HWT55RLJ3Jr9v5WG91QvfM/PJ+dj5uFRmrSdCITcC50UhLcJvgxVpq5CxCQSLOlHrIatwT+GXQXW3SGW1EAmqPiSqHhzvHqhiWhoTKstGfXkNYPKXtsZRH9XzM9ritRo6ZnhduY4VbB8qDEfamaJ+Smrpn3xdD7xkr2P1a4qvuXd1Py6a4bHSiH9YXi3IlaHmychRjRQsPm7qY8SHS8a6q7CkzwE4QywgEgpog5nZ2JD6nzy2DCRyLbNgSdJfUuDKgOE9kWLFP33GgoYBXn94BmwvZDSo9fUWZbPxUcUFLB/EaSGgHgeWWwT1FdYDLHBnQPLFP3rCbU7Kz4OtRPfbJLdYr4RLjgRDh7PRYnm6nvSc6oSbAuvB+Mpix4QRBC5kxEi7/ocgCoDt4VTpSWes0YFeM5LDWC89QAk0oCYBz69NlBYLz05m5zzfCQ7vjlB/IGIHHAMmS1ANzIj6H4BUKBfiKfFVCyIkTVatqXUBfjAVfozRFbbnuXpi94TelY5v+tnaAIxTrFzb2u8D+hbkHgBSHiCnA3RV5CwoPlwSzKdo/NlIrDmoGGx/14QTeQzhtHE4WZI54+SvIjCkn1Viqe+9erAk+sDVwKtBGLja6Ov5ls84+asI9Pln2bq1yEcxFQD7hlrdFVTx4O3k5xoE5837IlB+tpWthTwkdtBJIAJr4EGOSr8Yzjj5qwh08WcVZjxxXse8BwU0ghnYjbSAtc84+aMItPlnR3oE7mgj5ClrQUshgCwRt2ec/FUExp/F+GycVA8d5Q/V6wMYWBz5sufNZyPQ/nQO1JDLBGMTlYIyJ8TpjJP/aES4jl7Hk9T+1gKUhWZKF0LimGuUFSKis5TzICM5dIG27LqyGuqHndWCpS4qXExj4gEQ8N7T9yA4ExnDGlu/XTB1C2RTlISeLbA6mex6NwqHGHeStt4sLSS+T8Cg11G68KkddtjBTJfcp1Vod0YzprRn9xY7WWoINn1q1cDJYao7s9H9hYPlRhYCJcfha3F0BpYd7k5STn+VN3MIxsVj2LhF0KEIB/bQcqQGsy1pPxEDQJsAteZXJDtqLMrIH8Ogl26pkBrEkNb2J7K0/QZEYf1MQdOtQlcGuqw3G43jxZfTKezNaqEK4dVribqN6yzSKXWJ+ut+OmWaGB/012Mv8EDw24lfq8KR5eFnAlWt8LwNvNaKMoErOCcsTxlv6ybSod+2dTQeZTGewfPO6h9lBi8M/SSd60eRHfcJLHifvvuDWeYr6/rV8zvMSq1rmS1x9ao/iPStOuSYCPaT4weiwGAkaZUWASySdqyql3CyQt9LDL+wRwxhfAOD9pvHAGunmRa5uHQ4O7LahatxwRZJuKCieTiA4rCpM2iGgtvWFmIMC/PA1+gnkCVyrTDskA09TXTff5PQ2FzyWPe6tFJoU8SlLCWi5EZWcVP2gZuEOqNq+ulCMnFcY2URFOb99dRtUv2oYGl37Hzm02vu3duCPDmanliLiHyzOOlGruLQ24smh5dcxYqhVCS0siGv0bLRoAMu3QoamuFDFDuetoPM7LP9x1FZKp4H2lvDiQUObYuEiqHUYjHtchGkD6P6HVAc3+8jrywiYMPdUSpUw1kmldO2I2NYpqMO6snIZwRTK8/KmI+2sR7smYneq9E09TtOtfSXW9tjwT2aJzODldfFT1ARhSnNXWnHygqoJGrrZOeTz1I5Ie9s/0aBi1OQ7P2Lgs/eztuEM+PTL2yr9BsiNMrXkb7RhavCtIa4vo/v10yCN5Xf7nRgenOuEm5d6Nqo7ymqlbI3nkWh34E2cACWLks1zWfVtxjVbkG3lyKP00FYJwzhyaWP9g5gvvJ2mHVI2go2RjnxojeHD6cO8xWqdWy+JwoccamdG5WBvCKVRo/LHfZE8L+xugAETJGNHGUYloqsDu2l1DgaWgHHJWasHHAveY97Tc5ntf1m+KhJLVmZuii/InPOvXYWVQMl0ClXIT8VXVovulv2IcCA1NJKJZ+GpMaRLBQS0yjhWj93ZizWdgzTUj5Fqt8aS7MisNxswfqbmPGzRmZHub1/WXu8x6hSAHCalrHm78U49DaFd4098USLpq7gRkzWl79Va1OKnIXRW6MI7I/azmPGTiWfcJnTC64brUc49vIdFRgONpv2BpIF2R4JD3GbRIstLmOGPlWBqyoSXQxdEao+f8LC9zgpfqaVMaqCncHzgX7tuojdfjAtNeMux4h3cUkw8a+/GvBLwguN4xhv5gy4t27vdO9kLusTRMRYVcemMzHJdUy8jTKQYrLfrve9xEl9eySeaXxAunr4jgaEWaFznvHoq/Mdrw+7sQDr/QlcvlUTgHggpE8NNyG4CFG/MrzdMelFk8UFnUhd1mL6sej21+AYlxTKn0QwjeE8Xx+iPmZ/2Ay2U4zqoKXupZTUs+z1QDKReUNjDrun5BF/Ft5v1mOELewqkWcAnxsVMY0oN5hATFj+JXQSqjnqBYdJf6+EjB/jFyU5NIg7TmGtIlHU2BlerIStoeTc6b32CTwgqrrM0FyNM1ImrTB2V2mqym2i7cv26gnER1VbHSklc9vGphEde2scm1gnIAntBi7b2HOD9sLplPDecgj1TZomENZcsQuvsACWIuEyQ97AD81R1XOfeSRCP4lhCNRo9AJVvJGQe6e/GfpnH5SQOY+z9waRkJXEa3nX/jdPdVIYSUMyTk983MqKhKyX6gaXTuG3o1RxUGdSP49i5heYRlJLenCGDlvn51jkI8rleUXD3C2vie1koIHzZlkKm5emtO1IDPS1HUHs22fvzzBMR6y7dlfbgmEMoPbZ3/9DUuef7hsHQt2y3rKP4KWli+0rPuPjSsm5UfKhvOYerg4sMt3M2n33KylP6L7LObLt76T1OkuWpORXtnWvpUp/mymeTL6AWuhCVLXJgv/HlpHU6rfWTMn+P/yaHnq7sVbvxtTjGzgCGDFCQVO4SNni6PICTmf90HO5LlHn1ydSPXGPWH/CZoy1YfsBsoKbdoHdc2nTq1PXu6+h3z11zn1Wny9/nhYoBdhO9MCWsf0aue22TRW3phNKHCesGkVy/h2rb5TldmIeAVGaBJi5pF0AXhI2TTSK8mw57w1tQgq9J3AQwg0lgz0DyCrWi46osaVeeUDlUTeqnAv16WoohACRZ/CMsaSJr0IuF2q4yXE5UxWaoRJt658iRBhbweixBpsL29bDbSpf00e6Y716KkvgIHDApY4tcdvBJTQGi4oykCOCwl/9XizxIJlNYfxEze2k2/vWCW13cmlU45cYuzPxXkXmYxxJWFe/73JKvMe3zKf4NWfcwdNmaR8oxJUsl5cigYJNAI5k3SfKxJ7CZIcn9KomfS3Te0iSFk5y4zb16LXlwZjQGqG36zU2VWPad47loGklJg/8pXY3TOh8WpvZbAem8vdwU+Sg2KH1K/7MxJXtxBRjaaD79ZtSHDdN6qvSnRDRyCB+yFGH48hN13aDkvejn/R7dLh717rOtiIZrFjMTCAkUB8ewu9GlwcAYMY+jrFQaLY48BLqN6pZUKhdjYEbcaqh8TsIKMWV75Fir2+sY7nEiTErlOio5XKsl7SGB0tlyuunSZx9EwYQsZxYK6NUHyrWSsWhqGQpilKyPgWGt7USD5aFeESRbjAqqXGDBTRhIVuwjlbLKG8Sw8SCW+RYj0Z3BwNo9YUrZBoI9GlQohRUJg6HIwp/FLh4hvoVlmgINjhM2AxVHRMTKh48E3QIYbYpJIqb+vqCBRmrQKo5IQRBdKivD37mZRvM6cv3+GyaeDBI7QrQh78lk4YQRZ4+3hRYlvRYFKTK3Sc4ybrHEWXERYdAkQt6iHk3bVnnGeS5Y6HZx2m+6EYBlt4iSSoRpba383Yv3Ur4bC7ZjlgKMyKHN66tB0fZxL8bAsSVc4byLDD/j4wHFvEYZdzKLd6OE6GrT0qk785UDw21VFi8o+KOw/CXCOH2pyPfmpWF0EUB+gABIkywfQvQ7zCCLcF8T3MnB/V5V4orV6Z1OMszs7Rt2U2QAMCi2ERc9Zw00z4AzWWtwoG67Cs8tnhHsswjfWTdnbleY1Ii/4ivr7JEaLdTdQmKkA6uSg5wQC706XJAw2rZnmrlZ+mcFHB0On5uSq3d8cT1/wv6Rwko3wI8vgwPWWGzBxbgIyOzkZd5nqE/Sna/j5I/En95wOM5JuPrvkem8KDE/RIjbB6umShTvLEwfzTi0/o7zfBnvHROpldyCu9xSSoVkAiXPjS3bioowU1waM2CRLwvOgGJhY9cjDq/mbHUQublb8I8nJtmndlRU4WaFfP3GJubg7D44udLxjIjDGbosjupPNuNSrXAK+ALZ2jJFVTtUf2Rkg47HDcnIZTvAPx4GCeJ+vsGarpZ9SMud15wQzAjNooNHcGktpgR2DUt6pJSw0X3rhhAWJRCmFraEeaupGmxjGmInoDBYn0XSE12x16mL99DqMvHUEtZpg9pIw2xOuBANtg2RWvKAApXpvYgjli5n4ACCtK2FQMSL90sc3FnIuI6DGDsRE7CkDl0BKP4m61gPp/xY+5LTbQrjrzhvCM4XPweo5ZjpbHb8cDu4Ktb4QKxPN4wA9n567YFb7Os+1ESd5ESP8pe+h5Z60WKL8cqlpDz9+gLxoP29cvZo0qZF0040+KtbEptVA1QfWIhMTZMeYZopBC95F1E0UlndVclTfWMu7uaNIm74XFzjQeUKrWWqIcf8lyCHEmiWDzUuSZsEh1XBpQJbQtDQWX0ZADVAyodfBYAejuHhtBhrILPBLsM9Sj0ARtNZiPr+3uUTLM/GDBhhWiLeamfYGxVs9L/ttW6CA2eTTpsFV0+Q5Cw2sSZVGsd21fhZCil75xT7VzxRL9De59wotHET+lqbIb0A+YKMfOBqQGP5sKpkLTfqtMJdhTA/mR4nzdvZr4d3gKXr0ld4VgRFcsK8ZmTLv5XJpnHTdXDXJBHspWCuj4Ik5U+aCSFRFulPXTqRgFJy63/JSqdH3GBH/y57NJTV9yOIV1wOX0PLn1swCElrRBCRA8pN23MCiVut9FJLDkhujMpYVo8m0yeeOhZryiL4xe45a2OZPGiajTuziSjsUQiXlOcheBZdtVTFIN+2wa5gcslmBKDBDmCX9CVt936u51xe9S5REL6mtZdbHn3DMlR/UX1/Ky9og1tCkZHdX9HJds5SkDdIM2NQmlaaGG+gSdwfBqlBhRWR3fK6cZ9LZmbUZS7kVhCn9WDnWJz6ORZhx6eHhEB2FKzrJFQX1JieZbdONry9c+xsXSupXb5mr3bg1GynPz54XDAld24p5GU1xq1tSKD0XKlXo8kuZIAtTyX5Glf3jipyCLJcOJU6geBgI6gXQNDKNXEoKFc2+wIa86ExWucJxHCtYWSyRigOg9uiG/duAdBmhnI2c2ayCF+D5H+WFe2bMO5OGqpy+n5b9MYCGnCMh7cZe6sbdP2D1cr/dxqlG1QTecVDvicoH8Ky+MxmrDcBWpKXOmOutEKnXWHJUSJp/jDT8nkLCEpGZbCMS9/1By5ody1x+3VB/bQz8Tij1oy/8eUqR0UIu+K+5oO35niDsIhuSyhQADN4C7XChfFra+9q8soaIT/gAlu2kyrJUxA1QymEwaTESwdmP9Baa3U5oz8bopm1b96PepA4oGtDdQjBQV2gt2Nr3cJtRiMWMZEBY2Ru3Bvray/Eh9MK6OSMHWJg9up96zDEvBsYN/gEHVws94P6Dvo60Grt1rm53nYKAUEI26CFqbL+ts0aNTLNslTPMV57P5IPrZ+SDx+VMt5JI+wKV1al3actVui82vWcOdsnf1vi3Y4iC5jFFSAgCh5EiQj4YJumec6T6QJMpUJYbwpoMgg8yegFUkhFerRFUcMTEkyRCygWhETjKQdnelEZkbEA/BIZRCJ45nJDFbtP1NQ1A4MUSz10MnIsC8D6EIyENAW7J9TJOZx2n1LiCVk/F8OMQ8qCpwqEWo4ejEmxsI4d6sgJLBthxRGZXrZa1wGjSUKQOMoLtOieuE1jsLBqRoJYz8+TpddF9rt0+7eQlqf+zWeogZilV6FYOI/S1YZFhITIb6iTDHrFHSkxitIPpmiBzHyReZp9Lo95K7gXflZuTxuAoJRANsLQGGAXB2oSzWS6l84+LMU+eTNiBH+bAEKYQzuCzsK0YHnQrUM7CmnM07+KgKxTPujEYgiKXOCZOidmTj1ChPV+IyTP4pAm352YdaR9W6pAOroQ271v7jHxeq8ORqBv9u1UjNsyniiYmEykTkOjovPmz0RGH42Al2ehG2s0kJSy4F5I2/7vHlLBJqfrQNVC0R129Vz2ZKqhC+ep/CfRSBkWX71FFapLBIrhd6UwGXytJhwxslfReDv1oGTvESTqtC1Fv30BGM+HYB75h9iT8ey9+ZeNeKk7GGa7S6GvKv3cbr818TBY+7+nPqO2ZvyMV9R82ktOqzKujQVWdUHpiJjIE8Wq/Mk3nsVgRUyLLeRUZOTM2remS/DJMczXa3UpepHnyDu0szRYbndaZf00W0zOxDTu5OUwcwVRNnYLTZcJic75O4wk5yu9jT/MrtVmP7KmCzmM3Q+ZXVhOaUXjjKJPHd3VetbTdhWQSHMhPd+es3OZZCqphjThTZTtdEOXXgYE14WnTb7HkSlLWe4kW8Ngta2GDJyCjq9OYaEC1bQW+XCDFa55tgxhE+4y96cEkV1NaWnqZ1BFFukFir2Zt0VbFuJ084gB8gtYBXBEdGwjrulNGM+SfFvPrPStOynnqzLK6LyKtZ2K12vzmB+lrPY8WwgqWjhpKE4+voA+CuQ/IHuNIkc0BPSpcR5BwiMkR0hY09C51tDZlrOcqNQgB9XRXXzuNEoqcjFw8PifMmTI8IWSoDu/enK6PUu0UBJCbar7UzFjYu6HMQN1LCJRDpsA1tzBs3bT6hJLGXgHy7JWpbJZXAH6PXtULFuCqA4rbJzpJ/azw/DfK8qUd5274LQs12rzML4CrZpqJyJ582JJ6lNZft0ujLDArLYoXEaLph6fb+06pLJdeSTSbcJuwx7+PPaaxo1F1S3zI5N3h4fg2zOTv2tpi0XN8kPUGcelWu3NhXVqmyJoeUoH+b++aXtKjpqWKfPwPa7n5uCw4x83S5ZAN5bvtwq82xZihgGePnMQO+1cdHwUCEwP35nubhsh9U2qzLNryrQzk1bVI2x/EiSe1JE7AclmN1Eml4fhISzXf/U1mPakUc2iSmm11rB0CM1DafmoLujeh1jsZ+GWHSPjTnWC25zpqr3ymcLU1Wi3EJXzwhD/oldNMr0j6w2eMsj5xk2VIyWZzi4+gnaRJnGgIABT/sC+8KxNJJH2yOjIo+chtBvPeAo3BRLx+ukKzP5vHIgqd6zGwVl2ukYdqQh8VCJ4nYvt3Yn7bEV3zTLItzf+AvpcDoa+pKlp7LnQ5tmTg3Dt8ZQvJZ3l97tDx44RBDt5F0xUg7yVb7atz0yxywUWt0VoD20+3k4ueSmfWTqu6E47BAnCKfV03tXgtofX/je9ncOJBt6EUIt1fYjLh5Ut1C82k7SQl4PuHamiQrbqbKZ7XnSo0SCMv380nfg1eLOru3NaonaWOtV9FOGMfO1oWrgVU2bRmS7y8DvmKuaqd0SSvbojCx0BbkA9SlyqaDk2PrDGmhwewbyWXrlvcda6WzQPqVI4zadA490vsLlGG1YPqCNgaiPL3iCDNCkP6HJN68+tHMn6ARLaV1Y/1qcb7YXSkSYh2J5J0c4dTQdULVQt4Ee977TyWLvF/vQ1k2Hn71vB/yU4S3nRP+9wq/a/wQShfxU0Dq5Ub2BeK5V+XmQCfswnyfkricsVPkQ9ZzznUyWAnRHOq/RcJ4fSG207C8duYxUcyAjpBVQz3QnBwpjOse0b6aDuEsnnJU7iGJrmHKvr6744ja/CHKnru8rkPyIPS8N7jutbiPFsTOXEq0UpHta9pfk9pRPZyJ6r6ZIR5PNUPzIEtTW0vy6q7PTsoHYSe51e+Vl51HeWOtMzz51c82bsxEQVOCG0xU3Q9jbRRPyWQi98yZOGGDQm7Ksn6kc7tWIZ+ZZy7HdFKfAVMSRmDilHaoqKW20FvroI17sK4X4EDzlxLHfvcChNk1hFPgbEgVZabdO9R0YGLNDenqchcJphlN2Y1esjCNrDaSR3CN2PubG88pvXOGAU9QZN++7KVdl8PMGXjr1ffDS5vzDvjTjb3HhqW9+fWS65Uu1V6mv0Zsucjfen8lOnZH0iSnIt7y68JRT8IyEYF8B2UfjpjMEP8acfNTyLUYeDfZ2n0qw6Q6ivize5t1Kvw0hfZ7yHmuJuvLbu7TBQICq1rS1B7e1LIWuqK1/EwudWbDx/f/F8rfDwmyBQnk9SCM0ZiYFTCiRB1CeBNu8zutn2HQCogazl6DLVEDKoJaaQet0EMqkfzCX8x6YL7QAvDJnhar6t5iz2mMjh7JUkKIQLLy586VEDMaKXOrfNNlL2rYBm8yFxk9w6fF4AECPhV7fhnJ+lhLG4mnuhO3XqP7RlnrMcHwBaOUheWzdfcni0vBM0JfgvGoxSawVuE8qg5u5gld/AUjR61vFQL+/9qkcBIb68iCVi54WdmQQzE0gFjtXhIbiQYMOERbo47p1Yly+5uiUg1qydsVzilvXKoKtkwtrtrvQ00WA82HaBE+Wr3wkz70Qq6IrQfdELK+SOuMp08Q/rIrarys+6VY/l9rqh0VcP+8oNCTzjokEYxBm3PZ1ed4VR3gF7uqZMNLRxe/AOn3KXxMw8aC9r8krLLd0af5zujG/6UybPOHxs3FeflSPTF06U5dfGifGDoBumtnmtnk5vD28u2FiukSfjalCt6okr3etHWP3QYQzB3YWVn6xHS1hPda+phaSg6JIEtLKJE1Cc8X0DY9OG+1UtQ5wkwl0nLwSi/rOk3SCcGrHIWlGOJD8zULtHcvDbOZs6EYCJthrw4JdlGWfF24kB7DH3+ZvR83mTSpfow7h3TFFy5hXzMMzKpAENxzUHbWoxGZh2fiHrYc5qxWcMLV8qeUATBUE8GKmugx4+pED18iSRWD7jmeUnCAGk1GQgIZm7SXfq2Vi6oeNvlDYItoCfX0K6qNU4ljYcmOuPo1LBX7yVN6vH8F8B4r8DoMUzJFVNb6+4noO1bKnfoH2AbMJ57MipnyPNaLIsSoY1h+LjY2sOUFs03qTjZlGpQo1q+TLNPMvLX2Q76a6NBjQ6ztfhQ3DvBjt7zy0H/vyftosjatjHme5ts9g83CipUHwyO/FzYZM8z0TW2uOpSlZwnORZYgo4SNuq2DU3Ptq0N5GbWSByPWoNVzXOdsK6TSSrW07l8pTsPEOVDUwfPO9AfOmgjd8zXTWHVO49St4nm9/8cTqQi55W7CkaaPHciARepBMMVFY+aZ5l3Xva1zu/i8DvTyiOtl5qv8gunbESXCwr/uWSJFjWSXI8p2ZaLbhYcIRSBODo2B4ulDTgREXUfAESjdjxZoP5qalMqArhitDCQ5DEY8MOyFDKlhpMiHrqcy3UquWHrXiqadY7aDpe1SL53qgQs4O5RhUqoDOZMqhOYMaHF6C9bN6epVEiyGvKmg4L7Gx4RMqHNyJ9XT9KZAvs2ybwrpzeP9T5II3yO/6R+IEh9qvdC6PfOeM7iWO1KMyU3QR6b9QTfZwofsWCMCYgxBAWqEChYBDKLKHxqecDPlNVyPRwRFOuhnHKeTnE32xAotyy0dzpBbBKM8SKIZNoyEHSU/SuchfaPbZlU5s+sqSBfCoyE7m4dLVolzfAVCLTcl/z0gjH2wO/Qq3cTIcKOSrqpBZ3rgYC5TI0rbKTKCj6XJ7qsI2IQ1OFC2AZTRHJgpo3+Mz2gYa1lfcmjzsQMJ2MsPWVLqio7VjLooj/LEIBWe71s34gxhBux0VvAvyNa2eHNwJ80tU4KqDl71nSt8lkhkgWAkFhQm4nk8xrc1PJ11Q1s/QQjDtaU3fJxhGPr5vJkVv7lC+MXm/Lp52gEguYyb9LQFz0IBJypJ8T28JvZ1mn6r4v83hmosXTDeSJtGRoLLl3L93ZnrQQLYil1sVw/aN2n//sVt8S66JCRuzFru0sQZMCJTT4pgU1vVZnI5bkDMLZjVgAmRIkoAWELJVeQj0hQZ8jmJoJp8ueLQsnJgFrJ1sm4v5+DUhYw8OxtzyyPF56uvVGgy3HL+7uBHLFIILTkECHY1FPBKEY4SDEj24IoXaHOYTtugdlON/TwepESZshCp+vcQea/sOPCbPo00Yqzm33FO/AhtrKl9bUz9E7sHLKeVSPDZC6p+vtOziS3vP7JmiphMeOG9ee+/GdIeIcKg7K/FrSut88LxbIpw6CrMyKWPlaRi/bTlS2ytPykiYDjvHWQxn/LFPKcBB4gkn+VoOTe6KH03sug0lXn5UHsQ7NO6VdqzsQcVD+Z52/lgzFsriIqjtiqLU+C81dHxTcOYE4hhAZqpSWzrIgR1Y1CNEyDuMCpJjPAcKqSHNK9mpHpNHVOzYikKURxi6oVQCI9KESTWngKyY+uwFZZhn14l97XE8S7pIGdKM3SNek/LXUIb8sSF+LEs4znMexiWveRH1KTdfu/PIQV2eZ/KWSSZcKatnzT0odkfBvDvMt8YaNJa0wztT1kDp6/URLfKbif2HbCl3IYsd+UTMF6mJumMQ6hJmS6pkHSdB6Y3TU2UpRmWP2SlOZn3XiVVGcf1CFbxN0R07jwwtW7BAHAkxomNKblIe8WpJDbARecWiw+LZmaAOIlyoXtpiKoU2bY2IrwGMnT1W1C0lDSdVMc8Nvo365PHSNo89f9jeLLvbi1w5h2U+uDzewx/oB+1nbUNtlvQ1eTR/dkpIu0Y5zdvGC+e69G+J2coNljEUwaE7ma2fgvLJSVf+nrwV88FeakVmOqlOAxn12khtbaXUWlThHNwUEokc+fg4FKlMlHH64KCJG93wnpKnrPy362vDqL58EYyYjk1JXV7y9zDQdOQYBVRZjvMoZ1doYevxmOh6WYvb5OmCmbmhwx7Nop6GBxD7tnp0FbboMM10SlLyXPmRaQRm7pxhrX2OCPUCCSswnEvr8m3QHt/3BfwYJy2rQjmsKUPVH/cct4Vx+uMaXlDM1o2M78Gdj5XNZYlk6HBS+at2GwjmJs0Nzx/vrZVjc6XsRaHWwm6mhA93mDzPV+s/nmG2hNLXHFtXRm4/bv7n0ZpRjtjquisWH4NnIhWQF+22QxJuaZPsHpApWgingv9wxqvTDRdLHL+DvSdaPBrPCT8ZlJEGoWVamH26mx+pbQudNuxO1Hxd+8vAwQ5QKkeLiSz8Lerz4ct4lgjYzGI2aSyfHmpwCXd/JMezzT37ebyVIL8tBZCwPh3NtP6PUZ3TESsGxga4Ytocb9jJFQLUYhLCL2RiDKj9KKyNnSdM+NyFNFy6VhgoMUfuNhmOBfEGgKPoM+r/BRCFNThgja73wxcQpz8oNVhPqo+XvI6iAW0k2pZiadvhDSYMdI9VKKyy0CTVcpU06ppe2RF98+kdzc/2rR7VDkjWILVRJtIRq+a7Oxu9OOLOdvevmo/8u0RhxFnhoqTqTNSDp/D4q3+SHM9A+bP+1/2sVwYWbANGg1gWZukD6X+ZVnrPOPmjCIz2ZyMwcu27VjhY14qIOhDgDP1yzxz4ZxEY0s/2GIEK8djli1MvGIV7E/4S/BknfxaBv+uhh9gLyHg+cacmk+QTwNQ5I/Avt8V+1rnI65ZX4XaYw6cYV9D8xZ914J9F4Bct/b+dzZJUjBAfeJLyPc3Rfbg4OePkzyLQ/WwdiOkv90D0A/xHYTRdDjnj5L+ZFa4B2FLK6ZHzXjld5NlMuTbJ1wu+w8IssnOcFvTarjEckCV3ErMu8O2kZODBsBFVTz9MPaiC6nra9xRVzJH7zVTmxbxGZyhB/bzIz8nPllJGomc5fXLeuxJKhQDpWx12dgV0ZmS2iKicbVPqcubajGRYFNnEruBQTAkWErhVTjnc3FlgYXJhSanrTWZdADXd1ivsFmmy8j0Ck18y6B33GqAnmJEMdN452ytR/pzyUE18mJP8TD3tV/qVcS2htjyez45sV/MLRS1nUQzui7qMYXSLfYYRFDZvrFBcuGyUnUzxtBB8K6aSwH6LGQcb5rtQpNSFp5aucO5Q+tpJXw/wPGgardduFGS+imCqvHtdr1JqaWYY29lRh8iirke1qEO/bSlIRpnM+NwuYylU4k7D9zd3A5ZVTuRGCxZMzKgvOa3DCFZgfPdJctTEURG5vlgVdiQi+oCzoBLq3fUFCDfWTJ6adc6rTzeAmjg10WRBF1qMb4sdcfaMnXdyTmmZTGHkQaRNk841O6ifK9h7ouh/aaa5k92g33igpaDbv1BmDwMNNFzX4+AfxXkjgSwmCFEEnrQTCz7sES5J5Ty43l9NU55ykkKRUdpysZBX71wuw7rwlRXuNRd4m05nosyqMLGNjqlD5nPYz43IOsl1ubHYz7PheffY38Zzp+rNfZnQLaTtj7aMlEZUS/KYaIbjRjJZseElGb9i1ToVWirOXXlODvP9q0DP5kZAkKWcH623it1RHDl/NmrvZa5xU9zioKL9LQ67Xs2qoYmb9z7bnkqoKcPNutzyWjhHMEScrm2ZaRMdbRZfRYqzWklTd6vnYZYeUt0Oeud4+qyv3xtC2hcllj3xpk5KK+pgrXLqMIBhd21eX25xRl0JVORJ0kOdfHGTi0qXMKevhZWdKjhDXoqnSO77G/9NMhAPtW3WH+AllXPJs5nvkPDSiJM7LssPL2VA3ncCESPD+kS637xRaP2EaWveaPtOfvQTle6M5npQ0rEReWOvbgnbNaIK3CbVsk5/UNYCP87bpAgeoYH8KL6StuIDkDU8I+jd2BI0/lsYuFn8S5ZnT6JWkmo/DQA5bI2AIvjLDnVFSSyGStSa36ti5j1tZE9tshhHuRGNJU8hIDttGu+Q3Yn+jKe3ao11VNA51fKSefI1qB9PtbkZfddqpQyH2XJ5SaSzjW2E8VykOT2NOqZ0JswafYOVIGHwq5f8zJhgcb6dk9x3Y0/SHZlU9PuOVLSPvaYJXa0Nmcpvkj9+JCqkeq7CKglSrMPZZifdOlHGTjvxInkEws1hiCzguH0QSKPrWz5RzLcWSTwaEmddItMJkTvcjUtKrZaBYhpHuYWm9CTbOyws93IMguhI1FvwRJ0aJpCxYqfpKUinmGBNF6vojKfck6UzOw61cJ5pH9Ok7wrc24+ntIJZHZPc8cuP496u9DrFlZfI/SOuGU9Q6s3rkC34EmXi1bUdEqldmEXmNkrKTHii4g9EJB6E4DNQ1XeME/L0gMHz5AkOo+6OmzdYNc6zPG0Q9DVsRDgHJlMM5wT43R0evXNQiDiKQFlyUNx4p0I5eahMyARjm+5aSWR0bww59Xi29JXLcXIKv4pMoYhwCWQpQArDM4osTkj8HBR77czn3OPmLnKOWd5bRPFdb2f25HgompW5cBkRdPVECLF/feeJAzCCrggJITMz8OTi84rIlsfwuOXJQicfN+/x9t8i7znizrnLe7GCpvSm8kXjoPhmABzmS5770F/itBiW1PJ3B2yKM9R2CUUInqX+Ia3JYy7jkNqrIVSYNBrTpoprYKfIWZa/86aQYGYn+JsCRStJJfDYUYy65SwKNl3cMfFPT38foJ6xTH5iMp5R3tJRwZqZ5xQmcno4Vm2neOJMb106YQKxRt/Y5W7vRwc5oUjmYLxlb1ZUXLcLeJYkkic4BFDCd8qSGc3kp/munwNYZpS9Lzb49pTb5MVdOQ+ztxZItnPg3AqMWVbUPP0KLu55mKVX/GyuSh9xl1EOemmLSjeykVplI/0a0mvY90kgeC/oVP7paF8E1M6AXb+7vRyFoWqfeUbhR+Ix7RE2bjnQ2sv74ziODeTSKdbfgTydu8ec8U+/sGlL+Io6/OPFfjJYXsc+rFVhy1xUKBVLkSjFs/m/aGHxKyboNYXaIBZ+jH/Q6oU1g+Ocu6jFVD1cAb1BTMImurxisR9uV8BX+bFT0dX6CIpxPLDHbiF4pZsl34PBu4Pnm18ak0KqNtJjHCtJdHDCB2Ujcgk7skmLmX93T2ICmC6UdOZeU1HPM0+9zEzZZ0uX8cxdcU9f1/tJpkna4yW6Wvm7jEI+oG+Fx5ql8Wfy5Ljk4rj2wDiARGz9LpDS7Gk2qoLXCCJszGB5UHzCbLFcIrSjMWtEFBkK9W+SHPoiR7vz5i1yh8tje0W/2g2+Zt6kQazBDHuu1w8YzbIP2rHL5cV+zxryCllt55ZeWamwLcd7ClxPJJSycYETMhQUGLANtJ8gMq82D0xXlggqbc4wXyz8buYqlZ0tOheJu2EdeemeI8YPdtox42n6HYHX+ZRnNqrhMZn5r6bATG97KRTvX4p91Zy5Y5DoHcTKv8UaJB+TNnMlLt/LiWIqVFGDw0uivUu6bLNEyGR5gpMJS3DhongkSFV0g51LNdycql8sALGiShR4HsOOEBni6t7One9oGRwyQZcpavnpLe0/M/Sn8c5I2SmCC9Qrgr4Dhh6eF7NDLj3X0xSaLdTLtAaiCfVeDdw30W3kXhWD8/Rbko4cVOaWFBbv4ACXABhpFEuzOsHOOci14L8xjWzq0HFtLeQHMqRVkFmE9bCgmDLITADkDUUG6pccecCJedTrLrBFuYwXA1K7K4ws8KQKQf47SoC1q2hTGwsJVdgcxPr4XuDkYWr+iQ7xVGiskCbj4/quiLgRLEkbFGEJRTh8HhxMEQyE36LBjpkxmKEb2N3WUtDRjAE6DWFEbB8RjrM1v+LzKWv4jp8sPu1lozOa7RZo/TEa6YU2RtPSithuahSXrBN5OIEU14pkHEBTNxHKkDVq8A2fuqG+scaME0ykMNMx+iTHcK1g4Fj7LYkppGP0NuuX1mqZ/XGcXFcCTTgtVQsS+yUJm4IppEBvkwhxAvjs4Fg0RasQOKChX4SPj6HHSUD2QRaq51LAsWJwWtXMkWjZ4ZAVeXi5yQtoVDy4rvDawKhmVrxyKjrXAy+CJwMzIIhNmpotfeYCBlJXzTZWTYkSJlTZzFpnEjI9saE+BLWEPq1uFbktbk+tZL7m2LOf+ml5lCk2x/5LPy9vfEEtN1pZcaddlonuEa0qP8pb3QqwLw6lPWQIU74GIRV3DKy0S90UG6chrnDvVyVWuEC+bVu41iuea8DKLhDKgqEwUtkUMtwt15K5CRNJIbVeR5GW9sjrU6fpleYM8alSEEdIbKk+UmYPQIOymuhKIoxJWgVoDUis2COLGZhogIOMIWJmyT309f7ZQE0GUnX16hsSOCI1hrzd6Ikdviho3pun5J99qQfy3uKQNMs5taxMzh/AyoPk3fVAwu1dcx3qr/w9fWE8ptOfZUUPW9h1UXUlQc7yqSBc1y4QFaBT/pWhpbvu/tm2tOwbs5QJi5iUUIihTIakDxnqHluhFHBgNwdogPkK8lJ5gOWAKKEqr+VXlN7b1K5Q0fIwOxxII3M4t+NIi6aczPX/y2S8eJwYlvk5rMChyT+InwA6qRl4rn0nbdlF1DM37+kXzUmE+K0dtaUcm/jl5DMZuVNvZALEd1y/l7Hnd2RGkWi/hrCajjWYeU2shbtT2H655Om826akWHQvldKtXtfWE0stN4mU6UjoUpTLTr3ELvPr76xU276fKsNymPNtO4InvY2hq3kMIwOxS6yTjQiWnstA78rG7clZgNS+JErCsRNlCc7YSVCFNRauu9220jkJM6qmnVdKetY1Kk76St+3iSrgaSe2Oqo4d7dub30ggCFxAMaIU/kA7B0oFTAxQK5UyAM+bwF9WZRc3gHCMqYAmAJAVUjVtwkUiQi9jgJ6hgdfAzrZSf1vC3ir2+Y0KbivGe2Vg4O9j1OYiMXbGVMPreSWCVAXRqPjN2S+54PCKjQ0XZbNSLFdm9NSbf/64VKnyNRyfVjrcobLr5i9xBRWNqq3n0Y+nAIL582b6y8fzLERT/Tua+Rm7UHynltKJFgeeIn1TdjWrzn+gEw5aVpomD7rK1ZB9X/8jj6wne1+KezqwqAuhUHRoyE84EokrsVB4JYEeic7li2chO9p8MAhOHQGLhW9HElRasqhBi9KZtrGjvJuMnVzTb3OWqUiXFhGhwlhx4I6BH8wCCykY6VJQSbcBaZs6tR3pd5IcFxfdSHDjoH6L7Vigr1mIiSGkR1onhGjx8jPAZjFjCIMXE/QRQsmfRgF4jPvOnNmjzhV8DF/z8jlYIUtuSx61oghL3SCyU7B4AUlJ2rXQueornjwbPPTc6Tj4b2C4TB4I9hChcBQEa2ZyRmpn2K5OfPuoOt43YK3YI+AKg4+OPxkMJ+JqoKgU5v1Ur+vrdeKW+iBpeqPyRb8lCdVJxZU0rGoexZG2phQl8SptU9g+LU3VBLIrQVVxbbYVrQtnQXj782yF6ypLOlHTq4lL4FI9sSp1HI5busK2L1PA7uZsyJcwOMF6cyWwnPObTjDGuMmYjYYcn25EJdS/xfQr0rPTaFrNYjjCK/GSEKyMcp/oNMZ6O0CpRA7tZbtN/aPSISjk3I6SeU/tfezDAwpy/Nb7COKUBywTD+UiysQgd1VOMUTGP8pHa1lfR7MYOkQ/NoqxLXk7bDq78LhFzXoXYXvqeMPsmDyetfXGrftDZpjr4gqXIGrq592/NR1UqjhgSwbuFSPssiiaEijInq5u83st++U3qHmle/ZYpB0MEKWBWdRD2QaHAqXWoQKHNvUo2rXVt+8kbJTXjtFsI3YlkFds7Z9gaJo6q/mAFPnQiczesxYSinYO2Qp214ELPWIbetOnu2vjrzUQYcPtAaPKU6ZtYcpYMPXQJst7IumvDNMpMRfqcGXk0cllLNohRzPtgo8cZim6HfnmQv/F5hEWo8Ns1aMVLax1Rtg7+L8CI5bKqPcfXnEDCgjNZ6EmOW+a3pOCNgSOl8Dhl8psVn749v1yDJB3Rl9u+Um8pb3X5ogLgBmJGBKUt0aavjTxFog3AAbRxpMaOo0KuHol+S6O+9yy8UzqwPvqeOlCwm5X45yS0jIohuIgT5gFoPJ3B7evhLdu4LJAvn55WCSGAg81UI5Bd6S4QsiRNqa8urV9UphDhN5b/pglkAzHBGzYOOyg2SVtRIzzxufEBvVU4DHt2MAOz13OdcmG1pl4Ot/CbCMp7Oto6O8mivli7uEHSE1942/q/0IL0UaCXvWKIDB4+QOLPHsMT95c2Or/KsRKHmiTHFNXM1lxa7Kqp03n4q//LOCRirtGSmtWJTOF8/I+7vISz9rw6uVs1F94zg1ouGMjz+LvJ+V2WX/pzhr0MYtnSnv7wIv/ixDMSgt2fL/3JT0zuj4o7jzP9vlRqLIgbWdzpXOc/bvws79brpTrqqfqEPhDLsz2/2FiEpkpnPTOrf/qL7AebNxWnFFUzrV9N+qZEaShiO9cmU90k8UFNeTcleif60OEJnGIG5q34dxmVWf4TijmxyPEV2idOHzicgoen8Gy3uD5TpARgX7MVEqWSDOrCR5XaiqCXe5PqRVYtMwY7lxIvU9nvC6ZHRb3KGVCrL9GUFvdyjojG46Kl7ikEoC677YyCip7ey+IkI/RMjEWHI62Z/JLhbjXen72hiEyhix4jZmHCxRnPHyzi5A9/b9nHvivI6beCD0s0l6j7BRQHNA9ZQiCaV7ZhffQ2LaAu4Hn8qE+Tkmd8iPQMz3jI93zgF0ObJFwOBq0pmv/a49pq6qmJ0noO1SE0s+vw7BlA6kIDH0CggUc5Fux0w7n3Hy3sqFO/orVEU7HhHtmOoBEi5pLl9kW7x0CzqdyA9l0RCb87ETRhakY2EuG9XjRjbE6e/7AZWseyeKfwQl3NF3d9t4gssjqgNjsrIxsCiynO7jtpBar5UXP/wsvNIZXu9NTFcWu/ZOYPk7ETS2Ya8AVfZK6Aa81NXIHZ5tJQU6XfGUe9ssD8ohey5BfgDC9BSFl+v1ITdLPQy6MEG1J49pAeom7kONViJHCSVR7tT9cBP3e4+6dPZa7z3k7HWf9eC88DcwnL24R3ffsow4Ku7dJLjlwbrsudymo+wp3nPmo0/p0tsdgbhJ+PkVRGjY1JTLPT/M6ycZkSD36HXu0dpyZ/L6vKJtv3b5UcjYGTRyB0opO+dBjDh63Pt7RgR5PvjsRWllL8WS86ds23tBahXfv0GVrLlzao1m9nnSLdkj/B6KTri4tdNRCG+W69ZEKP01gC55bih32AjCz+cMmjfKKSwzTL9QK823zLDl9OMKS76Q78pVEvFXOcjeHHXcixzhLnfYVtydyu6fPLzunQh9wpmHL6eDjdwk2HTzxINbxJwWwzw64ThWOoopu6vusxj6QMWdJoGPuGzJpknozQR/8fH2Vg7+NSra1WTSuMZcOvrQVSddH8Sk3L8sVxD7jkPMnmfY57LPu2LxfX4/b3EQ89uEkZ9Dl/6MvffXT8pGU555vqEU9dFcxxTzsXDvlRNWF+2EK6UZ1ZJb9odMafNQ5AQ5hdbeqvmBC+gmpYM1TkagboZM3kp9eOYubvf4P6gUUumCklpzzxO3PNk5qSQTWrOMIzEYsgPadHgjmcicff17ySI7T7ZblLvzXuMuVbaB3zppctsbdpm5A0LCCqnpJqkQ01hj71B4tNGd4fR+NuwK+/WW7prXJrj+Em8GJzuWnx+V5zKEkqN3+BDOZqJ0y8tHWD5JAO+tu+VmELpyRIQ1MCAcXseLE5sxX4lFuhsQS254u+6lsF1gR3Lmo/dW0HbXrM1PE99NjO1NF5x8Nlkqg8YVVy9WYlfj5vFYc5t+j3Ny++layW04YxZ1SLgBml7GE557/crdVCprddzrJ56cJ94HwutfbSi39AHbmQtvWsp1Zzf436ygrGelT2wG28cEYb9tseqTe7lX4ET57RUFOMrAIxu6oLXFS9DfTAkcx+z+H36/enkn450U4PwF7W+LDyBVql5QHoqo3sAeXAz8NfEncYI7wfmHGrbQHt2gLHptifs9LoS5HAyhZVks6oRbqEMwyTm6jWg2lVzBPXJqoyPcN3GX6THJanGkakduQSb1QUqPhzQiZajxsVeQUNLXUK8Xv8BxLPJxSWEIeCcIzE3rczosc9ooRL5i/XMFBIbBll2maG2mx5RmN7etEvPBfw2Abo9NKJYmp6o8Zif8xu4ouJwyvcO8CHeFI4XJbmLmhHcy0fMBnm00binQSLZEyJEJEj29aEtgS4LgNR5XYqH2cIRZgY19EidSo7cUGH/FSyz4hlya4Y3YsKNSSvZ7JsPijh0XsjQMgia5TM7aQmKZlUl0elvMTkZ/kJEVWkkyoXBRRSVnNX/wfg4PDtvBNZ7BIrs1e63Uh2/ZNSjbDarawYMfkFMnwyHnOJWDqEeQl0aPg7I1Apa5r9CwbbnlF9IjdtwAk3tYCn5J8Lh0LHhCWPbYPkBQPGQMreqtL9iFdnSq3iTwkbRuqCFTUBl4/mQNl+QnW0mfWFbUh8dH9dJRXx1+g/Vix9K8+8KsAnD7qmMjOmWslEDfv56X9ed9vXiXXGMBmusGv0HCQVqfFv6SIhy81DuFSwurkGE6aJDDSmwZz7SMFJHB0jZIPHxPPVwOOkguCxLNGWESs8+TEc02n3aUINZMtQ43qKlfrcbafJQ0M8sMKok0pSAFEe+8xn4xUZvAG7tGFUxEI0TbQw0t7GTnnjDF1u8ERImByQiK13pMwZXUBP5wgjJN4gMjB9ZsZM1lm9lfTPl7jiN/LKPU4m6F3ez8ZGugdhlqISubEgp+lB4eUNmP/FHq6zMOUG/S7IAujJ5CEbQ2QufBo0IL6ntGRS0AoPPS6hAEQoT8gx8czWIeME7H4xSF72xBUysbkMHxm7bOoB14z+zqRz5//p7yxR1ztvJ5Zc85T/af/trC7Olij29ZIbLaTdP6vJ4vvfbJqiRFLkh4DE63a2Z9vRyZXh5of3M9tWryyMxx9XnEjDv9DHGsN/IOdiY5pgyeEZvpjMNuttX1rsQ95e33eIe6d+BhI7y/CvHLDtRZbvop+3gy4NbHC5uesU3P7LJGN8uveTPwBgJt0gxgpT4oG5ZQ4CF7i0jIjj5JSjFfk2jyMbVjMbKiRUf/MtGckzb7ZvB+wnMpNQ3wZlbMr3mePwguAi94hmvBoIevTybLdcsyGQactNQ2c0kz/SESHhg3WNwPEa+o9PiAXXXtDGuX3ZohcaMUxAPsavQYOJVofulmeRBJXJzR4UEgu3wvN4aDxFkf/Ndkq3BswlncSp0l0q0u8h5WBhsoxx7Lszhi/Ry0RsrqNMYUJSykIxNYfKwKUex8tR31OfGgqcwrH2ieGosA9p8B1584TWhZNnqCywCnWtcRW5aKO7gfIQf/NXtoNh6riVw2K0djbXlcxikBxN2gE7J+Y22egY5gkgPH10I+swDWC4lc/Pog9SMwnwPcfQnoFMIioZvZlbtsQt/iIXiYJZpadtd20KZ6vWKOmCEZIj8oc+oRKJ3s6mq/F+GoZjhtqr91LewbFlNPPAeE2eAegYVSRpvp640pj3Y7xrBJ30Pr8AfDJi1hZixvloKhZaA2C27R36C72ZKjMn4IVUlNBjUoQpimg0k7fYuwAhwIH3Hhs3FaCgmppAihUwtNdGh3PLST6fs60SAyM3MZ3TltrkEC5BDhiHmCY+XlOZq1sX4nIZ1hEuVrqMxvPw+4EM0cZHLCFFO+yI4eXaxE9z1jKH9wUumSLDuY+ieuFx3YTE0LuJoOgwD86aH2U6+T3URNzbUL9jXwcjG1pjV0offJ6VSxhhage+uIEbuagBKucn0W5+tBVoM6ArZDoOHH0F3Xi++MDiVRujhO5td/qWYULE4wzMTSfwE6yK5dHPal8ZTeY/6dcYolfBsvDt6gaPNT8QxFdF7APQ3wKUR/zUMRGxzZ1x8pmGWk+mZzCav+1jF3bkOWbb331+zH+nCwSzMr5UuZ6pEwWVlvmqpNLRqWdWjhm1TTwek8kp2b15pHtAK6Uh2+BzrlWVeawynMMjitqJfUGp5FGGNjgADwJ2MrNmH3J6DGKSH2d870dkyAJ2v0Oh+Ua4FmbsI2JZhtx5j130MNswennQBqbzGWgEME6DwSBBU0AktOu20CxsLGI3LRSGc+QFao/0L82LMI0lSDaRFOTMWjdcQaHrGzXAORa4YMmIyhCq7nTkLWc3yQgEPOF4sYrTnE2aTZBsOsIEhjvv3VaouPEhtlWs6o2h2V3ube3pjtZ1jJXwMjfpMJh/zgL15yPNbb54Qj/1ua+4NYZHZxyaGx5NAVcupqSsPk0XEQv23+AYdyHDk4NwonC8WRjOhJyfMcedTySNB01yyB86sEyg6hWiusxwUmwh55zjnt6Vdr8tLERzA5l2xYcRccg/VFBAPYU3T+gdquPqiQIWI9oAhwhLLBjD5nVG4BxTkTtqt9PJBMLGPjFaLONyjtG0EMxCG7rWgK9WV8DYsjuGNqC2k5c0UA4EoWxEAilZMciUvcFLpkcRT9v4gjKzhSJ7TuYWXlBTBAPTXBtcBxiKNUHO9R46BeJ2caVH0njlpdXnsyFmI1PhwpKbWdxznolehTn8h7VlQWKBjgAIMutR7OntQOoBCdRWQQ/tYw4E2DE1wL2PSARD1gjbVG+5r4kXSMZmiXLCK0KiTOYNKeJotxbby3BDQn4/VVeRLJUMKQSaYlEyOj1sKWaSbikuDehAM8G3ibVHQh3+lmO8aIxwToFRGnaBsNHxAhBIZGcFEmMX4kIuSamqGQeBx5qICf6r1q7rTg4qYu3J56QRXidjgpiv+eOvxgxCyXZtw8T4+bpes55VePj3gttqmriXFWopLpGWQDI6CVw0WYWjOyE4hhHtwwDuiJQ5OcXrQBA8AQwCbDmRQY7AVdQM71GK0B034xOxFQblb4Hwp9hu+hEx7r3pe9mVUBjInLYbfJ81IC0U92X5ZBMMqdWzXCneInc8N+oyCDT53mlIefKHnZLwqqk8UBVuNwGM/MrhKyBDH9HtOP2ut9zRhDzMHdhyVtGciJbiXwDdgPnE2HG3p3njqYDbhprqVtfFRU2FOSBedZUKFNz+7eKk3aMc7ynQlaY/AgJdQTIWHaQlSykC+Lj22+JAxK8M1an4BdiEOzPjGKYU8jqxoqGeMPfJfOU33oD+raxso2yvegPeHN6YgM0UigTnlemwrnRioVPVX8dVJRdNFPJEHJqv76jBPU5H9izQT1gnLXpZ4IrHAyCKZScvfrcFRtQZoIbuYg1S/VYsdzBSb13Rq3Q88FyxO/cbAsB1LcTcicVcfJMW4bcUd0MYJXWXixVWwsTo8n9FfxyhsNbUp+J87agQcwT8j2QYfqOErTQnYYwdraj2SnbGPXXjGKa51aldE9aK8e3fcoIBxbVg3rpMD3mSDIjnvLXR3VWeVio1rn0tIg3JhTpXCPOSvWlkfd/JL4XC7Z713+vY25rzmHZups9r8t22gN6Brg3AjnVwDaYDZnkRoxyizbOCMWzTowP1ZbXnSxBifatHATAr00dapFSj4oHoChSIlE771BRyhzQpLaOpJjosQA2CtloFZRikyRRsAnisS+PNc8hGsB8eI2bCAfDa2AfvGXQ8thbAVMBwsewI+4eVPDoDbd/Ldt7SgTBCoBV9JfVfSOU1xVmSaFiLwz0HYdh/WIj2SmZcctjrGoucHqrwFZ/y/nKTgzC3ae3QymeoIrJM7TGwiCopDgLaUp+IuS6LaH2Hxsl58VA8ViYWpktTTt9lgKiYu5/ORb6K9uxinwrwYgjrxI8n7qW4fiD4oKnzd7Yu9n3SNKWzeRMG2+xjWZ0PPmU6GXyu+GnrRtawBfqJwIpZ0B8kehF38262XiadOqnc790hkdfxV34WcFBMNFF5884eL0otPWefPa2t7PLpBaTXOeUyc76RKc0fFXcfezyIpru+h6yPrnzpDnzRt1evPv5rum26Kin/YMu4+H3Z4RRTanz+J7VcwzmWdXZr/upuqcxsS5K2vm2bpjJyeCErxJ945IHxFN7Hju4JVby3ID6T9x7dYSXBc7v5Rtoh/+NHh580qQmwmKMlOP5M7x7eZ2+dhmUMkTqbaMLc9AHsDyR6e3dl1E9QlaU6DdDu+a0x34U2JakTVeuOa+krxMOtt0j7CVILdu5hJHmnaedmezEig1TIzKHIVuUzYFjuHuwCB7cdlGmA7+tEd87yGlFGwl2Xe7KJ5a9qIUuOmOZd5/fuF5hMBK18afqNvWTUbWJPp3vyE7J8Qrel3egyqc3r/vPaKEI6grD824OMFGi+hwGYxRNz9TnEYQTfKH9VNPKRCUDpptHCezSYeyrouzRdlzCDl/Fr0fiBa7MKRb1UnMsyr4SOSXreaH3miFeyN9OMpRD2UK44N8emrlxw2EzfXIOVPMZyInrulw3ktKd2QcwksnFYj6ulbkR7qujIrDTVi+n4hh7vDM8MyyJ6DKWdq8d6xj5yxi70TTc5/T9HrR0xVdqH0exjgvd1o26GEP0RfH3DYt2e8RRjytwd48t1FahB/iyA+X0o9rSTO1Ir8eTqJPnBi0ayrHBnRnEFHTVSHtwi49yDu7h/4MoTeX08ISyT3tz1YsVtPBhRYsOiosOSIA/s7ySVmr5EReQqRn+Of09/2UuJB92yMdkxqSsbgejjF3GTQDe0NQ7hzUeY+g+2iMeeau95ZVV6s5cteN8rb1lwlqjnsDK5qWLs187KV45xFsXAr4j6KAEi/bFDuiPQPnvfi0vzpwZi2PFSNTy52ZUSjiBa9oqOMpAo6lr9l83N+BzlGjp1sUfVwVcntMx+Vs6N6LVXds+rozW8eG7eRId524wk1hvjlyR4mRaK6CMdxLfHYpRamUr335bwgod9ZM70abRn7KovQdR652rrDCOxKitaq1729a/vZkkyCW74CUgxqfrtBi1bBVS9sONDHpRALejTD5eVCfLlcCHnY6tPwaAO52n2QxTiYxAvHpiy5Ox15bNQkMaEfEQQxNZfkQMG4VznwqW3ZGzL8lBmuffuHY63jLa2qsgHAMI/DxLMHfu2EzM8+vuMBhDRB3c71lR9WZnREyaIpCOsePYnz2Xi/n0mKkbP3OmB9RzLMgfz+MSU95O01843A6TkbhIg0zH+Vv9oVu6qqNRW1WcfTSzmYiJJFEpM7AAXfvcp2qmy/JasXVSvqNup1nCnpzE3el0WmfHil2aP3cdbm1s5PL42Q22Stao3d39KcGEw5xugrbtSHNPQTjAah0Dnk/JhYW1zZdRtmtOESVzNI/+5S9evZbyWVuPN0CFWMHrIDGQmWGULecrDfGnGcMvXmgqyNVDFftihDISu/mHspGbXraPDwugUa8FO/X2AcSbwLm1bJ/kAU8OUxvBgRkxZbaDu/wMAEDD971bkedPQsV25sBW1oBq0nyzesUzjG6t59oJyb5ARb/ymm08qV7nVM+mJrGLis9PaGueE4P2ASbvrVIUScA9V8jTn/34mSDmuuDUlCe7sW8ootxBuCfh6K9S2yxHzizFwpICynIjRSXZ7/P87T3WEM0ud9uHh2WVrG0WGqZnqALGWllbxMEIoVf+3/oR7CjC1CNRjeF6JX6GdPxCsKi6B0c1nhh7oPvQdi0kF8hcCP1iQai0OsN8D9WS9xHSEULvnnYnLKk77HNPqYU5ZfOiJ6CwrQPgl6wKpG6MLZn97NKutAzBkAjLNQCGzi6SZKHQN1/WkCAy807J489Ak8DUgnT4vj6Ll1D7y18laESWIM/5zDbSWaYK8NeVhgrNMqCWxwcJuFXAcNR2LnV+5eYoWYLreQEAyy8l+BCmemh5QDQb7OeSOlsJn8KeltwbkpaYRpffTI0vX6kyNesbtpi++Gp4ffwZJw5mLiWiuxeVySp+QCPWIePocS+6ZlqFkJSECYumo9YulpBuhugpcFDWapNZBpd0USyfi1RrzQ9RhB8Mn2BpdvbrAaXha/WdfBAkLI5GfoB6bAjGzQdix6J3yP+6Y8p6ES/XHZSVYDEf25buR3UNDtOInrxeobc3Y+lT23ETtrKG8l4pcHn0aw0jHBZ12+b8ujx6g/bdm4OtISX3oFjugnha0TsepJ9NeJWCI/4w9N3QTMDBPkt08c2RX+D2qo4OIrCSzvykTIFalQiL+OocbAIgONDwHfgFoEMRyac9eqzne5US7N/UqrVDupkGARkGOkKVXEyHHXxOB4PByewACPTWsP5UmAQmWviIjwvGbbfCffAC6VhKEpwUH0LZHfCNlDL2+8x13bHTihr7UpDLRzUY1yfJzcF6zembnUDgKCRuqbpgL+VzPTznOSPONShC4lwDSDN4xR/57W2XLP027GjAPdg3ReHrZUw/lQMjYgQ87FMY20O3+MAeEwpX3xeAfjA5p/krYS1iWwTkdN7OzqEYPKqjxGbDInTgSwaLnqHCGm2ftv5JM2oOJT8FOge1n6HdwYsAoOEvlB+h37+CoIZ7ffsQEk2B5GARUDU7F4vrWNCgBEk22/rNlqpRZmMrQNPpv+x961bqus6sy/ED8t3v9M3zvv/PK5y7GASICGh12THY+/F7AsNdEfIUqlUVTwoDVkg9AOEW/FkYF7civNphmekfTFylbmb3a7ns0pHUNr082ebguq5M2K7oV5MrNRAC/Zs622rlktq9PC90b2kQjLGbjS6NiaEn1HpgunmISR4mXIcqw3LosBRd8Zpoimb7E0DIaQQJutqXNxiZZ+ocp4jwzLrGNqtuenffJufp3D/5elUo71YgbOSzSHoNAhwltr9qHBylRsi1ywNxFXo6ZVQZEWo/8ECNcJdIpctuDe82Y2CNbf4Aj3W00rqvy98xLuB8FDUuRShb6Uh2JnyTx/qdOEoMuLxeoxAXetPtzgUjFZP5i5fV3/OKTr9zlDloNFaj8tV6qMkNnwcSU3DEb0RKgBFLlLyqzyGVDvwAlsVCnj5PN+JNR5sIVmM+T4tmSeLnhWeDLWLA0oJSRUX7ZKRk16tA+dibPH3w4AGQznRZmnoGvatgqrfaQX92S0BhJL9ZJFV2v0yNovbHo9rJ2pCIh1VJ2AXyoXKYjA4k+dw14IxxMf9XXnSD9Ydgw7gNgreznq5HdMp1eEdUTOXyOJoNdUG/pO3Zs/8NO538tDBtmCNSVdUJYtG9jalwbsl7kmf0M3EDkvQO83K3+W729KaPDt/RKnGGVfvIX/bOaEja71YkN9pW+DV72BP9ljAuLREzSmSiyTAAYe/bUIqI3ML7hyL+oWaNd08I2jS2HU0mDcbdgEq1oQ1X0F3h7GHTjm3uJwIcy0OgDrhFFTIW2AeYAMh552kgKDDexkGtT7S7N5bBWADlrboGQUpC3SAXDQFGiQ7s3W13P7MeZTCQWRy2fGE6YAQU0uS6SjZNJLhGWOLT3DJSq4uJejyFUEA4Ygq555sNc+Q+hJcaPVMhYhih39hqGJNN6F/GNHbmJ+5/u3EUHaXZuHL49noHfqEMkQJxs3ZFefR087pn2nT4rHTTpb0LsCF4stgpEhxu42zOaY9zVaMBhFhOvs0dZhorZdILUCW1HjkfotKP7mcNWf1nJAq8rQsEK161UzlVKaWzhWVnmTjsg4TtyOfafU7DBITDmLmMayUKKAdeUDe+ZbI9ERE2oKZB1QxuYKxBj8HMoFHF29DOR21I6zuMHeBXheqG7AHTBmDcKb8XOfJ1/7J52op3epkVutuNKuhG6bUbEFgHZVUIL0DQP9B6hUcBZ94Nram0aU9EeOV/AxjLR0LGFnD41gDqTrID5P/sGx6Js1iq1DVOPFqFIBQhCu0Ls6yugie4tqSmxJK+nmmwdra+FwUkwxVQ8egukltPpTTRbcemvh6HBjqzs4YABgiFeiOBnwWW5sIrXY4WwiC5Wc694OQqlmOaDUnrrqMVouuEbEcvel8siQSWWKOhWYtLK7xADdSHQ1DT5ehLqOJqiNOT1YTLzlxukoLGsgugUIEOoElApbbZ7BKAjr4gB5ER6o1A1syTT3e8mz0+BFAhUo/SEkj0MM2my6vfianyNEw+f5iry8IoWXbbmduvp7VteP8FTP7Lr10lrD67Y6arhCQ27ZPqU8Yp/UyqGOee6neaXlAd6h1Pm/jqxTYVdbenxuLvyPgdPDksysyb56NWUEfN3pFF5Mb04QJZtXdSa3QznqW5WyTjcfoiwBYaodH+7d//Y6eDczzV85BHQ9OStxKPzWxsV0td0LhUW7bYtNswxzJuaCysbI2vtiG5mLMcdtE0uTJ5cGFRVEWWNPzfvoJWq4r3JhLMk/CJ4r+WIidjswoB3NU0WUuBmjBN40xiVPBjz3HYqRu7LbY2Bw7P4NM3gPx114RvhWNrpIlw7YwN/fy4k0ZShaGHQuIyr63DHv1rLIQQ9drThvrM6GiI6P35sVzouziq54kDJjJyjROywyycVlq5UK/BUBvd/K99uli8EbJ4jhFjn0qryGzGLa56Xur6o8DbWYeXDVy5LQ7jZuj1eGIy4+18sZf4a9C88ABbYYUwwX1lO5ASVn/br8I5CY5wmP78iPUrqXf/E5eTW87PV5y3Xa4LOlxcF9GetC/balfPGd4El8H858e9LVLF8Du0YP372rn7hgeNgWX0VPdjSTIA5h4Zx8tOwO0G62MkBs3n3pLnctSGCTya5/C8knY6WOJfHTBV1fpf9GZyN7jWw51waP8G2fstjuJnF/IjqJwRN5ncSSntlad6tmIw1Ek3hPn/zsK4nAQufSEZFMB+UVIqdf9GLH4vw0O7ulJ/EejlnEwj5u/JAyZbybE0a6MjPzuZ+RLj98dzMNG89JFonvK/H+GXrsDywed2MkIvHHzXXR85yxl9ChXaE9eLK32uyj/Tadsxtr7BQ9kt3bmPpsTr6zf2ZU1sB2yvmOMd6kb96pbNjvymz6W6kcjMm4+iiD9hdN59CYjxv6dbcOBFQ7k+rP89o3uZKwsj5sz6TenUrBHNA7w6B9doJ+DNPlLh+mkskvfXZksB8wXHNj+o9/N0C+xqDkVNTs9ebw0xTOKk9utri/PD1/5HZHvo/Kq7vtMFYi7hUna6E5qqygWurZW6YvRvJ4u7ZvXHb/9us1pqWpmx9hxjo6bPTFo1BKVkVMru4HCjJv/nMPVs1hH6ztuPkN1Tq11n0jJXTthyvcbxn+h+4Qs8WmDv29G4+8o1Ohjx4RNy8ai+OkJWwa7bTcDbjGhNh5P6HrFni/VaEw386Ct9iJMnfrX38LrgQQZ93Hqjpu9A7qlKldIZ+DNUV3EwdjaNU66nZKQu/kd18tN6Jj0otLmVr1tm1rkDgfj7yMtp3YPI4uNm/96yWkE5AiWfzdDyoD8xs3+Kuerm5qShsbbpWCkpP79TCk2DQHqay2KWBibVRjPqs45Ot5cVCvWffZmfeipCnffXnqaq/ARzWVz2P6esZnLb7RLv8+sym07TM89HIJzvw5fYRjxWTgI5//MpsJS4N/p8k+l/GGAW19+POduMNajtTIIFvBAFn4vP76nbXYEZcjBezgJ7ADhCAiLtbfjFHHxhofAy86PHe0tv3irb0FuKb8tyhN6fs8Jn7r4+uVnkhhvkT8CM3gFT81wezHbPss9JSp77frX54sBL2vt4BsJt2yd/4Olo6LNvUS/LdYi48aCtqPwIS59ugV9y2e7SYirHHeIXs9QhPdsQIDBfD3lK59gJEmbbID47+oBjbeFMTeTn1frKcjzg9OS3fFd4zWtv1W+g8Mz5zuo/HuaSHPLHKfGR94Zv2p+IZHW3/k3Tzui7r5kvazajc5vXh3yXy5fV5gCC9/Q+SrA3FzT4Pz9OTduzitVg0pXjcUoyCb5vR8UzqLgcfrkTz2PoREnfxSBXl+WfJ2TH/6fT5OECMy3OAcVCiFnR5z8VQS66y7Y51IO/2e82VxURVTUqKsdCqwRJ3+1Q3rdUziHX675c6mdO9bc9+XKHp7xkR+oESd/FYHGXxZIyekOgef5fwvgDZ9qdHd2nMJ/F4HusnUg4s0y/AJqvxx7wCsSQvH7a1YjAlsEKnNdXIb/19MHOQ4NQBomw9EL/x3Fwl62DpTEeMvnb5hC0agbINcInHfEyd+vxz/Fr70MFcRzh8dsuQM+ACReFwvkfgRs2B4JVqJrVWqwsy9tCoFZxU7kXHO8lsIN8w3hO440YEeub/RlRufAJs4nAr4gygMcyIcCBt6BGxRmU26LfkTNqUc25ldVv0AsEqhvqTR09IN8abU0RkEpLP1SW3VTs4MZsKj8oLoMyRrtIYdJfYIcKSCKR7ySCnRqKjCo7pniDkpNSMMi4mTc5S4DcZpfTluH/FIvXI6cnJfQFSfgg+VilnEJBqD+o4O+U0vNceIn3REQF1xbmcofgciAsiDiI34xB4H17NilW5fD6HBbHJmQRhydG0doEjwaV2HPEPGvq+98trWO4UV4pVyuhEOkfSa3necWhv+C80+D9iI8u8A8ET9LggTyVvTN27ZBiJfCpKQRvKbuHW3PQimO4DlVAADMJTac2Csy0kRpuotCeo9lgM3xY/wUbiUv7Ni6Bb1DIyYNyi1kjhoJTecZELTcwFUoT0s80JJxkl9sfsmeYbUx54zK5+TKJ9xKPZFwZN3HSdcpSprjJSJkhCu5nDFwsw2Xf9POIfhBN7alrneKdvdPnz+ZHg11Msri3M2jnnZ4sXZasts+Fzdjsfb806qcEpQ7sy93zB2Vp7xb7ufXdBF3bO17Yb2MJ0Wr14jC90+LMVghldWVdcxipwItdluzeocJdPBDO+pssTzyUyu1tnJPU9+wS7+C20UYyx97+2ThOUrJRWDjqka01S1CHlQoSKK9/47grEVKun9MtaMREzsasVPjSXKc2AK4S7myttU/OdICrpZrfXStm6JrDb180ob5AiQZNl+sz01LiYFgQg40lDyNCGLzk+oWx+ljkNvKsL49OyER+gMy4/rSeRkaWjfAMLSyKe2CgB6L+HRj65dKD/9soaW9VgabbTnTI9xjF097vFHc6Mi+IWJ0HyCb1HHWvppWct1Hr8Y2fR3p6jEtDwtVeCO4J68g3uwG+6glQXpkq5NlZ1F8sxsT9kn11LG+u2a+qcBK+4jHD9Bss5JY3kRoCQ4qo1A6dgqTZLoy3rUWs70s/hynk92TiH5R+vfboG5UTKeGUCBUVMKoHmpTBkpLO2tUT8b2bML8Sb7EkUOU+WG2PLfheAwLSqospfnWF4awlGFFVYUniT3ZIn/OjT3q9OgdCGS0A0s6eYrWhqdxeqfXQ8b6fsLgS2HcYU75PpqFz0dqTpXlL8Szvb/LSx00QH1rz+3O7nnwYt1d9G8BJMb2zzfhJT/XubY/prrDAyM2O0/A7lCBD5qrTlWNhXiZzUuzIuyIBEw4wAFiC+X8oUMPYLgSZaZ5yrbTbeCUp8vCWTTfZSZLBqhB9qkFNGZnU8KpCmsJQbSEmvYcayGWUR3qMeLjmpvYdZ4mJH+k0rxJS0I6vzjsK/EnZX6Jexo4M+rrU3fKeghyC8+ir86fpbQTNL73IObrcAR5JQeF1USGOMu5p55pYJMjlqM5ngNE3iZed34yheNZE5eGmMPnCEFqJxyHbewmgX4T3NQtqKfnc3Eu7m5kLdRXYnYDA1rLkJ469eBj7ARKQmgeNkQHw4MqTiwhxgsuLFVqz1eq6L2FuJTGHl2aV0XiJD+31+Aa1fCxDivh4AukMnYBAQ6SBRYNgyUwMaVJs4dOokYzdzadRCYrq2U26T/xfVVeCyxNNNzojRTFlY1uXyRwkqpVfE5RZg2Tn0REppNaGNWuMd0eSSmbTjY10IGzmSYVaVZdMWK7ukZiAaS65k0oKoM9QkfoeftoRYpdmdwJL7uurtOEKbxyfb2vecYKcSXABXZnYeT8qIvOvGEfHsvVKISTRSmdDxYNZpDMw1e0WO6o6UFOOEKhbu4VkPjk+k0u3ANg0x2sLa5wxd2x+tqrAQiceqoBqKY9oevPsJ7Cz20QVtxu7ZybamHTzrV3wz329alESGxgaacnR564ubEIup/u3DeitRwzLySO+yXMUVWfOixpgy1ZG5otCQJz7dNVLRp5wd0+keaaI4JmnPfxs3g4ie3ZdQ90+yUksKM0GjSBcwujf3olc0mPXES5vGJG6W/o+WM3YYTg31zuV9+bN+b86a/E9k2lff+2CW2V020Luvc57+Xybgjx2l7XzmHhBFNcbHeAUGKoREkVU+iSfmxD9I8VjcJNO6sxnLF0ONQqNwRgLsSQf3XPZboivWkcNjkt9XhNZC2pIUhHRK3wQMXAI9sS9UqtjHwRgXd4uzK/MyM0BzV/rE+rYsd2UlbLf3GbKgd7UzWFHW/yTSzgJUi0eT5KLsYcHiXgYSM5xFR9VjeCpmCqQMaNzGLDMt4+gbNsZa7wVQbQ7BTGkBF4usIVd5DpijY/tIMiiMtfhwiujbfkwVG22JJy+NxQXhdZRjDkDoLFUayXe4cIUoDlFSgTClgZ4X/8enYbYOp+pzvQ6WCeWimjQZONRJPMVq96cowEq0meszxRt3kwcium93reYFAcsVmuKslLzaypLu+kUtH9ad99QatuNm11KIROyYHTrZHm36cej0E9oLN+x76LxBwlvxIkYuzB0ieu8AeEmikT09JPFKFtWwKaAhSGAFRZyiZNrrhecrJHthMUSkndplYf9xYi/TTlyctsRKe4tK2LDYDC3jB0uV21S0AzWn8Ci8adLKpJmPZArQjLxWrZ3r4jQPQCA/I7TF/j5GByWWaX/B7DOUV5D3AmLRUZ7UYFMgEThG9/nkCO/EZI9ytOzhA7ACLzUYYDDGM7gEv4iXya5eY8UmXA+gIAPGHzAlmcns2Dd4eJr2V4g0ViFNc08wMlPecPHEAm+skZAbO6Susz0JZXqmBmqrxlagbSesemZsrn5M8U1V6Ote4xqOXYrU5FOZ2NmsL9ARfcxW1ZDNhlvnoApKLmx3ggydUF+UaWlO9Yqo4UwUyi44AlWUm7VGRJNMUkAiNX3DOQIvq6wInVSI0qOcQcWUnlnzGGYhcJYxtSxnPoaJNCSTYq3yGCWwAKiYd7izYhB2zA0mb+KxgH/Xqboyq/kSzEdPHCFY48aFskT/F7v41Zl+uln+GN22P+dWmJQmLAzhXcyEnWxkq5UOMSqxoS9MOtrF5zppZmnNqQha1KOVQOLv3kMdsKrhQxMqLw0amyZYlxm+oizSZKGZTyuI3o4rw3bNUdkm92gJjJp5/JMwfTzBK3ISmxudTuey2T1Xdxs+1nt8Xlti9czGyB237+LcCeu2phErif0/p5icQjduoeAE4vVWa8qXvvOOva725T7Ic3VvsdY7gQrrP4bd/iu7L2z7uwWdxXXj2PPA2+T98EFapclnu5aI4r0lw9K6HbqdTKvKIchO4pg+yh8KrgfueoknTMl9osrdw8LRvoD0TCR9E62irHZyhCk88TQ66AJm1AU74I5x8AvKKNWRQAuTBQdUzEEw3Qz0YW1ZJJLPojrcFwcybmAwgITS52oMmUS31jwL7LKckCS8JD5xwInNAoPItx+SU4ZCpjUXtBoxCvVun8AhJafq0Uek2hpoWP3LgyuY/btoYifoxGLrXAt+whVjbV5eV7Zs+j7xQoCMb8DoAUD2bD5YSpqBYVVitp3HEi2m5rBDRTlJ2q5YmVa1lqE4UyZgKo0LMj3eWkhM8qF0lKmbb6amPlkPsiQngrXm2WC1WKbjoVbgTLXNNBMCU0GBXXx++GOU9qnM/QGHt6T9OffoZSIHIMLsp16wozUopuIxnXhar9qKr0UrvU1fiyk26EMC5M2+IXXlKsq2FPgGqneA5btEeftWu14oboWmFORQRg8ByDRRJ8XcOHignd9FA++odFXTaHVfeyRoc0GGrTmoAk8zttvDk2tPBL4zTxCQxo+KolIEKwFFWchalt+c1w+GWK9LAnvANcUWAbaRAa6MRzTYZHLcvWgUgRnshBw8+yuKIo7hMvcl/3IJ233D2o99M+17XeFiEwC6vIytx2+kZ1ZNY4M6mO7RtsSV2/gqf9HihaK/cz89LkDpYCy2qaQwfN6UNbZI0bi2n6kRK5LiWomqSRKXLEitxSIkfzqpEU5/S0qlS2+cNNPzt9auegPVUAHE81XHAqjdItFMqkKUqNB8xnNIxxUVX7tuqEcQxWSfJpaV3DqusugN5F+c993c8Eiz+IPbsVsqJQWK8qiWCZelMOE9YaRURbyvyKgLIj5Fi01CuJmgUR52i8+3PN81aeaAtt0hwHwRJqzEkrUbEUXrdA8Rz0u5wr/sk4j6xFUaJAQYmYoVsTABvDOJwgeC5qk8u9VX6ExMYLa1A42jQyG35AgRawTYtd7A85jumDhxIILUtKddG0LnRpTbcdLFpvyjF4j3ukDcvCp+yclSKI6cNyJqoo8jFr83v6StkaqPrVekbDDXN53iRO2ip2TRQOv4DKdU7sVmJdQnqb0lm3PiR0UEZJBLPJ1DPE3Q7Ex/1O7asPri/7JT3Uzx9QtnijcL6ivKeZ5g3hTtSqKcjMCz+YesQZO3xFxfhDfx4TDu6GSECB/itT9mOn1RL84sAINJxYuxe7bdmGsZMmTdpCxNeN1q/KUMSza6ZGzYPQ8HqA1NGstktA1EolXWC2jlJKRzW/YmY5eTXzi0n1Y6DcBuzi8ITf8WSVeJDDE+waisKSFDhyAZTZ7GzbbbYkF6IvETYz9GrBEWXrXNQScQF/h4Mx9DN8Eorjx3bRzJPzODagDZCOifCrg8q/meedjibv9WzhiaSIzMHtIaCBM7ORjVbgB6JbC75+xWwkSHW9dvC/YyKoQzzYqy8HQMpPvB1TPFS5lq79RiWYfB0tptkOZUsOIlOE98ksJS0nB2Sg1gvW85mGLNsWNMl6kjqHGKh7cnjEVtAFkkV0YC9mPUrd3K8HtEMBAIHthBu9K1geKmSDdwUVrxKKqgTLIm7vF/nRSmxyufB5weTuz6T4O7Zr8dheaAprfZCdmijyJ9J2GE+qprnnETRJCAsPOe6cks9TpPaldFqGB8g7tkhqsAn4wbD2sEAawT0G3yeBRk159tL/YSSlQM/IHRVW6Ul8FqnpBfRmE3PAJhCUWk2OhclX6/XdSCCN3egfnTV9pDi7lJEEu3353vHmVfnoX0Hyeknq3H7SGRmeIteS9eoaUWjO2N7sxAkb/xcUu7Aim/QxVasLxuvY5soZ6eXUXPUP/Q5an4oV76j7FdaSfoYYGY79ncQvR2cYSWq0Vn4yRMM8nLRoz+FY0tuQ0sRu1uZHMxbTC88JBvb+KPuIup/LfxC+Mii+sK2B8gqT21yKY6UQRHsuWLoia5Qb0cilH/OEIOfqDAmsI2HTileeoEVqwTviyNA0LcobIHDs2Ylgeit8dN+E3MTkPzBwc/RB0GGq/bXdtmSG8vJXEKpzf1q+kGvkCAHyGYHy/UNOl5orHi/bJ/cKhndP8pHfa2zwwmL5PvR+Zm/tbv4Y07Ur0ZBzq6UpqeOSiAH9Hx9jWQTMzbRt8Q4YCOZG4Imj28WkKFdW6G3JolKYIHFxNnFpXUi+gWmzFCEXrO1xdw59CbauIvE9DCzj2yEJfhCDSgyyMAdNpFwgleuS+50rw9ZpSwe9PIheij09wBujpxftufuVCpikG8tq37tiXxB67GtdOQjztYApgcqHZby5iNW7yI0VCwJMvrI2bho0EEbDaBQkQKCytG4FMmR47SU4ILj4CDicFC4wsTxXpOfyc1vcGVPqXAXkGAyp7KW/R68t5tlByK6hcAE4y8EQDdYGtELhmwGEIMQXiIOQfQXvwgVypnP0e6DNMZVNdERwvmsg28zGHaF4195cVy/YgdoewebMVwN1XigJR+PPjasBSNbG0aJ/86bnhqXL2jkyp7D5iCXt2HIuCk2BkKDCvME7bv4gGNV1nY0wa+OpWKwRGHvC5WRSzi133Ue8/FEkxhSvG4gK4Za7jESqYOKQNodkJO4yAuWPQjCYy+r7gWqfbrCQ8ai0cwMIbaeICAx2xMlfRaC3l12jhKpGwpJG0NgLyS2qZ6MKUZtxDP9ZBLrr1oM50izV+TyVjqyh+J6hk1cacfJnESiXjUDEGySHbkWlEzu4lNoCa0qPOPmrCLT2sq2I00x9tGaCGmkZwVpac40c+O0I3DMxMSoOPuPZLZAmGdrHaXe1WUvpTn4PuVnTProueWHy53yThSvKCfu44I4wALe+jAPRwXNKwtFfGQ9iidCUAYmUqV7gqA6c/Pw9qMH4G79qXrF/e0X7MHRbTl0JoDNijRdNSk3Tkn9Q4CiOQVAVrGET6IinVoh92zanOb2bjdBg9qKovQdsMzWpjLIvC+y9WZW5WNzUK9wU+uX3TRxCm8yIpTMXBWy/OK2poumoxxJS222DrKZwNxVs+iYVBiwRiyDpMx0/26n5gJc2mduBvF9UYpsisC4qs5BID41xg2AskhFRz9ty/pWLWkfhcsPv5Vx8hUtAMYJWApVUN9FKqtJBfqtDEaOIbXhUgVWmKYXW/1q1296VBBc/Kd4bz5TEjeu2icrBNFfeDJmOVf6nvFZdj7XmTh33bCHKiKJT6Yp01sQSIGTEbWiaHu7hZNNF50e39RzDikbHVhlpe5PtTa0tGiLUjCoSdVVjw7RVRwDXhsynHMORC5O5kc4v1vDHtNCFjSoR26LHeTei59zoAauYXOAHy+huOQL1c2px5czkqJhjDmuNCJswbaNtWZhTk0ualV6l2JOCcM/AirMULG1U8tOkSKkJjyXKwLXtPdIuIFePADqdKTctsBaRsbuwWTEmqLJk/aqNbymoK3NlU9MGwoq+FReMOK9a+1u3ShYgBTGlrBpUkBOp/hidlZXZoVXP7cgRVKfqiwglgurmsQ5zoHUGirGjjXffM2VFwmw06VgshLCqL7ZM2vuW2oAxhF6qun0LBgpmVsEjelwMQ+od9lRKKY51xHOpbqiNEjEiU1SGmCuaBiF1Ocv2c11ZnZutfGGbtMIn3ExhdoKYpjA0KW08n24FVUIdFbl0X92jUK9p29KR7Fg064gUdiABZ2cogjVos21fKy1tTszs+NLgHXRu6YCsP+xAJlVsJ713nFlRNucrDvXpufTA5QP38UwG8iQjpE5Xle3roS0/8kxYce8+1XqXd2dlrh9ssKUn/1NjFpo66tmrE3VLH8ebmIGMn9v7FSinwk46Nl23qhgk5uFfKvTdAQqGWp1rojlvT8PSL9L6zKhJTXTKVWo+j+cU6Vso4esQQsLL7NpFrV/FeC9q5MZ5eGoseUAI0F+th49J8wWzS4UcOiewJbuHDCI2Y6iLxJ/eYeSnA5+aawuGDnYFXJoNECdhwLJSpcPDoW1d0S3lsIbBGPdoq9khZXPyjlTdnmeCsoQXY2NEdMWWcBgLtzDfD4+hyGZv+pOFbmzf1UKPSHecxG2XG896Ulc3d4O+8jopW2pjfxTLnrAyI02d3gJOl4iwZwcvdaVK6dIqC7EZi3EB+PNq6m6uY4v4IDYti9ZkHTlz4iNF8ZyaW5ADTwVsN8UimFH/QvCrHwLrASOcqudPAwQYR3PgChQcUtfVvVdzFCIcmtnU1LmxSiw9cvWkV3upJBIAKEEXkvLc2ITnORtmCwiDO0HEWHw74VwoHJaczKJtcS2uzRQ31Ux65KJzd4xWPtkxfwtryoH2xJekV17Si2hNS7Eh8RtFcl5ZfejR9Z3qLXGfK8gxsmmSGS1Elgqe12munqnOQK08UcrPUQVpGukwpqZMf4FhIZdBscx2UteGUGZqDR3boKYUuqDbIbNu9TgPz6bIQ0GFoz8iQmImc70Y+1EggOxyJEZTrY2aOHHCj+6t1XXF8RWZVUY3edRJKqOOhVJ+zsS5NWgHocIesK6G0nLiWVmNHnZNaaC7PMLpxPKKAxmKofQj4eUJ1TSzTQ+8m0j1ZNVQ1N05KsRJsDcWPm/Nf1F6DiCijOdukQQvX9PsWY1tcVSl5ZByNx56fpCkTl6iqAeYiX1Fk26x781CaFQXmWt66LmHyWYPZc32ql23kYuvh5u53Q2N8eKgCg6JvO7FegJglnrjZALvLJ3S77hC/EblRMobQWspyux6pV4HsKjrfXwDkcqJeIgu6oq6NkxxlOX5iTjsBNnJCs6BgrzkZoCMKVWO2oyoEU/nrrcQx9GmmEOkHqbqUpJOE8XKdU6Krr93/aa4Z55891gXfE8IIjhfW8l8fXtqC90uPC0E7Dz3tv2I0sy5NWxbJzUDKz+Vi9D6pJX6ubgEPB/qdu5xvsjNyfv4WT3pKkt84rrcIwFpZWBEU53QH5VYjQmvQI5XKl5qhNWZhfg/rTKyMnOOO5R85Zm7uzkIV8XRDX7pgqtdwWAarCDmfOjWNgir+7dLb+twrX3KUehd6TaMCd/It4q7Ns4lWDvxIHtr7AGDuhLzf/BJniRc9f+ExmZUmDjZW0StRpYqfKDVRHGAdrwvRlDYBMwVHmXf88coPIHt5iOXi4noNQ0AWai7BorAYmYEjmN6G4Z3Qu9Qqv0Va+507IzzS+vGlKCVFA2w7VBuFbcuN3E8IfGFAoxS0567ncUqzBeaAwtxKBAXIWgu7kGOnQq9sA8zhM70g1nh3RNUvWBAGtArkGTzM2GFC7atSud7UO1JlKAagzYxPboFirVGCxnu0ZKToTVYpHB9LpvwUtYJoS4MXzINUtA2uzDzQ2s5kszBct0vYWzuqBcuQFml41bfNutcQzKcddNKpnDJhfLmdMWU6ryMXRf6WmoMkTXhicRvvBqiNGdcs2SU6qUOmAvPuC6mu3NH4jHLDKPNDp6MUeZ3FHxFjuFAK9aYU9MWJnBScyGzfLppiEKEqPx0nIy/Q/FANYULRw9v3INbe4ViN9FWaE33jOI5XV3IjXfDIOOt694SoA3bzvY+8Ryi4kewyIY1gxpMEC3UzyP0sqPaEJUvFiN+iAnaRqefltBu5W81pY8yY52ykN/IvCzYtCteqJZB45h5iqVu2fAUYpGwOqD9O7nGhoaIFR19BSnUCrsb/Gi4EXbBza/ULKJVPiStpUuEYNsd9jlx1vSwHOQ8qdx3ClM5n34GFY3JHYs/sxQCN1GKQRIGvxy/CslqwklZ2KaSwl078ACKVQENBlxZh+JkLbKiqlYZpPiWtSgYfODTGOhIX6a+FnK9ia646ZlTRq5sG5HdahbG2il4HDhkvhw4lkMfx2ySwBgm9U8nzLg9S26MhNDOuZyCsJvgUBkIyFi5+UKY5z+JoY4CzF8dfZ22Awnmd+LqoA7Z0mwdgzJLJBB+8LLNC7422LN3vKZ/6lTb2Fs5sKo6Ap/EfQaJ6WXacMt6RXe/GFwe7s/c+0eoqUnTUNq+rKne7iL/ju+ukYPd2+IPVdx223WNvOZbIpgB5xgxmtRaPZls3VNz9Y0ETH5vW13+5PJ1M7vA9eJuiwXuy7aXeTadUILEo7S6CD+YH4kTZ45VzNGZZcpSVHfDHgrc7AKGX/lCOX2zmzp1DYcoDlZtOf+Um5Z7k3BdwBWqmhQCCarYHDaeozkKN2Hkr4oMAlY5KW5hn2GDsTLwjCd1yhXqLxhP0XFX3ZBAF5yyM84Ij2aP14YjTtNqSCWqslDdA8c1RKUCz7lnPd6LOV70vyNNbA4aadqk1tSJDUhjlrQ3FAZA3m5uUwDh7oZURi6qGJm06YjpFG94S1YcjS9gAIUayNO2EYwjHF/mSe3s6mW0wD61ilCXwqayytHqhcKG8KJSjFGYQyHZ6IDtJ1QpDsiQV3QqU5wGAuWR3NHluwqmhAmrC+Cho1eA2Fn+BTYKHKbB572YNsxSkXH70C28OGqjP3YImph+5gw8aMFk/VqNjUKmsji2VjVTkR0n7SU71UjlPxTtKNhjae9Td3mfAUW1DNRL43fB4ELPhBMxsAWaDqtUcAdPhdjYtv7aTC71UrE67HA/Fh1/x6BOy7FB1gqGBmNAQtAF4imSf6hQzMY+CYMougeCgEIMUZO6RolcM81lsQLA8Akolww9DRk6+vZMmcI0llOIS4UD7ZfYqF7eD5q+EyLSKwZVRArTwWU0Wpt2gNKah++vQIvmIDaU64SVvhVvz0CLa06IEuSUFUn/0EraaHJo4Y0Ip0kfOUSAii7+oyc3ICM8lCqbtiBJQiyaWwCOFosANHMh7PCTVCmLFG2G/2ogZvmkvdZSw8EY6ADX9T3UYyynW+IUf/+3i408l39nFFazcBR+eaxj+mU2d3YHZu1+ZxXPHQur5RFPqiSOFvAmHT/eJOd1IyfNEgHShH9w4BExCEXBEGITWhd53q07bzWPLM8W69OSkLTEdnQFtp3ST5O7XhZRO1ZUdHDudzDqY22aLN/MEqZ5KKVROXjAgeS3jsYoAoc2qYSK0HYXKKOfRhuh8LKFzgxCuXEUV++qKbGNt4u1Ok67Yi5gpHj95tThKS4FvTLOZBKY5chE2GEyCdqtODVVmccZDPA9VMUhB5sQNBgDli0/uOiEjcGS1M/whkw4Bgz55ZmFjj6gx55NN9zU42/BoIkBQIokcZEJbuXUsECaEmqsQhWCyltwUEaNhGlmKpQLRCUK6fhEE6PuESWd+smVM/mCR98KacwvekRakHuscL5nba/16upEGfZey4T7rvXoccXrmkaOmz0ty/Y8nyu2g42+hlP7r1Ti/linr5eZSpfmq1CBNOkhXPzWm3Ka5sbTJMlqpwPUl2VGdNtlCyoVMUGM/IvqjiI4sOkFt51zWSZ4mZFbKGu4V0CTeoIrLQkze1BuhybiV5CAqI+R06wssQABqc/D9EyhDcpXGsY2sL/I3bMB09THbbV87n7QsylolCShLImjTEk+NnHqcuQeySGw+apHlVgYWdT8OeqgJo/pOrhhkEn1EBHDawAbIJKq+oTQaaUSWozC+8DQxM0Cg3cI58gBoIq3gMrJkQAVJ91f48AiyL9ySvhG/gUCmLU4rXXlf2pVAfewI7RiMr8j8SvaHTM+lrRcgHRABMhCRTYC6wPTNMv1NLp/K78Nb/KchiFY2P4DF8SPg8yRgC8VMokp+kk2t1paRWIS/BjcthwBuNBoFYJjMhFLCQMdbjY8YeJVdFoU6LF49ajXKVtvAw3bAJmBwQKFgmCDuhPFo42g4tMlz9K/LfQpImiajBMl9GHFoA8dR7Qver/+0FP+Zzai7LG05eKSCmCJECSi1Oa2UUeeiIKdOABm+qgwRcoBeCvNVj1abEciWH1pVcg5wi4B2QMDYtCjc7RYEvHB0jWBsARIULQ5w6CPquNgrym0BAbwmQD60RzuAprFpPDlOd5P3tTPkGSdOhlFsFz09/wXLXvalrJuLH4iA4AeF/Uql1VFmYcRLIhUAa83BXOS5iNV82N+s2tCm/XQqrNr2S3/u4jOT+Zj4FiOZu5CCgdqETGRJOv7+POvJgWuk8acdVPsTX/GWOq3i3J59jONXIgH6y2zckgWNFLs1IwR03Zbu7jiRRinR4iTdQUgJ6gL2ElzS2JJa8bMGjia6e8JlbbVvo4olo+6sIuInlKoou5n5mMMFRB8DnNZw1ehXRPvKYeg1W2h3YZtuqld1fMz7Ef5ocQgP/CSlnu+9gnFxDzhgH7wm7+wCL6Pyp+pw+9EOty15RQsATJD1r5ANJzDHU8zO/67bYIE4AE5Dxr3mB9R8Dy3K55eMJb6+Z45EfCGA9kOoybyRkkfTX5aCRTydd4K60Oi2EwNtEeRmfvhMtHACgVmnNQzZq+Bbttw3onWIrcckabFOSUXg0f3JuueEmkhXdyl1uWrbOhooNn0gy5BBAMahQkIgN9aMHCPl1pigAy48Y3LnSienoMZ/GO0m6pYGpWORTliLvneUXPd2JN9+l44gSviZPmEaSsnTTtAvmAggcRmAsSoIu2E6YCyMQlYwaRWF7Ot/FcIGu5+jhPW103tU9mDeN2WxdAB2FISGkwXrAtKJILJPzq46Wb0Od+86Vg66rIyVzm/RJ5v+ewJFHx1Dm4thb0+4uSPIvCHVnxOP1PtVGc5iuY5qmkAcLcbmRzj5pQItJc9jRFyfqr0sVWWaJzMZGhHDvyzCATV6aIRaEnBL2LYji1kDkJD/Q5jR5z8VQQae9mFNyt3iySGXEhDbfS4kXs0bk6JQOWu2xPXkKNHruGirVGTce6Ikz+KQH1dK3PoZCnq8nEVyZjJd1XbmxkR+HcReF23ak2BL811hKI0KFx04hrdiJMvR+CeUYh4PXxfToaBcq0JenFh783SUL00E2qDdG9obqQoYswqeXZ34QGqslhKtzLdkzFf13YoOwOCHzzQ8AoNDKqwxopymWKLWpF/6LZxieMwVTiVXkD91GYgRfaMb6zA2O0SFN5MDSlD9US33DaQTbBPZKTGpibMncUyQ27RCnJrSO0ZE9cQuUDfSYjvkMGUICPznNr6hl4PIRWdwltZU7eNsmJJAsCE37YfREqw1O79IG57mbli6ihU59T0aK+iZBwJQ7tZ2eYkkwwVp/l/t+I0symSjBkWCKe2sGxeXWHoUdCSEhm2iatoIny6iEbHVvO5mXMpcY+xbLOI4VmEcrE4YBc+YKVWO36Jq2ROt2fKPwa3RcqR3do9t2/EBDdi59RlwonJyROJnIB2ht0rEAoV45v5apFqKQ5jk9rA9lwkuLOmVx7FWWePDGzJF2fznKSwzQc2kuG/qJAKQR/zkR0BowdD/dRecdqASb12eOgDpkg810TDuCkaQVLUM7jrvk3bpShG6dl8dXq+7vx0vj5anHZQcXxxpVUXFSv7buein4uPWuf83YEpa4S+ztUrm1mQOOj0bmK/yuL31Mswx2CqssxzTWos9QLF3AfT7cu23bX6CrnNvjszw2dUOueeVq7sGtR1kxoPqc8+3DZ/ooyHasRxX+sDNZB0myivqT3Dg25KqGeTf6BH0gNb91ko7dDNEDVspE922biRb1ZUWLgvMy9KIj5mN96qLgGurLtv+T/Am25kenD/F09quaE51eno0S2VL2wLccvnrCEs6mN82w73w5MF8XAxadosrp8VLtUWga2n7hjBWu+sSP+JPsptkoombCgvFz4piQaksT4flthRypldiyx3GvIDSzwfENqk2/Z2SyntFIJ71ha6FiuuE4XtIh2ZiuX8/T26HBs/i7Cgxml3crYqM4bi3VsSR2euEfsTpqyPTt/BJ2za7d4F8qQmfVdKVEhLeVWXzXWhbOf9JVNkYM2DVbWYF31cl6KsNiOCzmz8WZNQ9iS1zj72V7PT24jUtbv/jiVQyX0f93b48CDcJEUBz9I4SJqCgtgVw6ES5LY3u+auFHedqJ+n98ippgEHnCtC1eok+BJy8FHFcvWiRJ+4MPeLlxRy+qwAnx16kBC9vc1CiZ0EuhTMSpz0z2OY0LTpztk9B9tIS+eKKLQcNEkJrBc+1rYeCl1cu8Y2vTUYeIMJTFqxQkgTL2E50zAsohJpBLUEZyqK6D4ThYbDTd+2CRiIt6M2Opn+xHmqKSunukzQKrWjSAN7Nlpqnqj3OxptjrbjUIOrEL0Vix5YAQPirUqFC9e0Y5EMSq3shkmB56sxseag+NZgrYsfGc3bqbuMS4kItweFWrHdOMRo6pPTDnDBLV9K+GgZrscth0TUqTdetwbNFUfVSTpaN9bRjH8jebUWS0h0uz86981vdIOXsJ6hizwQx2xW5si3bSI3T2uEe5U1SYXdRZNGmT+C6ETKCKmO0PPgdNZMOvadYWI+BelIR2pAKp4KqY3qjdldf0uZ/oJyZGnnyrI/qCbGJ6yPPPWdUtGEIErOu6NGMhNLsvwOOwa6MQ3ayMksgDBZgS9HbKkPtO4979vPF9Og8FEqgoAYDT4gvWPvlfWbwH3Tq9ezyJwhExND3tifvhL3HGhx+NOdXH7fFdpdQeT7LjtQ5Uj1al6ANZm/NMBFvyOU9GTh2iouPStzFupInOUKG+hF5NSYIq5nb+ndYdbxSvRIQ6fWQlyeqr03ke2lzQ4VtNDqz2937rUc9URjwwalWIdGXtCr9X7OhuEh7i4BEUlPy0Z/B6cENp0jhk4cuwGZEU+/wvRkskEb3xJoHUBZj73QVyTvFTd9vJX0YZqTFFZIHno32tzZBn7GVnHph5y0UfDbDArA2RSSCj26ZTPtVyYovm2A9MKr+pEVt/klzLGR+keQNWPVSaHaP0pYh52gQ09yG0F1bmv2bxf+S27Jx3DZ6Uu8Mkhy38p18eVoeJ0WwKnHl/DWBy5w1yasE2W0etscyNaFlNeCpdFfG/P0CpoG4LuGWbBUaQpOUjI3hP+JVB0c3TctBZN08YZRk6sMfGcBXClV5n+YLxkaCwvkc2PRWs/diSOaGmiEWzSENX1n06upzkL43nvzOwIG9qCsgFu6OAEghGotzJcAPsOmkcC03VTZJI/BGzwSyQ+HEKDGZuQEORK/hgunxiRZpEDaAAGIjUZ6rViSWtxTc0ZpjaM3lJ0BwxguVbAtxrslAYqFJXIq0eGx06s0PH5c/q1CxNsnP4wOiKAEd0r6YeUXbiDfLMV5S+eXl7D24szNb1sOlx+SWLbHjpRgl8eDYy9WHYE2TcyKZVCrmx038cui0eTumto5VWxh9ewNI08a/mpErpc2wIg0Y7oCv3PDiz1JpV/O7UiYS1GZHUB6UP53LMvdMRE7vcy/SMpq2ouWONn7itkoFaXLlmyY7Dl8sc3AeUg4WwvtqLAwx/RCLQh+kV95EjO6WrI0z/onbxVrkr+DDDqlZzyIc415cH8666XN/csNzIdV75/hGsRjaWXlbVWWqrnpITwaJBQm/jYCNo+AVIbwhfcqNJWCSzBIlOjkyaUsy7Qbxqpi04r2wJMtPL+8T8Mxu8Ulu6JkoWVbc9jzUnz4ndGKhs/loeLRL6+CwGLBJkhxYhnb09jLKJz/msaXMCXcJBGSHwYy/rlYCNifjrB7duXhIDqLHISSJ8cNXKa9pkOigRVFlGJuDRtO1FEoaWgvXuw8xdNuIrgnv1SozZbQtBwZB1nSwMNcUKFYBfMKzWkc/Ms1TQydw0wPDmcxoVHw+aiLEJ6A0Wfi2ceaCLtRHgRfQ1NPOMKGWZTn3QqU+h3ypcixw0uWabs4+9L5clKv0WV2YrYluJrITElrxedXT4dXmbGUjSgO8pnx9KwF8TIxNZvMZXFn4tKuWOmHyv/+e+pBuAmjH5pbqINud/F3GixzDGVbvp8MvS7BjWSBu9FTjPs/pbiu4jUPhpjlm/VgYamsbzubwyoMIEsJLklp5WTthoP1ZXXMKN1LhB2TOFfR/8z+gHZyMPDCWmXkqGUJtd+iKlhKFr2xX8t9eII3KnpvQ+oRtmLR6N4oKYETgKqZgTasgQ26JRigKS1MaZH45AXX3SO6oeRHhbmv0EgVlZbnM3h6T88KADG/wWI+olAERDyEp8KNM1TvtBw6G0u6iaullfG7aCbW5grhZ04rdbB6Xib5aW4fymRdSgMtG8cN2FRKFDdvVvRc+cHKR1lpLOP7SLVfnldpEr1MJQc9I85K7RNcgBu0oqqEQnkG92oafhugegLhmVwkQoYNrwDsuoCCJuALTliJESxMuMk1TYJ0ifLwmVZ0SMTDAReaqOlguJiNRr4mjDHItYT8l++exRLdy2Xyj763TThw8FUuNb8O76PzCSotZgmOHBoUPWJRv4MumIPgwrJoReVFsrctOoBUe7sTPHoLumNHiRqDWk0MurKWOxkF6zSJydUFhXyHXB0ZO/kEpwkfX+c8mEri7RjomK15q5fAbjTLh2gt5JL2UgsvwA1dX23sHuVKi9P4RyIoHavjZYl9+yp5i6p7MpgO2+gcNJEESB7LhCxxbbPQbQmEx8KK9EQ1CzQxIwbyJFk01dwlEidKll/T97kkdSFk5UWe0UcGJhp41zj/LrSQXHUPG0E9LQE2edUKOvUMTNHu2BnoQ/gdDMsf24NcdpQmFUIS1+MEw5Nw22acy7Gcn+Y30yzH3qlwS1nE47wH6008HLmWFzgoxujmSclTmaPw+A3Bw+0WBIOUCNhjdJu7S8fRbw6kSNEmAxQ9H3PJ5WYx6GRzts9PoMC6oVduhDAvBeJh7Ovx8yreHOZ/mp00xgPbRngu/s62uTPmYMgsYiZEAE2RAvy5R/eUVY8KH28690grocg/MSpbRHRp+MeTEKAVxZApp+yLvC0k/yMttwHWB8phrldpodZ5EtWScJJzUGp4SHcHfE857oR268uwW67HZPIr0+/tqOdYkho3J7+9/cHTT/B+/JXT72Aqs8tGGju8kf+F29apXyrLDZ60KEc5nqqfW3DSeQ247BGQqKDfauPEtnnp/AptxT34Z3hn7avRZFyOHXSFpI1e9kJGqx3r5y79jo5vn9A/0WbyK/iNLn4zoX6Q+IHbiE3mn7AFhC8YAa0uQIO8cWvTcMyfv+0RO5DnUbyDKtKC7+JUh8a0K1pRjaYSpR6bNgWyFwzGSeDbWpZr1uUasG1tYXajgI/g9dUt05p09mybS4jxd0Y3B0lyZploHJlK0i8jbZPALDu8TCs322tJspJuAsqa3/Z8pndzxKadY4q0rgHj07M2lkCNE8Ro6HQGPYeL5DoAlqwKdxaVU93T01bfd2Uh7NCUy+kp/AwwEI75UcuSmShVvJYdWbpN7lrbsSRFZoG9312jtDwdI9qQP0x7m4oo5bt9W2mZI2AIrGF1g41zQQ0PJjiMnaDgbOp4JWK8CJa2Yz+oMav2NxsQrMEEtFr556Ju9gS6vJa0UbL5ZyJEH4uQJRUOFGp20iw19LZGPXHMb5g/3JyChEQT3e0L+YnwvR0mtfZZGerS+9/nCV9yuy7wpgVf8ztm5gf3HJd/RcvjwU5ZYaMQhC1cWp4865lBpodNt7LbQf7ANr3ACuSlJWvTpIcdXFHuRVz4rvz17361HXIC+nesTo5GzNrqquO1NbfCC9l0VX1bFTEMHDMNtijhN++DSAH99MbKJ/3H7eaO6jba+EM0WnXMQ1m8WrzbHPcyItmFqAsEksMUhgk06IzbOEowTYOlCNa26LnruIchznHbB4bEIKKBSeswuTW8O7cHdSj+vJyP5teQuGKJoZ3ku0cA0+bJFME39V0MdEurY6ni5ihHiq22uj4EdYoYwFSKNFaKMLF0mNwFXYwq8EJasttkgdrr4fxMm3SQjb3CazAdPqK39kiNjlv7rFbiyPw908uqz9XPxidpKuz3whRLGEXc3QCkFVv2QcO5Tub9CiH9kz3rxyj6GVGTuy26a8+ErZ+c7kvi0YXZa2/b5jeYgpUNhoJkTn6XcmdYQcqoLx2hLwa8hVLwHiyg0YH4iWvqpwbTFKkwVco/Uz7W5MSH++0G/Ukw74odQBFXjh2HSSdOKaxekwkOO1q9Uai2zH5dsR+0hX7C2JksCdx9wiohVu6tZ2lTeQ83iZmEmwqZpUSTTN2GuCm+6PedQ9mSgQy1uTlRmx2BNJ+nl00rouqb00xdmrnpMTX75k3fRV418Ao+JayxzAwjjJu/irzLqo85Rp3ci5fqm4z4+LPIu+xeg7nPdHrit5kRH38VeZd1o+qbLHZkI+f9feK7topswfvdFHx6VHx/F3nXtZLRd7Q7xp0dkfenkSfXjbzuuB0H7t8H36DSrxmVj+z3d6G4Z0AhY/XjG02PrM1u5eX99C5+2wvB7cQ5GOds/TsRPCvd5JfaiCXwf3cLvNs8u9MwpvxW9GwaXL17pBMyrjywHtQzT42F+ENo0dSoE+FgTeeGMskXepT783p1h/8RxZl+QA7GZ+ee08s3ies+jaWDCiuEl8eUuWfrQw13nXMzl1k/3/qUVP97GYcfU73k1qlGPKzg67X8ZGZk/MNIcsNR569b2/UAfBN+BwBs+5qOZ+/oSsIZXwvxtMssbmiPfOuEk48uv2yj6svenng61xYj4l6/d+bKdJnuo+Fdt6iURpidf/ztLt31GSnqVdWu1w5I/+Rl2ifrBXZPPu28J0a5/tX28GUMyYZq7ePo832s++Ve35OGVr9oLLryf3uQDfDqL/LZi8CS9bHXWa9i4yopJrwmzGWXfpAu/xx0GPH13QnpeZEqB0vET8YUzw79gxWaHr6Yl1qwedsr+P1tjexMgL1v2Ii/85Od2TA12l7Hbe5OX4nHTOL5b/XiwibQZQfUISPFfQeD3Qis+hnHf97Ebj9RsRbYWorYB8WL9WrsVj1b/NqRyUbq+suBpH5d/b/Hbz/VyL5bvfYbsD56vMhaxpKPD0Y/+s3/FKY13wuvFXzj7eooxc/uh9uhjrj8xgF8z5cdk6SvUHFenoR3ig56fRa4u7/U92yadhpSO216pNgfgrppVpUteP1kKvDu7BvhM27Oe+McFPCN46z8FqdW70f8T6aHSZ8gzZ2ejVsF51YHZPEgTKbGgXn2dry+B9EX9dmdUIM9kbYojS3xYM5eJEdbF2iLkW1/nmu6vMvGrNVlqDGi/Op0ck+Ntt5CHpAFeZiCpz6q7DZxvc74JTx9W7wr7M0ItL/tGPf0kXIOWWz7+KhoHPeib3qP/OQ6q2eMKv/rtKb3A/y7ZZOe8ynShhmrHBi8dsEWR7B9KaF9HJYbc96m54rLEaXUQzBt+zE59mbqufoj2n4uI8pX+t5vsOc2UbNHBF45H+v/uE8a++X/o/3vnu5453OevnH/ZLN8Xgj2186StqjcOniOQOtWQbDdyc2q/4XfDkrzESRbXQSdizMYfcU47qJxGFoS29zw8v1dnMzBfCF7vOpwa3zd4SYwkvuRkIrh2Ft9ac01+a9RK5dr+kJvpE3eE5qWFqb431IKQBcHXFMMloS62JHuarfiDFBU4cM8037m5F1XQkKEb20OcnoZeFiQwgFVYKmUowQCyRJ1fhEh38lDmd5TSBmRlJ8r0W8ekuIWxgU0RU2U6lIUGd/Gz1bxZ7aZ5JhryFJ/X/S0bNi3+5sSf5gc2SzFIvS00U2J9HnhEUY3k4KaeX0Y1RwncLQQmGLEYG5e4W0Phz5c84SsAUFtWPsZTR14n6MEvmxWbj5fc0dHwJsP0IWP9paUZeho62/Vr83GV26YXXTYHB8/45dzrHxweolje+57lStsttGBi41X0eU2VUd/cvMztb9nSoFlUxEWffHCbXWcUA4hFCO84/L7uxseRQWR91jnPCFfb+dmgqIzPueJOl5UkTaAmrbay5xpdlAFhbaBv2Lqd7D3XdoxSTFOKL5+phglhI1GszT0Q7KvzguxHPD1mpnpNBHX4hqZhLL65WdqeK2fhTVsBHr7iXkIjjbBUAjCw4cnJwrdvdgcODnPUOMmKqSRqjuCiCteg7qPypS2ZpJo0u94ypqj58zi5yMPZFMMhBSLi1KNbPOUdczpKmd6nBOaho/akjRAt4WEu6ASyW98WoQEmPTlaDE0HJHY6AbrbwJdTx/Y4aLkCNUlFMU37SdhPGGay1LwMtkvpXgLrlm0pZRLJfiMJbg4wetd0z9MXrCwemF9+Zl6VR8dRWwEpeWjlyX7+cVbJLk2FUbTu8h1ikUOll+dS5d0HJjuTdf5/9XMK8Vd5MXS/zvgx/6O1Ii4k4shGKG3PZp9cqqRRF3L0jY8FEKlQNJ3+xBqcox8X0dX45mU82E1j8SHEV5zzCVa5dLGuC6K0QMxCyJVtRgzzIEQy6pnn3W7A8QmdY3s487PO29aKHktELNKJ95JOi+/mayU0LqranvlLH+3yHV3H9/GdvFJgtu2pRX9z7TXQU6vkIW9UKhFsiqV7rZePbHQUaWDTpOlFJdXJijHt45eqFuFYlxPkmavmAQ1N+qEh8xpDZ6WMLE2aL1zevGlqk/l1Qo8YyNKY94/12LJwH7LxwDnbPblrHO0jw8HlrUb9xaGoMyVbvwjCWWZs+z7U/M+W655Ce5aJtU/o0Uqx04+vaIaVTZG9B524qySUdC/As2bByDITD26ZQml75HBtyil0O6Rjn2mg3ty6pHqTYrO8P5JQ2xbfvB15EBh0WjYHZFhcznlfgcBjMfmTyEty3DHrlvjFg010jxAMr3Nu1NpNj4a0B3GWvloAQTDKRfdZnO9kgLAGIvjhsiOj4QgcpbAvQPuracpwzpEqNtgAS7JOQY8/kXdY3NZHfJfxVsOMEysRbFWObacwvODDw5MIrn8Q1D1jCjCY8h1fMg3AuzHeNscJzG/2NjNm/g7IlbeHpw/qWXLZoylmTX6lRQx4crXOnjAJU5tK4MALUJ0OhT4P8eCwGeTEy3DB8/hkuuP6AjrAu8TTK1SLGae+KYjICj5iMjPnQsWh9GBflKRq9qIs97J9asqP43YTCnw8udw5YtSwhlmjhQYeUvunkzAEwE6UgqtIZy8+W7J9wGiiZlu3TNQL1YNurbdmd/xo4jH+naxixSmy2BYTfWtmMnjV2/EAeC3zmOCKCCx4LJci6q5zDe5EK7ZPRcPV5a+gZX0kzCpNYwJJdpyLrOIDqUtenBMILVCNvKIvpzc8nenMZZyqOZRTAc8M8pmwYjTaAyqYCTrHII0Jx9vYj5B8/29RWpEVmSf4fSmyDHK/8xKp5wLB8i5r00+Vso763Xphg/lFJcDwSjVoVs5lGJbMMEZGHBkl/ekqgwMnnAcrYv4xG2smotkW0jlbPw73G1rjx2Jy6jykzmCmabaO6p2XzkVt1h8p/20yIFRV7oV/sSNftGuECne28vaVK+fJv1BMIdL+dTJAZLTTT79bL7WGHcRHkC37osdden9FQtslEH5cIy53MLEIxc/U1ikHcPQNFYpx825N+moTrFKvzPwCAfL7yU5CLQYVyqlOmV3G9UwPXJEziFSqmg1jeJZROk6gy/f4Bcs6mHh84mZiGHPtK5rQ+6FD5pL8phLqJirdB/RCmLc7qNFjeNjqdwwAYlRbhYzXoXW0eZeMriyuBscG0ZUbjjHJFeLaAArnBvEveo2OpK+1r+z0qutPhYyxmu/Ag7jL5/PDRSkEa1+PoVybGoHM4T8B9dxWxuAvt3cEurofI465XLXlKMC86x8JR2Rm4TZuUk5ArBRi5DLVUvMz5ara8fjLF98a4SVCwoew+ttgQo8oUsa3wAklT/yeBMYxyPbOOLo+XcB4Jxr4ym9uHx4GhcZ1LmlQ/kOBpkG/KDRCpgcVtaDS5APU9soQuJ3jNZyC/A7kxBAHse6OL9SqbAfZ/FRUEPZKLEL3oUQc+I0SrBBRv5nKaR4QQD4KG7yIzsZcMt06RX1w9r1AuCqg1dkUJv7tgiKIaI+5XhAbOA6a03uSQ5H1FS2ZKn8/dzuGpANC1aALJwbTIPGUkBCM0jrpg7cTM5cettIJKTrbHwPf8k7rEM/mQ/qLnBsyU1hieWbQ+/cvtNT+hpsgGdSJv/4suMRuYxK0dMVRdBL7B/k600iFx3fz/SFX9pxRF7I8UG/lXCWw4jVKWCZPqRjp3qhDPsqihZ8La38iX/ynrjtfgZQ18f+CN4s6TupWTvvEXMgcu5ukcCUm5ScdNsNqNMfOxVo+kGAZz1F++m3i7qX/ep81wBZ+tCFzSrDBDsHDn1u6lheOwSd0J78So1+MEGsSiXJEc+rwgPQd/K5825RYQIs9vFN40q+O8sr8dWFLmnWbtT0bDbTOEhrFbcrEXVwi1q5a4xW3psLnHAQyq6TSb/QZ93I3qxD2ECoquagTq+k3w1pbeQrOfLYZTFsPKS929CPcfYzjNw5iV5crQyQUUEoyoIUV5zF916iL95uMi9NYo8ucEykp/XKdso6/mf2vhs99+emh9cTP8tM4ojNN7fQrtqSxjZf8W3G8e/jx+lr6xAbAlmAuslg06RMmXgzatsFlrvq7PFodfxKKNdckb6nd1m5xQK+hZvjf6RJ6JlIaLmzfSPBhoQKkUcT+R3xM6/PXTUgZJ2DMiCzP7rpmoMx4P5/r8w9RlD+WSgO76OREf+FgHyQ2xlROcJwpMkRqeNmpMkRfCNNjtAcNwfFQZ8iQkPS+1pvIEM9ugmOtsunSjfXRjZxxrq7geS+tOiG6cql4tYuGQ8vyDD2CY0lbn2Ad/s041S+jky3eqWxwznNeoAZ9+xR3hPMXgDdwwf0MpWnWVlxfJcGNwWVPdaTDMezi97c6USbV28JM6lN9xQgs8yRm6jHw47qVzKZnJvu3Kt7PPs4HFs96EnvI/IudPMoHXr/2TOX+WfmuH4PK78XtRoxd6Gb+LLdkFcMwrincFR7ePYjAv+Zg1i+dYZ/5lmqG8X6FPHuxWbtiLzxBji0//A552248I043J3P5CtGfPNRPHDm38tdH61+9zR/t2Oty54nvNcN2Ibs9z9x4H0deF4qwy6bBbGvVo+3tyE7tn31wJivir3szl0SvnoID3vw/9FTd6WY0/N+/Lb7tb2+6fP4cZylgbtchjr4gKLIw3a7ejIE6dfeXT1g7c4GZizOjZs/ZC3sZPaNiLxGb7JsMzoRhldGHq+a3oPhJzIwl8uc2aL7aW0nnFeZBJRNKGpIayZy0ls57jDgswNi+YGoOiEI/avRLZW/15/umVaj2Znzep/ZEXQ/Pfv9ZvBCl8a585Nvd8AOOOXfPjflW5Be+Fs451WNN0LwQjf6tW6u3aqhM9Z6x83/1N5yN28bATmC9D99sBGN4+YkTulXVQ/ukOpr81Whf2oohKqKPRM9ftJGLd1//rcrusDFcxbirKlJpurJ8dbSbY0qBg7rvvlu+DtMsqBmh+qQie5npr9WHfvxtILC+sm0M0yGBRseJ9BBiu53RR7ZzX4GtlhL+TZjwGWz9Oe9F75//hqnVwCZXBVgmJB/aViiVUOqEGNR/aVvMd3HPO6L94KGGkazYhM4p0QLi2yETyieebA5w9tmm1e5C+oizgcmfD16KVVSxbX1wzKXnZwRpiOIUbTHh6MGt5Yv/SIS42ktqJUfCqtjTiviFtlY041O6EGOd2axHo8vPQTuHjAxl0QaayJ/0SK4pKAyFBLqbFezXp6Uqph0uvf7PSGe/LaD9115h+mTgQz9OzbmyR4MorRCnm1lAV2ci7/Opjd/jgWUD3oKITyEmT52NKKGS+EtNQcveBXwCXIc+XnB9EkE+RMKaC3P1Jm0uLMCyBr5nZ1X7+KxEFJqEUO59rvhTyAMAn+L6ebjzcMpHI5JW64Tq9QcKdbDgpfOS4KSQyk4rd5gJx9oxcnPYC+OajUnLF0KI8kFhsEPwhUjfytqWLjmYgcR6Z/8JtVHVOOuobixiqe5vYdNsOHDwbsO1TF8ORNdZBMc0fFiNQw4YUmQmDHz7+r5dZic5y/kRAWXw+2BpAdz6FLtp3ypz9TqxBrrdzCCoA+WaLKkOQj8TMr/cpqJKwya9SK31mXIX7dYKDizIx6PyVSKKrkVo3HH83HBzF60mtOLjPKuFnD/NSBvBgg6bv6v+A7/K1MiiTjPfyQs48FaTYe1rk+zSSzFuikt3raDSBOxMqo5n5csp5izQrFMLz1laRWZ0STQZ+wdJN68NvOBA0uz/CQhoQCDj3vSbF0s6j4NbAuGeQEW6Tk753tHlf8NwG0BjETk0YBHUcExYTqJrWNxsz3xFmBzSHeNm62iNX+TwIwa/LNrdQmB/fE9G1dSeLjHPgjZxB1c31c0NPUzzYGog6TCKMvF8Xzk0YJz8qQWd9sG82qeltryGFZ0vQb05m+l2wCGwm4gFiPFfGARiHhYKXkCnMVwRgdp/qhJsNcZQcvB73/pVXz9aetAQkv8Z7rVbqPAm58p8479mWQ5RCpsgA8NFs2M4b+nQsv93vkK9r/pBaR5CBpsTqFAhRWz5JT1jA912gCtNyNsgzDNzgnVerrKJvQO+aeCutncY+UuAkkT3caO5ScvP9NHvmh4NsWcXc6gza0OCwPNMTYNru297PId1CXNhNpONtTu3pn2lU6zOS1Hhbf3+IwS2PeTGhSLi0wb45qKZxlZx1LjlKpp0zWUUiyVITfe/m4aNWqaRecvJVAdaEqdg7NMJBN5OS+VSDFMKnWvethjU+/fRrpSifwieoyyZ51PSX5mLuSOnU9xRXBJMCyOU04It03FLcIkx0NJU4mO5UJF5ELPqnCXJ0YFJH6jDF6sHkHWvOqTbP9SPlmw/Fh8IP7OqeT+yx/fxOBF8JQMs8KhsiRbyVySxDnJbONaVZKe+uR81lr/Jewk7jrqPuYH1l/+5iXZW+3ZzDJRJdTQeln8+XiL7mZPyWYD6ry6GI95tVhhTgEmdlTvPyOsLMd6PuuWyEM5B/1klmg25o92iE4Xz3SX0jx0BzfOJQ1Zy3oblv2vh3BvTfAznAjRJ7+3LCt4O+FAGwEnN+EMfkKq7kyZ3LSkohmO9gFZenFIVgqNNmuCOO17pjOy8I3Zs2k+qMNHVdZgzIybMzdWDkBWb0L1Z7qBO9O/aysHYdyoOUu05B7m4zZthFP0rax9lM1APcGzplCA6mNoYnSEWuzuCAaObCcQGCBPb45mCf1MsKHlt+X9WtM20+/3geMuLmxrNXdENXdJIz/QXJbdcYIXsKTsSJp5AGCJzc2qsfFWdkderoZ0utkFQAbhVtUlJi0MltTYaWZeosTk3ZVNJ0LIL0J1GT7z7OeywnfTho+fuH/14ulxEv9tH3FZ+R09ofp2agr0v6pN8z8Zdpc9CMukuxAYyhnmRnD82SaJvXLYyfyhudeIGDd/scN02UKvUcPsFHbjnB0J7w8GjqYRBc3UIo7gGNnu67Rae++cVNoKM+Lj79Yyr1vhyfSf2T4VGzfnRZ66boUnDx+80R4YN9/V5XyGNscxFT477mXuq2XJJNJP91z0hp2ELR29XmMcg9IQm/aW5ef2swp4kOj+OKTsIpnexdodgnNUomZZuC7TuO1ERtdJ5vroqTlceL4lFm0Xp/ILerLcz1I/zkydlpCegxm6RA+1qvQUqDBNdffxTu5DKYQRSSfjdm5rHadngkX74WMUc39HzNjgwi63MqvvI948nLrbdzKHgN65WUkeiDjPktBKquqOPr0/iM1DiC5iofcObviNe6CCur3l0nCx/taein579slDELx4sD1QyV119nKdoNmgd4XWc6VaGdjqvwNjbLo2ei2QXkTEztpNtj6a7N0A3RFqw5b1+4jZVoLiQ5N4qK7qdEnrQ/m9WiHyQJlyO8qrcTR+a+ppX+QxWbteZsOiyx5O3ZuQNq14l/oyThNQ1yNffaHikoWHj36fz04IJnsvLLTv5T7rQT4NrIEsXK1b3dI4/PGA0Q6k9OuFmPlIRaXAmZ/wixa71eHpLOl4BtwkETS6y3NJGY7LBZuqaj/vx6+3frunPnEaKIW34sN6rTsQrkbIxmjsfdpGGH19vrMHmdcPIJb+iJTm7lHVFhfhVX5bmTH5g+fgcAz/r4WBzNqE+Bks9lkBJluPb1m+uGJtGbe/lH4iPWTRz66m7yQ6zcYW8plCj+w4/NoDN+C9txyc8fh50CnrPJ4dqOkIn6uKnO2GPU4X3JgR1kH1O5fWv8hqe046vfaTB6lbhN/Dg7rF9rpRPtv/e7DNHUF2MhhhZgR9BYIybA7N07L8kzQXG8nGU79WZkS+SGNNnr6td5DiL6E3FfNdThr80f/6dNO7zh3ZmySl52jJa7BhkVml60zlgXLxLrrG8OcL0rVbSBFvPBvkb2uqyuaKL3ga8llrqAeq9a209T7tPCtv5NyAXwE5XlIWz50QdRopA4r/czR1D/Hw6JWPTwbeLx9cP4SlfAa7Da3Qf682e3ZS2i+gF3Lau+ODyO+S3Ii9kW//UySv90Qd4fjXF16ennTyraZmZ4TJl8Lvyfb23b7ttUcJ1lIulkKxcDmNNxMm0dD/hbeEpcRsoPasne3MdJGoV/ytKZJq4JGg5WYi5Wkxw0rv96EWnhNitfkZCtk7R41372G/ZCJIk/lfH12/oMxPPxDvYX/30BLKvDnb0aA3HXzVSAyq1BH+kTkG8mWH4aRP+Uv2lvIvYGhsoRO8zOg1mT811TlOp+kDqxBIIf9IDjE8WMghBNAWxsAq3IzbdBZGM9COSzUqSx80Exf8RBefrW46/exu1j4sWG7nXf+OYok5lrBsWtYqgVSW4nyzsRrykyyImygX5p4Tii/K/RzHT9p4W369qs1vVriEuqYvLR2jtTNF6TJ6p/j+Sa7vAYz0M9i/PdYCuSUupCYfA9ecbzeNaqBCHBoV0D4QBDVJMww+P0XiNhOlirpXmk+sB5uVl6kE1gCoeUyzxiz3sW3XzXcHatxhsBxj/JlB9TGzrbDEjvR0Nfdxw+Veicb0K/gyk9TNDErukw2ZgikpFLiYJgebkxFMuFHoo761avLmVQkfaFMJWr7lmqBuxsCFxNagri8svDKd6t0o9e+cMAfXqeL6YRFvYfKtlW0hViTzS85w69QWjYLW0E29CbG+ne9Mob90/rU9Mt65SRun+nTxor4xh4+ZURBfaQJuXg1oQuvZFpn3/mNn9sJPL7BypMoRgRcCwJbW7zG5pRhSfAGIaf+iUlqac+q0Y1fM/w6jy51bV+n1HYXdzF/9joxi1k9m6Un1m169gN+nc53lrGPRhJPUqJ4nkxszn7+Fbj5/29YyrVbzuUL3Aj+s6hmei3gxk59X2FZzjRnLuPnK4OZjXVMvV4EP0loPYOms7Lgcs2m0IsWy0U1uuWYSDw211VQ155ZHlXdJzsn8A3cvrYck0grrSsdtgVJPNb1jjUfC7+xQHPToXnaW+RK2btr0MsfvAUgAS36KrDCDCMV9uagRi0yfmtf0ljqr0DG1yYu9eczFPHnqprPtNrNmZGwGyngQUwO7st3NDvxIjLr2maVPY3TIO7LwSeps716vDf4ltGowgHtlXG7V27ek/fhA0i79TGEdj6UetLTLSYrQdNVy/m2JT20qAHRxDvYcptvpUfg16hhwX0rz0du8NeHpPL7BQja+PflqOtNonqzgEWzIKcnjeWlwG/vejE9azE5Ve5km5MPT1Awbpx8JO5ZpktM/EyPyhdpPH9422Cci+h0VyQqgBxxdxgAEzSeTTQ18qoVOjrXcjaEj0zAfVjmiKp7pdFAILxpyKwRRhVD9HnBTfmbcr4/xf+yKaIFnZWKKM/i2EVrxnDbTmNVMgtV+AsZFz2VPJ8on72esfiUn5sdU9yVLN07rRGY7TKcreMMrPPNduhlN+7j5ryedXcJyY530Wk1IWPKTliMa/6qxa0Pk1QN6kQ3Dnh4x/o6RiYvHKn6/ggex0K7VdpjYrJuwaSBEljTX6UAtRMpQ+JY8OaWMk8EP2YBDxHb0Cum0Gj2BAp/WzFyUCnnkJ8hB5HBMh9Qgp8LEDb4d43f8zB1CQuFn+Nvv6DRv6bayEhN+7sAQG2kjTCVs/TRlBgLLJzcRFGJ5wMBSF8OM0umle5E6ed1mml64qssWki+/efHe8ObJ9t4SKNgRJvbiPNsrOlWa/rQJTw48RGM94up7x4JuGV++ldIYw42bf2XQtqeiVz8zcNHHcpZbacXLDC2R9Gi2QhBNqsffG7h1u+K6HkY8hu00j9vEPqlwZafRklSj6k3ZRj85NDXYnR395Ikyu4o74qVfaorOX2RIp9dKLP2w/i87BjJ+4nibOWLMFD6tgvZEw/wkPLXBpmTmmhBtB2RZC6+exilCwE0XgGw6BrXS24uoVwMUO0QYL7rFlEIficsdu081iPvx+CebvY9h+jMuODNVRsfLryTbWxm+YDlT8wO3Ah6tK764CVpQPLvTtKclJRvy2/jPFf6F44aFbAzIgJs4rQK5uTIoGMg0/+SZgftG3m3LlGubx/j70IkXz8nWA20wDuCFUZzxJQyM7bYLTFQtlvCxhfoy66nLdD7PVxijbL9LQwFR7KdYrmgelod5PoPjySGjMNwth9rlszRF6pv2YRlG82zpssMl/Akj3u+pgKBqmhaOk/yvPHUum5PKFldi/e8mn5IRHH8UdvqyYafn6Kt7x/LXoNOlI++yG2RV/kUm2Ewf3AkaN7sAmesmPDtBajIxzEZ593cjhXjlbKcfdNQ1A3CEyF/lvMu6Y5jmiHkn5z8i7+/S3oVPW7k37zU7R2LjZgjofk7pmf7XH7sj7X07+PYMIcQME+0zb8K9gqCsqZ3e6YLZJzwjs3+LFBKp3C2WfrcGKCYQ9cqBi3yF4d3e6bps3PBF+B7PUz98phe9i920MbxpxbR7gH6X9JmGU3w27Q8HD0g3oupbq6V6Lvz0mmNjn4buWHafxFcnlGS64Ym+03+eJ6P3QSRmPa71HvGlEUfn815l01awXhAz9BHj6/sTLPVah/5J0Kc5vvRHQgwLpeVRF30hLd2BHyvrKfKWd32QZfxw1MpCh/NuClL2nu2tqEIvzsAtMeSHHew3ZwjvkY/1mJHtZo0LvlpLbi83nNzMROqr+p7HvrcAdyOe/nbl6uVXzY5KbNOh117KSxEv/9AOqOVTfuR6FwZD/Ps0D72egV4WVwdq8iqWKaH7cbuWJuOipjMrjeP2cBpt3VcTln5RQK3UUfYM0F8v7DHkJRKmu5cQHsTRPx4jDpmLL3GBNolC6a2GCZ/U51VGeLe79d1vIQcBqdH4XenGvT6KzTkr+jsOTq9G/H0JfZD1wut97S+bdFaerKnIGqr2dmsuPGQ2vXsq9KDYOqLq5PrLL4xZZQ3ItOtjnt3hVKup1PR8n9xhGd9+Ac3aB1RuQFr/aWJ6Ppt5A6PedXkfr73cP3DYev7p5y/t2P7R8Nj8qtDsZi9nOaOgf6ay8HK01PpVeQAtphmh+Qw8lZG6vjEg1ItRn17ortzxUU5gf9WTjxhIah+rGZ2fQ2Quv7RMHo9bff865suInD8ESX8klR4bQn56QPpBczjzxq9zpR/T1teDN/SDQjvvhfoXk8szlAO7MzIN1P5s9n01In4GWa5W7/agAp1IsR2SIhg7C5C29sHSz0bctIcHuVk1n89uB+9qlFVfOAPl6TjwxUnyKbTwNIK6T+8Zo+5JrIZOxe6hvdWfpKQ0hPa/VcVswz3lxTrlXr7BR4ckEmTQD4itfvqukG04wyjpv6CgsptDcwZ89Ax379Kpepo5V6s8fSxmh6LOl9fKdgNe5qk/0ic1lsir2Nev/eFe8pO3BV6Pa434+us2X289Vo+WYu9J9HrvL3AGBWeA9P8isvQ3mJw+45eTE4Jw8HRGKH8ysfj6rvU8NgjXPpudo2EHvRythbyrjjdrbib8T1SidGPSrngRUrrUYcw0bTsWaVuF/1szCbsbWp2moiRrX7oaLIT9TXA/k/GOvdOWtCg5Y+t5MXdepYLppwv25kiVKDDWzW+DpCdR2xwc0bb5ZY6E/B2n/S00nk8dc+YGEiLuxnH2vTSs95tOS+N+x870mA6hW+4tcJHPcpHPzfYK79AMT4i8iOa4h8sf2cjFOkQKk5bYprio6U/cBgpXeDasMs8WM3Ta+XbsJ0BxFPeXqthUfLCBtOo+/6Yc1l1ESeo/6+aTug/EJRqzywduIBsD7VsWXY9fSeosnsVLvVb/O9WXP/n8pJOG5THn780N3l07xxO36GzaeQpoZwKyb09QLE5lwyjHVWoEXo2Gi0RSTcNk/VdPtNRy+btatfmAy5WT5W6k3jbJWK+rfigujg1Xli651ZmtcAD9trI/MTBksoc3C36LZrU1hYqbhNE3vXKrn7zzl+7xHUZ7f7Vd2IP678wh4zy70k08eN7FbWyxj7RtBmfnUpyi5eK+XTbJnYnlfU706clCUlp5mD27REn9TBzqYyL1Vq9JQrtJAt9v9V6IvKOZbCndvVdI+XI9VN3EANz02qaSCFlBcjUEXzKfe8CUP0wTYNWV3dHC8VTfAgMALlxuFhZUIf82AfZNDcDagaTPtK+RoC6/mL2vKP+qirO/Digml36ti6iLak97rY8eCy+IsHEQyS6lJL2cDqiXYq8a48bQ5lg9FGvsaUhYGG3s5Zm+J1gjaqNOC0nn3HXPZ9lIf9+ukXJwo+zDn7JtOuo0p0wSyaowMNelH6xvqhpGs+uwwT4Ek075Z8CzUCu+Yva2cVYef2cI6g8at5tlxUOINtERO261QcWiNekM4ic/5uZHEMoWduHG0OmbG9p0JfDvmYI6VOnnVI/BKigXe30A1yHU1ncaGV3VpqOfQREU98eIiENbZ9ycfMCqYyFpBonjWgDv2z5Wf8TW8wdxE5XMCMQr8TWqBkvMp3zsib6FCDvNr2w3kpAe/9YoGFwjsrmPMmDyP7PiqeOxwyIs54NuGs2LopHBpsl85XeYyZX3TpHcTGwO4QOTD9KG8s9Yj/VlwWJM7mvxKGC0usZjNGJ6xiNtF2JHMwvdACY3fIs6Me2A0tyo2K51POboVXtIMCb3GDn9aK4u1DgO5ubty1N3+8E4WLbj5i67pc8pI2eNuNSIyEvF3FLqWu05U234QjT2HABtfkc7wR7jVvoVOk6p3YDFhYkJuYldydI5Vs6u4QNgX2Vi7oaZqoEqkctIZiF91u3wldSkbzHXf4ZKi4JSUXJv51qVmJ8xKCC3TlDTCWo8e3Mpvxq5pdQ0Gf0nyWmoko2b/1xM8oWz8n2s/kxrcUcHTddWQ/IAG7xwmUlC/tfnfKXzx7kxl5zM0qa6DHMJUfmRcteAXkEMPs/ZO5bMaW9eU6YWqReDEM27S350nf/BLrG1eC7cNXA91MSSot+1N9D6S2xz+Mj4N5/dLj9xfrTc+eQ0rfUt5FfhsGrh+IKSoS8U9h/yXfhDuaPJbXe+n8EER5tP3gu7Qk/yn/nayT3lv7nJIWJwHfIl0UFKBCVgIPli+k3nPq+m1WSAQOmaE9L8cY4jRJQVbDbkSMrPJNg7zs+GQE8c2CHOMTRlDJgAtbWAV3WzK5yTx8JHUBHkMiCf9iY/ljZYcgfik58pYD8ej68w0cCvYvCmiHhWU340cLDnEP34CxhoNgf+KmXmG3fE4P2y82XVQRxqMJPrwJj/wipfxvzmNoiMnNw0ijNWZm7UCH/WWevrHq98LyObGV9SknHTySoFFwZjQMsImT8LRuT4qwYjyiw0vviPHyMAc4ttyofKY9t9BMwfhWLSl13yEOiR5uosOkZdFBbquRlIcsuVS9QjVv4qCqO+LO6dFIItZ7/cEOSSP7I1zbe58E5mxMlfRWDQlz2REXiR/7eAjiN2Cm+5ew2qKX6Pm+9HoL9uDgxhir0gmFx4B0I1Pna30SP/XQQ6e128hkCtTdCucQbZL8ce5mr25kYE/lkEWnvZU9gGpD7r+X9BEOavAEHUvVDOuPlGBO4Zl2gfxyj81ONfcN5z7hVJWp6JCh0p17MsBYgZOLiruijiI75R3kbuZna2TTnNY8yDfTdxlAmOyPu+PbnhYE8UBjEassEKbA3By3S5cjHTk+o0WU1vggDN2OA9l/RuGTqxabha06II4r2mp13hSusWKt6WOFrRfJW4DdX0uKemMYrBEJEyMakt7jlTvqBv2ldukcLgLTSpv9Q4R9spOVENAf5Te+HOlEgrMJVzYvCMpWTaUZyvrw+Yi6JXqVrROQQUZvh+VSJ6k+ay6RWfgkOIWHAV/C2axgVEuaqQCY1LbToruXLIrz8y9O+JgTbezLZwMkPt9WReAXqKfLr4ciE9PbBsQ/YiLmMKt8IMqFvEzhKbtqnFmtj90DZC1KF70ZqBI7oI5Nume40lb4WUGUNbEsqnGQ40dTNlOVjtT0r5JB3Kdqe2BtzazpcFLI6EN389QzrCK8TtyQp1pl23/H52PHKqEAnYHrLrUNVIcPk5GSNCbbOiEOrKV/IJ5CqxxbKSy6EDmXyIkSa57RCbFqsH//3UyOHuGahmgqzSVUAddzxfuFoLge5mWCJpQiEMPqE4ML64qRzCRAP3xs+nnk8dbJ8fa2qjNwPKpfw6c9jZElyWgrZ7QkgNU8kvjEojU0Hi8aVWiOl3d/W4aqCndwFXBSRqBVOT0MZ4AvEe5b3CVKLZdXTlkkHJLayWqiSFd/eJsDxf/XzPgQZ+woipE1nhPEjgRyQP0SHtw7qX2q0od6vMuTRPgSsan0ypArY6UAShulKt95OH9cIcy9VfJPb6o8L4s7b3MVU7NmAlDIWIk7lFVL7RKEIs8gQCTVrTxo3nG/m5c9deB1CSr6RtYjSfBFR+Ps+zU5fVbErpz2Gl2UBCuE3fqicHOMJaNdSiVtmyEzaHBs+Io1OxJFgheDTSQJJCf8wsVZxrHqunG+oW2/KS/kRjDUU0idnC8v3+uNJ+ubtaTty5miKKGRmK+uNxDGjkI67OTlKu/3fTPuH6tsFe+YVnomF2lg/zXUYzevZmLmrW6pkUZqSA9jspm2W5LkMF4uTSCpIvfjrsUDNPV9DNS6ddJSxz65coBMIqeilV+m7VGBxKrqFgC5WZqEHodc05duEM/KCqniPwdAGdesWRF0/7kKkGEH4qcsDmHfJ8VZsQOFKtT/xSr1CIa4a+38/FDjaQhMMYv0e/H6tUiEQheiXTbKUeqMuuEZUUYAqFinwqolzZ3SMsFgmP7SnOjRtN37n7nQ2ztO5G14pa9wbVH2Kc/xYJ0rufDxjDGLVirbjl2V2rnfL/I3u5egJ30pMo4xF0xvY5EB66kVZVbvt+c48iuDFcObvbmysXo3pN+O4yBT8bbISGhefMlsK2+caLV0EgA/goFif5/5WH9IrDH/YSVZ4tp0xvy3Yl1hB0MUGTjeedDHOOk7U+8/kBMr5harDgA3KbtoFNhgcQcNDQLO5AI4h95zhNcncMfcusxJTtXPIEkABjG0ZzLSpB+A1lnW8J0OQvRkUgys0gh3rLF7uqqcafEAh6hHAvnLTS07mPLO+eqJDWon/HK1IrX9EfSe302mtxYAvnbrM1ie5CXFEYwpYqBqnMt+9W8T09F8TC81G6ems35+AOPQ2WyclyXpjPvuQbu2luSMPsvI6Q8lh5qnkzdmr0m6RGh1PxyZR4XdDDwLhwnCTbUIaAnR96UbbI8ROEbaApulZpxjH9ba/NRBGuyNHiJ3kW+o9abmjW4w8Au6W4C3gR0H2B0gXQLEpbQPWCSEhtCP2eY9EMDsvZmsRlBlJb997O/D48Kg2qJTTXynXMeONc9e8c0yBuWUQ5Zss5+Ug/SbaNnRVkhssCZUhzmLsHZmjaVW2Nsv3UJOVbL1gq+A477NFqhwywGLUV1kkxoVYTz2WHZDSTXc6RzWYx9p0nKKKaYsudNLchk8uSNAyezKaCrNvbH6Pjs8GEQm9DHULVYd0S0F1170mmmpr+eiXtgzXnB2EsU7jiiOPMkdIsvZO6o3CkEAOrka4LqdPdDrpiJz+Ou1PbQLbluC5uIs49Qaak8NyERHPfU1+6cU2Ykaq3GYrFUCH9GrLHpZGurHRzRU6ZUZ+FuRB3vTataafhCw28bo00jFg6daQ3R8JygKLVShnk2vpBkP7Lku5ZAvsqOFXhBOmPK1FrOsYzUN7lxolDrLuqKewZGI/du1Pr8vRPo7KyjQrxAo5bceozx85KPUqvP3NQehWoNe8Z+YwB+ib0+idZ1HdLA2LfJgXrxaB0/7zntL/WbFVXL9liBCk9/wc1dKzImES7IxhWEjdy/xNr857ePOnm86/n8gkO7VZDng3ogZB0BYwa2NtibwJ2nSl/y2F8rrkjiJ0ujs4hKZxIraBMckH4vNpuBuBd+hmQ1RzzRnBmefSUSsfRdcnSjmnLBZyYc9wKdfR3StyfIlKABReZCzy0oXRe6qgHz9bWpwoQQZC7UFewUUf+goDXjm3UxBIRW4gGasL5tUTsJztu3d9CkiIHmrg4YYjBcwSpNuKkfqDul6oX+0V6XXSnF7Mo+9CN9jrp9+1LR/1RBx03w5U2KuTtF770PCfc84PasGZ1v6K90G2aGYx+umFPToY1WSKFm+j7RaAJzJXb0oTYqR36Wfp3mlN3RnF8f+XvnMt3O49TNWPJpdPLqJIngaYP/iZG6+6PY5NaIi3rZT2GjN29jQ/uVccqO0iD+ZF/5nw92IQt9yE8Sy3DYkvvuM6OY5jIAk3feldTLGW5W1vag6+g3ri38LBIGqm8gf0/MFUJzGuS+7pZd6L2jJQJtm7bjSFg7mRocqIBhoHWNSHBm8QiZWAQt6uc8D6t7HstlUa6den7wy++4pst3lFmKwfVuPgzuzv6mJSyccsjKzKLGOKJentiKs6+5UfMfGYW/7fAj1LpCjc+Zl1of9B3yP3csnZxrh9EWcII2H5VPUrfU6kXf7yw4whDizlS1ZUm6WG5lOafTZMWJZxO+kn9v3gPuh1zI6N+x3LjYLKydlnkeqYpy1u3rdApEFeTP7jLV3pWOTSFDSysq8zWnNUc6F37XEyxXNPzktfsbI6HFw1ztVa4aThh5jvHF62GixsxrJGfrpSf/lFXhQdlkJ/p+v7yp+VEhEyeYhgbH2oHLrbIyL4jdvUUidAynNl6Eu6MLp1+KL4+EmO5b5WWuIKaVrwKFYZznXDbNC4ypIhaS1kO8nGk6CRymEP5GdyFSw6YxVQ5Pls4olxtfXJZpeo9itNc3Kf9Z375HOJAhg1Lq9UPAcvUNpCOfNMe9kX4HfJrcCQj5i/lT1JXg+1YpojqdySuRR37cb/GGdHTjE925B3P6Z5MNt5m1sOYajBWMVOrJ/U9bN5WTE2syEChKIW+y/M9ttXEhVG8wQocCxkKygxxlom9MeaX43EtOwrqEMLP7McfI+fqFRKSTOXxbqi7hBW3WR4hczPX19PlLPDnxueYdWV8XTA2icajotpKhVIAGWINk/mMyT+TnJsFhjFG9l6aUhUlbF3cMQwJvzMZjicnIHd/adtll72TieWD3H1FzzlET53X9ieYRRghd69y3lJ2cjzR0ZIQPOlJgW2CRUED52p1wzkDAF07rIBCIEt4sgT2cPmB3KvV574I0b9juXVsWqb3Fqx/VVPr188qe/8+VpmllJruJaPg1dBDlaoS56h2buys0Zm/4GClro1rY9r7ym6P0NSYl4ybkwvPcKwNC9b/zDKgPkam83qpJoZdTE/cMNz0tiNY8+5cROHeCktszWkvz8C66EsxurT1RLRt4cXh9RTN0Eg3FxOgjS+x27vApmAQ6ohy0aZCoTmPwScilf/e/gVeKQWp30lX5hictkzrOk4cyXKJ7bbDF8vpLFhYtjji1qWRS/xfMQ0q67+JsZHe7lxWCqj13NYEsbh8HtDcOXT44OP6FgAokHURaMEZp+sBhWY9l1TJu7bG5ebhrN6WLZy5jh6ZeVvYyBFAUJ58U54+mZzBbWueVksKm+1UhCRgmdl2U9aOQ6m6ntTUdi7RQesxve1Qz3fmIrjzCtdsFeGVj16ZHLmb/vz3c7MEv7+bn4EOOVPKLZfgsU2wZPFFGi88yHVuaYM68NCNUvvSS1vL+fWrifYr2qA/VmEnPULxUqG4YkfSsXahF/RKd9t0tBR7fFLcVXBir0LlleXJUaYi83xk03FWQPbS490RV2TC3g0/sj1F+E2I6JWl9Cc5Smx4tV6282+0Z8l9iARdfs/qvCHowUPU23B5LspfrVrtfG0nvAqJy2KtbuHZZ5vu9z8ed8SwfuUG+MKF+z4cf4ZyPvdD196QtcRjXelDeVB/Eu+6jcnlYUbac07NEahGs8hYQYpkDTmSxtQ6MLfb5j3/PsiuLi5viedGThUSTSM3Rdld3bh7PN/4O/LhQ2hypuMU1aWkbd+441uTZC1cDtlW5S6Dahavuazdzrx60yWUUWz+Eaf52vnpKZdn3PxlENrrZr/304gRkSMO/ywPfoP5Nm52r4IMoPE/1rUZN7245jigRzSO9Djy4bgZATmC758PSDPO6w8WwsfNeaG4Z0oyTL2+9h7Q/4G+w2Y0S55uWPa4g17M/T45o4cT/WUKgfdCpLIkRMj64XHQUdWMsPvqhdYbV0V6LsKxSNWvvmDX8q90/Ap37O3SWxeO8PrHD2A5vBTz7ufdjv12Oa3njSPyvhQ9clA9W/6irXr20s2myaXZG21qRNtVijnz9lWYM1Q9PtkVGUF4PRhxY7Uo22LyaL032onLRK48bXRe9jc7M6Dbo4Dx/9u7kuXGcRh678+Ysw4CwPV/pqv6OIe59r83QFNbazFpyY4UoSphHNuipBjB8rA8Fb7zCx98SLRhqwAbjjLJWqt6uQYt+Go9CofuPpnEoRJ492b2yory9wQi2on88U8XTnE9eBZNqPDfB9CPM0TDZufUVSydtQQaiHwv0AVWQ9c32d5qHFH7RHQ5xT8KviyKqLJ4HSDl0KwIlSLM4ydiUYmEljvrcnbFqpO5PlSLgIfye+3Nv9kihOWtWWDSWoT3ox0l7BdwtNDhX2XHm6E5LAexvjp1rJrspAYH3hUJmFUQhEpPSjtwZmVg0Ta41+6OjkxyKKJymuGUcGfZVmT5ZGZ2R/EIHOGFwqf6R1UDXsws47f1LrqWXR35ost7CqSP6iIfcZXeuwYhZEo99sp9mlPrv8ddCbVo5pjIoS7NmqJwYOqmNB4aCqvsZ3rOk7+Mz4c7OwlnAhLTpGOTfB5TYeJkELLLPI/5KJ8ptAHT9GXbvRFoRAvyJMVFHcYbHF8VX5yRL/CJHYuajkeGn0AhQubXTEeXFUVuPAkXsiEw6a6EllJEicpqO7W8+FZWy62hG8PiyiA8s7lJZY27uYxRw7gPBG2X6iBcpg0SfoKiSjPbz4vvufT88kiRnkPgcY7iPtTGtp36NZspgba2VA5bXLniyr7E+zjreHe9hc+1FMUP/nUn6Bm217GibidHcpyTRxOK7yp0x/yTLUHEJsRGeInbxhZpM0T251mRILlEAgTEu7HbF2wT+ZGxjQNxAwO7Oxz+gLy9ZXcI5HEDid5YHsqRJMTXXvwhYbNYlonYuZRghcCbL9PLWVhHysbiP4WelA3knKw5W2g8635M18IXFVk/8hFyfSAM0VjmSWpjtS7jiOJcAxS1xuNOi3lqFyeun6s4VKeH6XKoElyLQWq5KX2NGDp3E5LcMA9KaXc6EHOMOgMozbCrGY9MgiFCrUjidxCp840AYa34n8DOmWEP0Bh21VwfMouTyM8CxpiANgHzxGtNfqeLspcZbt21FXkjTRzdfQmvG1+3z1BPkLRWW1RvBejOAmwT51jJa0Xj8+abCkFEq0VFt0LoDB4Rc7w6sUkLjbQcuHgO9teiLA7pMkwVsA8tnodbIWfdYZnHekNvUIoOXAoqKGXh89E2JeQf25qccqfnvQzZ6XKGd4jJ/fccK/AZOEjwvINtfId1I2/tfQOCbHsSqDo0lkJDPqXjISXtnQQMkmQL/FtN88t18liwD/Yx5v2IllQ/2JwYtYOMTHucfOffhMyZXSSCZCsc/Q8Pa51Go4bU2t0ZQHO1rttGvlChXF1qJRFPVZM58b1UM94+OolT+MStweg4KRk9NMEFWrp0TNj4IkXWUuc9HBFvGskhUJ+UoKE876EfW0k6YCv1IlmwSKbTmJWz+7IIQtP2d1rsKbbYQH7DZYzsTkdlniHEBE7Y9O3Sv3/Rp2FZCYzqczH3fnSDaEL3vpii23Jd19XwVsW3H/TL/mptAt/epCllIW3T41iPvHmR3XRJdkwGvnqgrB/KggkPyc/7DJ3RkylCft0/eggVQsqbj+0US/wkOUSd/fITuMTX2zYIl0lo2mOPNk99o8KMCwzSsTh8dtpFhoMmw9Jhe+MbAINTrr8uMeQ6/3uMjZkwkYkN2CxOxMbbMuVS/dI///787/9f7KP//vEHg3kIvAaYHAA=";
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/MarkovChain.js
var require_MarkovChain = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/MarkovChain.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.train = train;
    exports.load = load;
    exports.evaluateFull = evaluateFull;
    exports.evaluate = evaluate;
    exports.generate = generate;
    exports.test = test;
    var EncodedMarkovChain_1 = require_EncodedMarkovChain();
    var Support_1 = require_Support();
    function makeTrie() {
      const arr = [];
      for (let i2 = 0; i2 < 128; i2++) {
        arr.push(null);
      }
      return {
        count: 0,
        arr
      };
    }
    function lookup(t, seq, i2) {
      if (i2 >= seq.length) {
        return t;
      }
      let first = seq.charCodeAt(i2);
      if (first >= 128) {
        first = 0;
      }
      const n = t.arr[first];
      if (n === null) {
        return void 0;
      }
      if (typeof n === "object") {
        return lookup(n, seq, i2 + 1);
      } else {
        return n / t.count;
      }
    }
    function increment(t, seq, i2) {
      let first = seq.charCodeAt(i2);
      if (first >= 128) {
        first = 0;
      }
      if (i2 >= seq.length - 1) {
        if (typeof t !== "object") {
          return (0, Support_1.panic)("Malformed trie");
        }
        let n = t.arr[first];
        if (n === null) {
          n = 0;
        } else if (typeof n === "object") {
          return (0, Support_1.panic)("Malformed trie");
        }
        t.arr[first] = n + 1;
        t.count += 1;
        return;
      }
      let st = t.arr[first];
      if (st === null) {
        t.arr[first] = st = makeTrie();
      }
      if (typeof st !== "object") {
        return (0, Support_1.panic)("Malformed trie");
      }
      increment(st, seq, i2 + 1);
    }
    function train(lines, depth) {
      const trie = makeTrie();
      for (const l of lines) {
        for (let i2 = depth; i2 <= l.length; i2++) {
          increment(trie, l.slice(i2 - depth, i2), 0);
        }
      }
      return {
        trie,
        depth
      };
    }
    function load() {
      return JSON.parse((0, Support_1.inflateBase64)(EncodedMarkovChain_1.encodedMarkovChain));
    }
    function evaluateFull(mc, word) {
      const { trie, depth } = mc;
      if (word.length < depth) {
        return [
          1,
          []
        ];
      }
      let p = 1;
      const scores = [];
      for (let i2 = depth; i2 <= word.length; i2++) {
        let cp = lookup(trie, word.slice(i2 - depth, i2), 0);
        if (typeof cp === "object") {
          return (0, Support_1.panic)("Did we mess up the depth?");
        }
        if (cp === void 0) {
          cp = 1e-4;
        }
        scores.push(cp);
        p = p * cp;
      }
      return [
        Math.pow(p, 1 / (word.length - depth + 1)),
        scores
      ];
    }
    function evaluate(mc, word) {
      return evaluateFull(mc, word)[0];
    }
    function randomInt(lower, upper) {
      const range = upper - lower;
      return lower + Math.floor(Math.random() * range);
    }
    function generate(mc, state, unseenWeight) {
      (0, Support_1.assert)(state.length === mc.depth - 1, "State and chain length don't match up");
      const t = lookup(mc.trie, state, 0);
      if (typeof t === "number") {
        return (0, Support_1.panic)("Wrong depth?");
      }
      if (t === void 0) {
        return String.fromCharCode(randomInt(32, 127));
      }
      const counts = t.arr.map((x, i2) => x === null ? i2 === 0 ? 0 : unseenWeight : x);
      let n = 0;
      for (const c of counts) {
        n += c;
      }
      const r = randomInt(0, n);
      let sum = 0;
      for (let i2 = 0; i2 < counts.length; i2++) {
        sum += counts[i2];
        if (r < sum) {
          return String.fromCharCode(i2);
        }
      }
      return (0, Support_1.panic)("We screwed up bookkeeping, or randomInt");
    }
    function testWord(mc, word) {
      console.log(`"${word}": ${evaluate(mc, word)}`);
    }
    function test() {
      const mc = load();
      testWord(mc, "url");
      testWord(mc, "json");
      testWord(mc, "my_property");
      testWord(mc, "ordinary");
      testWord(mc, "different");
      testWord(mc, "189512");
      testWord(mc, "2BTZIqw0ntH9MvilQ3ewNY");
      testWord(mc, "0uBTNdNGb2OY5lou41iYL52LcDq2");
      testWord(mc, "-KpqHmWuDOUnr1hmAhxp");
      testWord(mc, "granularity");
      testWord(mc, "coverage");
      testWord(mc, "postingFrequency");
      testWord(mc, "dataFrequency");
      testWord(mc, "units");
      testWord(mc, "datasetOwner");
      testWord(mc, "organization");
      testWord(mc, "timePeriod");
      testWord(mc, "contactInformation");
      testWord(mc, "\u{1F6BE} \u{1F192} \u{1F193} \u{1F195} \u{1F196} \u{1F197} \u{1F199} \u{1F3E7}");
    }
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/rewrites/InferMaps.js
var require_InferMaps = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/rewrites/InferMaps.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.inferMaps = inferMaps;
    var collection_utils_1 = require_dist();
    var MarkovChain_1 = require_MarkovChain();
    var Support_1 = require_Support();
    var Type_1 = require_Type2();
    var TypeUtils_1 = require_TypeUtils();
    var UnifyClasses_1 = require_UnifyClasses();
    var mapSizeThreshold = 20;
    var stringMapSizeThreshold = 50;
    var markovChain = void 0;
    function nameProbability(name) {
      if (markovChain === void 0) {
        markovChain = (0, MarkovChain_1.load)();
      }
      return (0, MarkovChain_1.evaluate)(markovChain, name);
    }
    function shouldBeMap(properties) {
      const numProperties = properties.size;
      if (numProperties < 2) return void 0;
      if ((0, collection_utils_1.iterableEvery)(properties.keys(), (n) => /^[0-9]+$/.test(n))) {
        return (0, collection_utils_1.setMap)(properties.values(), (cp) => cp.type);
      }
      if (numProperties < stringMapSizeThreshold && (0, collection_utils_1.iterableEvery)(properties.values(), (cp) => (0, Type_1.isPrimitiveStringTypeKind)(cp.type.kind) || cp.type.kind === "null")) {
        return void 0;
      }
      if (numProperties < mapSizeThreshold) {
        const names = Array.from(properties.keys());
        const probabilities = names.map(nameProbability);
        const product = probabilities.reduce((a, b) => a * b, 1);
        const probability = Math.pow(product, 1 / numProperties);
        const exponent = 5;
        const scale = Math.pow(22, exponent);
        const limit = Math.pow(numProperties + 2, exponent) / scale + (25e-4 - Math.pow(3, exponent) / scale);
        if (probability > limit) return void 0;
      }
      let firstNonNullCases = void 0;
      const allCases = /* @__PURE__ */ new Set();
      let canBeMap = true;
      for (const [, p] of properties) {
        const nn = (0, TypeUtils_1.removeNullFromType)(p.type)[1];
        if (nn.size > 0) {
          if (firstNonNullCases !== void 0) {
            if (!(0, Type_1.setOperationCasesEqual)(nn, firstNonNullCases, true, (a, b) => a.structurallyCompatible(b, true))) {
              canBeMap = false;
              break;
            }
          } else {
            firstNonNullCases = nn;
          }
        }
        allCases.add(p.type);
      }
      if (!canBeMap) {
        return void 0;
      }
      return allCases;
    }
    function inferMaps(graph, stringTypeMapping, conflateNumbers, debugPrintReconstitution) {
      function replaceClass(setOfOneClass, builder, forwardingRef) {
        const c = (0, Support_1.defined)((0, collection_utils_1.iterableFirst)(setOfOneClass));
        const properties = c.getProperties();
        const shouldBe = shouldBeMap(properties);
        if (shouldBe === void 0) {
          return (0, Support_1.panic)(`We shouldn't be replacing class ${c.getCombinedName()} with a map`);
        }
        return builder.getMapType(c.getAttributes(), (0, UnifyClasses_1.unifyTypes)(shouldBe, c.getAttributes(), builder, (0, UnifyClasses_1.unionBuilderForUnification)(builder, false, false, conflateNumbers), conflateNumbers), forwardingRef);
      }
      const classesToReplace = Array.from(graph.allNamedTypesSeparated().objects).filter((o) => {
        if (!(o instanceof Type_1.ClassType)) return false;
        return !o.isFixed && shouldBeMap(o.getProperties()) !== void 0;
      });
      return graph.rewrite("infer maps", stringTypeMapping, false, classesToReplace.map((c) => [
        c
      ]), debugPrintReconstitution, replaceClass);
    }
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/rewrites/ReplaceObjectType.js
var require_ReplaceObjectType = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/rewrites/ReplaceObjectType.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.replaceObjectType = replaceObjectType;
    var collection_utils_1 = require_dist();
    var TypeAttributes_1 = require_TypeAttributes();
    var Support_1 = require_Support();
    function replaceObjectType(graph, stringTypeMapping, _conflateNumbers, leaveFullObjects, debugPrintReconstitution) {
      function replace(setOfOneType, builder, forwardingRef) {
        const o = (0, Support_1.defined)((0, collection_utils_1.iterableFirst)(setOfOneType));
        const attributes = o.getAttributes();
        const properties = o.getProperties();
        const additionalProperties = o.getAdditionalProperties();
        function reconstituteProperties() {
          return (0, collection_utils_1.mapMap)(properties, (cp) => builder.makeClassProperty(builder.reconstituteTypeRef(cp.typeRef), cp.isOptional));
        }
        function makeClass() {
          return builder.getUniqueClassType(attributes, true, reconstituteProperties(), forwardingRef);
        }
        function reconstituteAdditionalProperties() {
          return builder.reconstituteType((0, Support_1.defined)(additionalProperties));
        }
        if (additionalProperties === void 0) {
          return makeClass();
        }
        if (properties.size === 0) {
          return builder.getMapType(attributes, reconstituteAdditionalProperties(), forwardingRef);
        }
        if (additionalProperties.kind === "any") {
          builder.setLostTypeAttributes();
          return makeClass();
        }
        const propertyTypes = (0, collection_utils_1.setMap)(properties.values(), (cp) => cp.type).add(additionalProperties);
        let union = builder.lookupTypeRefs(Array.from(propertyTypes).map((t) => t.typeRef));
        if (union === void 0) {
          const reconstitutedTypes = (0, collection_utils_1.setMap)(propertyTypes, (t) => builder.reconstituteType(t));
          union = builder.getUniqueUnionType(TypeAttributes_1.emptyTypeAttributes, new Set(reconstitutedTypes));
        }
        return builder.getMapType(attributes, union, forwardingRef);
      }
      const allObjectTypes = (0, collection_utils_1.setFilter)(graph.allTypesUnordered(), (t) => t.kind === "object");
      const objectTypesToReplace = leaveFullObjects ? (0, collection_utils_1.setFilter)(allObjectTypes, (o) => o.getProperties().size === 0 || o.getAdditionalProperties() === void 0) : allObjectTypes;
      const groups = Array.from(objectTypesToReplace).map((t) => [
        t
      ]);
      return graph.rewrite("replace object type", stringTypeMapping, false, groups, debugPrintReconstitution, replace);
    }
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/rewrites/ResolveIntersections.js
var require_ResolveIntersections = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/rewrites/ResolveIntersections.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.resolveIntersections = resolveIntersections;
    var collection_utils_1 = require_dist();
    var TypeAttributes_1 = require_TypeAttributes();
    var Support_1 = require_Support();
    var Type_1 = require_Type2();
    var TypeUtils_1 = require_TypeUtils();
    var UnionBuilder_1 = require_UnionBuilder();
    function canResolve(t) {
      const members = (0, TypeUtils_1.setOperationMembersRecursively)(t, void 0)[0];
      if (members.size <= 1) return true;
      return (0, collection_utils_1.iterableEvery)(members, (m) => !(m instanceof Type_1.UnionType) || m.isCanonical);
    }
    function attributesForTypes(types) {
      return (0, collection_utils_1.mapMapEntries)(types.entries(), (t) => [
        t.kind,
        t.getAttributes()
      ]);
    }
    var IntersectionAccumulator = class {
      constructor() {
        this._primitiveAttributes = /* @__PURE__ */ new Map();
        this._arrayAttributes = TypeAttributes_1.emptyTypeAttributes;
        this._objectProperties = /* @__PURE__ */ new Map();
        this._objectAttributes = TypeAttributes_1.emptyTypeAttributes;
        this._additionalPropertyTypes = /* @__PURE__ */ new Set();
        this._lostTypeAttributes = false;
      }
      updatePrimitiveTypes(members) {
        const types = (0, collection_utils_1.setFilter)(members, (t) => (0, Type_1.isPrimitiveTypeKind)(t.kind));
        const attributes = attributesForTypes(types);
        (0, collection_utils_1.mapMergeWithInto)(this._primitiveAttributes, (a, b) => (0, TypeAttributes_1.combineTypeAttributes)("intersect", a, b), attributes);
        const kinds = (0, collection_utils_1.setMap)(types, (t) => t.kind);
        if (this._primitiveTypes === void 0) {
          this._primitiveTypes = new Set(kinds);
          return;
        }
        const haveNumber = (0, collection_utils_1.iterableFind)(this._primitiveTypes, Type_1.isNumberTypeKind) !== void 0 && (0, collection_utils_1.iterableFind)(kinds, Type_1.isNumberTypeKind) !== void 0;
        this._primitiveTypes = (0, collection_utils_1.setIntersect)(this._primitiveTypes, kinds);
        if (haveNumber && (0, collection_utils_1.iterableFind)(this._primitiveTypes, Type_1.isNumberTypeKind) === void 0) {
          this._primitiveTypes = this._primitiveTypes.add("integer");
        }
      }
      updateArrayItemTypes(members) {
        const maybeArray = (0, collection_utils_1.iterableFind)(members, (t) => t instanceof Type_1.ArrayType);
        if (maybeArray === void 0) {
          this._arrayItemTypes = false;
          return;
        }
        this._arrayAttributes = (0, TypeAttributes_1.combineTypeAttributes)("intersect", this._arrayAttributes, maybeArray.getAttributes());
        if (this._arrayItemTypes === void 0) {
          this._arrayItemTypes = /* @__PURE__ */ new Set();
        } else if (this._arrayItemTypes !== false) {
          this._arrayItemTypes.add(maybeArray.items);
        }
      }
      updateObjectProperties(members) {
        const maybeObject = (0, collection_utils_1.iterableFind)(members, (t) => t instanceof Type_1.ObjectType);
        if (maybeObject === void 0) {
          this._objectProperties = void 0;
          this._additionalPropertyTypes = void 0;
          return;
        }
        this._objectAttributes = (0, TypeAttributes_1.combineTypeAttributes)("intersect", this._objectAttributes, maybeObject.getAttributes());
        const objectAdditionalProperties = maybeObject.getAdditionalProperties();
        if (this._objectProperties === void 0) {
          (0, Support_1.assert)(this._additionalPropertyTypes === void 0);
          return;
        }
        const allPropertyNames = (0, collection_utils_1.setUnionInto)(new Set(this._objectProperties.keys()), maybeObject.getProperties().keys());
        for (const name of allPropertyNames) {
          const existing = (0, Support_1.defined)(this._objectProperties).get(name);
          const newProperty = maybeObject.getProperties().get(name);
          if (existing !== void 0 && newProperty !== void 0) {
            const cp = new Type_1.GenericClassProperty(existing.typeData.add(newProperty.type), existing.isOptional && newProperty.isOptional);
            (0, Support_1.defined)(this._objectProperties).set(name, cp);
          } else if (existing !== void 0 && objectAdditionalProperties !== void 0) {
            const cp = new Type_1.GenericClassProperty(existing.typeData.add(objectAdditionalProperties), existing.isOptional);
            (0, Support_1.defined)(this._objectProperties).set(name, cp);
          } else if (existing !== void 0) {
            (0, Support_1.defined)(this._objectProperties).delete(name);
          } else if (newProperty !== void 0 && this._additionalPropertyTypes !== void 0) {
            const types = new Set(this._additionalPropertyTypes).add(newProperty.type);
            (0, Support_1.defined)(this._objectProperties).set(name, new Type_1.GenericClassProperty(types, newProperty.isOptional));
          } else if (newProperty !== void 0) {
            (0, Support_1.defined)(this._objectProperties).delete(name);
          } else {
            (0, Support_1.mustNotHappen)();
          }
        }
        if (this._additionalPropertyTypes !== void 0 && objectAdditionalProperties !== void 0) {
          this._additionalPropertyTypes.add(objectAdditionalProperties);
        } else if (this._additionalPropertyTypes !== void 0 || objectAdditionalProperties !== void 0) {
          this._additionalPropertyTypes = void 0;
          this._lostTypeAttributes = true;
        }
      }
      addUnionSet(members) {
        this.updatePrimitiveTypes(members);
        this.updateArrayItemTypes(members);
        this.updateObjectProperties(members);
      }
      addType(t) {
        let attributes = t.getAttributes();
        (0, TypeUtils_1.matchTypeExhaustive)(t, (_noneType) => {
          return (0, Support_1.panic)("There shouldn't be a none type");
        }, (_anyType) => {
          return (0, Support_1.panic)("The any type should have been filtered out in setOperationMembersRecursively");
        }, (nullType) => this.addUnionSet([
          nullType
        ]), (boolType) => this.addUnionSet([
          boolType
        ]), (integerType) => this.addUnionSet([
          integerType
        ]), (doubleType) => this.addUnionSet([
          doubleType
        ]), (stringType) => this.addUnionSet([
          stringType
        ]), (arrayType) => this.addUnionSet([
          arrayType
        ]), (_classType) => (0, Support_1.panic)("We should never see class types in intersections"), (_mapType) => (0, Support_1.panic)("We should never see map types in intersections"), (objectType) => this.addUnionSet([
          objectType
        ]), (_enumType) => (0, Support_1.panic)("We should never see enum types in intersections"), (unionType) => {
          attributes = (0, TypeAttributes_1.combineTypeAttributes)("intersect", [
            attributes
          ].concat(Array.from(unionType.members).map((m) => m.getAttributes())));
          this.addUnionSet(unionType.members);
        }, (transformedStringType) => this.addUnionSet([
          transformedStringType
        ]));
        return (0, TypeAttributes_1.makeTypeAttributesInferred)(attributes);
      }
      get arrayData() {
        if (this._arrayItemTypes === void 0 || this._arrayItemTypes === false) {
          return (0, Support_1.panic)("This should not be called if the type can't be an array");
        }
        return this._arrayItemTypes;
      }
      get objectData() {
        if (this._objectProperties === void 0) {
          (0, Support_1.assert)(this._additionalPropertyTypes === void 0);
          return void 0;
        }
        return [
          this._objectProperties,
          this._additionalPropertyTypes
        ];
      }
      get enumCases() {
        return (0, Support_1.panic)("We don't support enums in intersections");
      }
      getMemberKinds() {
        const kinds = (0, collection_utils_1.mapMap)((0, Support_1.defined)(this._primitiveTypes).entries(), (k) => (0, Support_1.defined)(this._primitiveAttributes.get(k)));
        const maybeDoubleAttributes = this._primitiveAttributes.get("double");
        if (maybeDoubleAttributes !== void 0 && !kinds.has("double") && kinds.has("integer")) {
          (0, collection_utils_1.mapUpdateInto)(kinds, "integer", (a) => {
            return (0, TypeAttributes_1.combineTypeAttributes)("intersect", (0, Support_1.defined)(a), maybeDoubleAttributes);
          });
        }
        if (this._arrayItemTypes !== void 0 && this._arrayItemTypes !== false) {
          kinds.set("array", this._arrayAttributes);
        } else if (this._arrayAttributes.size > 0) {
          this._lostTypeAttributes = true;
        }
        if (this._objectProperties !== void 0) {
          kinds.set("object", this._objectAttributes);
        } else if (this._objectAttributes.size > 0) {
          this._lostTypeAttributes = true;
        }
        return kinds;
      }
      get lostTypeAttributes() {
        return this._lostTypeAttributes;
      }
    };
    var IntersectionUnionBuilder = class extends UnionBuilder_1.UnionBuilder {
      constructor() {
        super(...arguments);
        this._createdNewIntersections = false;
      }
      makeIntersection(members, attributes) {
        const reconstitutedMembers = (0, collection_utils_1.setMap)(members, (t) => this.typeBuilder.reconstituteTypeRef(t.typeRef));
        const first = (0, Support_1.defined)((0, collection_utils_1.iterableFirst)(reconstitutedMembers));
        if (reconstitutedMembers.size === 1) {
          this.typeBuilder.addAttributes(first, attributes);
          return first;
        }
        this._createdNewIntersections = true;
        return this.typeBuilder.getUniqueIntersectionType(attributes, reconstitutedMembers);
      }
      get createdNewIntersections() {
        return this._createdNewIntersections;
      }
      makeObject(maybeData, typeAttributes, forwardingRef) {
        if (maybeData === void 0) {
          return (0, Support_1.panic)("Either properties or additional properties must be given to make an object type");
        }
        const [propertyTypes, maybeAdditionalProperties] = maybeData;
        const properties = (0, collection_utils_1.mapMap)(propertyTypes, (cp) => this.typeBuilder.makeClassProperty(this.makeIntersection(cp.typeData, TypeAttributes_1.emptyTypeAttributes), cp.isOptional));
        const additionalProperties = maybeAdditionalProperties === void 0 ? void 0 : this.makeIntersection(maybeAdditionalProperties, TypeAttributes_1.emptyTypeAttributes);
        return this.typeBuilder.getUniqueObjectType(typeAttributes, properties, additionalProperties, forwardingRef);
      }
      makeArray(arrays, typeAttributes, forwardingRef) {
        const itemsType = this.makeIntersection(arrays, TypeAttributes_1.emptyTypeAttributes);
        const tref = this.typeBuilder.getArrayType(typeAttributes, itemsType, forwardingRef);
        return tref;
      }
    };
    function resolveIntersections(graph, stringTypeMapping, debugPrintReconstitution) {
      let needsRepeat = false;
      function replace(types, builder, forwardingRef) {
        const intersections = (0, collection_utils_1.setFilter)(types, (t) => t instanceof Type_1.IntersectionType);
        const [members, intersectionAttributes] = (0, TypeUtils_1.setOperationMembersRecursively)(Array.from(intersections), "intersect");
        if (members.size === 0) {
          const t = builder.getPrimitiveType("any", intersectionAttributes, forwardingRef);
          return t;
        }
        if (members.size === 1) {
          return builder.reconstituteType((0, Support_1.defined)((0, collection_utils_1.iterableFirst)(members)), intersectionAttributes, forwardingRef);
        }
        const accumulator = new IntersectionAccumulator();
        const extraAttributes = (0, TypeAttributes_1.makeTypeAttributesInferred)((0, TypeAttributes_1.combineTypeAttributes)("intersect", Array.from(members).map((t) => accumulator.addType(t))));
        const attributes = (0, TypeAttributes_1.combineTypeAttributes)("intersect", intersectionAttributes, extraAttributes);
        const unionBuilder = new IntersectionUnionBuilder(builder);
        const tref = unionBuilder.buildUnion(accumulator, true, attributes, forwardingRef);
        if (unionBuilder.createdNewIntersections) {
          needsRepeat = true;
        }
        return tref;
      }
      const allIntersections = (0, collection_utils_1.setFilter)(graph.allTypesUnordered(), (t) => t instanceof Type_1.IntersectionType);
      const resolvableIntersections = (0, collection_utils_1.setFilter)(allIntersections, canResolve);
      const groups = (0, TypeUtils_1.makeGroupsToFlatten)(resolvableIntersections, void 0);
      graph = graph.rewrite("resolve intersections", stringTypeMapping, false, groups, debugPrintReconstitution, replace);
      return [
        graph,
        !needsRepeat && allIntersections.size === resolvableIntersections.size
      ];
    }
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/GatherNames.js
var require_GatherNames = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/GatherNames.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
          enumerable: true,
          get: function() {
            return m[k];
          }
        };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
      });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || /* @__PURE__ */ function() {
      var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      };
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i2 = 0; i2 < k.length; i2++) if (k[i2] !== "default") __createBinding(result, mod, k[i2]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.gatherNames = gatherNames;
    var collection_utils_1 = require_dist();
    var pluralize = __importStar(require_pluralize());
    var TypeNames_1 = require_TypeNames();
    var Support_1 = require_Support();
    var Transformers_1 = require_Transformers();
    var Type_1 = require_Type();
    var TypeUtils_1 = require_TypeUtils();
    var UniqueQueue = class {
      constructor() {
        this._present = /* @__PURE__ */ new Set();
        this._queue = [];
        this._front = 0;
      }
      get size() {
        return this._queue.length - this._front;
      }
      get isEmpty() {
        return this.size <= 0;
      }
      push(v) {
        if (this._present.has(v)) return;
        this._queue.push(v);
        this._present.add(v);
      }
      unshift() {
        (0, Support_1.assert)(!this.isEmpty, "Trying to unshift from an empty queue");
        const v = this._queue[this._front];
        if (v === void 0) {
          return (0, Support_1.panic)("Value should have been present in queue");
        }
        this._queue[this._front] = void 0;
        this._front += 1;
        this._present.delete(v);
        if (this._front > this.size) {
          this._queue = this._queue.slice(this._front);
          this._front = 0;
        }
        return v;
      }
    };
    function gatherNames(graph, destructive, debugPrint) {
      function setNames(t, tn) {
        graph.attributeStore.set(TypeNames_1.namesTypeAttributeKind, t, tn);
      }
      if (destructive) {
        for (const t of graph.allTypesUnordered()) {
          if (t.hasNames) {
            setNames(t, t.getNames().clearInferred());
          }
        }
      }
      const queue = new UniqueQueue();
      const namesForType = /* @__PURE__ */ new Map();
      function addNames(t, names) {
        if (t.hasNames) {
          const originalNames = t.getNames();
          if (!originalNames.areInferred) {
            names = originalNames.names;
          }
        }
        const oldNames = namesForType.get(t);
        if (oldNames === null) return;
        let newNames;
        if (oldNames === void 0) {
          newNames = names;
        } else if (names === null) {
          newNames = null;
        } else {
          newNames = (0, collection_utils_1.setUnion)(oldNames, names);
        }
        if (newNames !== null && newNames.size >= TypeNames_1.tooManyNamesThreshold) {
          newNames = null;
        }
        namesForType.set(t, newNames);
        const transformation = (0, Transformers_1.transformationForType)(t);
        if (transformation !== void 0) {
          addNames(transformation.targetType, names);
        }
        if (oldNames !== void 0 && newNames !== null) {
          if (oldNames.size === newNames.size) {
            return;
          }
        } else if (oldNames === newNames) {
          return;
        }
        queue.push(t);
      }
      for (const [name, t] of graph.topLevels) {
        addNames(t, /* @__PURE__ */ new Set([
          name
        ]));
      }
      while (!queue.isEmpty) {
        const t = queue.unshift();
        const names = (0, Support_1.defined)(namesForType.get(t));
        if (t instanceof Type_1.ObjectType) {
          const properties = t.getSortedProperties();
          for (const [propertyName, property] of properties) {
            addNames(property.type, /* @__PURE__ */ new Set([
              propertyName
            ]));
          }
          const values = t.getAdditionalProperties();
          if (values !== void 0) {
            addNames(values, names === null ? null : (0, collection_utils_1.setMap)(names, pluralize.singular));
          }
        } else {
          (0, TypeUtils_1.matchCompoundType)(t, (arrayType) => {
            addNames(arrayType.items, names === null ? null : (0, collection_utils_1.setMap)(names, pluralize.singular));
          }, (_classType) => (0, Support_1.panic)("We handled this above"), (_mapType) => (0, Support_1.panic)("We handled this above"), (_objectType) => (0, Support_1.panic)("We handled this above"), (unionType) => {
            const members = (0, collection_utils_1.setSortBy)(unionType.members, (member) => member.kind);
            for (const memberType of members) {
              addNames(memberType, names);
            }
          });
        }
      }
      if (debugPrint) {
        for (const t of graph.allTypesUnordered()) {
          const names = namesForType.get(t);
          if (names === void 0) return;
          const index = t.index;
          console.log(`${index}: ${names === null ? "*** too many ***" : Array.from(names).join(" ")}`);
        }
      }
      const directAlternativesForType = /* @__PURE__ */ new Map();
      const ancestorAlternativesForType = /* @__PURE__ */ new Map();
      const pairsProcessed = /* @__PURE__ */ new Map();
      function addAlternatives(existing, alternatives) {
        if (alternatives.length === 0) {
          return existing;
        }
        if (existing === void 0) {
          existing = /* @__PURE__ */ new Set();
        }
        existing = (0, collection_utils_1.setUnion)(existing, alternatives);
        if (existing.size < TypeNames_1.tooManyNamesThreshold) {
          return existing;
        }
        return null;
      }
      function processType(ancestor, t, alternativeSuffix) {
        const names = (0, Support_1.defined)(namesForType.get(t));
        let processedEntry = pairsProcessed.get(ancestor);
        if (processedEntry === void 0) processedEntry = /* @__PURE__ */ new Set();
        if (processedEntry.has(t)) return;
        processedEntry.add(t);
        pairsProcessed.set(ancestor, processedEntry);
        const transformation = (0, Transformers_1.transformationForType)(t);
        if (transformation !== void 0) {
          processType(ancestor, transformation.targetType, alternativeSuffix);
        }
        let ancestorAlternatives = ancestorAlternativesForType.get(t);
        let directAlternatives = directAlternativesForType.get(t);
        if (names === null) {
          ancestorAlternatives = null;
          directAlternatives = null;
        } else {
          if (ancestor !== void 0 && ancestorAlternatives !== null) {
            const ancestorNames = namesForType.get(ancestor);
            if (ancestorNames === null) {
              ancestorAlternatives = null;
            } else if (ancestorNames !== void 0) {
              const alternatives = [];
              for (const name of names) {
                alternatives.push(...Array.from(ancestorNames).map((an) => `${an}_${name}`));
                alternatives.push(...Array.from(ancestorNames).map((an) => `${an}_${name}_${t.kind}`));
              }
              ancestorAlternatives = addAlternatives(ancestorAlternatives, alternatives);
            }
          }
          if (alternativeSuffix !== void 0 && directAlternatives !== null) {
            const alternatives = [];
            for (const name of names) {
              alternatives.push(`${name}_${alternativeSuffix}`);
            }
            directAlternatives = addAlternatives(directAlternatives, alternatives);
          }
        }
        if (ancestorAlternatives !== void 0) {
          ancestorAlternativesForType.set(t, ancestorAlternatives);
        }
        if (directAlternatives !== void 0) {
          directAlternativesForType.set(t, directAlternatives);
        }
        if (t instanceof Type_1.ObjectType) {
          const properties = t.getSortedProperties();
          for (const [, property] of properties) {
            processType(t, property.type, void 0);
          }
          const values = t.getAdditionalProperties();
          if (values !== void 0) {
            processType(properties.size === 0 ? ancestor : t, values, "value");
          }
        } else {
          (0, TypeUtils_1.matchCompoundType)(t, (arrayType) => {
            processType(ancestor, arrayType.items, "element");
          }, (_classType) => (0, Support_1.panic)("We handled this above"), (_mapType) => (0, Support_1.panic)("We handled this above"), (_objectType) => (0, Support_1.panic)("We handled this above"), (unionType) => {
            const members = (0, collection_utils_1.setSortBy)(unionType.members, (member) => member.kind);
            const unionHasGivenName = unionType.hasNames && !unionType.getNames().areInferred;
            const unionIsAncestor = unionHasGivenName || (0, TypeUtils_1.nullableFromUnion)(unionType) === null;
            const ancestorForMembers = unionIsAncestor ? unionType : ancestor;
            for (const memberType of members) {
              processType(ancestorForMembers, memberType, void 0);
            }
          });
        }
      }
      for (const [, t] of graph.topLevels) {
        processType(void 0, t, void 0);
      }
      for (const t of graph.allTypesUnordered()) {
        const names = namesForType.get(t);
        if (names === void 0) continue;
        if (names === null) {
          directAlternativesForType.set(t, null);
          continue;
        }
        let alternatives = directAlternativesForType.get(t);
        if (alternatives === null) continue;
        if (alternatives === void 0) {
          alternatives = /* @__PURE__ */ new Set();
        }
        alternatives = (0, collection_utils_1.setUnion)(alternatives, (0, collection_utils_1.setMap)(names, (name) => `${name}_${t.kind}`));
        directAlternativesForType.set(t, alternatives);
      }
      for (const t of graph.allTypesUnordered()) {
        const names = namesForType.get(t);
        if (names === void 0) continue;
        let typeNames;
        if (names === null) {
          typeNames = new TypeNames_1.TooManyTypeNames(1);
        } else {
          const ancestorAlternatives = ancestorAlternativesForType.get(t);
          const directAlternatives = directAlternativesForType.get(t);
          let alternatives;
          if (ancestorAlternatives === null && directAlternatives === null) {
            alternatives = void 0;
          } else {
            if (directAlternatives !== null && directAlternatives !== void 0) {
              alternatives = directAlternatives;
            } else {
              alternatives = /* @__PURE__ */ new Set();
            }
            if (ancestorAlternatives !== null && ancestorAlternatives !== void 0) {
              alternatives = (0, collection_utils_1.setUnion)(alternatives, ancestorAlternatives);
            }
          }
          typeNames = TypeNames_1.TypeNames.makeWithDistance(names, alternatives, destructive ? 1 : 10);
        }
        setNames(t, t.hasNames ? t.getNames().add([
          typeNames
        ]) : typeNames);
      }
    }
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/Inference.js
var require_Inference2 = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/Inference.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.defaultInferenceFlags = exports.inferenceFlags = exports.inferenceFlagNames = exports.inferenceFlagsObject = void 0;
    exports.inferenceFlagsObject = {
      /** Whether to infer map types from JSON data */
      inferMaps: {
        description: "Detect maps",
        negationDescription: "Don't infer maps, always use classes",
        explanation: "Infer maps when object keys look like map keys.",
        order: 1
      },
      /** Whether to infer enum types from JSON data */
      inferEnums: {
        description: "Detect enums",
        negationDescription: "Don't infer enums, always use strings",
        explanation: "If string values occur within a relatively small domain,\ninfer them as enum values.",
        order: 2
      },
      /** Whether to convert UUID strings to UUID objects */
      inferUuids: {
        description: "Detect UUIDs",
        negationDescription: "Don't convert UUIDs to UUID objects",
        explanation: "Detect UUIDs like '123e4567-e89b-12d3-a456-426655440000' (partial support).",
        stringType: "uuid",
        order: 3
      },
      /** Whether to assume that JSON strings that look like dates are dates */
      inferDateTimes: {
        description: "Detect dates & times",
        negationDescription: "Don't infer dates or times",
        explanation: "Infer dates from strings (partial support).",
        stringType: "date-time",
        order: 4
      },
      /** Whether to convert stringified integers to integers */
      inferIntegerStrings: {
        description: "Detect integers in strings",
        negationDescription: "Don't convert stringified integers to integers",
        explanation: 'Automatically convert stringified integers to integers.\nFor example, "1" is converted to 1.',
        stringType: "integer-string",
        order: 5
      },
      /** Whether to convert stringified booleans to boolean values */
      inferBooleanStrings: {
        description: "Detect booleans in strings",
        negationDescription: "Don't convert stringified booleans to booleans",
        explanation: 'Automatically convert stringified booleans to booleans.\nFor example, "true" is converted to true.',
        stringType: "bool-string",
        order: 6
      },
      /** Combine similar classes.  This doesn't apply to classes from a schema, only from inference. */
      combineClasses: {
        description: "Merge similar classes",
        negationDescription: "Don't combine similar classes",
        explanation: "Combine classes with significantly overlapping properties,\ntreating contingent properties as nullable.",
        order: 7
      },
      /** Whether to treat $ref as references within JSON */
      ignoreJsonRefs: {
        description: "Don't treat $ref as a reference in JSON",
        negationDescription: "Treat $ref as a reference in JSON",
        explanation: `Like in JSON Schema, allow objects like
'{ $ref: "#/foo/bar" }' to refer
to another part of the input.`,
        order: 8
      }
    };
    exports.inferenceFlagNames = Object.getOwnPropertyNames(exports.inferenceFlagsObject);
    exports.inferenceFlags = exports.inferenceFlagsObject;
    function makeDefaultInferenceFlags() {
      const flags = {};
      for (const flag of exports.inferenceFlagNames) {
        flags[flag] = true;
      }
      return flags;
    }
    exports.defaultInferenceFlags = makeDefaultInferenceFlags();
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/MakeTransformations.js
var require_MakeTransformations = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/MakeTransformations.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.makeTransformations = makeTransformations;
    var collection_utils_1 = require_dist();
    var Constraints_1 = require_Constraints();
    var StringTypes_1 = require_StringTypes();
    var TypeAttributes_1 = require_TypeAttributes();
    var Support_1 = require_Support();
    var Transformers_1 = require_Transformers();
    var Type_1 = require_Type2();
    var TypeRef_1 = require_TypeRef();
    function transformationAttributes(graph, reconstitutedTargetType, transformer, debugPrintTransformations) {
      const transformation = new Transformers_1.Transformation(graph, reconstitutedTargetType, transformer);
      if (debugPrintTransformations) {
        console.log(`transformation for ${(0, TypeRef_1.typeRefIndex)(reconstitutedTargetType)}:`);
        transformation.debugPrint();
        console.log("reverse:");
        transformation.reverse.debugPrint();
      }
      return Transformers_1.transformationTypeAttributeKind.makeAttributes(transformation);
    }
    function makeEnumTransformer(graph, enumType, stringType, continuation) {
      const sortedCases = Array.from(enumType.cases).sort();
      const caseTransformers = sortedCases.map((c) => new Transformers_1.StringMatchTransformer(graph, stringType, new Transformers_1.StringProducerTransformer(graph, stringType, continuation, c), c));
      return new Transformers_1.ChoiceTransformer(graph, stringType, caseTransformers);
    }
    function replaceUnion(union, builder, forwardingRef, transformedTypes, debugPrintTransformations) {
      const graph = builder.typeGraph;
      (0, Support_1.assert)(union.members.size > 0, "We can't have empty unions");
      let additionalAttributes = TypeAttributes_1.emptyTypeAttributes;
      function reconstituteMember(t) {
        if ((0, Type_1.isPrimitiveStringTypeKind)(t.kind)) {
          const targetTypeKind = (0, Type_1.targetTypeKindForTransformedStringTypeKind)(t.kind);
          if (targetTypeKind !== void 0) {
            const targetTypeMember = union.findMember(targetTypeKind);
            additionalAttributes = (0, TypeAttributes_1.combineTypeAttributes)("union", additionalAttributes, t.getAttributes());
            if (targetTypeMember !== void 0) {
              return builder.reconstituteType(targetTypeMember);
            }
            return builder.getPrimitiveType(targetTypeKind);
          }
        }
        return builder.reconstituteType(t);
      }
      const reconstitutedMembersByKind = (0, collection_utils_1.mapMapEntries)(union.members.entries(), (m) => [
        m.kind,
        reconstituteMember(m)
      ]);
      const reconstitutedMemberSet = new Set(reconstitutedMembersByKind.values());
      const haveUnion = reconstitutedMemberSet.size > 1;
      if (!haveUnion) {
        builder.setLostTypeAttributes();
      }
      const reconstitutedTargetType = haveUnion ? builder.getUnionType(union.getAttributes(), reconstitutedMemberSet) : (0, Support_1.defined)((0, collection_utils_1.iterableFirst)(reconstitutedMemberSet));
      function memberForKind(kind) {
        return (0, Support_1.defined)(reconstitutedMembersByKind.get(kind));
      }
      function consumer(memberTypeRef) {
        if (!haveUnion) return void 0;
        return new Transformers_1.UnionInstantiationTransformer(graph, memberTypeRef);
      }
      function transformerForKind(kind) {
        const member = union.findMember(kind);
        if (member === void 0) return void 0;
        const memberTypeRef = memberForKind(kind);
        return new Transformers_1.DecodingTransformer(graph, memberTypeRef, consumer(memberTypeRef));
      }
      let maybeStringType = void 0;
      function getStringType() {
        if (maybeStringType === void 0) {
          maybeStringType = builder.getStringType(TypeAttributes_1.emptyTypeAttributes, StringTypes_1.StringTypes.unrestricted);
        }
        return maybeStringType;
      }
      function transformerForStringType(t) {
        const memberRef = memberForKind(t.kind);
        if (t.kind === "string") {
          const minMax = (0, Constraints_1.minMaxLengthForType)(t);
          if (minMax === void 0) {
            return consumer(memberRef);
          }
          const [min, max] = minMax;
          return new Transformers_1.MinMaxLengthCheckTransformer(graph, getStringType(), consumer(memberRef), min, max);
        }
        if (t instanceof Type_1.EnumType && transformedTypes.has(t)) {
          return makeEnumTransformer(graph, t, getStringType(), consumer(memberRef));
        }
        return new Transformers_1.ParseStringTransformer(graph, getStringType(), consumer(memberRef));
      }
      const stringTypes = (0, collection_utils_1.arraySortByInto)(Array.from(union.stringTypeMembers), (t) => t.kind);
      let transformerForString;
      if (stringTypes.length === 0) {
        transformerForString = void 0;
      } else if (stringTypes.length === 1) {
        const t = stringTypes[0];
        transformerForString = new Transformers_1.DecodingTransformer(graph, getStringType(), transformerForStringType(t));
      } else {
        transformerForString = new Transformers_1.DecodingTransformer(graph, getStringType(), new Transformers_1.ChoiceTransformer(graph, getStringType(), stringTypes.map((t) => (0, Support_1.defined)(transformerForStringType(t)))));
      }
      const transformerForClass = transformerForKind("class");
      const transformerForMap = transformerForKind("map");
      (0, Support_1.assert)(transformerForClass === void 0 || transformerForMap === void 0, "Can't have both class and map in a transformed union");
      const transformerForObject = transformerForClass !== null && transformerForClass !== void 0 ? transformerForClass : transformerForMap;
      const transformer = new Transformers_1.DecodingChoiceTransformer(graph, builder.getPrimitiveType("any"), transformerForKind("null"), transformerForKind("integer"), transformerForKind("double"), transformerForKind("bool"), transformerForString, transformerForKind("array"), transformerForObject);
      const attributes = transformationAttributes(graph, reconstitutedTargetType, transformer, debugPrintTransformations);
      return builder.getPrimitiveType("any", (0, TypeAttributes_1.combineTypeAttributes)("union", attributes, additionalAttributes), forwardingRef);
    }
    function replaceArray(arrayType, builder, forwardingRef, debugPrintTransformations) {
      const anyType = builder.getPrimitiveType("any");
      const anyArrayType = builder.getArrayType(TypeAttributes_1.emptyTypeAttributes, anyType);
      const reconstitutedItems = builder.reconstituteType(arrayType.items);
      const transformer = new Transformers_1.ArrayDecodingTransformer(builder.typeGraph, anyArrayType, void 0, reconstitutedItems, new Transformers_1.DecodingTransformer(builder.typeGraph, anyType, void 0));
      const reconstitutedArray = builder.getArrayType(builder.reconstituteTypeAttributes(arrayType.getAttributes()), reconstitutedItems);
      const attributes = transformationAttributes(builder.typeGraph, reconstitutedArray, transformer, debugPrintTransformations);
      return builder.getArrayType(attributes, anyType, forwardingRef);
    }
    function replaceEnum(enumType, builder, forwardingRef, debugPrintTransformations) {
      const stringType = builder.getStringType(TypeAttributes_1.emptyTypeAttributes, StringTypes_1.StringTypes.unrestricted);
      const transformer = new Transformers_1.DecodingTransformer(builder.typeGraph, stringType, makeEnumTransformer(builder.typeGraph, enumType, stringType));
      const reconstitutedEnum = builder.getEnumType(enumType.getAttributes(), enumType.cases);
      const attributes = transformationAttributes(builder.typeGraph, reconstitutedEnum, transformer, debugPrintTransformations);
      return builder.getStringType(attributes, StringTypes_1.StringTypes.unrestricted, forwardingRef);
    }
    function replaceNumber(t, builder, forwardingRef, debugPrintTransformations) {
      const stringType = builder.getStringType(TypeAttributes_1.emptyTypeAttributes, StringTypes_1.StringTypes.unrestricted);
      const [min, max] = (0, Support_1.defined)((0, Constraints_1.minMaxValueForType)(t));
      const transformer = new Transformers_1.DecodingTransformer(builder.typeGraph, stringType, new Transformers_1.MinMaxValueTransformer(builder.typeGraph, stringType, void 0, min, max));
      const reconstitutedAttributes = builder.reconstituteTypeAttributes(t.getAttributes());
      const attributes = transformationAttributes(builder.typeGraph, builder.getPrimitiveType("double", reconstitutedAttributes, void 0), transformer, debugPrintTransformations);
      return builder.getPrimitiveType("double", attributes, forwardingRef);
    }
    function replaceString(t, builder, forwardingRef, debugPrintTransformations) {
      const [min, max] = (0, Support_1.defined)((0, Constraints_1.minMaxLengthForType)(t));
      const reconstitutedAttributes = builder.reconstituteTypeAttributes(t.getAttributes());
      const stringType = builder.getStringType(TypeAttributes_1.emptyTypeAttributes, StringTypes_1.StringTypes.unrestricted);
      const transformer = new Transformers_1.DecodingTransformer(builder.typeGraph, stringType, new Transformers_1.MinMaxLengthCheckTransformer(builder.typeGraph, stringType, void 0, min, max));
      const attributes = transformationAttributes(builder.typeGraph, builder.getStringType(reconstitutedAttributes, void 0), transformer, debugPrintTransformations);
      return builder.getStringType(attributes, StringTypes_1.StringTypes.unrestricted, forwardingRef);
    }
    function replaceTransformedStringType(t, kind, builder, forwardingRef, debugPrintTransformations) {
      const reconstitutedAttributes = builder.reconstituteTypeAttributes(t.getAttributes());
      const targetTypeKind = (0, collection_utils_1.withDefault)((0, Type_1.targetTypeKindForTransformedStringTypeKind)(kind), kind);
      const stringType = builder.getStringType(TypeAttributes_1.emptyTypeAttributes, StringTypes_1.StringTypes.unrestricted);
      const transformer = new Transformers_1.DecodingTransformer(builder.typeGraph, stringType, new Transformers_1.ParseStringTransformer(builder.typeGraph, stringType, void 0));
      const attributes = transformationAttributes(builder.typeGraph, builder.getPrimitiveType(targetTypeKind, reconstitutedAttributes), transformer, debugPrintTransformations);
      return builder.getStringType(attributes, StringTypes_1.StringTypes.unrestricted, forwardingRef);
    }
    function makeTransformations(ctx, graph, targetLanguage) {
      const transformedTypes = (0, collection_utils_1.setFilter)(graph.allTypesUnordered(), (t) => {
        if (targetLanguage.needsTransformerForType(t)) return true;
        if (!(t instanceof Type_1.UnionType)) return false;
        const stringMembers = t.stringTypeMembers;
        if (stringMembers.size <= 1) return false;
        return (0, collection_utils_1.iterableSome)(stringMembers, (m) => targetLanguage.needsTransformerForType(m));
      });
      function replace(setOfOneUnion, builder, forwardingRef) {
        const t = (0, Support_1.defined)((0, collection_utils_1.iterableFirst)(setOfOneUnion));
        if (t instanceof Type_1.UnionType) {
          return replaceUnion(t, builder, forwardingRef, transformedTypes, ctx.debugPrintTransformations);
        }
        if (t instanceof Type_1.ArrayType) {
          return replaceArray(t, builder, forwardingRef, ctx.debugPrintTransformations);
        }
        if (t instanceof Type_1.EnumType) {
          return replaceEnum(t, builder, forwardingRef, ctx.debugPrintTransformations);
        }
        if (t.kind === "string") {
          return replaceString(t, builder, forwardingRef, ctx.debugPrintTransformations);
        }
        if ((0, Type_1.isNumberTypeKind)(t.kind)) {
          return replaceNumber(t, builder, forwardingRef, ctx.debugPrintTransformations);
        }
        if ((0, Type_1.isPrimitiveStringTypeKind)(t.kind)) {
          return replaceTransformedStringType(t, t.kind, builder, forwardingRef, ctx.debugPrintTransformations);
        }
        return (0, Support_1.panic)(`Cannot make transformation for type ${t.kind}`);
      }
      const groups = Array.from(transformedTypes).map((t) => [
        t
      ]);
      return graph.rewrite("make-transformations", ctx.stringTypeMapping, false, groups, ctx.debugPrintReconstitution, replace);
    }
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/Run.js
var require_Run = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/Run.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
          enumerable: true,
          get: function() {
            return m[k];
          }
        };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
      });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || /* @__PURE__ */ function() {
      var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      };
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i2 = 0; i2 < k.length; i2++) if (k[i2] !== "default") __createBinding(result, mod, k[i2]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.getTargetLanguage = getTargetLanguage;
    exports.quicktypeMultiFile = quicktypeMultiFile;
    exports.quicktypeMultiFileSync = quicktypeMultiFileSync;
    exports.combineRenderResults = combineRenderResults;
    exports.quicktype = quicktype2;
    var collection_utils_1 = require_dist();
    var TypeNames_1 = require_TypeNames();
    var Inputs_1 = require_Inputs();
    var targetLanguages = __importStar(require_All());
    var CombineClasses_1 = require_CombineClasses();
    var ExpandStrings_1 = require_ExpandStrings();
    var FlattenStrings_1 = require_FlattenStrings();
    var FlattenUnions_1 = require_FlattenUnions();
    var InferMaps_1 = require_InferMaps();
    var ReplaceObjectType_1 = require_ReplaceObjectType();
    var ResolveIntersections_1 = require_ResolveIntersections();
    var Support_1 = require_Support();
    var GatherNames_1 = require_GatherNames();
    var Inference_1 = require_Inference2();
    var MakeTransformations_1 = require_MakeTransformations();
    var Messages_1 = require_Messages();
    var TypeBuilder_1 = require_TypeBuilder();
    var TypeGraph_1 = require_TypeGraph();
    var TypeGraphUtils_1 = require_TypeGraphUtils();
    function getTargetLanguage(nameOrInstance) {
      if (typeof nameOrInstance === "object") {
        return nameOrInstance;
      }
      const language = targetLanguages.languageNamed(nameOrInstance);
      if (language !== void 0) {
        return language;
      }
      return (0, Messages_1.messageError)("DriverUnknownOutputLanguage", {
        lang: nameOrInstance
      });
    }
    var defaultOptions = {
      lang: "ts",
      inputData: new Inputs_1.InputData(),
      alphabetizeProperties: false,
      allPropertiesOptional: false,
      fixedTopLevels: false,
      noRender: false,
      leadingComments: void 0,
      rendererOptions: {},
      indentation: void 0,
      outputFilename: "stdout",
      debugPrintGraph: false,
      checkProvenance: false,
      debugPrintReconstitution: false,
      debugPrintGatherNames: false,
      debugPrintTransformations: false,
      debugPrintTimes: false,
      debugPrintSchemaResolving: false
    };
    var Run = class {
      constructor(options) {
        this._options = Object.fromEntries(Object.entries(Object.assign({}, defaultOptions, Inference_1.defaultInferenceFlags)).map(([k, v]) => {
          var _a;
          return [
            k,
            (_a = options[k]) !== null && _a !== void 0 ? _a : v
          ];
        }));
      }
      get stringTypeMapping() {
        const targetLanguage = getTargetLanguage(this._options.lang);
        const mapping = new Map(targetLanguage.stringTypeMapping);
        for (const flag of Inference_1.inferenceFlagNames) {
          const stringType = Inference_1.inferenceFlags[flag].stringType;
          if (!this._options[flag] && stringType !== void 0) {
            mapping.set(stringType, "string");
          }
        }
        return mapping;
      }
      get debugPrintReconstitution() {
        return this._options.debugPrintReconstitution === true;
      }
      get debugPrintTransformations() {
        return this._options.debugPrintTransformations;
      }
      get debugPrintSchemaResolving() {
        return this._options.debugPrintSchemaResolving;
      }
      timeSync(name, f) {
        return __awaiter(this, void 0, void 0, function* () {
          const start = Date.now();
          const result = yield f();
          const end = Date.now();
          if (this._options.debugPrintTimes) {
            console.log(`${name} took ${end - start}ms`);
          }
          return result;
        });
      }
      time(name, f) {
        const start = Date.now();
        const result = f();
        const end = Date.now();
        if (this._options.debugPrintTimes) {
          console.log(`${name} took ${end - start}ms`);
        }
        return result;
      }
      makeGraphInputs() {
        const targetLanguage = getTargetLanguage(this._options.lang);
        const stringTypeMapping = this.stringTypeMapping;
        const conflateNumbers = !targetLanguage.supportsUnionsWithBothNumberTypes;
        const typeBuilder = new TypeBuilder_1.TypeBuilder(stringTypeMapping, this._options.alphabetizeProperties, this._options.allPropertiesOptional, this._options.checkProvenance, false);
        typeBuilder.typeGraph = new TypeGraph_1.TypeGraph(typeBuilder, 0, this._options.checkProvenance);
        return {
          targetLanguage,
          stringTypeMapping,
          conflateNumbers,
          typeBuilder
        };
      }
      makeGraph(allInputs) {
        return __awaiter(this, void 0, void 0, function* () {
          const graphInputs = this.makeGraphInputs();
          yield this.timeSync("read input", () => __awaiter(this, void 0, void 0, function* () {
            return yield allInputs.addTypes(this, graphInputs.typeBuilder, this._options.inferMaps, this._options.inferEnums, this._options.fixedTopLevels);
          }));
          return this.processGraph(allInputs, graphInputs);
        });
      }
      makeGraphSync(allInputs) {
        const graphInputs = this.makeGraphInputs();
        this.time("read input", () => allInputs.addTypesSync(this, graphInputs.typeBuilder, this._options.inferMaps, this._options.inferEnums, this._options.fixedTopLevels));
        return this.processGraph(allInputs, graphInputs);
      }
      processGraph(allInputs, graphInputs) {
        const { targetLanguage, stringTypeMapping, conflateNumbers, typeBuilder } = graphInputs;
        let graph = typeBuilder.finish();
        if (this._options.debugPrintGraph) {
          graph.setPrintOnRewrite();
          graph.printGraph();
        }
        const debugPrintReconstitution = this.debugPrintReconstitution;
        if (typeBuilder.didAddForwardingIntersection || !this._options.ignoreJsonRefs) {
          this.time("remove indirection intersections", () => {
            graph = (0, TypeGraphUtils_1.removeIndirectionIntersections)(graph, stringTypeMapping, debugPrintReconstitution);
          });
        }
        let unionsDone = false;
        if (allInputs.needSchemaProcessing || !this._options.ignoreJsonRefs) {
          let intersectionsDone = false;
          do {
            const graphBeforeRewrites = graph;
            if (!intersectionsDone) {
              this.time("resolve intersections", () => {
                [graph, intersectionsDone] = (0, ResolveIntersections_1.resolveIntersections)(graph, stringTypeMapping, debugPrintReconstitution);
              });
            }
            if (!unionsDone) {
              this.time("flatten unions", () => {
                [graph, unionsDone] = (0, FlattenUnions_1.flattenUnions)(graph, stringTypeMapping, conflateNumbers, true, debugPrintReconstitution);
              });
            }
            if (graph === graphBeforeRewrites) {
              (0, Support_1.assert)(intersectionsDone && unionsDone, "Graph didn't change but we're not done");
            }
          } while (!intersectionsDone || !unionsDone);
        }
        this.time("replace object type", () => {
          graph = (0, ReplaceObjectType_1.replaceObjectType)(graph, stringTypeMapping, conflateNumbers, targetLanguage.supportsFullObjectType, debugPrintReconstitution);
        });
        do {
          this.time("flatten unions", () => {
            [graph, unionsDone] = (0, FlattenUnions_1.flattenUnions)(graph, stringTypeMapping, conflateNumbers, false, debugPrintReconstitution);
          });
        } while (!unionsDone);
        if (this._options.combineClasses) {
          const combinedGraph = this.time("combine classes", () => (0, CombineClasses_1.combineClasses)(this, graph, this._options.alphabetizeProperties, true, false, debugPrintReconstitution));
          if (combinedGraph === graph) {
            graph = combinedGraph;
          } else {
            this.time("combine classes cleanup", () => {
              graph = (0, CombineClasses_1.combineClasses)(this, combinedGraph, this._options.alphabetizeProperties, false, true, debugPrintReconstitution);
            });
          }
        }
        if (this._options.inferMaps) {
          for (; ; ) {
            const newGraph = this.time("infer maps", () => (0, InferMaps_1.inferMaps)(graph, stringTypeMapping, true, debugPrintReconstitution));
            if (newGraph === graph) {
              break;
            }
            graph = newGraph;
          }
        }
        const enumInference = allInputs.needSchemaProcessing ? "all" : this._options.inferEnums ? "infer" : "none";
        this.time("expand strings", () => {
          graph = (0, ExpandStrings_1.expandStrings)(this, graph, enumInference);
        });
        this.time("flatten unions", () => {
          [graph, unionsDone] = (0, FlattenUnions_1.flattenUnions)(graph, stringTypeMapping, conflateNumbers, false, debugPrintReconstitution);
        });
        (0, Support_1.assert)(unionsDone, "We should only have to flatten unions once after expanding strings");
        if (allInputs.needSchemaProcessing) {
          this.time("flatten strings", () => {
            graph = (0, FlattenStrings_1.flattenStrings)(graph, stringTypeMapping, debugPrintReconstitution);
          });
        }
        this.time("none to any", () => {
          graph = (0, TypeGraphUtils_1.noneToAny)(graph, stringTypeMapping, debugPrintReconstitution);
        });
        if (!targetLanguage.supportsOptionalClassProperties) {
          this.time("optional to nullable", () => {
            graph = (0, TypeGraphUtils_1.optionalToNullable)(graph, stringTypeMapping, debugPrintReconstitution);
          });
        }
        this.time("fixed point", () => {
          graph = graph.rewriteFixedPoint(false, debugPrintReconstitution);
        });
        this.time("make transformations", () => {
          graph = (0, MakeTransformations_1.makeTransformations)(this, graph, targetLanguage);
        });
        this.time("flatten unions", () => {
          [graph, unionsDone] = (0, FlattenUnions_1.flattenUnions)(graph, stringTypeMapping, conflateNumbers, false, debugPrintReconstitution);
        });
        (0, Support_1.assert)(unionsDone, "We should only have to flatten unions once after making transformations");
        this.time("GC", () => {
          graph = graph.garbageCollect(this._options.alphabetizeProperties, debugPrintReconstitution);
        });
        if (this._options.debugPrintGraph) {
          console.log("\n# gather names");
        }
        this.time("gather names", () => (0, GatherNames_1.gatherNames)(graph, !allInputs.needSchemaProcessing, this._options.debugPrintGatherNames));
        if (this._options.debugPrintGraph) {
          graph.printGraph();
        }
        return graph;
      }
      makeSimpleTextResult(lines) {
        return /* @__PURE__ */ new Map([
          [
            this._options.outputFilename,
            {
              lines,
              annotations: []
            }
          ]
        ]);
      }
      preRun() {
        (0, TypeNames_1.initTypeNames)();
        const targetLanguage = getTargetLanguage(this._options.lang);
        const inputData = this._options.inputData;
        const needIR = inputData.needIR || !targetLanguage.names.includes("schema");
        const schemaString = needIR ? void 0 : inputData.singleStringSchemaSource();
        if (schemaString !== void 0) {
          const lines = JSON.stringify(JSON.parse(schemaString), void 0, 4).split("\n");
          lines.push("");
          const srr = {
            lines,
            annotations: []
          };
          return /* @__PURE__ */ new Map([
            [
              this._options.outputFilename,
              srr
            ]
          ]);
        }
        return [
          inputData,
          targetLanguage
        ];
      }
      run() {
        return __awaiter(this, void 0, void 0, function* () {
          const preRunResult = this.preRun();
          if (!Array.isArray(preRunResult)) {
            return preRunResult;
          }
          const [inputData, targetLanguage] = preRunResult;
          const graph = yield this.makeGraph(inputData);
          return this.renderGraph(targetLanguage, graph);
        });
      }
      runSync() {
        const preRunResult = this.preRun();
        if (!Array.isArray(preRunResult)) {
          return preRunResult;
        }
        const [inputData, targetLanguage] = preRunResult;
        const graph = this.makeGraphSync(inputData);
        return this.renderGraph(targetLanguage, graph);
      }
      renderGraph(targetLanguage, graph) {
        if (this._options.noRender) {
          return this.makeSimpleTextResult([
            "Done.",
            ""
          ]);
        }
        return targetLanguage.renderGraphAndSerialize(graph, this._options.outputFilename, this._options.alphabetizeProperties, this._options.leadingComments, this._options.rendererOptions, this._options.indentation);
      }
    };
    function quicktypeMultiFile(options) {
      return __awaiter(this, void 0, void 0, function* () {
        return yield new Run(options).run();
      });
    }
    function quicktypeMultiFileSync(options) {
      return new Run(options).runSync();
    }
    function offsetLocation(loc, lineOffset) {
      return {
        line: loc.line + lineOffset,
        column: loc.column
      };
    }
    function offsetSpan(span, lineOffset) {
      return {
        start: offsetLocation(span.start, lineOffset),
        end: offsetLocation(span.end, lineOffset)
      };
    }
    function combineRenderResults(result) {
      if (result.size <= 1) {
        const first = (0, collection_utils_1.mapFirst)(result);
        if (first === void 0) {
          return {
            lines: [],
            annotations: []
          };
        }
        return first;
      }
      let lines = [];
      let annotations = [];
      for (const [filename, srr] of result) {
        const offset = lines.length + 2;
        lines = lines.concat([
          `// ${filename}`,
          ""
        ], srr.lines);
        annotations = annotations.concat(srr.annotations.map((ann) => ({
          annotation: ann.annotation,
          span: offsetSpan(ann.span, offset)
        })));
      }
      return {
        lines,
        annotations
      };
    }
    function quicktype2(options) {
      return __awaiter(this, void 0, void 0, function* () {
        const result = yield quicktypeMultiFile(options);
        return combineRenderResults(result);
      });
    }
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/input/JSONSchemaStore.js
var require_JSONSchemaStore = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/input/JSONSchemaStore.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.JSONSchemaStore = void 0;
    var Support_1 = require_Support();
    var JSONSchemaStore = class {
      constructor() {
        this._schemas = /* @__PURE__ */ new Map();
      }
      add(address, schema) {
        (0, Support_1.assert)(!this._schemas.has(address), "Cannot set a schema for an address twice");
        this._schemas.set(address, schema);
      }
      get(address, debugPrint) {
        return __awaiter(this, void 0, void 0, function* () {
          let schema = this._schemas.get(address);
          if (schema !== void 0) {
            return schema;
          }
          if (debugPrint) {
            console.log(`trying to fetch ${address}`);
          }
          try {
            schema = yield this.fetch(address);
          } catch (e) {
          }
          if (schema === void 0) {
            if (debugPrint) {
              console.log(`couldn't fetch ${address}`);
            }
            return void 0;
          }
          if (debugPrint) {
            console.log(`successully fetched ${address}`);
          }
          this.add(address, schema);
          return schema;
        });
      }
    };
    exports.JSONSchemaStore = JSONSchemaStore;
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/input/JSONSchemaInput.js
var require_JSONSchemaInput = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/input/JSONSchemaInput.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : {
        "default": mod
      };
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.JSONSchemaInput = exports.schemaTypeDict = exports.Ref = void 0;
    var collection_utils_1 = require_dist();
    var urijs_1 = __importDefault(require_URI());
    var AccessorNames_1 = require_AccessorNames();
    var Constraints_1 = require_Constraints();
    var Description_1 = require_Description();
    var EnumValues_1 = require_EnumValues();
    var StringTypes_1 = require_StringTypes();
    var TypeAttributes_1 = require_TypeAttributes();
    var TypeNames_1 = require_TypeNames();
    var URIAttributes_1 = require_URIAttributes();
    var Messages_1 = require_Messages();
    var Support_1 = require_Support();
    var Type_1 = require_Type2();
    var JSONSchemaStore_1 = require_JSONSchemaStore();
    var PathElement_1 = require_PathElement();
    function keyOrIndex(pe) {
      if (pe.kind !== PathElement_1.PathElementKind.KeyOrIndex) return void 0;
      return pe.key;
    }
    function pathElementEquals(a, b) {
      if (a.kind !== b.kind) return false;
      if (a.kind === PathElement_1.PathElementKind.Type && b.kind === PathElement_1.PathElementKind.Type) {
        return a.index === b.index;
      }
      if (a.kind === PathElement_1.PathElementKind.KeyOrIndex && b.kind === PathElement_1.PathElementKind.KeyOrIndex) {
        return a.key === b.key;
      }
      return true;
    }
    function withRef(refOrLoc, props) {
      const ref = typeof refOrLoc === "function" ? refOrLoc() : refOrLoc instanceof Ref ? refOrLoc : refOrLoc.canonicalRef;
      return Object.assign({
        ref
      }, props !== null && props !== void 0 ? props : {});
    }
    function checkJSONSchemaObject(x, refOrLoc) {
      if (Array.isArray(x)) {
        return (0, Messages_1.messageError)("SchemaArrayIsInvalidSchema", withRef(refOrLoc));
      }
      if (x === null) {
        return (0, Messages_1.messageError)("SchemaNullIsInvalidSchema", withRef(refOrLoc));
      }
      if (typeof x !== "object") {
        return (0, Messages_1.messageError)("SchemaInvalidJSONSchemaType", withRef(refOrLoc, {
          type: typeof x
        }));
      }
      return x;
    }
    function checkJSONSchema(x, refOrLoc) {
      if (typeof x === "boolean") return x;
      return checkJSONSchemaObject(x, refOrLoc);
    }
    var numberRegexp = /^[0-9]+$/;
    function normalizeURI(uri) {
      if (typeof uri === "string") {
        uri = new urijs_1.default(uri);
      }
      return new urijs_1.default(urijs_1.default.decode(uri.clone().normalize().toString()));
    }
    var Ref = class _Ref {
      static root(address) {
        const uri = (0, collection_utils_1.definedMap)(address, (a) => new urijs_1.default(a));
        return new _Ref(uri, []);
      }
      static parsePath(path2) {
        const elements = [];
        if (path2.startsWith("/")) {
          elements.push({
            kind: PathElement_1.PathElementKind.Root
          });
          path2 = path2.slice(1);
        }
        if (path2 !== "") {
          const parts = path2.split("/");
          parts.forEach((part) => elements.push({
            kind: PathElement_1.PathElementKind.KeyOrIndex,
            key: part
          }));
        }
        return elements;
      }
      static parseURI(uri, destroyURI = false) {
        if (!destroyURI) {
          uri = uri.clone();
        }
        let path2 = uri.fragment();
        uri.fragment("");
        if ((uri.host() !== "" || uri.filename() !== "") && path2 === "") {
          path2 = "/";
        }
        const elements = _Ref.parsePath(path2);
        return new _Ref(uri, elements);
      }
      static parse(ref) {
        return _Ref.parseURI(new urijs_1.default(ref), true);
      }
      constructor(addressURI, path2) {
        this.path = path2;
        if (addressURI !== void 0) {
          (0, Support_1.assert)(addressURI.fragment() === "", `Ref URI with fragment is not allowed: ${addressURI.toString()}`);
          this.addressURI = normalizeURI(addressURI);
        } else {
          this.addressURI = void 0;
        }
      }
      get hasAddress() {
        return this.addressURI !== void 0;
      }
      get address() {
        return (0, Support_1.defined)(this.addressURI).toString();
      }
      get isRoot() {
        return this.path.length === 1 && this.path[0].kind === PathElement_1.PathElementKind.Root;
      }
      pushElement(pe) {
        const newPath = Array.from(this.path);
        newPath.push(pe);
        return new _Ref(this.addressURI, newPath);
      }
      push(...keys) {
        let ref = this;
        for (const key of keys) {
          ref = ref.pushElement({
            kind: PathElement_1.PathElementKind.KeyOrIndex,
            key
          });
        }
        return ref;
      }
      pushObject() {
        return this.pushElement({
          kind: PathElement_1.PathElementKind.Object
        });
      }
      pushType(index) {
        return this.pushElement({
          kind: PathElement_1.PathElementKind.Type,
          index
        });
      }
      resolveAgainst(base) {
        let addressURI = this.addressURI;
        if ((base === null || base === void 0 ? void 0 : base.addressURI) !== void 0) {
          addressURI = addressURI === void 0 ? base.addressURI : addressURI.absoluteTo(base.addressURI);
        }
        return new _Ref(addressURI, this.path);
      }
      get name() {
        const path2 = Array.from(this.path);
        for (; ; ) {
          const e = path2.pop();
          if (e === void 0 || e.kind === PathElement_1.PathElementKind.Root) {
            let name = this.addressURI !== void 0 ? this.addressURI.filename() : "";
            const suffix = this.addressURI !== void 0 ? this.addressURI.suffix() : "";
            if (name.length > suffix.length + 1) {
              name = name.slice(0, name.length - suffix.length - 1);
            }
            if (name === "") {
              return "Something";
            }
            return name;
          }
          switch (e.kind) {
            case PathElement_1.PathElementKind.KeyOrIndex:
              if (numberRegexp.test(e.key)) {
                return e.key;
              }
              break;
            case PathElement_1.PathElementKind.Type:
            case PathElement_1.PathElementKind.Object:
              return (0, Support_1.panic)("We shouldn't try to get the name of Type or Object refs");
            default:
              return (0, Support_1.assertNever)(e);
          }
        }
      }
      get definitionName() {
        const pe = (0, collection_utils_1.arrayGetFromEnd)(this.path, 2);
        if (pe === void 0) return void 0;
        if (keyOrIndex(pe) === "definitions") return keyOrIndex((0, Support_1.defined)((0, collection_utils_1.arrayLast)(this.path)));
        return void 0;
      }
      toString() {
        function elementToString(e) {
          switch (e.kind) {
            case PathElement_1.PathElementKind.Root:
              return "";
            case PathElement_1.PathElementKind.Type:
              return `type/${e.index.toString()}`;
            case PathElement_1.PathElementKind.Object:
              return "object";
            case PathElement_1.PathElementKind.KeyOrIndex:
              return e.key;
            default:
              return (0, Support_1.assertNever)(e);
          }
        }
        const address = this.addressURI === void 0 ? "" : this.addressURI.toString();
        return `${address}#${this.path.map(elementToString).join("/")}`;
      }
      lookup(local, path2, root) {
        const refMaker = () => new _Ref(this.addressURI, path2);
        const first = path2[0];
        if (first === void 0) {
          return checkJSONSchema(local, refMaker);
        }
        const rest = path2.slice(1);
        switch (first.kind) {
          case PathElement_1.PathElementKind.Root:
            return this.lookup(root, rest, root);
          case PathElement_1.PathElementKind.KeyOrIndex:
            const key = first.key;
            if (Array.isArray(local)) {
              if (!/^\d+$/.test(key)) {
                return (0, Messages_1.messageError)("SchemaCannotIndexArrayWithNonNumber", withRef(refMaker, {
                  actual: key
                }));
              }
              const index = Number.parseInt(first.key, 10);
              if (index >= local.length) {
                return (0, Messages_1.messageError)("SchemaIndexNotInArray", withRef(refMaker, {
                  index
                }));
              }
              return this.lookup(local[index], rest, root);
            }
            if (!(0, collection_utils_1.hasOwnProperty)(local, key)) {
              return (0, Messages_1.messageError)("SchemaKeyNotInObject", withRef(refMaker, {
                key
              }));
            }
            return this.lookup(checkJSONSchemaObject(local, refMaker)[first.key], rest, root);
          case PathElement_1.PathElementKind.Type:
            return (0, Support_1.panic)('Cannot look up path that indexes "type"');
          case PathElement_1.PathElementKind.Object:
            return (0, Support_1.panic)('Cannot look up path that indexes "object"');
          default:
            return (0, Support_1.assertNever)(first);
        }
      }
      lookupRef(root) {
        return this.lookup(root, this.path, root);
      }
      equals(other) {
        if (!(other instanceof _Ref)) return false;
        if (this.addressURI !== void 0 && other.addressURI !== void 0) {
          if (!this.addressURI.equals(other.addressURI)) return false;
        } else {
          if (this.addressURI === void 0 !== (other.addressURI === void 0)) return false;
        }
        const l = this.path.length;
        if (l !== other.path.length) return false;
        for (let i2 = 0; i2 < l; i2++) {
          if (!pathElementEquals(this.path[i2], other.path[i2])) return false;
        }
        return true;
      }
      hashCode() {
        let acc = (0, collection_utils_1.hashCodeOf)((0, collection_utils_1.definedMap)(this.addressURI, (u) => u.toString()));
        for (const pe of this.path) {
          acc = (0, collection_utils_1.addHashCode)(acc, pe.kind);
          switch (pe.kind) {
            case PathElement_1.PathElementKind.Type:
              acc = (0, collection_utils_1.addHashCode)(acc, pe.index);
              break;
            case PathElement_1.PathElementKind.KeyOrIndex:
              acc = (0, collection_utils_1.addHashCode)(acc, (0, collection_utils_1.hashString)(pe.key));
              break;
            default:
              break;
          }
        }
        return acc;
      }
    };
    exports.Ref = Ref;
    var Location = class _Location {
      constructor(canonicalRef, virtualRef, haveID = false) {
        this.haveID = haveID;
        this.canonicalRef = canonicalRef;
        this.virtualRef = virtualRef !== null && virtualRef !== void 0 ? virtualRef : canonicalRef;
      }
      updateWithID(id) {
        if (typeof id !== "string") return this;
        const parsed = Ref.parse(id);
        const virtual = this.haveID ? parsed.resolveAgainst(this.virtualRef) : parsed;
        if (!this.haveID) {
          (0, Messages_1.messageAssert)(virtual.hasAddress, "SchemaIDMustHaveAddress", withRef(this, {
            id
          }));
        }
        return new _Location(this.canonicalRef, virtual, true);
      }
      push(...keys) {
        return new _Location(this.canonicalRef.push(...keys), this.virtualRef.push(...keys), this.haveID);
      }
      pushObject() {
        return new _Location(this.canonicalRef.pushObject(), this.virtualRef.pushObject(), this.haveID);
      }
      pushType(index) {
        return new _Location(this.canonicalRef.pushType(index), this.virtualRef.pushType(index), this.haveID);
      }
      toString() {
        return `${this.virtualRef.toString()} (${this.canonicalRef.toString()})`;
      }
    };
    var Canonizer = class {
      constructor(_ctx) {
        this._ctx = _ctx;
        this._map = new collection_utils_1.EqualityMap();
        this._schemaAddressesAdded = /* @__PURE__ */ new Set();
      }
      addIDs(schema, loc) {
        if (schema === null) return;
        if (Array.isArray(schema)) {
          for (let i2 = 0; i2 < schema.length; i2++) {
            this.addIDs(schema[i2], loc.push(i2.toString()));
          }
          return;
        }
        if (typeof schema !== "object") {
          return;
        }
        const locWithoutID = loc;
        const maybeID = "$id" in schema ? schema.$id : void 0;
        if (typeof maybeID === "string") {
          loc = loc.updateWithID(maybeID);
        }
        if (loc.haveID) {
          if (this._ctx.debugPrintSchemaResolving) {
            console.log(`adding mapping ${loc.toString()}`);
          }
          this._map.set(loc.virtualRef, locWithoutID);
        }
        for (const property of Object.getOwnPropertyNames(schema)) {
          this.addIDs(schema[property], loc.push(property));
        }
      }
      addSchema(schema, address) {
        if (this._schemaAddressesAdded.has(address)) return false;
        this.addIDs(schema, new Location(Ref.root(address), Ref.root(void 0)));
        this._schemaAddressesAdded.add(address);
        return true;
      }
      // Returns: Canonical ref
      canonize(base, ref) {
        const virtual = ref.resolveAgainst(base.virtualRef);
        const loc = this._map.get(virtual);
        if (loc !== void 0) {
          return loc;
        }
        const canonicalRef = virtual.addressURI === void 0 ? new Ref(base.canonicalRef.addressURI, virtual.path) : virtual;
        return new Location(canonicalRef, new Ref(void 0, virtual.path));
      }
    };
    function checkTypeList(typeOrTypes, loc) {
      let set;
      if (typeof typeOrTypes === "string") {
        set = /* @__PURE__ */ new Set([
          typeOrTypes
        ]);
      } else if (Array.isArray(typeOrTypes)) {
        const arr = [];
        for (const t of typeOrTypes) {
          if (typeof t !== "string") {
            return (0, Messages_1.messageError)("SchemaTypeElementMustBeString", withRef(loc, {
              element: t
            }));
          }
          arr.push(t);
        }
        set = new Set(arr);
      } else {
        return (0, Messages_1.messageError)("SchemaTypeMustBeStringOrStringArray", withRef(loc, {
          actual: typeOrTypes
        }));
      }
      (0, Messages_1.messageAssert)(set.size > 0, "SchemaNoTypeSpecified", withRef(loc));
      const validTypes = [
        "null",
        "boolean",
        "object",
        "array",
        "number",
        "string",
        "integer"
      ];
      const maybeInvalid = (0, collection_utils_1.iterableFind)(set, (s) => !validTypes.includes(s));
      if (maybeInvalid !== void 0) {
        return (0, Messages_1.messageError)("SchemaInvalidType", withRef(loc, {
          type: maybeInvalid
        }));
      }
      return set;
    }
    function checkRequiredArray(arr, loc) {
      if (!Array.isArray(arr)) {
        return (0, Messages_1.messageError)("SchemaRequiredMustBeStringOrStringArray", withRef(loc, {
          actual: arr
        }));
      }
      for (const e of arr) {
        if (typeof e !== "string") {
          return (0, Messages_1.messageError)("SchemaRequiredElementMustBeString", withRef(loc, {
            element: e
          }));
        }
      }
      return arr;
    }
    exports.schemaTypeDict = {
      null: true,
      boolean: true,
      string: true,
      integer: true,
      number: true,
      array: true,
      object: true
    };
    var schemaTypes = Object.getOwnPropertyNames(exports.schemaTypeDict);
    function typeKindForJSONSchemaFormat(format) {
      const target = (0, collection_utils_1.iterableFind)(Type_1.transformedStringTypeTargetTypeKindsMap, ([_, { jsonSchema }]) => jsonSchema === format);
      if (target === void 0) return void 0;
      return target[0];
    }
    function schemaFetchError(base, address) {
      if (base === void 0) {
        return (0, Messages_1.messageError)("SchemaFetchErrorTopLevel", {
          address
        });
      }
      return (0, Messages_1.messageError)("SchemaFetchError", {
        address,
        base: base.canonicalRef
      });
    }
    var Resolver = class {
      constructor(_ctx, _store, _canonizer) {
        this._ctx = _ctx;
        this._store = _store;
        this._canonizer = _canonizer;
      }
      tryResolveVirtualRef(fetchBase, lookupBase, virtualRef) {
        return __awaiter(this, void 0, void 0, function* () {
          let didAdd = false;
          for (; ; ) {
            const loc = this._canonizer.canonize(fetchBase, virtualRef);
            const canonical = loc.canonicalRef;
            (0, Support_1.assert)(canonical.hasAddress, "Canonical ref can't be resolved without an address");
            const address = canonical.address;
            const schema = canonical.addressURI === void 0 ? void 0 : yield this._store.get(address, this._ctx.debugPrintSchemaResolving);
            if (schema === void 0) {
              return [
                void 0,
                loc
              ];
            }
            if (this._canonizer.addSchema(schema, address)) {
              (0, Support_1.assert)(!didAdd, "We can't add a schema twice");
              didAdd = true;
            } else {
              let lookupLoc = this._canonizer.canonize(lookupBase, virtualRef);
              if (fetchBase !== void 0) {
                lookupLoc = new Location(new Ref(loc.canonicalRef.addressURI, lookupLoc.canonicalRef.path), lookupLoc.virtualRef, lookupLoc.haveID);
              }
              return [
                lookupLoc.canonicalRef.lookupRef(schema),
                lookupLoc
              ];
            }
          }
        });
      }
      resolveVirtualRef(base, virtualRef) {
        return __awaiter(this, void 0, void 0, function* () {
          if (this._ctx.debugPrintSchemaResolving) {
            console.log(`resolving ${virtualRef.toString()} relative to ${base.toString()}`);
          }
          let result = yield this.tryResolveVirtualRef(base, base, virtualRef);
          let schema = result[0];
          if (schema !== void 0) {
            if (this._ctx.debugPrintSchemaResolving) {
              console.log(`resolved to ${result[1].toString()}`);
            }
            return [
              schema,
              result[1]
            ];
          }
          const altBase = new Location(base.canonicalRef, new Ref(base.canonicalRef.addressURI, base.virtualRef.path), base.haveID);
          result = yield this.tryResolveVirtualRef(altBase, base, virtualRef);
          schema = result[0];
          if (schema !== void 0) {
            if (this._ctx.debugPrintSchemaResolving) {
              console.log(`resolved to ${result[1].toString()}`);
            }
            return [
              schema,
              result[1]
            ];
          }
          return schemaFetchError(base, virtualRef.address);
        });
      }
      resolveTopLevelRef(ref) {
        return __awaiter(this, void 0, void 0, function* () {
          return yield this.resolveVirtualRef(new Location(new Ref(ref.addressURI, [])), new Ref(void 0, ref.path));
        });
      }
    };
    function addTypesInSchema(resolver, typeBuilder, references, attributeProducers) {
      return __awaiter(this, void 0, void 0, function* () {
        const typeForCanonicalRef = new collection_utils_1.EqualityMap();
        function setTypeForLocation(loc, t) {
          const maybeRef = typeForCanonicalRef.get(loc.canonicalRef);
          if (maybeRef !== void 0) {
            (0, Support_1.assert)(maybeRef === t, "Trying to set path again to different type");
          }
          typeForCanonicalRef.set(loc.canonicalRef, t);
        }
        function makeObject(loc_1, attributes_1, properties_1, requiredArray_1, additionalProperties_1) {
          return __awaiter(this, arguments, void 0, function* (loc, attributes, properties, requiredArray, additionalProperties, sortKey = (k) => k.toLowerCase()) {
            const required = new Set(requiredArray);
            const propertiesMap = (0, collection_utils_1.mapSortBy)((0, collection_utils_1.mapFromObject)(properties), (_, k) => sortKey(k));
            const props = yield (0, collection_utils_1.mapMapSync)(propertiesMap, (propSchema, propName) => __awaiter(this, void 0, void 0, function* () {
              const propLoc = loc.push("properties", propName);
              const t = yield toType(checkJSONSchema(propSchema, propLoc.canonicalRef), propLoc, (0, TypeNames_1.makeNamesTypeAttributes)(propName, true));
              const isOptional = !required.has(propName);
              return typeBuilder.makeClassProperty(t, isOptional);
            }));
            let additionalPropertiesType;
            if (additionalProperties === void 0 || additionalProperties === true) {
              additionalPropertiesType = typeBuilder.getPrimitiveType("any");
            } else if (additionalProperties === false) {
              additionalPropertiesType = void 0;
            } else {
              const additionalLoc = loc.push("additionalProperties");
              additionalPropertiesType = yield toType(checkJSONSchema(additionalProperties, additionalLoc.canonicalRef), additionalLoc, (0, TypeNames_1.singularizeTypeNames)(attributes));
            }
            const additionalRequired = (0, collection_utils_1.setSubtract)(required, props.keys());
            if (additionalRequired.size > 0) {
              const t = additionalPropertiesType;
              if (t === void 0) {
                return (0, Messages_1.messageError)("SchemaAdditionalTypesForbidRequired", withRef(loc));
              }
              const additionalProps = (0, collection_utils_1.mapFromIterable)(additionalRequired, (_name) => typeBuilder.makeClassProperty(t, false));
              (0, collection_utils_1.mapMergeInto)(props, additionalProps);
            }
            return typeBuilder.getUniqueObjectType(attributes, props, additionalPropertiesType);
          });
        }
        function convertToType(schema, loc, typeAttributes) {
          return __awaiter(this, void 0, void 0, function* () {
            var _a;
            const enumArray = Array.isArray(schema.enum) ? schema.enum : void 0;
            const isConst = schema.const !== void 0;
            const typeSet = (0, collection_utils_1.definedMap)(schema.type, (t) => checkTypeList(t, loc));
            function isTypeIncluded(name) {
              var _a2;
              if (typeSet !== void 0 && !typeSet.has(name)) {
                return false;
              }
              if (enumArray !== void 0) {
                let predicate;
                switch (name) {
                  case "null":
                    predicate = (x) => x === null;
                    break;
                  case "integer":
                    predicate = (x) => typeof x === "number" && x === Math.floor(x);
                    break;
                  default:
                    predicate = (x) => typeof x === name;
                    break;
                }
                return enumArray.find(predicate) !== void 0;
              }
              if (isConst) {
                return name === ((_a2 = schema.type) !== null && _a2 !== void 0 ? _a2 : typeof schema.const);
              }
              return true;
            }
            const includedTypes = (0, collection_utils_1.setFilter)(schemaTypes, isTypeIncluded);
            let producedAttributesForNoCases = void 0;
            function forEachProducedAttribute(cases, f) {
              let attributes;
              if (cases === void 0 && producedAttributesForNoCases !== void 0) {
                attributes = producedAttributesForNoCases;
              } else {
                attributes = [];
                for (const producer of attributeProducers) {
                  const newAttributes = producer(schema, loc.canonicalRef, includedTypes, cases);
                  if (newAttributes === void 0) continue;
                  attributes.push(newAttributes);
                }
                if (cases === void 0) {
                  producedAttributesForNoCases = attributes;
                }
              }
              for (const a of attributes) {
                f(a);
              }
            }
            function combineProducedAttributes(f) {
              let result = TypeAttributes_1.emptyTypeAttributes;
              forEachProducedAttribute(void 0, (attr) => {
                const maybeAttributes = f(attr);
                if (maybeAttributes === void 0) return;
                result = (0, TypeAttributes_1.combineTypeAttributes)("union", result, maybeAttributes);
              });
              return result;
            }
            function makeAttributes(attributes) {
              if (schema.oneOf === void 0) {
                attributes = (0, TypeAttributes_1.combineTypeAttributes)("union", attributes, combineProducedAttributes(({ forType, forUnion, forCases }) => {
                  (0, Support_1.assert)(forUnion === void 0 && forCases === void 0, "We can't have attributes for unions and cases if we don't have a union");
                  return forType;
                }));
              }
              return (0, TypeNames_1.modifyTypeNames)(attributes, (maybeTypeNames) => {
                const typeNames = (0, Support_1.defined)(maybeTypeNames);
                if (!typeNames.areInferred) {
                  return typeNames;
                }
                let title = schema.title;
                if (typeof title !== "string") {
                  title = loc.canonicalRef.definitionName;
                }
                if (typeof title === "string") {
                  return TypeNames_1.TypeNames.make(/* @__PURE__ */ new Set([
                    title
                  ]), /* @__PURE__ */ new Set(), schema.$ref !== void 0);
                }
                return typeNames.makeInferred();
              });
            }
            typeAttributes = makeAttributes(typeAttributes);
            const inferredAttributes = (0, TypeAttributes_1.makeTypeAttributesInferred)(typeAttributes);
            function makeStringType(attributes) {
              const kind = typeKindForJSONSchemaFormat(schema.format);
              if (kind === void 0) {
                return typeBuilder.getStringType(attributes, StringTypes_1.StringTypes.unrestricted);
              }
              return typeBuilder.getPrimitiveType(kind, attributes);
            }
            function makeArrayType() {
              return __awaiter(this, void 0, void 0, function* () {
                const singularAttributes = (0, TypeNames_1.singularizeTypeNames)(typeAttributes);
                const items = schema.items;
                let itemType;
                if (Array.isArray(items)) {
                  const itemsLoc = loc.push("items");
                  const itemTypes = yield (0, collection_utils_1.arrayMapSync)(items, (item, i2) => __awaiter(this, void 0, void 0, function* () {
                    const itemLoc = itemsLoc.push(i2.toString());
                    return yield toType(checkJSONSchema(item, itemLoc.canonicalRef), itemLoc, singularAttributes);
                  }));
                  itemType = typeBuilder.getUnionType(TypeAttributes_1.emptyTypeAttributes, new Set(itemTypes));
                } else if (typeof items === "object") {
                  const itemsLoc = loc.push("items");
                  itemType = yield toType(checkJSONSchema(items, itemsLoc.canonicalRef), itemsLoc, singularAttributes);
                } else if (items !== void 0 && items !== true) {
                  return (0, Messages_1.messageError)("SchemaArrayItemsMustBeStringOrArray", withRef(loc, {
                    actual: items
                  }));
                } else {
                  itemType = typeBuilder.getPrimitiveType("any");
                }
                typeBuilder.addAttributes(itemType, singularAttributes);
                return typeBuilder.getArrayType(TypeAttributes_1.emptyTypeAttributes, itemType);
              });
            }
            function makeObjectType() {
              return __awaiter(this, void 0, void 0, function* () {
                let required;
                if (schema.required === void 0 || typeof schema.required === "boolean") {
                  required = [];
                } else {
                  required = Array.from(checkRequiredArray(schema.required, loc));
                }
                let properties;
                if (schema.properties === void 0) {
                  properties = {};
                } else {
                  properties = checkJSONSchemaObject(schema.properties, loc.canonicalRef);
                }
                for (const p of Object.getOwnPropertyNames(properties)) {
                  if (properties[p].required === true && !required.includes(p)) {
                    required.push(p);
                  }
                }
                let additionalProperties = schema.additionalProperties;
                if (additionalProperties === void 0 && typeof schema.patternProperties === "object" && (0, collection_utils_1.hasOwnProperty)(schema.patternProperties, ".*")) {
                  additionalProperties = schema.patternProperties[".*"];
                }
                const objectAttributes = (0, TypeAttributes_1.combineTypeAttributes)("union", inferredAttributes, combineProducedAttributes(({ forObject }) => forObject));
                const order = schema.quicktypePropertyOrder ? schema.quicktypePropertyOrder : [];
                const orderKey = (propertyName) => {
                  const index = order.indexOf(propertyName);
                  return index !== -1 ? index : propertyName.toLowerCase();
                };
                return yield makeObject(loc, objectAttributes, properties, required, additionalProperties, orderKey);
              });
            }
            function makeTypesFromCases(cases, kind) {
              return __awaiter(this, void 0, void 0, function* () {
                const kindLoc = loc.push(kind);
                if (!Array.isArray(cases)) {
                  return (0, Messages_1.messageError)("SchemaSetOperationCasesIsNotArray", withRef(kindLoc, {
                    operation: kind,
                    cases
                  }));
                }
                return yield (0, collection_utils_1.arrayMapSync)(cases, (t, index) => __awaiter(this, void 0, void 0, function* () {
                  const caseLoc = kindLoc.push(index.toString());
                  return yield toType(checkJSONSchema(t, caseLoc.canonicalRef), caseLoc, (0, TypeAttributes_1.makeTypeAttributesInferred)(typeAttributes));
                }));
              });
            }
            const intersectionType = typeBuilder.getUniqueIntersectionType(typeAttributes, void 0);
            setTypeForLocation(loc, intersectionType);
            function convertOneOrAnyOf(cases, kind) {
              return __awaiter(this, void 0, void 0, function* () {
                const typeRefs = yield makeTypesFromCases(cases, kind);
                let unionAttributes = (0, TypeAttributes_1.makeTypeAttributesInferred)(typeAttributes);
                if (kind === "oneOf") {
                  forEachProducedAttribute(cases, ({ forType, forUnion, forCases }) => {
                    if (forType !== void 0) {
                      typeBuilder.addAttributes(intersectionType, forType);
                    }
                    if (forUnion !== void 0) {
                      unionAttributes = (0, TypeAttributes_1.combineTypeAttributes)("union", unionAttributes, forUnion);
                    }
                    if (forCases !== void 0) {
                      (0, Support_1.assert)(forCases.length === typeRefs.length, "Number of case attributes doesn't match number of cases");
                      for (let i2 = 0; i2 < typeRefs.length; i2++) {
                        typeBuilder.addAttributes(typeRefs[i2], forCases[i2]);
                      }
                    }
                  });
                }
                const unionType = typeBuilder.getUniqueUnionType(unionAttributes, void 0);
                typeBuilder.setSetOperationMembers(unionType, new Set(typeRefs));
                return unionType;
              });
            }
            const includeObject = enumArray === void 0 && !isConst && (typeSet === void 0 || typeSet.has("object"));
            const includeArray = enumArray === void 0 && !isConst && (typeSet === void 0 || typeSet.has("array"));
            const needStringEnum = includedTypes.has("string") && (enumArray === null || enumArray === void 0 ? void 0 : enumArray.find((x) => typeof x === "string")) !== void 0;
            const needUnion = typeSet !== void 0 || schema.properties !== void 0 || schema.additionalProperties !== void 0 || schema.items !== void 0 || schema.required !== void 0 || enumArray !== void 0 || isConst;
            const types = [];
            if (needUnion) {
              const unionTypes = [];
              const numberAttributes = combineProducedAttributes(({ forNumber }) => forNumber);
              for (const [name, kind] of [
                [
                  "null",
                  "null"
                ],
                [
                  "number",
                  "double"
                ],
                [
                  "integer",
                  "integer"
                ],
                [
                  "boolean",
                  "bool"
                ]
              ]) {
                if (!includedTypes.has(name)) continue;
                const attributes = (0, Type_1.isNumberTypeKind)(kind) ? numberAttributes : void 0;
                unionTypes.push(typeBuilder.getPrimitiveType(kind, attributes));
              }
              const stringAttributes = (0, TypeAttributes_1.combineTypeAttributes)("union", inferredAttributes, combineProducedAttributes(({ forString }) => forString));
              if (needStringEnum || isConst) {
                const cases = isConst ? [
                  schema.const
                ] : (_a = enumArray === null || enumArray === void 0 ? void 0 : enumArray.filter((x) => typeof x === "string")) !== null && _a !== void 0 ? _a : [];
                unionTypes.push(typeBuilder.getStringType(stringAttributes, StringTypes_1.StringTypes.fromCases(cases)));
              } else if (includedTypes.has("string")) {
                unionTypes.push(makeStringType(stringAttributes));
              }
              if (includeArray) {
                unionTypes.push(yield makeArrayType());
              }
              if (includeObject) {
                unionTypes.push(yield makeObjectType());
              }
              types.push(typeBuilder.getUniqueUnionType(inferredAttributes, new Set(unionTypes)));
            }
            if (schema.$ref !== void 0) {
              if (typeof schema.$ref !== "string") {
                return (0, Messages_1.messageError)("SchemaRefMustBeString", withRef(loc, {
                  actual: typeof schema.$ref
                }));
              }
              const virtualRef = Ref.parse(schema.$ref);
              const [target, newLoc] = yield resolver.resolveVirtualRef(loc, virtualRef);
              const attributes = (0, TypeNames_1.modifyTypeNames)(typeAttributes, (tn) => {
                if (!(0, Support_1.defined)(tn).areInferred) return tn;
                return TypeNames_1.TypeNames.make(/* @__PURE__ */ new Set([
                  newLoc.canonicalRef.name
                ]), /* @__PURE__ */ new Set(), true);
              });
              types.push(yield toType(target, newLoc, attributes));
            }
            if (schema.allOf !== void 0) {
              types.push(...yield makeTypesFromCases(schema.allOf, "allOf"));
            }
            if (schema.oneOf !== void 0) {
              types.push(yield convertOneOrAnyOf(schema.oneOf, "oneOf"));
            }
            if (schema.anyOf !== void 0) {
              types.push(yield convertOneOrAnyOf(schema.anyOf, "anyOf"));
            }
            typeBuilder.setSetOperationMembers(intersectionType, new Set(types));
            return intersectionType;
          });
        }
        function toType(schema, loc, typeAttributes) {
          return __awaiter(this, void 0, void 0, function* () {
            const maybeType = typeForCanonicalRef.get(loc.canonicalRef);
            if (maybeType !== void 0) {
              return maybeType;
            }
            let result;
            if (typeof schema === "boolean") {
              (0, Messages_1.messageAssert)(schema === true, "SchemaFalseNotSupported", withRef(loc));
              result = typeBuilder.getPrimitiveType("any");
            } else {
              loc = loc.updateWithID(schema.$id);
              result = yield convertToType(schema, loc, typeAttributes);
            }
            setTypeForLocation(loc, result);
            return result;
          });
        }
        for (const [topLevelName, topLevelRef] of references) {
          const [target, loc] = yield resolver.resolveTopLevelRef(topLevelRef);
          const t = yield toType(target, loc, (0, TypeNames_1.makeNamesTypeAttributes)(topLevelName, false));
          typeBuilder.addTopLevel(topLevelName, t);
        }
      });
    }
    function removeExtension(fn) {
      const lower = fn.toLowerCase();
      const extensions = [
        ".json",
        ".schema"
      ];
      for (const ext of extensions) {
        if (lower.endsWith(ext)) {
          const base = fn.slice(0, fn.length - ext.length);
          if (base.length > 0) {
            return base;
          }
        }
      }
      return fn;
    }
    function nameFromURI(uri) {
      const fragment = uri.fragment();
      if (fragment !== "") {
        const components = fragment.split("/");
        const len = components.length;
        if (components[len - 1] !== "") {
          return removeExtension(components[len - 1]);
        }
        if (len > 1 && components[len - 2] !== "") {
          return removeExtension(components[len - 2]);
        }
      }
      const filename = uri.filename();
      if (filename !== "") {
        return removeExtension(filename);
      }
      return (0, Messages_1.messageError)("DriverCannotInferNameForSchema", {
        uri: uri.toString()
      });
    }
    function refsInSchemaForURI(resolver, uri, defaultName) {
      return __awaiter(this, void 0, void 0, function* () {
        const fragment = uri.fragment();
        let propertiesAreTypes = fragment.endsWith("/");
        if (propertiesAreTypes) {
          uri = uri.clone().fragment(fragment.slice(0, -1));
        }
        const ref = Ref.parseURI(uri);
        if (ref.isRoot) {
          propertiesAreTypes = false;
        }
        const schema = (yield resolver.resolveTopLevelRef(ref))[0];
        if (propertiesAreTypes) {
          if (typeof schema !== "object") {
            return (0, Messages_1.messageError)("SchemaCannotGetTypesFromBoolean", {
              ref: ref.toString()
            });
          }
          return (0, collection_utils_1.mapMap)((0, collection_utils_1.mapFromObject)(schema), (_, name2) => ref.push(name2));
        }
        let name;
        if (typeof schema === "object" && typeof schema.title === "string") {
          name = schema.title;
        } else {
          const maybeName = nameFromURI(uri);
          name = maybeName !== null && maybeName !== void 0 ? maybeName : defaultName;
        }
        return [
          name,
          ref
        ];
      });
    }
    var InputJSONSchemaStore = class extends JSONSchemaStore_1.JSONSchemaStore {
      constructor(_inputs, _delegate) {
        super();
        this._inputs = _inputs;
        this._delegate = _delegate;
      }
      fetch(address) {
        return __awaiter(this, void 0, void 0, function* () {
          const maybeInput = this._inputs.get(address);
          if (maybeInput !== void 0) {
            return checkJSONSchema((0, Support_1.parseJSON)(maybeInput, "JSON Schema", address), () => Ref.root(address));
          }
          if (this._delegate === void 0) {
            return (0, Support_1.panic)(`Schema URI ${address} requested, but no store given`);
          }
          return yield this._delegate.fetch(address);
        });
      }
    };
    var JSONSchemaInput = class {
      constructor(_schemaStore, additionalAttributeProducers = [], _additionalSchemaAddresses = []) {
        this._schemaStore = _schemaStore;
        this._additionalSchemaAddresses = _additionalSchemaAddresses;
        this.kind = "schema";
        this.needSchemaProcessing = true;
        this._schemaInputs = /* @__PURE__ */ new Map();
        this._schemaSources = [];
        this._topLevels = /* @__PURE__ */ new Map();
        this._needIR = false;
        this._attributeProducers = [
          Description_1.descriptionAttributeProducer,
          AccessorNames_1.accessorNamesAttributeProducer,
          EnumValues_1.enumValuesAttributeProducer,
          URIAttributes_1.uriSchemaAttributesProducer,
          Constraints_1.minMaxAttributeProducer,
          Constraints_1.minMaxLengthAttributeProducer,
          Constraints_1.patternAttributeProducer
        ].concat(additionalAttributeProducers);
      }
      get needIR() {
        return this._needIR;
      }
      addTopLevel(name, ref) {
        this._topLevels.set(name, ref);
      }
      addTypes(ctx, typeBuilder) {
        return __awaiter(this, void 0, void 0, function* () {
          if (this._schemaSources.length === 0) return;
          let maybeSchemaStore = this._schemaStore;
          if (this._schemaInputs.size === 0) {
            if (maybeSchemaStore === void 0) {
              return (0, Support_1.panic)("Must have a schema store to process JSON Schema");
            }
          } else {
            maybeSchemaStore = this._schemaStore = new InputJSONSchemaStore(this._schemaInputs, maybeSchemaStore);
          }
          const schemaStore = maybeSchemaStore;
          const canonizer = new Canonizer(ctx);
          for (const address of this._additionalSchemaAddresses) {
            const schema = yield schemaStore.get(address, ctx.debugPrintSchemaResolving);
            if (schema === void 0) {
              return (0, Messages_1.messageError)("SchemaFetchErrorAdditional", {
                address
              });
            }
            canonizer.addSchema(schema, address);
          }
          const resolver = new Resolver(ctx, (0, Support_1.defined)(this._schemaStore), canonizer);
          for (const [normalizedURI, source] of this._schemaSources) {
            const givenName = source.name;
            const refs = yield refsInSchemaForURI(resolver, normalizedURI, givenName);
            if (Array.isArray(refs)) {
              let name;
              if (this._schemaSources.length === 1 && givenName !== void 0) {
                name = givenName;
              } else {
                name = refs[0];
              }
              this.addTopLevel(name, refs[1]);
            } else {
              for (const [refName, ref] of refs) {
                this.addTopLevel(refName, ref);
              }
            }
          }
          yield addTypesInSchema(resolver, typeBuilder, this._topLevels, this._attributeProducers);
        });
      }
      addTypesSync() {
        (0, Support_1.panic)("addTypesSync not supported in JSONSchemaInput");
      }
      addSource(schemaSource) {
        return __awaiter(this, void 0, void 0, function* () {
          this.addSourceSync(schemaSource);
        });
      }
      addSourceSync(schemaSource) {
        const { name, uris, schema, isConverted } = schemaSource;
        if (isConverted !== true) {
          this._needIR = true;
        }
        let normalizedURIs;
        if (uris === void 0) {
          normalizedURIs = [
            new urijs_1.default(name)
          ];
        } else {
          normalizedURIs = uris.map((uri) => {
            const normalizedURI = normalizeURI(uri);
            if (normalizedURI.clone().hash("").toString() === "") {
              normalizedURI.path(name);
            }
            return normalizedURI;
          });
        }
        if (schema === void 0) {
          (0, Support_1.assert)(uris !== void 0, "URIs must be given if schema source is not specified");
        } else {
          for (let i2 = 0; i2 < normalizedURIs.length; i2++) {
            const normalizedURI = normalizedURIs[i2];
            const uri = normalizedURI.clone().hash("");
            const path2 = uri.path();
            let suffix = 0;
            do {
              if (suffix > 0) {
                uri.path(`${path2}-${suffix}`);
              }
              suffix++;
            } while (this._schemaInputs.has(uri.toString()));
            this._schemaInputs.set(uri.toString(), schema);
            normalizedURIs[i2] = uri.hash(normalizedURI.hash());
          }
        }
        for (const normalizedURI of normalizedURIs) {
          this._schemaSources.push([
            normalizedURI,
            schemaSource
          ]);
        }
      }
      singleStringSchemaSource() {
        if (!this._schemaSources.every(([_, { schema }]) => typeof schema === "string")) {
          return void 0;
        }
        const set = new Set(this._schemaSources.map(([_, { schema }]) => schema));
        if (set.size === 1) {
          return (0, Support_1.defined)((0, collection_utils_1.iterableFirst)(set));
        }
        return void 0;
      }
    };
    exports.JSONSchemaInput = JSONSchemaInput;
  }
});

// ../../../../../node_modules/.deno/readable-stream@4.5.2/node_modules/readable-stream/lib/ours/primordials.js
var require_primordials = __commonJS({
  "../../../../../node_modules/.deno/readable-stream@4.5.2/node_modules/readable-stream/lib/ours/primordials.js"(exports, module) {
    "use strict";
    module.exports = {
      ArrayIsArray(self2) {
        return Array.isArray(self2);
      },
      ArrayPrototypeIncludes(self2, el) {
        return self2.includes(el);
      },
      ArrayPrototypeIndexOf(self2, el) {
        return self2.indexOf(el);
      },
      ArrayPrototypeJoin(self2, sep) {
        return self2.join(sep);
      },
      ArrayPrototypeMap(self2, fn) {
        return self2.map(fn);
      },
      ArrayPrototypePop(self2, el) {
        return self2.pop(el);
      },
      ArrayPrototypePush(self2, el) {
        return self2.push(el);
      },
      ArrayPrototypeSlice(self2, start, end) {
        return self2.slice(start, end);
      },
      Error,
      FunctionPrototypeCall(fn, thisArgs, ...args) {
        return fn.call(thisArgs, ...args);
      },
      FunctionPrototypeSymbolHasInstance(self2, instance) {
        return Function.prototype[Symbol.hasInstance].call(self2, instance);
      },
      MathFloor: Math.floor,
      Number,
      NumberIsInteger: Number.isInteger,
      NumberIsNaN: Number.isNaN,
      NumberMAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER,
      NumberMIN_SAFE_INTEGER: Number.MIN_SAFE_INTEGER,
      NumberParseInt: Number.parseInt,
      ObjectDefineProperties(self2, props) {
        return Object.defineProperties(self2, props);
      },
      ObjectDefineProperty(self2, name, prop) {
        return Object.defineProperty(self2, name, prop);
      },
      ObjectGetOwnPropertyDescriptor(self2, name) {
        return Object.getOwnPropertyDescriptor(self2, name);
      },
      ObjectKeys(obj2) {
        return Object.keys(obj2);
      },
      ObjectSetPrototypeOf(target, proto) {
        return Object.setPrototypeOf(target, proto);
      },
      Promise,
      PromisePrototypeCatch(self2, fn) {
        return self2.catch(fn);
      },
      PromisePrototypeThen(self2, thenFn, catchFn) {
        return self2.then(thenFn, catchFn);
      },
      PromiseReject(err) {
        return Promise.reject(err);
      },
      PromiseResolve(val) {
        return Promise.resolve(val);
      },
      ReflectApply: Reflect.apply,
      RegExpPrototypeTest(self2, value) {
        return self2.test(value);
      },
      SafeSet: Set,
      String,
      StringPrototypeSlice(self2, start, end) {
        return self2.slice(start, end);
      },
      StringPrototypeToLowerCase(self2) {
        return self2.toLowerCase();
      },
      StringPrototypeToUpperCase(self2) {
        return self2.toUpperCase();
      },
      StringPrototypeTrim(self2) {
        return self2.trim();
      },
      Symbol,
      SymbolFor: Symbol.for,
      SymbolAsyncIterator: Symbol.asyncIterator,
      SymbolHasInstance: Symbol.hasInstance,
      SymbolIterator: Symbol.iterator,
      SymbolDispose: Symbol.dispose || Symbol("Symbol.dispose"),
      SymbolAsyncDispose: Symbol.asyncDispose || Symbol("Symbol.asyncDispose"),
      TypedArrayPrototypeSet(self2, buf, len) {
        return self2.set(buf, len);
      },
      Boolean,
      Uint8Array
    };
  }
});

// ../../../../../node_modules/.deno/event-target-shim@5.0.1/node_modules/event-target-shim/dist/event-target-shim.js
var require_event_target_shim = __commonJS({
  "../../../../../node_modules/.deno/event-target-shim@5.0.1/node_modules/event-target-shim/dist/event-target-shim.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var privateData = /* @__PURE__ */ new WeakMap();
    var wrappers = /* @__PURE__ */ new WeakMap();
    function pd(event) {
      const retv = privateData.get(event);
      console.assert(retv != null, "'this' is expected an Event object, but got", event);
      return retv;
    }
    function setCancelFlag(data) {
      if (data.passiveListener != null) {
        if (typeof console !== "undefined" && typeof console.error === "function") {
          console.error("Unable to preventDefault inside passive event listener invocation.", data.passiveListener);
        }
        return;
      }
      if (!data.event.cancelable) {
        return;
      }
      data.canceled = true;
      if (typeof data.event.preventDefault === "function") {
        data.event.preventDefault();
      }
    }
    function Event(eventTarget, event) {
      privateData.set(this, {
        eventTarget,
        event,
        eventPhase: 2,
        currentTarget: eventTarget,
        canceled: false,
        stopped: false,
        immediateStopped: false,
        passiveListener: null,
        timeStamp: event.timeStamp || Date.now()
      });
      Object.defineProperty(this, "isTrusted", {
        value: false,
        enumerable: true
      });
      const keys = Object.keys(event);
      for (let i2 = 0; i2 < keys.length; ++i2) {
        const key = keys[i2];
        if (!(key in this)) {
          Object.defineProperty(this, key, defineRedirectDescriptor(key));
        }
      }
    }
    Event.prototype = {
      /**
         * The type of this event.
         * @type {string}
         */
      get type() {
        return pd(this).event.type;
      },
      /**
         * The target of this event.
         * @type {EventTarget}
         */
      get target() {
        return pd(this).eventTarget;
      },
      /**
         * The target of this event.
         * @type {EventTarget}
         */
      get currentTarget() {
        return pd(this).currentTarget;
      },
      /**
         * @returns {EventTarget[]} The composed path of this event.
         */
      composedPath() {
        const currentTarget = pd(this).currentTarget;
        if (currentTarget == null) {
          return [];
        }
        return [
          currentTarget
        ];
      },
      /**
         * Constant of NONE.
         * @type {number}
         */
      get NONE() {
        return 0;
      },
      /**
         * Constant of CAPTURING_PHASE.
         * @type {number}
         */
      get CAPTURING_PHASE() {
        return 1;
      },
      /**
         * Constant of AT_TARGET.
         * @type {number}
         */
      get AT_TARGET() {
        return 2;
      },
      /**
         * Constant of BUBBLING_PHASE.
         * @type {number}
         */
      get BUBBLING_PHASE() {
        return 3;
      },
      /**
         * The target of this event.
         * @type {number}
         */
      get eventPhase() {
        return pd(this).eventPhase;
      },
      /**
         * Stop event bubbling.
         * @returns {void}
         */
      stopPropagation() {
        const data = pd(this);
        data.stopped = true;
        if (typeof data.event.stopPropagation === "function") {
          data.event.stopPropagation();
        }
      },
      /**
         * Stop event bubbling.
         * @returns {void}
         */
      stopImmediatePropagation() {
        const data = pd(this);
        data.stopped = true;
        data.immediateStopped = true;
        if (typeof data.event.stopImmediatePropagation === "function") {
          data.event.stopImmediatePropagation();
        }
      },
      /**
         * The flag to be bubbling.
         * @type {boolean}
         */
      get bubbles() {
        return Boolean(pd(this).event.bubbles);
      },
      /**
         * The flag to be cancelable.
         * @type {boolean}
         */
      get cancelable() {
        return Boolean(pd(this).event.cancelable);
      },
      /**
         * Cancel this event.
         * @returns {void}
         */
      preventDefault() {
        setCancelFlag(pd(this));
      },
      /**
         * The flag to indicate cancellation state.
         * @type {boolean}
         */
      get defaultPrevented() {
        return pd(this).canceled;
      },
      /**
         * The flag to be composed.
         * @type {boolean}
         */
      get composed() {
        return Boolean(pd(this).event.composed);
      },
      /**
         * The unix time of this event.
         * @type {number}
         */
      get timeStamp() {
        return pd(this).timeStamp;
      },
      /**
         * The target of this event.
         * @type {EventTarget}
         * @deprecated
         */
      get srcElement() {
        return pd(this).eventTarget;
      },
      /**
         * The flag to stop event bubbling.
         * @type {boolean}
         * @deprecated
         */
      get cancelBubble() {
        return pd(this).stopped;
      },
      set cancelBubble(value) {
        if (!value) {
          return;
        }
        const data = pd(this);
        data.stopped = true;
        if (typeof data.event.cancelBubble === "boolean") {
          data.event.cancelBubble = true;
        }
      },
      /**
         * The flag to indicate cancellation state.
         * @type {boolean}
         * @deprecated
         */
      get returnValue() {
        return !pd(this).canceled;
      },
      set returnValue(value) {
        if (!value) {
          setCancelFlag(pd(this));
        }
      },
      /**
         * Initialize this event object. But do nothing under event dispatching.
         * @param {string} type The event type.
         * @param {boolean} [bubbles=false] The flag to be possible to bubble up.
         * @param {boolean} [cancelable=false] The flag to be possible to cancel.
         * @deprecated
         */
      initEvent() {
      }
    };
    Object.defineProperty(Event.prototype, "constructor", {
      value: Event,
      configurable: true,
      writable: true
    });
    if (typeof window !== "undefined" && typeof window.Event !== "undefined") {
      Object.setPrototypeOf(Event.prototype, window.Event.prototype);
      wrappers.set(window.Event.prototype, Event);
    }
    function defineRedirectDescriptor(key) {
      return {
        get() {
          return pd(this).event[key];
        },
        set(value) {
          pd(this).event[key] = value;
        },
        configurable: true,
        enumerable: true
      };
    }
    function defineCallDescriptor(key) {
      return {
        value() {
          const event = pd(this).event;
          return event[key].apply(event, arguments);
        },
        configurable: true,
        enumerable: true
      };
    }
    function defineWrapper(BaseEvent, proto) {
      const keys = Object.keys(proto);
      if (keys.length === 0) {
        return BaseEvent;
      }
      function CustomEvent(eventTarget, event) {
        BaseEvent.call(this, eventTarget, event);
      }
      CustomEvent.prototype = Object.create(BaseEvent.prototype, {
        constructor: {
          value: CustomEvent,
          configurable: true,
          writable: true
        }
      });
      for (let i2 = 0; i2 < keys.length; ++i2) {
        const key = keys[i2];
        if (!(key in BaseEvent.prototype)) {
          const descriptor = Object.getOwnPropertyDescriptor(proto, key);
          const isFunc = typeof descriptor.value === "function";
          Object.defineProperty(CustomEvent.prototype, key, isFunc ? defineCallDescriptor(key) : defineRedirectDescriptor(key));
        }
      }
      return CustomEvent;
    }
    function getWrapper(proto) {
      if (proto == null || proto === Object.prototype) {
        return Event;
      }
      let wrapper = wrappers.get(proto);
      if (wrapper == null) {
        wrapper = defineWrapper(getWrapper(Object.getPrototypeOf(proto)), proto);
        wrappers.set(proto, wrapper);
      }
      return wrapper;
    }
    function wrapEvent(eventTarget, event) {
      const Wrapper = getWrapper(Object.getPrototypeOf(event));
      return new Wrapper(eventTarget, event);
    }
    function isStopped(event) {
      return pd(event).immediateStopped;
    }
    function setEventPhase(event, eventPhase) {
      pd(event).eventPhase = eventPhase;
    }
    function setCurrentTarget(event, currentTarget) {
      pd(event).currentTarget = currentTarget;
    }
    function setPassiveListener(event, passiveListener) {
      pd(event).passiveListener = passiveListener;
    }
    var listenersMap = /* @__PURE__ */ new WeakMap();
    var CAPTURE = 1;
    var BUBBLE = 2;
    var ATTRIBUTE = 3;
    function isObject(x) {
      return x !== null && typeof x === "object";
    }
    function getListeners(eventTarget) {
      const listeners = listenersMap.get(eventTarget);
      if (listeners == null) {
        throw new TypeError("'this' is expected an EventTarget object, but got another value.");
      }
      return listeners;
    }
    function defineEventAttributeDescriptor(eventName) {
      return {
        get() {
          const listeners = getListeners(this);
          let node = listeners.get(eventName);
          while (node != null) {
            if (node.listenerType === ATTRIBUTE) {
              return node.listener;
            }
            node = node.next;
          }
          return null;
        },
        set(listener) {
          if (typeof listener !== "function" && !isObject(listener)) {
            listener = null;
          }
          const listeners = getListeners(this);
          let prev = null;
          let node = listeners.get(eventName);
          while (node != null) {
            if (node.listenerType === ATTRIBUTE) {
              if (prev !== null) {
                prev.next = node.next;
              } else if (node.next !== null) {
                listeners.set(eventName, node.next);
              } else {
                listeners.delete(eventName);
              }
            } else {
              prev = node;
            }
            node = node.next;
          }
          if (listener !== null) {
            const newNode = {
              listener,
              listenerType: ATTRIBUTE,
              passive: false,
              once: false,
              next: null
            };
            if (prev === null) {
              listeners.set(eventName, newNode);
            } else {
              prev.next = newNode;
            }
          }
        },
        configurable: true,
        enumerable: true
      };
    }
    function defineEventAttribute(eventTargetPrototype, eventName) {
      Object.defineProperty(eventTargetPrototype, `on${eventName}`, defineEventAttributeDescriptor(eventName));
    }
    function defineCustomEventTarget(eventNames) {
      function CustomEventTarget() {
        EventTarget.call(this);
      }
      CustomEventTarget.prototype = Object.create(EventTarget.prototype, {
        constructor: {
          value: CustomEventTarget,
          configurable: true,
          writable: true
        }
      });
      for (let i2 = 0; i2 < eventNames.length; ++i2) {
        defineEventAttribute(CustomEventTarget.prototype, eventNames[i2]);
      }
      return CustomEventTarget;
    }
    function EventTarget() {
      if (this instanceof EventTarget) {
        listenersMap.set(this, /* @__PURE__ */ new Map());
        return;
      }
      if (arguments.length === 1 && Array.isArray(arguments[0])) {
        return defineCustomEventTarget(arguments[0]);
      }
      if (arguments.length > 0) {
        const types = new Array(arguments.length);
        for (let i2 = 0; i2 < arguments.length; ++i2) {
          types[i2] = arguments[i2];
        }
        return defineCustomEventTarget(types);
      }
      throw new TypeError("Cannot call a class as a function");
    }
    EventTarget.prototype = {
      /**
         * Add a given listener to this event target.
         * @param {string} eventName The event name to add.
         * @param {Function} listener The listener to add.
         * @param {boolean|{capture?:boolean,passive?:boolean,once?:boolean}} [options] The options for this listener.
         * @returns {void}
         */
      addEventListener(eventName, listener, options) {
        if (listener == null) {
          return;
        }
        if (typeof listener !== "function" && !isObject(listener)) {
          throw new TypeError("'listener' should be a function or an object.");
        }
        const listeners = getListeners(this);
        const optionsIsObj = isObject(options);
        const capture = optionsIsObj ? Boolean(options.capture) : Boolean(options);
        const listenerType = capture ? CAPTURE : BUBBLE;
        const newNode = {
          listener,
          listenerType,
          passive: optionsIsObj && Boolean(options.passive),
          once: optionsIsObj && Boolean(options.once),
          next: null
        };
        let node = listeners.get(eventName);
        if (node === void 0) {
          listeners.set(eventName, newNode);
          return;
        }
        let prev = null;
        while (node != null) {
          if (node.listener === listener && node.listenerType === listenerType) {
            return;
          }
          prev = node;
          node = node.next;
        }
        prev.next = newNode;
      },
      /**
         * Remove a given listener from this event target.
         * @param {string} eventName The event name to remove.
         * @param {Function} listener The listener to remove.
         * @param {boolean|{capture?:boolean,passive?:boolean,once?:boolean}} [options] The options for this listener.
         * @returns {void}
         */
      removeEventListener(eventName, listener, options) {
        if (listener == null) {
          return;
        }
        const listeners = getListeners(this);
        const capture = isObject(options) ? Boolean(options.capture) : Boolean(options);
        const listenerType = capture ? CAPTURE : BUBBLE;
        let prev = null;
        let node = listeners.get(eventName);
        while (node != null) {
          if (node.listener === listener && node.listenerType === listenerType) {
            if (prev !== null) {
              prev.next = node.next;
            } else if (node.next !== null) {
              listeners.set(eventName, node.next);
            } else {
              listeners.delete(eventName);
            }
            return;
          }
          prev = node;
          node = node.next;
        }
      },
      /**
         * Dispatch a given event.
         * @param {Event|{type:string}} event The event to dispatch.
         * @returns {boolean} `false` if canceled.
         */
      dispatchEvent(event) {
        if (event == null || typeof event.type !== "string") {
          throw new TypeError('"event.type" should be a string.');
        }
        const listeners = getListeners(this);
        const eventName = event.type;
        let node = listeners.get(eventName);
        if (node == null) {
          return true;
        }
        const wrappedEvent = wrapEvent(this, event);
        let prev = null;
        while (node != null) {
          if (node.once) {
            if (prev !== null) {
              prev.next = node.next;
            } else if (node.next !== null) {
              listeners.set(eventName, node.next);
            } else {
              listeners.delete(eventName);
            }
          } else {
            prev = node;
          }
          setPassiveListener(wrappedEvent, node.passive ? node.listener : null);
          if (typeof node.listener === "function") {
            try {
              node.listener.call(this, wrappedEvent);
            } catch (err) {
              if (typeof console !== "undefined" && typeof console.error === "function") {
                console.error(err);
              }
            }
          } else if (node.listenerType !== ATTRIBUTE && typeof node.listener.handleEvent === "function") {
            node.listener.handleEvent(wrappedEvent);
          }
          if (isStopped(wrappedEvent)) {
            break;
          }
          node = node.next;
        }
        setPassiveListener(wrappedEvent, null);
        setEventPhase(wrappedEvent, 0);
        setCurrentTarget(wrappedEvent, null);
        return !wrappedEvent.defaultPrevented;
      }
    };
    Object.defineProperty(EventTarget.prototype, "constructor", {
      value: EventTarget,
      configurable: true,
      writable: true
    });
    if (typeof window !== "undefined" && typeof window.EventTarget !== "undefined") {
      Object.setPrototypeOf(EventTarget.prototype, window.EventTarget.prototype);
    }
    exports.defineEventAttribute = defineEventAttribute;
    exports.EventTarget = EventTarget;
    exports.default = EventTarget;
    module.exports = EventTarget;
    module.exports.EventTarget = module.exports["default"] = EventTarget;
    module.exports.defineEventAttribute = defineEventAttribute;
  }
});

// ../../../../../node_modules/.deno/abort-controller@3.0.0/node_modules/abort-controller/dist/abort-controller.js
var require_abort_controller = __commonJS({
  "../../../../../node_modules/.deno/abort-controller@3.0.0/node_modules/abort-controller/dist/abort-controller.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var eventTargetShim = require_event_target_shim();
    var AbortSignal = class extends eventTargetShim.EventTarget {
      /**
         * AbortSignal cannot be constructed directly.
         */
      constructor() {
        super();
        throw new TypeError("AbortSignal cannot be constructed directly");
      }
      /**
         * Returns `true` if this `AbortSignal`'s `AbortController` has signaled to abort, and `false` otherwise.
         */
      get aborted() {
        const aborted = abortedFlags.get(this);
        if (typeof aborted !== "boolean") {
          throw new TypeError(`Expected 'this' to be an 'AbortSignal' object, but got ${this === null ? "null" : typeof this}`);
        }
        return aborted;
      }
    };
    eventTargetShim.defineEventAttribute(AbortSignal.prototype, "abort");
    function createAbortSignal() {
      const signal = Object.create(AbortSignal.prototype);
      eventTargetShim.EventTarget.call(signal);
      abortedFlags.set(signal, false);
      return signal;
    }
    function abortSignal(signal) {
      if (abortedFlags.get(signal) !== false) {
        return;
      }
      abortedFlags.set(signal, true);
      signal.dispatchEvent({
        type: "abort"
      });
    }
    var abortedFlags = /* @__PURE__ */ new WeakMap();
    Object.defineProperties(AbortSignal.prototype, {
      aborted: {
        enumerable: true
      }
    });
    if (typeof Symbol === "function" && typeof Symbol.toStringTag === "symbol") {
      Object.defineProperty(AbortSignal.prototype, Symbol.toStringTag, {
        configurable: true,
        value: "AbortSignal"
      });
    }
    var AbortController = class {
      /**
         * Initialize this controller.
         */
      constructor() {
        signals.set(this, createAbortSignal());
      }
      /**
         * Returns the `AbortSignal` object associated with this object.
         */
      get signal() {
        return getSignal(this);
      }
      /**
         * Abort and signal to any observers that the associated activity is to be aborted.
         */
      abort() {
        abortSignal(getSignal(this));
      }
    };
    var signals = /* @__PURE__ */ new WeakMap();
    function getSignal(controller) {
      const signal = signals.get(controller);
      if (signal == null) {
        throw new TypeError(`Expected 'this' to be an 'AbortController' object, but got ${controller === null ? "null" : typeof controller}`);
      }
      return signal;
    }
    Object.defineProperties(AbortController.prototype, {
      signal: {
        enumerable: true
      },
      abort: {
        enumerable: true
      }
    });
    if (typeof Symbol === "function" && typeof Symbol.toStringTag === "symbol") {
      Object.defineProperty(AbortController.prototype, Symbol.toStringTag, {
        configurable: true,
        value: "AbortController"
      });
    }
    exports.AbortController = AbortController;
    exports.AbortSignal = AbortSignal;
    exports.default = AbortController;
    module.exports = AbortController;
    module.exports.AbortController = module.exports["default"] = AbortController;
    module.exports.AbortSignal = AbortSignal;
  }
});

// ../../../../../node_modules/.deno/readable-stream@4.5.2/node_modules/readable-stream/lib/ours/util.js
var require_util = __commonJS({
  "../../../../../node_modules/.deno/readable-stream@4.5.2/node_modules/readable-stream/lib/ours/util.js"(exports, module) {
    "use strict";
    var bufferModule = __require("node:buffer");
    var { kResistStopPropagation, SymbolDispose } = require_primordials();
    var AbortSignal = globalThis.AbortSignal || require_abort_controller().AbortSignal;
    var AbortController = globalThis.AbortController || require_abort_controller().AbortController;
    var AsyncFunction = Object.getPrototypeOf(async function() {
    }).constructor;
    var Blob2 = globalThis.Blob || bufferModule.Blob;
    var isBlob2 = typeof Blob2 !== "undefined" ? function isBlob3(b) {
      return b instanceof Blob2;
    } : function isBlob3(b) {
      return false;
    };
    var validateAbortSignal = (signal, name) => {
      if (signal !== void 0 && (signal === null || typeof signal !== "object" || !("aborted" in signal))) {
        throw new ERR_INVALID_ARG_TYPE(name, "AbortSignal", signal);
      }
    };
    var validateFunction = (value, name) => {
      if (typeof value !== "function") throw new ERR_INVALID_ARG_TYPE(name, "Function", value);
    };
    var AggregateError = class extends Error {
      constructor(errors) {
        if (!Array.isArray(errors)) {
          throw new TypeError(`Expected input to be an Array, got ${typeof errors}`);
        }
        let message = "";
        for (let i2 = 0; i2 < errors.length; i2++) {
          message += `    ${errors[i2].stack}
`;
        }
        super(message);
        this.name = "AggregateError";
        this.errors = errors;
      }
    };
    module.exports = {
      AggregateError,
      kEmptyObject: Object.freeze({}),
      once(callback) {
        let called = false;
        return function(...args) {
          if (called) {
            return;
          }
          called = true;
          callback.apply(this, args);
        };
      },
      createDeferredPromise: function() {
        let resolve;
        let reject;
        const promise = new Promise((res, rej) => {
          resolve = res;
          reject = rej;
        });
        return {
          promise,
          resolve,
          reject
        };
      },
      promisify(fn) {
        return new Promise((resolve, reject) => {
          fn((err, ...args) => {
            if (err) {
              return reject(err);
            }
            return resolve(...args);
          });
        });
      },
      debuglog() {
        return function() {
        };
      },
      format(format, ...args) {
        return format.replace(/%([sdifj])/g, function(...[_unused, type]) {
          const replacement = args.shift();
          if (type === "f") {
            return replacement.toFixed(6);
          } else if (type === "j") {
            return JSON.stringify(replacement);
          } else if (type === "s" && typeof replacement === "object") {
            const ctor = replacement.constructor !== Object ? replacement.constructor.name : "";
            return `${ctor} {}`.trim();
          } else {
            return replacement.toString();
          }
        });
      },
      inspect(value) {
        switch (typeof value) {
          case "string":
            if (value.includes("'")) {
              if (!value.includes('"')) {
                return `"${value}"`;
              } else if (!value.includes("`") && !value.includes("${")) {
                return `\`${value}\``;
              }
            }
            return `'${value}'`;
          case "number":
            if (isNaN(value)) {
              return "NaN";
            } else if (Object.is(value, -0)) {
              return String(value);
            }
            return value;
          case "bigint":
            return `${String(value)}n`;
          case "boolean":
          case "undefined":
            return String(value);
          case "object":
            return "{}";
        }
      },
      types: {
        isAsyncFunction(fn) {
          return fn instanceof AsyncFunction;
        },
        isArrayBufferView(arr) {
          return ArrayBuffer.isView(arr);
        }
      },
      isBlob: isBlob2,
      deprecate(fn, message) {
        return fn;
      },
      addAbortListener: __require("node:events").addAbortListener || function addAbortListener(signal, listener) {
        if (signal === void 0) {
          throw new ERR_INVALID_ARG_TYPE("signal", "AbortSignal", signal);
        }
        validateAbortSignal(signal, "signal");
        validateFunction(listener, "listener");
        let removeEventListener;
        if (signal.aborted) {
          queueMicrotask(() => listener());
        } else {
          signal.addEventListener("abort", listener, {
            __proto__: null,
            once: true,
            [kResistStopPropagation]: true
          });
          removeEventListener = () => {
            signal.removeEventListener("abort", listener);
          };
        }
        return {
          __proto__: null,
          [SymbolDispose]() {
            var _removeEventListener;
            (_removeEventListener = removeEventListener) === null || _removeEventListener === void 0 ? void 0 : _removeEventListener();
          }
        };
      },
      AbortSignalAny: AbortSignal.any || function AbortSignalAny(signals) {
        if (signals.length === 1) {
          return signals[0];
        }
        const ac = new AbortController();
        const abort = () => ac.abort();
        signals.forEach((signal) => {
          validateAbortSignal(signal, "signals");
          signal.addEventListener("abort", abort, {
            once: true
          });
        });
        ac.signal.addEventListener("abort", () => {
          signals.forEach((signal) => signal.removeEventListener("abort", abort));
        }, {
          once: true
        });
        return ac.signal;
      }
    };
    module.exports.promisify.custom = Symbol.for("nodejs.util.promisify.custom");
  }
});

// ../../../../../node_modules/.deno/readable-stream@4.5.2/node_modules/readable-stream/lib/ours/errors.js
var require_errors2 = __commonJS({
  "../../../../../node_modules/.deno/readable-stream@4.5.2/node_modules/readable-stream/lib/ours/errors.js"(exports, module) {
    "use strict";
    var { format, inspect, AggregateError: CustomAggregateError } = require_util();
    var AggregateError = globalThis.AggregateError || CustomAggregateError;
    var kIsNodeError = Symbol("kIsNodeError");
    var kTypes = [
      "string",
      "function",
      "number",
      "object",
      // Accept 'Function' and 'Object' as alternative to the lower cased version.
      "Function",
      "Object",
      "boolean",
      "bigint",
      "symbol"
    ];
    var classRegExp = /^([A-Z][a-z0-9]*)+$/;
    var nodeInternalPrefix = "__node_internal_";
    var codes = {};
    function assert(value, message) {
      if (!value) {
        throw new codes.ERR_INTERNAL_ASSERTION(message);
      }
    }
    function addNumericalSeparator(val) {
      let res = "";
      let i2 = val.length;
      const start = val[0] === "-" ? 1 : 0;
      for (; i2 >= start + 4; i2 -= 3) {
        res = `_${val.slice(i2 - 3, i2)}${res}`;
      }
      return `${val.slice(0, i2)}${res}`;
    }
    function getMessage(key, msg, args) {
      if (typeof msg === "function") {
        assert(
          msg.length <= args.length,
          // Default options do not count.
          `Code: ${key}; The provided arguments length (${args.length}) does not match the required ones (${msg.length}).`
        );
        return msg(...args);
      }
      const expectedLength = (msg.match(/%[dfijoOs]/g) || []).length;
      assert(expectedLength === args.length, `Code: ${key}; The provided arguments length (${args.length}) does not match the required ones (${expectedLength}).`);
      if (args.length === 0) {
        return msg;
      }
      return format(msg, ...args);
    }
    function E(code, message, Base) {
      if (!Base) {
        Base = Error;
      }
      class NodeError extends Base {
        constructor(...args) {
          super(getMessage(code, message, args));
        }
        toString() {
          return `${this.name} [${code}]: ${this.message}`;
        }
      }
      Object.defineProperties(NodeError.prototype, {
        name: {
          value: Base.name,
          writable: true,
          enumerable: false,
          configurable: true
        },
        toString: {
          value() {
            return `${this.name} [${code}]: ${this.message}`;
          },
          writable: true,
          enumerable: false,
          configurable: true
        }
      });
      NodeError.prototype.code = code;
      NodeError.prototype[kIsNodeError] = true;
      codes[code] = NodeError;
    }
    function hideStackFrames(fn) {
      const hidden = nodeInternalPrefix + fn.name;
      Object.defineProperty(fn, "name", {
        value: hidden
      });
      return fn;
    }
    function aggregateTwoErrors(innerError, outerError) {
      if (innerError && outerError && innerError !== outerError) {
        if (Array.isArray(outerError.errors)) {
          outerError.errors.push(innerError);
          return outerError;
        }
        const err = new AggregateError([
          outerError,
          innerError
        ], outerError.message);
        err.code = outerError.code;
        return err;
      }
      return innerError || outerError;
    }
    var AbortError2 = class extends Error {
      constructor(message = "The operation was aborted", options = void 0) {
        if (options !== void 0 && typeof options !== "object") {
          throw new codes.ERR_INVALID_ARG_TYPE("options", "Object", options);
        }
        super(message, options);
        this.code = "ABORT_ERR";
        this.name = "AbortError";
      }
    };
    E("ERR_ASSERTION", "%s", Error);
    E("ERR_INVALID_ARG_TYPE", (name, expected, actual) => {
      assert(typeof name === "string", "'name' must be a string");
      if (!Array.isArray(expected)) {
        expected = [
          expected
        ];
      }
      let msg = "The ";
      if (name.endsWith(" argument")) {
        msg += `${name} `;
      } else {
        msg += `"${name}" ${name.includes(".") ? "property" : "argument"} `;
      }
      msg += "must be ";
      const types = [];
      const instances = [];
      const other = [];
      for (const value of expected) {
        assert(typeof value === "string", "All expected entries have to be of type string");
        if (kTypes.includes(value)) {
          types.push(value.toLowerCase());
        } else if (classRegExp.test(value)) {
          instances.push(value);
        } else {
          assert(value !== "object", 'The value "object" should be written as "Object"');
          other.push(value);
        }
      }
      if (instances.length > 0) {
        const pos = types.indexOf("object");
        if (pos !== -1) {
          types.splice(types, pos, 1);
          instances.push("Object");
        }
      }
      if (types.length > 0) {
        switch (types.length) {
          case 1:
            msg += `of type ${types[0]}`;
            break;
          case 2:
            msg += `one of type ${types[0]} or ${types[1]}`;
            break;
          default: {
            const last = types.pop();
            msg += `one of type ${types.join(", ")}, or ${last}`;
          }
        }
        if (instances.length > 0 || other.length > 0) {
          msg += " or ";
        }
      }
      if (instances.length > 0) {
        switch (instances.length) {
          case 1:
            msg += `an instance of ${instances[0]}`;
            break;
          case 2:
            msg += `an instance of ${instances[0]} or ${instances[1]}`;
            break;
          default: {
            const last = instances.pop();
            msg += `an instance of ${instances.join(", ")}, or ${last}`;
          }
        }
        if (other.length > 0) {
          msg += " or ";
        }
      }
      switch (other.length) {
        case 0:
          break;
        case 1:
          if (other[0].toLowerCase() !== other[0]) {
            msg += "an ";
          }
          msg += `${other[0]}`;
          break;
        case 2:
          msg += `one of ${other[0]} or ${other[1]}`;
          break;
        default: {
          const last = other.pop();
          msg += `one of ${other.join(", ")}, or ${last}`;
        }
      }
      if (actual == null) {
        msg += `. Received ${actual}`;
      } else if (typeof actual === "function" && actual.name) {
        msg += `. Received function ${actual.name}`;
      } else if (typeof actual === "object") {
        var _actual$constructor;
        if ((_actual$constructor = actual.constructor) !== null && _actual$constructor !== void 0 && _actual$constructor.name) {
          msg += `. Received an instance of ${actual.constructor.name}`;
        } else {
          const inspected = inspect(actual, {
            depth: -1
          });
          msg += `. Received ${inspected}`;
        }
      } else {
        let inspected = inspect(actual, {
          colors: false
        });
        if (inspected.length > 25) {
          inspected = `${inspected.slice(0, 25)}...`;
        }
        msg += `. Received type ${typeof actual} (${inspected})`;
      }
      return msg;
    }, TypeError);
    E("ERR_INVALID_ARG_VALUE", (name, value, reason = "is invalid") => {
      let inspected = inspect(value);
      if (inspected.length > 128) {
        inspected = inspected.slice(0, 128) + "...";
      }
      const type = name.includes(".") ? "property" : "argument";
      return `The ${type} '${name}' ${reason}. Received ${inspected}`;
    }, TypeError);
    E("ERR_INVALID_RETURN_VALUE", (input, name, value) => {
      var _value$constructor;
      const type = value !== null && value !== void 0 && (_value$constructor = value.constructor) !== null && _value$constructor !== void 0 && _value$constructor.name ? `instance of ${value.constructor.name}` : `type ${typeof value}`;
      return `Expected ${input} to be returned from the "${name}" function but got ${type}.`;
    }, TypeError);
    E("ERR_MISSING_ARGS", (...args) => {
      assert(args.length > 0, "At least one arg needs to be specified");
      let msg;
      const len = args.length;
      args = (Array.isArray(args) ? args : [
        args
      ]).map((a) => `"${a}"`).join(" or ");
      switch (len) {
        case 1:
          msg += `The ${args[0]} argument`;
          break;
        case 2:
          msg += `The ${args[0]} and ${args[1]} arguments`;
          break;
        default:
          {
            const last = args.pop();
            msg += `The ${args.join(", ")}, and ${last} arguments`;
          }
          break;
      }
      return `${msg} must be specified`;
    }, TypeError);
    E("ERR_OUT_OF_RANGE", (str, range, input) => {
      assert(range, 'Missing "range" argument');
      let received;
      if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
        received = addNumericalSeparator(String(input));
      } else if (typeof input === "bigint") {
        received = String(input);
        if (input > 2n ** 32n || input < -(2n ** 32n)) {
          received = addNumericalSeparator(received);
        }
        received += "n";
      } else {
        received = inspect(input);
      }
      return `The value of "${str}" is out of range. It must be ${range}. Received ${received}`;
    }, RangeError);
    E("ERR_MULTIPLE_CALLBACK", "Callback called multiple times", Error);
    E("ERR_METHOD_NOT_IMPLEMENTED", "The %s method is not implemented", Error);
    E("ERR_STREAM_ALREADY_FINISHED", "Cannot call %s after a stream was finished", Error);
    E("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable", Error);
    E("ERR_STREAM_DESTROYED", "Cannot call %s after a stream was destroyed", Error);
    E("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    E("ERR_STREAM_PREMATURE_CLOSE", "Premature close", Error);
    E("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF", Error);
    E("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event", Error);
    E("ERR_STREAM_WRITE_AFTER_END", "write after end", Error);
    E("ERR_UNKNOWN_ENCODING", "Unknown encoding: %s", TypeError);
    module.exports = {
      AbortError: AbortError2,
      aggregateTwoErrors: hideStackFrames(aggregateTwoErrors),
      hideStackFrames,
      codes
    };
  }
});

// ../../../../../node_modules/.deno/readable-stream@4.5.2/node_modules/readable-stream/lib/internal/validators.js
var require_validators = __commonJS({
  "../../../../../node_modules/.deno/readable-stream@4.5.2/node_modules/readable-stream/lib/internal/validators.js"(exports, module) {
    "use strict";
    var { ArrayIsArray, ArrayPrototypeIncludes, ArrayPrototypeJoin, ArrayPrototypeMap, NumberIsInteger, NumberIsNaN, NumberMAX_SAFE_INTEGER, NumberMIN_SAFE_INTEGER, NumberParseInt, ObjectPrototypeHasOwnProperty, RegExpPrototypeExec, String: String2, StringPrototypeToUpperCase, StringPrototypeTrim } = require_primordials();
    var { hideStackFrames, codes: { ERR_SOCKET_BAD_PORT, ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE2, ERR_INVALID_ARG_VALUE, ERR_OUT_OF_RANGE, ERR_UNKNOWN_SIGNAL } } = require_errors2();
    var { normalizeEncoding } = require_util();
    var { isAsyncFunction, isArrayBufferView } = require_util().types;
    var signals = {};
    function isInt32(value) {
      return value === (value | 0);
    }
    function isUint32(value) {
      return value === value >>> 0;
    }
    var octalReg = /^[0-7]+$/;
    var modeDesc = "must be a 32-bit unsigned integer or an octal string";
    function parseFileMode(value, name, def) {
      if (typeof value === "undefined") {
        value = def;
      }
      if (typeof value === "string") {
        if (RegExpPrototypeExec(octalReg, value) === null) {
          throw new ERR_INVALID_ARG_VALUE(name, value, modeDesc);
        }
        value = NumberParseInt(value, 8);
      }
      validateUint32(value, name);
      return value;
    }
    var validateInteger = hideStackFrames((value, name, min = NumberMIN_SAFE_INTEGER, max = NumberMAX_SAFE_INTEGER) => {
      if (typeof value !== "number") throw new ERR_INVALID_ARG_TYPE2(name, "number", value);
      if (!NumberIsInteger(value)) throw new ERR_OUT_OF_RANGE(name, "an integer", value);
      if (value < min || value > max) throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);
    });
    var validateInt32 = hideStackFrames((value, name, min = -2147483648, max = 2147483647) => {
      if (typeof value !== "number") {
        throw new ERR_INVALID_ARG_TYPE2(name, "number", value);
      }
      if (!NumberIsInteger(value)) {
        throw new ERR_OUT_OF_RANGE(name, "an integer", value);
      }
      if (value < min || value > max) {
        throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);
      }
    });
    var validateUint32 = hideStackFrames((value, name, positive = false) => {
      if (typeof value !== "number") {
        throw new ERR_INVALID_ARG_TYPE2(name, "number", value);
      }
      if (!NumberIsInteger(value)) {
        throw new ERR_OUT_OF_RANGE(name, "an integer", value);
      }
      const min = positive ? 1 : 0;
      const max = 4294967295;
      if (value < min || value > max) {
        throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);
      }
    });
    function validateString(value, name) {
      if (typeof value !== "string") throw new ERR_INVALID_ARG_TYPE2(name, "string", value);
    }
    function validateNumber(value, name, min = void 0, max) {
      if (typeof value !== "number") throw new ERR_INVALID_ARG_TYPE2(name, "number", value);
      if (min != null && value < min || max != null && value > max || (min != null || max != null) && NumberIsNaN(value)) {
        throw new ERR_OUT_OF_RANGE(name, `${min != null ? `>= ${min}` : ""}${min != null && max != null ? " && " : ""}${max != null ? `<= ${max}` : ""}`, value);
      }
    }
    var validateOneOf = hideStackFrames((value, name, oneOf) => {
      if (!ArrayPrototypeIncludes(oneOf, value)) {
        const allowed = ArrayPrototypeJoin(ArrayPrototypeMap(oneOf, (v) => typeof v === "string" ? `'${v}'` : String2(v)), ", ");
        const reason = "must be one of: " + allowed;
        throw new ERR_INVALID_ARG_VALUE(name, value, reason);
      }
    });
    function validateBoolean(value, name) {
      if (typeof value !== "boolean") throw new ERR_INVALID_ARG_TYPE2(name, "boolean", value);
    }
    function getOwnPropertyValueOrDefault(options, key, defaultValue) {
      return options == null || !ObjectPrototypeHasOwnProperty(options, key) ? defaultValue : options[key];
    }
    var validateObject = hideStackFrames((value, name, options = null) => {
      const allowArray = getOwnPropertyValueOrDefault(options, "allowArray", false);
      const allowFunction = getOwnPropertyValueOrDefault(options, "allowFunction", false);
      const nullable = getOwnPropertyValueOrDefault(options, "nullable", false);
      if (!nullable && value === null || !allowArray && ArrayIsArray(value) || typeof value !== "object" && (!allowFunction || typeof value !== "function")) {
        throw new ERR_INVALID_ARG_TYPE2(name, "Object", value);
      }
    });
    var validateDictionary = hideStackFrames((value, name) => {
      if (value != null && typeof value !== "object" && typeof value !== "function") {
        throw new ERR_INVALID_ARG_TYPE2(name, "a dictionary", value);
      }
    });
    var validateArray = hideStackFrames((value, name, minLength = 0) => {
      if (!ArrayIsArray(value)) {
        throw new ERR_INVALID_ARG_TYPE2(name, "Array", value);
      }
      if (value.length < minLength) {
        const reason = `must be longer than ${minLength}`;
        throw new ERR_INVALID_ARG_VALUE(name, value, reason);
      }
    });
    function validateStringArray(value, name) {
      validateArray(value, name);
      for (let i2 = 0; i2 < value.length; i2++) {
        validateString(value[i2], `${name}[${i2}]`);
      }
    }
    function validateBooleanArray(value, name) {
      validateArray(value, name);
      for (let i2 = 0; i2 < value.length; i2++) {
        validateBoolean(value[i2], `${name}[${i2}]`);
      }
    }
    function validateAbortSignalArray(value, name) {
      validateArray(value, name);
      for (let i2 = 0; i2 < value.length; i2++) {
        const signal = value[i2];
        const indexedName = `${name}[${i2}]`;
        if (signal == null) {
          throw new ERR_INVALID_ARG_TYPE2(indexedName, "AbortSignal", signal);
        }
        validateAbortSignal(signal, indexedName);
      }
    }
    function validateSignalName(signal, name = "signal") {
      validateString(signal, name);
      if (signals[signal] === void 0) {
        if (signals[StringPrototypeToUpperCase(signal)] !== void 0) {
          throw new ERR_UNKNOWN_SIGNAL(signal + " (signals must use all capital letters)");
        }
        throw new ERR_UNKNOWN_SIGNAL(signal);
      }
    }
    var validateBuffer = hideStackFrames((buffer, name = "buffer") => {
      if (!isArrayBufferView(buffer)) {
        throw new ERR_INVALID_ARG_TYPE2(name, [
          "Buffer",
          "TypedArray",
          "DataView"
        ], buffer);
      }
    });
    function validateEncoding(data, encoding) {
      const normalizedEncoding = normalizeEncoding(encoding);
      const length = data.length;
      if (normalizedEncoding === "hex" && length % 2 !== 0) {
        throw new ERR_INVALID_ARG_VALUE("encoding", encoding, `is invalid for data of length ${length}`);
      }
    }
    function validatePort(port, name = "Port", allowZero = true) {
      if (typeof port !== "number" && typeof port !== "string" || typeof port === "string" && StringPrototypeTrim(port).length === 0 || +port !== +port >>> 0 || port > 65535 || port === 0 && !allowZero) {
        throw new ERR_SOCKET_BAD_PORT(name, port, allowZero);
      }
      return port | 0;
    }
    var validateAbortSignal = hideStackFrames((signal, name) => {
      if (signal !== void 0 && (signal === null || typeof signal !== "object" || !("aborted" in signal))) {
        throw new ERR_INVALID_ARG_TYPE2(name, "AbortSignal", signal);
      }
    });
    var validateFunction = hideStackFrames((value, name) => {
      if (typeof value !== "function") throw new ERR_INVALID_ARG_TYPE2(name, "Function", value);
    });
    var validatePlainFunction = hideStackFrames((value, name) => {
      if (typeof value !== "function" || isAsyncFunction(value)) throw new ERR_INVALID_ARG_TYPE2(name, "Function", value);
    });
    var validateUndefined = hideStackFrames((value, name) => {
      if (value !== void 0) throw new ERR_INVALID_ARG_TYPE2(name, "undefined", value);
    });
    function validateUnion(value, name, union) {
      if (!ArrayPrototypeIncludes(union, value)) {
        throw new ERR_INVALID_ARG_TYPE2(name, `('${ArrayPrototypeJoin(union, "|")}')`, value);
      }
    }
    var linkValueRegExp = /^(?:<[^>]*>)(?:\s*;\s*[^;"\s]+(?:=(")?[^;"\s]*\1)?)*$/;
    function validateLinkHeaderFormat(value, name) {
      if (typeof value === "undefined" || !RegExpPrototypeExec(linkValueRegExp, value)) {
        throw new ERR_INVALID_ARG_VALUE(name, value, 'must be an array or string of format "</styles.css>; rel=preload; as=style"');
      }
    }
    function validateLinkHeaderValue(hints) {
      if (typeof hints === "string") {
        validateLinkHeaderFormat(hints, "hints");
        return hints;
      } else if (ArrayIsArray(hints)) {
        const hintsLength = hints.length;
        let result = "";
        if (hintsLength === 0) {
          return result;
        }
        for (let i2 = 0; i2 < hintsLength; i2++) {
          const link = hints[i2];
          validateLinkHeaderFormat(link, "hints");
          result += link;
          if (i2 !== hintsLength - 1) {
            result += ", ";
          }
        }
        return result;
      }
      throw new ERR_INVALID_ARG_VALUE("hints", hints, 'must be an array or string of format "</styles.css>; rel=preload; as=style"');
    }
    module.exports = {
      isInt32,
      isUint32,
      parseFileMode,
      validateArray,
      validateStringArray,
      validateBooleanArray,
      validateAbortSignalArray,
      validateBoolean,
      validateBuffer,
      validateDictionary,
      validateEncoding,
      validateFunction,
      validateInt32,
      validateInteger,
      validateNumber,
      validateObject,
      validateOneOf,
      validatePlainFunction,
      validatePort,
      validateSignalName,
      validateString,
      validateUint32,
      validateUndefined,
      validateUnion,
      validateAbortSignal,
      validateLinkHeaderValue
    };
  }
});

// ../../../../../node_modules/.deno/process@0.11.10/node_modules/process/index.js
var require_process = __commonJS({
  "../../../../../node_modules/.deno/process@0.11.10/node_modules/process/index.js"(exports, module) {
    module.exports = global.process;
  }
});

// ../../../../../node_modules/.deno/readable-stream@4.5.2/node_modules/readable-stream/lib/internal/streams/utils.js
var require_utils24 = __commonJS({
  "../../../../../node_modules/.deno/readable-stream@4.5.2/node_modules/readable-stream/lib/internal/streams/utils.js"(exports, module) {
    "use strict";
    var { SymbolAsyncIterator, SymbolIterator, SymbolFor } = require_primordials();
    var kIsDestroyed = SymbolFor("nodejs.stream.destroyed");
    var kIsErrored = SymbolFor("nodejs.stream.errored");
    var kIsReadable = SymbolFor("nodejs.stream.readable");
    var kIsWritable = SymbolFor("nodejs.stream.writable");
    var kIsDisturbed = SymbolFor("nodejs.stream.disturbed");
    var kIsClosedPromise = SymbolFor("nodejs.webstream.isClosedPromise");
    var kControllerErrorFunction = SymbolFor("nodejs.webstream.controllerErrorFunction");
    function isReadableNodeStream(obj2, strict = false) {
      var _obj$_readableState;
      return !!(obj2 && typeof obj2.pipe === "function" && typeof obj2.on === "function" && (!strict || typeof obj2.pause === "function" && typeof obj2.resume === "function") && (!obj2._writableState || ((_obj$_readableState = obj2._readableState) === null || _obj$_readableState === void 0 ? void 0 : _obj$_readableState.readable) !== false) && // Duplex
      (!obj2._writableState || obj2._readableState));
    }
    function isWritableNodeStream(obj2) {
      var _obj$_writableState;
      return !!(obj2 && typeof obj2.write === "function" && typeof obj2.on === "function" && (!obj2._readableState || ((_obj$_writableState = obj2._writableState) === null || _obj$_writableState === void 0 ? void 0 : _obj$_writableState.writable) !== false));
    }
    function isDuplexNodeStream(obj2) {
      return !!(obj2 && typeof obj2.pipe === "function" && obj2._readableState && typeof obj2.on === "function" && typeof obj2.write === "function");
    }
    function isNodeStream(obj2) {
      return obj2 && (obj2._readableState || obj2._writableState || typeof obj2.write === "function" && typeof obj2.on === "function" || typeof obj2.pipe === "function" && typeof obj2.on === "function");
    }
    function isReadableStream(obj2) {
      return !!(obj2 && !isNodeStream(obj2) && typeof obj2.pipeThrough === "function" && typeof obj2.getReader === "function" && typeof obj2.cancel === "function");
    }
    function isWritableStream(obj2) {
      return !!(obj2 && !isNodeStream(obj2) && typeof obj2.getWriter === "function" && typeof obj2.abort === "function");
    }
    function isTransformStream(obj2) {
      return !!(obj2 && !isNodeStream(obj2) && typeof obj2.readable === "object" && typeof obj2.writable === "object");
    }
    function isWebStream(obj2) {
      return isReadableStream(obj2) || isWritableStream(obj2) || isTransformStream(obj2);
    }
    function isIterable(obj2, isAsync) {
      if (obj2 == null) return false;
      if (isAsync === true) return typeof obj2[SymbolAsyncIterator] === "function";
      if (isAsync === false) return typeof obj2[SymbolIterator] === "function";
      return typeof obj2[SymbolAsyncIterator] === "function" || typeof obj2[SymbolIterator] === "function";
    }
    function isDestroyed(stream) {
      if (!isNodeStream(stream)) return null;
      const wState = stream._writableState;
      const rState = stream._readableState;
      const state = wState || rState;
      return !!(stream.destroyed || stream[kIsDestroyed] || state !== null && state !== void 0 && state.destroyed);
    }
    function isWritableEnded(stream) {
      if (!isWritableNodeStream(stream)) return null;
      if (stream.writableEnded === true) return true;
      const wState = stream._writableState;
      if (wState !== null && wState !== void 0 && wState.errored) return false;
      if (typeof (wState === null || wState === void 0 ? void 0 : wState.ended) !== "boolean") return null;
      return wState.ended;
    }
    function isWritableFinished(stream, strict) {
      if (!isWritableNodeStream(stream)) return null;
      if (stream.writableFinished === true) return true;
      const wState = stream._writableState;
      if (wState !== null && wState !== void 0 && wState.errored) return false;
      if (typeof (wState === null || wState === void 0 ? void 0 : wState.finished) !== "boolean") return null;
      return !!(wState.finished || strict === false && wState.ended === true && wState.length === 0);
    }
    function isReadableEnded(stream) {
      if (!isReadableNodeStream(stream)) return null;
      if (stream.readableEnded === true) return true;
      const rState = stream._readableState;
      if (!rState || rState.errored) return false;
      if (typeof (rState === null || rState === void 0 ? void 0 : rState.ended) !== "boolean") return null;
      return rState.ended;
    }
    function isReadableFinished(stream, strict) {
      if (!isReadableNodeStream(stream)) return null;
      const rState = stream._readableState;
      if (rState !== null && rState !== void 0 && rState.errored) return false;
      if (typeof (rState === null || rState === void 0 ? void 0 : rState.endEmitted) !== "boolean") return null;
      return !!(rState.endEmitted || strict === false && rState.ended === true && rState.length === 0);
    }
    function isReadable(stream) {
      if (stream && stream[kIsReadable] != null) return stream[kIsReadable];
      if (typeof (stream === null || stream === void 0 ? void 0 : stream.readable) !== "boolean") return null;
      if (isDestroyed(stream)) return false;
      return isReadableNodeStream(stream) && stream.readable && !isReadableFinished(stream);
    }
    function isWritable(stream) {
      if (stream && stream[kIsWritable] != null) return stream[kIsWritable];
      if (typeof (stream === null || stream === void 0 ? void 0 : stream.writable) !== "boolean") return null;
      if (isDestroyed(stream)) return false;
      return isWritableNodeStream(stream) && stream.writable && !isWritableEnded(stream);
    }
    function isFinished(stream, opts) {
      if (!isNodeStream(stream)) {
        return null;
      }
      if (isDestroyed(stream)) {
        return true;
      }
      if ((opts === null || opts === void 0 ? void 0 : opts.readable) !== false && isReadable(stream)) {
        return false;
      }
      if ((opts === null || opts === void 0 ? void 0 : opts.writable) !== false && isWritable(stream)) {
        return false;
      }
      return true;
    }
    function isWritableErrored(stream) {
      var _stream$_writableStat, _stream$_writableStat2;
      if (!isNodeStream(stream)) {
        return null;
      }
      if (stream.writableErrored) {
        return stream.writableErrored;
      }
      return (_stream$_writableStat = (_stream$_writableStat2 = stream._writableState) === null || _stream$_writableStat2 === void 0 ? void 0 : _stream$_writableStat2.errored) !== null && _stream$_writableStat !== void 0 ? _stream$_writableStat : null;
    }
    function isReadableErrored(stream) {
      var _stream$_readableStat, _stream$_readableStat2;
      if (!isNodeStream(stream)) {
        return null;
      }
      if (stream.readableErrored) {
        return stream.readableErrored;
      }
      return (_stream$_readableStat = (_stream$_readableStat2 = stream._readableState) === null || _stream$_readableStat2 === void 0 ? void 0 : _stream$_readableStat2.errored) !== null && _stream$_readableStat !== void 0 ? _stream$_readableStat : null;
    }
    function isClosed(stream) {
      if (!isNodeStream(stream)) {
        return null;
      }
      if (typeof stream.closed === "boolean") {
        return stream.closed;
      }
      const wState = stream._writableState;
      const rState = stream._readableState;
      if (typeof (wState === null || wState === void 0 ? void 0 : wState.closed) === "boolean" || typeof (rState === null || rState === void 0 ? void 0 : rState.closed) === "boolean") {
        return (wState === null || wState === void 0 ? void 0 : wState.closed) || (rState === null || rState === void 0 ? void 0 : rState.closed);
      }
      if (typeof stream._closed === "boolean" && isOutgoingMessage(stream)) {
        return stream._closed;
      }
      return null;
    }
    function isOutgoingMessage(stream) {
      return typeof stream._closed === "boolean" && typeof stream._defaultKeepAlive === "boolean" && typeof stream._removedConnection === "boolean" && typeof stream._removedContLen === "boolean";
    }
    function isServerResponse(stream) {
      return typeof stream._sent100 === "boolean" && isOutgoingMessage(stream);
    }
    function isServerRequest(stream) {
      var _stream$req;
      return typeof stream._consuming === "boolean" && typeof stream._dumped === "boolean" && ((_stream$req = stream.req) === null || _stream$req === void 0 ? void 0 : _stream$req.upgradeOrConnect) === void 0;
    }
    function willEmitClose(stream) {
      if (!isNodeStream(stream)) return null;
      const wState = stream._writableState;
      const rState = stream._readableState;
      const state = wState || rState;
      return !state && isServerResponse(stream) || !!(state && state.autoDestroy && state.emitClose && state.closed === false);
    }
    function isDisturbed(stream) {
      var _stream$kIsDisturbed;
      return !!(stream && ((_stream$kIsDisturbed = stream[kIsDisturbed]) !== null && _stream$kIsDisturbed !== void 0 ? _stream$kIsDisturbed : stream.readableDidRead || stream.readableAborted));
    }
    function isErrored(stream) {
      var _ref, _ref2, _ref3, _ref4, _ref5, _stream$kIsErrored, _stream$_readableStat3, _stream$_writableStat3, _stream$_readableStat4, _stream$_writableStat4;
      return !!(stream && ((_ref = (_ref2 = (_ref3 = (_ref4 = (_ref5 = (_stream$kIsErrored = stream[kIsErrored]) !== null && _stream$kIsErrored !== void 0 ? _stream$kIsErrored : stream.readableErrored) !== null && _ref5 !== void 0 ? _ref5 : stream.writableErrored) !== null && _ref4 !== void 0 ? _ref4 : (_stream$_readableStat3 = stream._readableState) === null || _stream$_readableStat3 === void 0 ? void 0 : _stream$_readableStat3.errorEmitted) !== null && _ref3 !== void 0 ? _ref3 : (_stream$_writableStat3 = stream._writableState) === null || _stream$_writableStat3 === void 0 ? void 0 : _stream$_writableStat3.errorEmitted) !== null && _ref2 !== void 0 ? _ref2 : (_stream$_readableStat4 = stream._readableState) === null || _stream$_readableStat4 === void 0 ? void 0 : _stream$_readableStat4.errored) !== null && _ref !== void 0 ? _ref : (_stream$_writableStat4 = stream._writableState) === null || _stream$_writableStat4 === void 0 ? void 0 : _stream$_writableStat4.errored));
    }
    module.exports = {
      isDestroyed,
      kIsDestroyed,
      isDisturbed,
      kIsDisturbed,
      isErrored,
      kIsErrored,
      isReadable,
      kIsReadable,
      kIsClosedPromise,
      kControllerErrorFunction,
      kIsWritable,
      isClosed,
      isDuplexNodeStream,
      isFinished,
      isIterable,
      isReadableNodeStream,
      isReadableStream,
      isReadableEnded,
      isReadableFinished,
      isReadableErrored,
      isNodeStream,
      isWebStream,
      isWritable,
      isWritableNodeStream,
      isWritableStream,
      isWritableEnded,
      isWritableFinished,
      isWritableErrored,
      isServerRequest,
      isServerResponse,
      willEmitClose,
      isTransformStream
    };
  }
});

// ../../../../../node_modules/.deno/readable-stream@4.5.2/node_modules/readable-stream/lib/internal/streams/end-of-stream.js
var require_end_of_stream = __commonJS({
  "../../../../../node_modules/.deno/readable-stream@4.5.2/node_modules/readable-stream/lib/internal/streams/end-of-stream.js"(exports, module) {
    var process2 = require_process();
    var { AbortError: AbortError2, codes } = require_errors2();
    var { ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE2, ERR_STREAM_PREMATURE_CLOSE } = codes;
    var { kEmptyObject, once } = require_util();
    var { validateAbortSignal, validateFunction, validateObject, validateBoolean } = require_validators();
    var { Promise: Promise2, PromisePrototypeThen, SymbolDispose } = require_primordials();
    var { isClosed, isReadable, isReadableNodeStream, isReadableStream, isReadableFinished, isReadableErrored, isWritable, isWritableNodeStream, isWritableStream, isWritableFinished, isWritableErrored, isNodeStream, willEmitClose: _willEmitClose, kIsClosedPromise } = require_utils24();
    var addAbortListener;
    function isRequest2(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    var nop = () => {
    };
    function eos(stream, options, callback) {
      var _options$readable, _options$writable;
      if (arguments.length === 2) {
        callback = options;
        options = kEmptyObject;
      } else if (options == null) {
        options = kEmptyObject;
      } else {
        validateObject(options, "options");
      }
      validateFunction(callback, "callback");
      validateAbortSignal(options.signal, "options.signal");
      callback = once(callback);
      if (isReadableStream(stream) || isWritableStream(stream)) {
        return eosWeb(stream, options, callback);
      }
      if (!isNodeStream(stream)) {
        throw new ERR_INVALID_ARG_TYPE2("stream", [
          "ReadableStream",
          "WritableStream",
          "Stream"
        ], stream);
      }
      const readable = (_options$readable = options.readable) !== null && _options$readable !== void 0 ? _options$readable : isReadableNodeStream(stream);
      const writable = (_options$writable = options.writable) !== null && _options$writable !== void 0 ? _options$writable : isWritableNodeStream(stream);
      const wState = stream._writableState;
      const rState = stream._readableState;
      const onlegacyfinish = () => {
        if (!stream.writable) {
          onfinish();
        }
      };
      let willEmitClose = _willEmitClose(stream) && isReadableNodeStream(stream) === readable && isWritableNodeStream(stream) === writable;
      let writableFinished = isWritableFinished(stream, false);
      const onfinish = () => {
        writableFinished = true;
        if (stream.destroyed) {
          willEmitClose = false;
        }
        if (willEmitClose && (!stream.readable || readable)) {
          return;
        }
        if (!readable || readableFinished) {
          callback.call(stream);
        }
      };
      let readableFinished = isReadableFinished(stream, false);
      const onend = () => {
        readableFinished = true;
        if (stream.destroyed) {
          willEmitClose = false;
        }
        if (willEmitClose && (!stream.writable || writable)) {
          return;
        }
        if (!writable || writableFinished) {
          callback.call(stream);
        }
      };
      const onerror = (err) => {
        callback.call(stream, err);
      };
      let closed = isClosed(stream);
      const onclose = () => {
        closed = true;
        const errored = isWritableErrored(stream) || isReadableErrored(stream);
        if (errored && typeof errored !== "boolean") {
          return callback.call(stream, errored);
        }
        if (readable && !readableFinished && isReadableNodeStream(stream, true)) {
          if (!isReadableFinished(stream, false)) return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE());
        }
        if (writable && !writableFinished) {
          if (!isWritableFinished(stream, false)) return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE());
        }
        callback.call(stream);
      };
      const onclosed = () => {
        closed = true;
        const errored = isWritableErrored(stream) || isReadableErrored(stream);
        if (errored && typeof errored !== "boolean") {
          return callback.call(stream, errored);
        }
        callback.call(stream);
      };
      const onrequest = () => {
        stream.req.on("finish", onfinish);
      };
      if (isRequest2(stream)) {
        stream.on("complete", onfinish);
        if (!willEmitClose) {
          stream.on("abort", onclose);
        }
        if (stream.req) {
          onrequest();
        } else {
          stream.on("request", onrequest);
        }
      } else if (writable && !wState) {
        stream.on("end", onlegacyfinish);
        stream.on("close", onlegacyfinish);
      }
      if (!willEmitClose && typeof stream.aborted === "boolean") {
        stream.on("aborted", onclose);
      }
      stream.on("end", onend);
      stream.on("finish", onfinish);
      if (options.error !== false) {
        stream.on("error", onerror);
      }
      stream.on("close", onclose);
      if (closed) {
        process2.nextTick(onclose);
      } else if (wState !== null && wState !== void 0 && wState.errorEmitted || rState !== null && rState !== void 0 && rState.errorEmitted) {
        if (!willEmitClose) {
          process2.nextTick(onclosed);
        }
      } else if (!readable && (!willEmitClose || isReadable(stream)) && (writableFinished || isWritable(stream) === false)) {
        process2.nextTick(onclosed);
      } else if (!writable && (!willEmitClose || isWritable(stream)) && (readableFinished || isReadable(stream) === false)) {
        process2.nextTick(onclosed);
      } else if (rState && stream.req && stream.aborted) {
        process2.nextTick(onclosed);
      }
      const cleanup = () => {
        callback = nop;
        stream.removeListener("aborted", onclose);
        stream.removeListener("complete", onfinish);
        stream.removeListener("abort", onclose);
        stream.removeListener("request", onrequest);
        if (stream.req) stream.req.removeListener("finish", onfinish);
        stream.removeListener("end", onlegacyfinish);
        stream.removeListener("close", onlegacyfinish);
        stream.removeListener("finish", onfinish);
        stream.removeListener("end", onend);
        stream.removeListener("error", onerror);
        stream.removeListener("close", onclose);
      };
      if (options.signal && !closed) {
        const abort = () => {
          const endCallback = callback;
          cleanup();
          endCallback.call(stream, new AbortError2(void 0, {
            cause: options.signal.reason
          }));
        };
        if (options.signal.aborted) {
          process2.nextTick(abort);
        } else {
          addAbortListener = addAbortListener || require_util().addAbortListener;
          const disposable = addAbortListener(options.signal, abort);
          const originalCallback = callback;
          callback = once((...args) => {
            disposable[SymbolDispose]();
            originalCallback.apply(stream, args);
          });
        }
      }
      return cleanup;
    }
    function eosWeb(stream, options, callback) {
      let isAborted = false;
      let abort = nop;
      if (options.signal) {
        abort = () => {
          isAborted = true;
          callback.call(stream, new AbortError2(void 0, {
            cause: options.signal.reason
          }));
        };
        if (options.signal.aborted) {
          process2.nextTick(abort);
        } else {
          addAbortListener = addAbortListener || require_util().addAbortListener;
          const disposable = addAbortListener(options.signal, abort);
          const originalCallback = callback;
          callback = once((...args) => {
            disposable[SymbolDispose]();
            originalCallback.apply(stream, args);
          });
        }
      }
      const resolverFn = (...args) => {
        if (!isAborted) {
          process2.nextTick(() => callback.apply(stream, args));
        }
      };
      PromisePrototypeThen(stream[kIsClosedPromise].promise, resolverFn, resolverFn);
      return nop;
    }
    function finished(stream, opts) {
      var _opts;
      let autoCleanup = false;
      if (opts === null) {
        opts = kEmptyObject;
      }
      if ((_opts = opts) !== null && _opts !== void 0 && _opts.cleanup) {
        validateBoolean(opts.cleanup, "cleanup");
        autoCleanup = opts.cleanup;
      }
      return new Promise2((resolve, reject) => {
        const cleanup = eos(stream, opts, (err) => {
          if (autoCleanup) {
            cleanup();
          }
          if (err) {
            reject(err);
          } else {
            resolve();
          }
        });
      });
    }
    module.exports = eos;
    module.exports.finished = finished;
  }
});

// ../../../../../node_modules/.deno/readable-stream@4.5.2/node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy = __commonJS({
  "../../../../../node_modules/.deno/readable-stream@4.5.2/node_modules/readable-stream/lib/internal/streams/destroy.js"(exports, module) {
    "use strict";
    var process2 = require_process();
    var { aggregateTwoErrors, codes: { ERR_MULTIPLE_CALLBACK }, AbortError: AbortError2 } = require_errors2();
    var { Symbol: Symbol2 } = require_primordials();
    var { kIsDestroyed, isDestroyed, isFinished, isServerRequest } = require_utils24();
    var kDestroy = Symbol2("kDestroy");
    var kConstruct = Symbol2("kConstruct");
    function checkError(err, w, r) {
      if (err) {
        err.stack;
        if (w && !w.errored) {
          w.errored = err;
        }
        if (r && !r.errored) {
          r.errored = err;
        }
      }
    }
    function destroy(err, cb) {
      const r = this._readableState;
      const w = this._writableState;
      const s = w || r;
      if (w !== null && w !== void 0 && w.destroyed || r !== null && r !== void 0 && r.destroyed) {
        if (typeof cb === "function") {
          cb();
        }
        return this;
      }
      checkError(err, w, r);
      if (w) {
        w.destroyed = true;
      }
      if (r) {
        r.destroyed = true;
      }
      if (!s.constructed) {
        this.once(kDestroy, function(er) {
          _destroy(this, aggregateTwoErrors(er, err), cb);
        });
      } else {
        _destroy(this, err, cb);
      }
      return this;
    }
    function _destroy(self2, err, cb) {
      let called = false;
      function onDestroy(err2) {
        if (called) {
          return;
        }
        called = true;
        const r = self2._readableState;
        const w = self2._writableState;
        checkError(err2, w, r);
        if (w) {
          w.closed = true;
        }
        if (r) {
          r.closed = true;
        }
        if (typeof cb === "function") {
          cb(err2);
        }
        if (err2) {
          process2.nextTick(emitErrorCloseNT, self2, err2);
        } else {
          process2.nextTick(emitCloseNT, self2);
        }
      }
      try {
        self2._destroy(err || null, onDestroy);
      } catch (err2) {
        onDestroy(err2);
      }
    }
    function emitErrorCloseNT(self2, err) {
      emitErrorNT(self2, err);
      emitCloseNT(self2);
    }
    function emitCloseNT(self2) {
      const r = self2._readableState;
      const w = self2._writableState;
      if (w) {
        w.closeEmitted = true;
      }
      if (r) {
        r.closeEmitted = true;
      }
      if (w !== null && w !== void 0 && w.emitClose || r !== null && r !== void 0 && r.emitClose) {
        self2.emit("close");
      }
    }
    function emitErrorNT(self2, err) {
      const r = self2._readableState;
      const w = self2._writableState;
      if (w !== null && w !== void 0 && w.errorEmitted || r !== null && r !== void 0 && r.errorEmitted) {
        return;
      }
      if (w) {
        w.errorEmitted = true;
      }
      if (r) {
        r.errorEmitted = true;
      }
      self2.emit("error", err);
    }
    function undestroy() {
      const r = this._readableState;
      const w = this._writableState;
      if (r) {
        r.constructed = true;
        r.closed = false;
        r.closeEmitted = false;
        r.destroyed = false;
        r.errored = null;
        r.errorEmitted = false;
        r.reading = false;
        r.ended = r.readable === false;
        r.endEmitted = r.readable === false;
      }
      if (w) {
        w.constructed = true;
        w.destroyed = false;
        w.closed = false;
        w.closeEmitted = false;
        w.errored = null;
        w.errorEmitted = false;
        w.finalCalled = false;
        w.prefinished = false;
        w.ended = w.writable === false;
        w.ending = w.writable === false;
        w.finished = w.writable === false;
      }
    }
    function errorOrDestroy(stream, err, sync) {
      const r = stream._readableState;
      const w = stream._writableState;
      if (w !== null && w !== void 0 && w.destroyed || r !== null && r !== void 0 && r.destroyed) {
        return this;
      }
      if (r !== null && r !== void 0 && r.autoDestroy || w !== null && w !== void 0 && w.autoDestroy) stream.destroy(err);
      else if (err) {
        err.stack;
        if (w && !w.errored) {
          w.errored = err;
        }
        if (r && !r.errored) {
          r.errored = err;
        }
        if (sync) {
          process2.nextTick(emitErrorNT, stream, err);
        } else {
          emitErrorNT(stream, err);
        }
      }
    }
    function construct(stream, cb) {
      if (typeof stream._construct !== "function") {
        return;
      }
      const r = stream._readableState;
      const w = stream._writableState;
      if (r) {
        r.constructed = false;
      }
      if (w) {
        w.constructed = false;
      }
      stream.once(kConstruct, cb);
      if (stream.listenerCount(kConstruct) > 1) {
        return;
      }
      process2.nextTick(constructNT, stream);
    }
    function constructNT(stream) {
      let called = false;
      function onConstruct(err) {
        if (called) {
          errorOrDestroy(stream, err !== null && err !== void 0 ? err : new ERR_MULTIPLE_CALLBACK());
          return;
        }
        called = true;
        const r = stream._readableState;
        const w = stream._writableState;
        const s = w || r;
        if (r) {
          r.constructed = true;
        }
        if (w) {
          w.constructed = true;
        }
        if (s.destroyed) {
          stream.emit(kDestroy, err);
        } else if (err) {
          errorOrDestroy(stream, err, true);
        } else {
          process2.nextTick(emitConstructNT, stream);
        }
      }
      try {
        stream._construct((err) => {
          process2.nextTick(onConstruct, err);
        });
      } catch (err) {
        process2.nextTick(onConstruct, err);
      }
    }
    function emitConstructNT(stream) {
      stream.emit(kConstruct);
    }
    function isRequest2(stream) {
      return (stream === null || stream === void 0 ? void 0 : stream.setHeader) && typeof stream.abort === "function";
    }
    function emitCloseLegacy(stream) {
      stream.emit("close");
    }
    function emitErrorCloseLegacy(stream, err) {
      stream.emit("error", err);
      process2.nextTick(emitCloseLegacy, stream);
    }
    function destroyer(stream, err) {
      if (!stream || isDestroyed(stream)) {
        return;
      }
      if (!err && !isFinished(stream)) {
        err = new AbortError2();
      }
      if (isServerRequest(stream)) {
        stream.socket = null;
        stream.destroy(err);
      } else if (isRequest2(stream)) {
        stream.abort();
      } else if (isRequest2(stream.req)) {
        stream.req.abort();
      } else if (typeof stream.destroy === "function") {
        stream.destroy(err);
      } else if (typeof stream.close === "function") {
        stream.close();
      } else if (err) {
        process2.nextTick(emitErrorCloseLegacy, stream, err);
      } else {
        process2.nextTick(emitCloseLegacy, stream);
      }
      if (!stream.destroyed) {
        stream[kIsDestroyed] = true;
      }
    }
    module.exports = {
      construct,
      destroyer,
      destroy,
      undestroy,
      errorOrDestroy
    };
  }
});

// ../../../../../node_modules/.deno/readable-stream@4.5.2/node_modules/readable-stream/lib/internal/streams/legacy.js
var require_legacy = __commonJS({
  "../../../../../node_modules/.deno/readable-stream@4.5.2/node_modules/readable-stream/lib/internal/streams/legacy.js"(exports, module) {
    "use strict";
    var { ArrayIsArray, ObjectSetPrototypeOf } = require_primordials();
    var { EventEmitter: EE } = __require("node:events");
    function Stream2(opts) {
      EE.call(this, opts);
    }
    ObjectSetPrototypeOf(Stream2.prototype, EE.prototype);
    ObjectSetPrototypeOf(Stream2, EE);
    Stream2.prototype.pipe = function(dest, options) {
      const source = this;
      function ondata(chunk) {
        if (dest.writable && dest.write(chunk) === false && source.pause) {
          source.pause();
        }
      }
      source.on("data", ondata);
      function ondrain() {
        if (source.readable && source.resume) {
          source.resume();
        }
      }
      dest.on("drain", ondrain);
      if (!dest._isStdio && (!options || options.end !== false)) {
        source.on("end", onend);
        source.on("close", onclose);
      }
      let didOnEnd = false;
      function onend() {
        if (didOnEnd) return;
        didOnEnd = true;
        dest.end();
      }
      function onclose() {
        if (didOnEnd) return;
        didOnEnd = true;
        if (typeof dest.destroy === "function") dest.destroy();
      }
      function onerror(er) {
        cleanup();
        if (EE.listenerCount(this, "error") === 0) {
          this.emit("error", er);
        }
      }
      prependListener(source, "error", onerror);
      prependListener(dest, "error", onerror);
      function cleanup() {
        source.removeListener("data", ondata);
        dest.removeListener("drain", ondrain);
        source.removeListener("end", onend);
        source.removeListener("close", onclose);
        source.removeListener("error", onerror);
        dest.removeListener("error", onerror);
        source.removeListener("end", cleanup);
        source.removeListener("close", cleanup);
        dest.removeListener("close", cleanup);
      }
      source.on("end", cleanup);
      source.on("close", cleanup);
      dest.on("close", cleanup);
      dest.emit("pipe", source);
      return dest;
    };
    function prependListener(emitter, event, fn) {
      if (typeof emitter.prependListener === "function") return emitter.prependListener(event, fn);
      if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);
      else if (ArrayIsArray(emitter._events[event])) emitter._events[event].unshift(fn);
      else emitter._events[event] = [
        fn,
        emitter._events[event]
      ];
    }
    module.exports = {
      Stream: Stream2,
      prependListener
    };
  }
});

// ../../../../../node_modules/.deno/readable-stream@4.5.2/node_modules/readable-stream/lib/internal/streams/add-abort-signal.js
var require_add_abort_signal = __commonJS({
  "../../../../../node_modules/.deno/readable-stream@4.5.2/node_modules/readable-stream/lib/internal/streams/add-abort-signal.js"(exports, module) {
    "use strict";
    var { SymbolDispose } = require_primordials();
    var { AbortError: AbortError2, codes } = require_errors2();
    var { isNodeStream, isWebStream, kControllerErrorFunction } = require_utils24();
    var eos = require_end_of_stream();
    var { ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE2 } = codes;
    var addAbortListener;
    var validateAbortSignal = (signal, name) => {
      if (typeof signal !== "object" || !("aborted" in signal)) {
        throw new ERR_INVALID_ARG_TYPE2(name, "AbortSignal", signal);
      }
    };
    module.exports.addAbortSignal = function addAbortSignal(signal, stream) {
      validateAbortSignal(signal, "signal");
      if (!isNodeStream(stream) && !isWebStream(stream)) {
        throw new ERR_INVALID_ARG_TYPE2("stream", [
          "ReadableStream",
          "WritableStream",
          "Stream"
        ], stream);
      }
      return module.exports.addAbortSignalNoValidate(signal, stream);
    };
    module.exports.addAbortSignalNoValidate = function(signal, stream) {
      if (typeof signal !== "object" || !("aborted" in signal)) {
        return stream;
      }
      const onAbort = isNodeStream(stream) ? () => {
        stream.destroy(new AbortError2(void 0, {
          cause: signal.reason
        }));
      } : () => {
        stream[kControllerErrorFunction](new AbortError2(void 0, {
          cause: signal.reason
        }));
      };
      if (signal.aborted) {
        onAbort();
      } else {
        addAbortListener = addAbortListener || require_util().addAbortListener;
        const disposable = addAbortListener(signal, onAbort);
        eos(stream, disposable[SymbolDispose]);
      }
      return stream;
    };
  }
});

// ../../../../../node_modules/.deno/readable-stream@4.5.2/node_modules/readable-stream/lib/internal/streams/buffer_list.js
var require_buffer_list = __commonJS({
  "../../../../../node_modules/.deno/readable-stream@4.5.2/node_modules/readable-stream/lib/internal/streams/buffer_list.js"(exports, module) {
    "use strict";
    var { StringPrototypeSlice, SymbolIterator, TypedArrayPrototypeSet, Uint8Array: Uint8Array2 } = require_primordials();
    var { Buffer: Buffer2 } = __require("node:buffer");
    var { inspect } = require_util();
    module.exports = class BufferList {
      constructor() {
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      push(v) {
        const entry = {
          data: v,
          next: null
        };
        if (this.length > 0) this.tail.next = entry;
        else this.head = entry;
        this.tail = entry;
        ++this.length;
      }
      unshift(v) {
        const entry = {
          data: v,
          next: this.head
        };
        if (this.length === 0) this.tail = entry;
        this.head = entry;
        ++this.length;
      }
      shift() {
        if (this.length === 0) return;
        const ret = this.head.data;
        if (this.length === 1) this.head = this.tail = null;
        else this.head = this.head.next;
        --this.length;
        return ret;
      }
      clear() {
        this.head = this.tail = null;
        this.length = 0;
      }
      join(s) {
        if (this.length === 0) return "";
        let p = this.head;
        let ret = "" + p.data;
        while ((p = p.next) !== null) ret += s + p.data;
        return ret;
      }
      concat(n) {
        if (this.length === 0) return Buffer2.alloc(0);
        const ret = Buffer2.allocUnsafe(n >>> 0);
        let p = this.head;
        let i2 = 0;
        while (p) {
          TypedArrayPrototypeSet(ret, p.data, i2);
          i2 += p.data.length;
          p = p.next;
        }
        return ret;
      }
      // Consumes a specified amount of bytes or characters from the buffered data.
      consume(n, hasStrings) {
        const data = this.head.data;
        if (n < data.length) {
          const slice = data.slice(0, n);
          this.head.data = data.slice(n);
          return slice;
        }
        if (n === data.length) {
          return this.shift();
        }
        return hasStrings ? this._getString(n) : this._getBuffer(n);
      }
      first() {
        return this.head.data;
      }
      *[SymbolIterator]() {
        for (let p = this.head; p; p = p.next) {
          yield p.data;
        }
      }
      // Consumes a specified amount of characters from the buffered data.
      _getString(n) {
        let ret = "";
        let p = this.head;
        let c = 0;
        do {
          const str = p.data;
          if (n > str.length) {
            ret += str;
            n -= str.length;
          } else {
            if (n === str.length) {
              ret += str;
              ++c;
              if (p.next) this.head = p.next;
              else this.head = this.tail = null;
            } else {
              ret += StringPrototypeSlice(str, 0, n);
              this.head = p;
              p.data = StringPrototypeSlice(str, n);
            }
            break;
          }
          ++c;
        } while ((p = p.next) !== null);
        this.length -= c;
        return ret;
      }
      // Consumes a specified amount of bytes from the buffered data.
      _getBuffer(n) {
        const ret = Buffer2.allocUnsafe(n);
        const retLen = n;
        let p = this.head;
        let c = 0;
        do {
          const buf = p.data;
          if (n > buf.length) {
            TypedArrayPrototypeSet(ret, buf, retLen - n);
            n -= buf.length;
          } else {
            if (n === buf.length) {
              TypedArrayPrototypeSet(ret, buf, retLen - n);
              ++c;
              if (p.next) this.head = p.next;
              else this.head = this.tail = null;
            } else {
              TypedArrayPrototypeSet(ret, new Uint8Array2(buf.buffer, buf.byteOffset, n), retLen - n);
              this.head = p;
              p.data = buf.slice(n);
            }
            break;
          }
          ++c;
        } while ((p = p.next) !== null);
        this.length -= c;
        return ret;
      }
      // Make sure the linked list only shows the minimal necessary information.
      [Symbol.for("nodejs.util.inspect.custom")](_, options) {
        return inspect(this, {
          ...options,
          // Only inspect one level.
          depth: 0,
          // It should not recurse.
          customInspect: false
        });
      }
    };
  }
});

// ../../../../../node_modules/.deno/readable-stream@4.5.2/node_modules/readable-stream/lib/internal/streams/state.js
var require_state = __commonJS({
  "../../../../../node_modules/.deno/readable-stream@4.5.2/node_modules/readable-stream/lib/internal/streams/state.js"(exports, module) {
    "use strict";
    var { MathFloor, NumberIsInteger } = require_primordials();
    var { validateInteger } = require_validators();
    var { ERR_INVALID_ARG_VALUE } = require_errors2().codes;
    var defaultHighWaterMarkBytes = 16 * 1024;
    var defaultHighWaterMarkObjectMode = 16;
    function highWaterMarkFrom(options, isDuplex, duplexKey) {
      return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
    }
    function getDefaultHighWaterMark(objectMode) {
      return objectMode ? defaultHighWaterMarkObjectMode : defaultHighWaterMarkBytes;
    }
    function setDefaultHighWaterMark(objectMode, value) {
      validateInteger(value, "value", 0);
      if (objectMode) {
        defaultHighWaterMarkObjectMode = value;
      } else {
        defaultHighWaterMarkBytes = value;
      }
    }
    function getHighWaterMark(state, options, duplexKey, isDuplex) {
      const hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
      if (hwm != null) {
        if (!NumberIsInteger(hwm) || hwm < 0) {
          const name = isDuplex ? `options.${duplexKey}` : "options.highWaterMark";
          throw new ERR_INVALID_ARG_VALUE(name, hwm);
        }
        return MathFloor(hwm);
      }
      return getDefaultHighWaterMark(state.objectMode);
    }
    module.exports = {
      getHighWaterMark,
      getDefaultHighWaterMark,
      setDefaultHighWaterMark
    };
  }
});

// ../../../../../node_modules/.deno/readable-stream@4.5.2/node_modules/readable-stream/lib/internal/streams/from.js
var require_from = __commonJS({
  "../../../../../node_modules/.deno/readable-stream@4.5.2/node_modules/readable-stream/lib/internal/streams/from.js"(exports, module) {
    "use strict";
    var process2 = require_process();
    var { PromisePrototypeThen, SymbolAsyncIterator, SymbolIterator } = require_primordials();
    var { Buffer: Buffer2 } = __require("node:buffer");
    var { ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE2, ERR_STREAM_NULL_VALUES } = require_errors2().codes;
    function from(Readable2, iterable, opts) {
      let iterator;
      if (typeof iterable === "string" || iterable instanceof Buffer2) {
        return new Readable2({
          objectMode: true,
          ...opts,
          read() {
            this.push(iterable);
            this.push(null);
          }
        });
      }
      let isAsync;
      if (iterable && iterable[SymbolAsyncIterator]) {
        isAsync = true;
        iterator = iterable[SymbolAsyncIterator]();
      } else if (iterable && iterable[SymbolIterator]) {
        isAsync = false;
        iterator = iterable[SymbolIterator]();
      } else {
        throw new ERR_INVALID_ARG_TYPE2("iterable", [
          "Iterable"
        ], iterable);
      }
      const readable = new Readable2({
        objectMode: true,
        highWaterMark: 1,
        // TODO(ronag): What options should be allowed?
        ...opts
      });
      let reading = false;
      readable._read = function() {
        if (!reading) {
          reading = true;
          next();
        }
      };
      readable._destroy = function(error, cb) {
        PromisePrototypeThen(
          close(error),
          () => process2.nextTick(cb, error),
          // nextTick is here in case cb throws
          (e) => process2.nextTick(cb, e || error)
        );
      };
      async function close(error) {
        const hadError = error !== void 0 && error !== null;
        const hasThrow = typeof iterator.throw === "function";
        if (hadError && hasThrow) {
          const { value, done } = await iterator.throw(error);
          await value;
          if (done) {
            return;
          }
        }
        if (typeof iterator.return === "function") {
          const { value } = await iterator.return();
          await value;
        }
      }
      async function next() {
        for (; ; ) {
          try {
            const { value, done } = isAsync ? await iterator.next() : iterator.next();
            if (done) {
              readable.push(null);
            } else {
              const res = value && typeof value.then === "function" ? await value : value;
              if (res === null) {
                reading = false;
                throw new ERR_STREAM_NULL_VALUES();
              } else if (readable.push(res)) {
                continue;
              } else {
                reading = false;
              }
            }
          } catch (err) {
            readable.destroy(err);
          }
          break;
        }
      }
      return readable;
    }
    module.exports = from;
  }
});

// ../../../../../node_modules/.deno/readable-stream@4.5.2/node_modules/readable-stream/lib/internal/streams/readable.js
var require_readable = __commonJS({
  "../../../../../node_modules/.deno/readable-stream@4.5.2/node_modules/readable-stream/lib/internal/streams/readable.js"(exports, module) {
    var process2 = require_process();
    var { ArrayPrototypeIndexOf, NumberIsInteger, NumberIsNaN, NumberParseInt, ObjectDefineProperties, ObjectKeys, ObjectSetPrototypeOf, Promise: Promise2, SafeSet, SymbolAsyncDispose, SymbolAsyncIterator, Symbol: Symbol2 } = require_primordials();
    module.exports = Readable2;
    Readable2.ReadableState = ReadableState;
    var { EventEmitter: EE } = __require("node:events");
    var { Stream: Stream2, prependListener } = require_legacy();
    var { Buffer: Buffer2 } = __require("node:buffer");
    var { addAbortSignal } = require_add_abort_signal();
    var eos = require_end_of_stream();
    var debug = require_util().debuglog("stream", (fn) => {
      debug = fn;
    });
    var BufferList = require_buffer_list();
    var destroyImpl = require_destroy();
    var { getHighWaterMark, getDefaultHighWaterMark } = require_state();
    var { aggregateTwoErrors, codes: { ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE2, ERR_METHOD_NOT_IMPLEMENTED, ERR_OUT_OF_RANGE, ERR_STREAM_PUSH_AFTER_EOF, ERR_STREAM_UNSHIFT_AFTER_END_EVENT }, AbortError: AbortError2 } = require_errors2();
    var { validateObject } = require_validators();
    var kPaused = Symbol2("kPaused");
    var { StringDecoder } = __require("node:string_decoder");
    var from = require_from();
    ObjectSetPrototypeOf(Readable2.prototype, Stream2.prototype);
    ObjectSetPrototypeOf(Readable2, Stream2);
    var nop = () => {
    };
    var { errorOrDestroy } = destroyImpl;
    var kObjectMode = 1 << 0;
    var kEnded = 1 << 1;
    var kEndEmitted = 1 << 2;
    var kReading = 1 << 3;
    var kConstructed = 1 << 4;
    var kSync = 1 << 5;
    var kNeedReadable = 1 << 6;
    var kEmittedReadable = 1 << 7;
    var kReadableListening = 1 << 8;
    var kResumeScheduled = 1 << 9;
    var kErrorEmitted = 1 << 10;
    var kEmitClose = 1 << 11;
    var kAutoDestroy = 1 << 12;
    var kDestroyed = 1 << 13;
    var kClosed = 1 << 14;
    var kCloseEmitted = 1 << 15;
    var kMultiAwaitDrain = 1 << 16;
    var kReadingMore = 1 << 17;
    var kDataEmitted = 1 << 18;
    function makeBitMapDescriptor(bit) {
      return {
        enumerable: false,
        get() {
          return (this.state & bit) !== 0;
        },
        set(value) {
          if (value) this.state |= bit;
          else this.state &= ~bit;
        }
      };
    }
    ObjectDefineProperties(ReadableState.prototype, {
      objectMode: makeBitMapDescriptor(kObjectMode),
      ended: makeBitMapDescriptor(kEnded),
      endEmitted: makeBitMapDescriptor(kEndEmitted),
      reading: makeBitMapDescriptor(kReading),
      // Stream is still being constructed and cannot be
      // destroyed until construction finished or failed.
      // Async construction is opt in, therefore we start as
      // constructed.
      constructed: makeBitMapDescriptor(kConstructed),
      // A flag to be able to tell if the event 'readable'/'data' is emitted
      // immediately, or on a later tick.  We set this to true at first, because
      // any actions that shouldn't happen until "later" should generally also
      // not happen before the first read call.
      sync: makeBitMapDescriptor(kSync),
      // Whenever we return null, then we set a flag to say
      // that we're awaiting a 'readable' event emission.
      needReadable: makeBitMapDescriptor(kNeedReadable),
      emittedReadable: makeBitMapDescriptor(kEmittedReadable),
      readableListening: makeBitMapDescriptor(kReadableListening),
      resumeScheduled: makeBitMapDescriptor(kResumeScheduled),
      // True if the error was already emitted and should not be thrown again.
      errorEmitted: makeBitMapDescriptor(kErrorEmitted),
      emitClose: makeBitMapDescriptor(kEmitClose),
      autoDestroy: makeBitMapDescriptor(kAutoDestroy),
      // Has it been destroyed.
      destroyed: makeBitMapDescriptor(kDestroyed),
      // Indicates whether the stream has finished destroying.
      closed: makeBitMapDescriptor(kClosed),
      // True if close has been emitted or would have been emitted
      // depending on emitClose.
      closeEmitted: makeBitMapDescriptor(kCloseEmitted),
      multiAwaitDrain: makeBitMapDescriptor(kMultiAwaitDrain),
      // If true, a maybeReadMore has been scheduled.
      readingMore: makeBitMapDescriptor(kReadingMore),
      dataEmitted: makeBitMapDescriptor(kDataEmitted)
    });
    function ReadableState(options, stream, isDuplex) {
      if (typeof isDuplex !== "boolean") isDuplex = stream instanceof require_duplex();
      this.state = kEmitClose | kAutoDestroy | kConstructed | kSync;
      if (options && options.objectMode) this.state |= kObjectMode;
      if (isDuplex && options && options.readableObjectMode) this.state |= kObjectMode;
      this.highWaterMark = options ? getHighWaterMark(this, options, "readableHighWaterMark", isDuplex) : getDefaultHighWaterMark(false);
      this.buffer = new BufferList();
      this.length = 0;
      this.pipes = [];
      this.flowing = null;
      this[kPaused] = null;
      if (options && options.emitClose === false) this.state &= ~kEmitClose;
      if (options && options.autoDestroy === false) this.state &= ~kAutoDestroy;
      this.errored = null;
      this.defaultEncoding = options && options.defaultEncoding || "utf8";
      this.awaitDrainWriters = null;
      this.decoder = null;
      this.encoding = null;
      if (options && options.encoding) {
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
      }
    }
    function Readable2(options) {
      if (!(this instanceof Readable2)) return new Readable2(options);
      const isDuplex = this instanceof require_duplex();
      this._readableState = new ReadableState(options, this, isDuplex);
      if (options) {
        if (typeof options.read === "function") this._read = options.read;
        if (typeof options.destroy === "function") this._destroy = options.destroy;
        if (typeof options.construct === "function") this._construct = options.construct;
        if (options.signal && !isDuplex) addAbortSignal(options.signal, this);
      }
      Stream2.call(this, options);
      destroyImpl.construct(this, () => {
        if (this._readableState.needReadable) {
          maybeReadMore(this, this._readableState);
        }
      });
    }
    Readable2.prototype.destroy = destroyImpl.destroy;
    Readable2.prototype._undestroy = destroyImpl.undestroy;
    Readable2.prototype._destroy = function(err, cb) {
      cb(err);
    };
    Readable2.prototype[EE.captureRejectionSymbol] = function(err) {
      this.destroy(err);
    };
    Readable2.prototype[SymbolAsyncDispose] = function() {
      let error;
      if (!this.destroyed) {
        error = this.readableEnded ? null : new AbortError2();
        this.destroy(error);
      }
      return new Promise2((resolve, reject) => eos(this, (err) => err && err !== error ? reject(err) : resolve(null)));
    };
    Readable2.prototype.push = function(chunk, encoding) {
      return readableAddChunk(this, chunk, encoding, false);
    };
    Readable2.prototype.unshift = function(chunk, encoding) {
      return readableAddChunk(this, chunk, encoding, true);
    };
    function readableAddChunk(stream, chunk, encoding, addToFront) {
      debug("readableAddChunk", chunk);
      const state = stream._readableState;
      let err;
      if ((state.state & kObjectMode) === 0) {
        if (typeof chunk === "string") {
          encoding = encoding || state.defaultEncoding;
          if (state.encoding !== encoding) {
            if (addToFront && state.encoding) {
              chunk = Buffer2.from(chunk, encoding).toString(state.encoding);
            } else {
              chunk = Buffer2.from(chunk, encoding);
              encoding = "";
            }
          }
        } else if (chunk instanceof Buffer2) {
          encoding = "";
        } else if (Stream2._isUint8Array(chunk)) {
          chunk = Stream2._uint8ArrayToBuffer(chunk);
          encoding = "";
        } else if (chunk != null) {
          err = new ERR_INVALID_ARG_TYPE2("chunk", [
            "string",
            "Buffer",
            "Uint8Array"
          ], chunk);
        }
      }
      if (err) {
        errorOrDestroy(stream, err);
      } else if (chunk === null) {
        state.state &= ~kReading;
        onEofChunk(stream, state);
      } else if ((state.state & kObjectMode) !== 0 || chunk && chunk.length > 0) {
        if (addToFront) {
          if ((state.state & kEndEmitted) !== 0) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
          else if (state.destroyed || state.errored) return false;
          else addChunk(stream, state, chunk, true);
        } else if (state.ended) {
          errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
        } else if (state.destroyed || state.errored) {
          return false;
        } else {
          state.state &= ~kReading;
          if (state.decoder && !encoding) {
            chunk = state.decoder.write(chunk);
            if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);
            else maybeReadMore(stream, state);
          } else {
            addChunk(stream, state, chunk, false);
          }
        }
      } else if (!addToFront) {
        state.state &= ~kReading;
        maybeReadMore(stream, state);
      }
      return !state.ended && (state.length < state.highWaterMark || state.length === 0);
    }
    function addChunk(stream, state, chunk, addToFront) {
      if (state.flowing && state.length === 0 && !state.sync && stream.listenerCount("data") > 0) {
        if ((state.state & kMultiAwaitDrain) !== 0) {
          state.awaitDrainWriters.clear();
        } else {
          state.awaitDrainWriters = null;
        }
        state.dataEmitted = true;
        stream.emit("data", chunk);
      } else {
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront) state.buffer.unshift(chunk);
        else state.buffer.push(chunk);
        if ((state.state & kNeedReadable) !== 0) emitReadable(stream);
      }
      maybeReadMore(stream, state);
    }
    Readable2.prototype.isPaused = function() {
      const state = this._readableState;
      return state[kPaused] === true || state.flowing === false;
    };
    Readable2.prototype.setEncoding = function(enc) {
      const decoder = new StringDecoder(enc);
      this._readableState.decoder = decoder;
      this._readableState.encoding = this._readableState.decoder.encoding;
      const buffer = this._readableState.buffer;
      let content = "";
      for (const data of buffer) {
        content += decoder.write(data);
      }
      buffer.clear();
      if (content !== "") buffer.push(content);
      this._readableState.length = content.length;
      return this;
    };
    var MAX_HWM = 1073741824;
    function computeNewHighWaterMark(n) {
      if (n > MAX_HWM) {
        throw new ERR_OUT_OF_RANGE("size", "<= 1GiB", n);
      } else {
        n--;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        n++;
      }
      return n;
    }
    function howMuchToRead(n, state) {
      if (n <= 0 || state.length === 0 && state.ended) return 0;
      if ((state.state & kObjectMode) !== 0) return 1;
      if (NumberIsNaN(n)) {
        if (state.flowing && state.length) return state.buffer.first().length;
        return state.length;
      }
      if (n <= state.length) return n;
      return state.ended ? state.length : 0;
    }
    Readable2.prototype.read = function(n) {
      debug("read", n);
      if (n === void 0) {
        n = NaN;
      } else if (!NumberIsInteger(n)) {
        n = NumberParseInt(n, 10);
      }
      const state = this._readableState;
      const nOrig = n;
      if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
      if (n !== 0) state.state &= ~kEmittedReadable;
      if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
        debug("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended) endReadable(this);
        else emitReadable(this);
        return null;
      }
      n = howMuchToRead(n, state);
      if (n === 0 && state.ended) {
        if (state.length === 0) endReadable(this);
        return null;
      }
      let doRead = (state.state & kNeedReadable) !== 0;
      debug("need readable", doRead);
      if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
      }
      if (state.ended || state.reading || state.destroyed || state.errored || !state.constructed) {
        doRead = false;
        debug("reading, ended or constructing", doRead);
      } else if (doRead) {
        debug("do read");
        state.state |= kReading | kSync;
        if (state.length === 0) state.state |= kNeedReadable;
        try {
          this._read(state.highWaterMark);
        } catch (err) {
          errorOrDestroy(this, err);
        }
        state.state &= ~kSync;
        if (!state.reading) n = howMuchToRead(nOrig, state);
      }
      let ret;
      if (n > 0) ret = fromList(n, state);
      else ret = null;
      if (ret === null) {
        state.needReadable = state.length <= state.highWaterMark;
        n = 0;
      } else {
        state.length -= n;
        if (state.multiAwaitDrain) {
          state.awaitDrainWriters.clear();
        } else {
          state.awaitDrainWriters = null;
        }
      }
      if (state.length === 0) {
        if (!state.ended) state.needReadable = true;
        if (nOrig !== n && state.ended) endReadable(this);
      }
      if (ret !== null && !state.errorEmitted && !state.closeEmitted) {
        state.dataEmitted = true;
        this.emit("data", ret);
      }
      return ret;
    };
    function onEofChunk(stream, state) {
      debug("onEofChunk");
      if (state.ended) return;
      if (state.decoder) {
        const chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
      if (state.sync) {
        emitReadable(stream);
      } else {
        state.needReadable = false;
        state.emittedReadable = true;
        emitReadable_(stream);
      }
    }
    function emitReadable(stream) {
      const state = stream._readableState;
      debug("emitReadable", state.needReadable, state.emittedReadable);
      state.needReadable = false;
      if (!state.emittedReadable) {
        debug("emitReadable", state.flowing);
        state.emittedReadable = true;
        process2.nextTick(emitReadable_, stream);
      }
    }
    function emitReadable_(stream) {
      const state = stream._readableState;
      debug("emitReadable_", state.destroyed, state.length, state.ended);
      if (!state.destroyed && !state.errored && (state.length || state.ended)) {
        stream.emit("readable");
        state.emittedReadable = false;
      }
      state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
      flow(stream);
    }
    function maybeReadMore(stream, state) {
      if (!state.readingMore && state.constructed) {
        state.readingMore = true;
        process2.nextTick(maybeReadMore_, stream, state);
      }
    }
    function maybeReadMore_(stream, state) {
      while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
        const len = state.length;
        debug("maybeReadMore read 0");
        stream.read(0);
        if (len === state.length) break;
      }
      state.readingMore = false;
    }
    Readable2.prototype._read = function(n) {
      throw new ERR_METHOD_NOT_IMPLEMENTED("_read()");
    };
    Readable2.prototype.pipe = function(dest, pipeOpts) {
      const src = this;
      const state = this._readableState;
      if (state.pipes.length === 1) {
        if (!state.multiAwaitDrain) {
          state.multiAwaitDrain = true;
          state.awaitDrainWriters = new SafeSet(state.awaitDrainWriters ? [
            state.awaitDrainWriters
          ] : []);
        }
      }
      state.pipes.push(dest);
      debug("pipe count=%d opts=%j", state.pipes.length, pipeOpts);
      const doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process2.stdout && dest !== process2.stderr;
      const endFn = doEnd ? onend : unpipe;
      if (state.endEmitted) process2.nextTick(endFn);
      else src.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable, unpipeInfo) {
        debug("onunpipe");
        if (readable === src) {
          if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
            unpipeInfo.hasUnpiped = true;
            cleanup();
          }
        }
      }
      function onend() {
        debug("onend");
        dest.end();
      }
      let ondrain;
      let cleanedUp = false;
      function cleanup() {
        debug("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        if (ondrain) {
          dest.removeListener("drain", ondrain);
        }
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend);
        src.removeListener("end", unpipe);
        src.removeListener("data", ondata);
        cleanedUp = true;
        if (ondrain && state.awaitDrainWriters && (!dest._writableState || dest._writableState.needDrain)) ondrain();
      }
      function pause() {
        if (!cleanedUp) {
          if (state.pipes.length === 1 && state.pipes[0] === dest) {
            debug("false write response, pause", 0);
            state.awaitDrainWriters = dest;
            state.multiAwaitDrain = false;
          } else if (state.pipes.length > 1 && state.pipes.includes(dest)) {
            debug("false write response, pause", state.awaitDrainWriters.size);
            state.awaitDrainWriters.add(dest);
          }
          src.pause();
        }
        if (!ondrain) {
          ondrain = pipeOnDrain(src, dest);
          dest.on("drain", ondrain);
        }
      }
      src.on("data", ondata);
      function ondata(chunk) {
        debug("ondata");
        const ret = dest.write(chunk);
        debug("dest.write", ret);
        if (ret === false) {
          pause();
        }
      }
      function onerror(er) {
        debug("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (dest.listenerCount("error") === 0) {
          const s = dest._writableState || dest._readableState;
          if (s && !s.errorEmitted) {
            errorOrDestroy(dest, er);
          } else {
            dest.emit("error", er);
          }
        }
      }
      prependListener(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug("unpipe");
        src.unpipe(dest);
      }
      dest.emit("pipe", src);
      if (dest.writableNeedDrain === true) {
        pause();
      } else if (!state.flowing) {
        debug("pipe resume");
        src.resume();
      }
      return dest;
    };
    function pipeOnDrain(src, dest) {
      return function pipeOnDrainFunctionResult() {
        const state = src._readableState;
        if (state.awaitDrainWriters === dest) {
          debug("pipeOnDrain", 1);
          state.awaitDrainWriters = null;
        } else if (state.multiAwaitDrain) {
          debug("pipeOnDrain", state.awaitDrainWriters.size);
          state.awaitDrainWriters.delete(dest);
        }
        if ((!state.awaitDrainWriters || state.awaitDrainWriters.size === 0) && src.listenerCount("data")) {
          src.resume();
        }
      };
    }
    Readable2.prototype.unpipe = function(dest) {
      const state = this._readableState;
      const unpipeInfo = {
        hasUnpiped: false
      };
      if (state.pipes.length === 0) return this;
      if (!dest) {
        const dests = state.pipes;
        state.pipes = [];
        this.pause();
        for (let i2 = 0; i2 < dests.length; i2++) dests[i2].emit("unpipe", this, {
          hasUnpiped: false
        });
        return this;
      }
      const index = ArrayPrototypeIndexOf(state.pipes, dest);
      if (index === -1) return this;
      state.pipes.splice(index, 1);
      if (state.pipes.length === 0) this.pause();
      dest.emit("unpipe", this, unpipeInfo);
      return this;
    };
    Readable2.prototype.on = function(ev, fn) {
      const res = Stream2.prototype.on.call(this, ev, fn);
      const state = this._readableState;
      if (ev === "data") {
        state.readableListening = this.listenerCount("readable") > 0;
        if (state.flowing !== false) this.resume();
      } else if (ev === "readable") {
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true;
          state.flowing = false;
          state.emittedReadable = false;
          debug("on readable", state.length, state.reading);
          if (state.length) {
            emitReadable(this);
          } else if (!state.reading) {
            process2.nextTick(nReadingNextTick, this);
          }
        }
      }
      return res;
    };
    Readable2.prototype.addListener = Readable2.prototype.on;
    Readable2.prototype.removeListener = function(ev, fn) {
      const res = Stream2.prototype.removeListener.call(this, ev, fn);
      if (ev === "readable") {
        process2.nextTick(updateReadableListening, this);
      }
      return res;
    };
    Readable2.prototype.off = Readable2.prototype.removeListener;
    Readable2.prototype.removeAllListeners = function(ev) {
      const res = Stream2.prototype.removeAllListeners.apply(this, arguments);
      if (ev === "readable" || ev === void 0) {
        process2.nextTick(updateReadableListening, this);
      }
      return res;
    };
    function updateReadableListening(self2) {
      const state = self2._readableState;
      state.readableListening = self2.listenerCount("readable") > 0;
      if (state.resumeScheduled && state[kPaused] === false) {
        state.flowing = true;
      } else if (self2.listenerCount("data") > 0) {
        self2.resume();
      } else if (!state.readableListening) {
        state.flowing = null;
      }
    }
    function nReadingNextTick(self2) {
      debug("readable nexttick read 0");
      self2.read(0);
    }
    Readable2.prototype.resume = function() {
      const state = this._readableState;
      if (!state.flowing) {
        debug("resume");
        state.flowing = !state.readableListening;
        resume(this, state);
      }
      state[kPaused] = false;
      return this;
    };
    function resume(stream, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        process2.nextTick(resume_, stream, state);
      }
    }
    function resume_(stream, state) {
      debug("resume", state.reading);
      if (!state.reading) {
        stream.read(0);
      }
      state.resumeScheduled = false;
      stream.emit("resume");
      flow(stream);
      if (state.flowing && !state.reading) stream.read(0);
    }
    Readable2.prototype.pause = function() {
      debug("call pause flowing=%j", this._readableState.flowing);
      if (this._readableState.flowing !== false) {
        debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      this._readableState[kPaused] = true;
      return this;
    };
    function flow(stream) {
      const state = stream._readableState;
      debug("flow", state.flowing);
      while (state.flowing && stream.read() !== null) ;
    }
    Readable2.prototype.wrap = function(stream) {
      let paused = false;
      stream.on("data", (chunk) => {
        if (!this.push(chunk) && stream.pause) {
          paused = true;
          stream.pause();
        }
      });
      stream.on("end", () => {
        this.push(null);
      });
      stream.on("error", (err) => {
        errorOrDestroy(this, err);
      });
      stream.on("close", () => {
        this.destroy();
      });
      stream.on("destroy", () => {
        this.destroy();
      });
      this._read = () => {
        if (paused && stream.resume) {
          paused = false;
          stream.resume();
        }
      };
      const streamKeys = ObjectKeys(stream);
      for (let j = 1; j < streamKeys.length; j++) {
        const i2 = streamKeys[j];
        if (this[i2] === void 0 && typeof stream[i2] === "function") {
          this[i2] = stream[i2].bind(stream);
        }
      }
      return this;
    };
    Readable2.prototype[SymbolAsyncIterator] = function() {
      return streamToAsyncIterator(this);
    };
    Readable2.prototype.iterator = function(options) {
      if (options !== void 0) {
        validateObject(options, "options");
      }
      return streamToAsyncIterator(this, options);
    };
    function streamToAsyncIterator(stream, options) {
      if (typeof stream.read !== "function") {
        stream = Readable2.wrap(stream, {
          objectMode: true
        });
      }
      const iter = createAsyncIterator(stream, options);
      iter.stream = stream;
      return iter;
    }
    async function* createAsyncIterator(stream, options) {
      let callback = nop;
      function next(resolve) {
        if (this === stream) {
          callback();
          callback = nop;
        } else {
          callback = resolve;
        }
      }
      stream.on("readable", next);
      let error;
      const cleanup = eos(stream, {
        writable: false
      }, (err) => {
        error = err ? aggregateTwoErrors(error, err) : null;
        callback();
        callback = nop;
      });
      try {
        while (true) {
          const chunk = stream.destroyed ? null : stream.read();
          if (chunk !== null) {
            yield chunk;
          } else if (error) {
            throw error;
          } else if (error === null) {
            return;
          } else {
            await new Promise2(next);
          }
        }
      } catch (err) {
        error = aggregateTwoErrors(error, err);
        throw error;
      } finally {
        if ((error || (options === null || options === void 0 ? void 0 : options.destroyOnReturn) !== false) && (error === void 0 || stream._readableState.autoDestroy)) {
          destroyImpl.destroyer(stream, null);
        } else {
          stream.off("readable", next);
          cleanup();
        }
      }
    }
    ObjectDefineProperties(Readable2.prototype, {
      readable: {
        __proto__: null,
        get() {
          const r = this._readableState;
          return !!r && r.readable !== false && !r.destroyed && !r.errorEmitted && !r.endEmitted;
        },
        set(val) {
          if (this._readableState) {
            this._readableState.readable = !!val;
          }
        }
      },
      readableDidRead: {
        __proto__: null,
        enumerable: false,
        get: function() {
          return this._readableState.dataEmitted;
        }
      },
      readableAborted: {
        __proto__: null,
        enumerable: false,
        get: function() {
          return !!(this._readableState.readable !== false && (this._readableState.destroyed || this._readableState.errored) && !this._readableState.endEmitted);
        }
      },
      readableHighWaterMark: {
        __proto__: null,
        enumerable: false,
        get: function() {
          return this._readableState.highWaterMark;
        }
      },
      readableBuffer: {
        __proto__: null,
        enumerable: false,
        get: function() {
          return this._readableState && this._readableState.buffer;
        }
      },
      readableFlowing: {
        __proto__: null,
        enumerable: false,
        get: function() {
          return this._readableState.flowing;
        },
        set: function(state) {
          if (this._readableState) {
            this._readableState.flowing = state;
          }
        }
      },
      readableLength: {
        __proto__: null,
        enumerable: false,
        get() {
          return this._readableState.length;
        }
      },
      readableObjectMode: {
        __proto__: null,
        enumerable: false,
        get() {
          return this._readableState ? this._readableState.objectMode : false;
        }
      },
      readableEncoding: {
        __proto__: null,
        enumerable: false,
        get() {
          return this._readableState ? this._readableState.encoding : null;
        }
      },
      errored: {
        __proto__: null,
        enumerable: false,
        get() {
          return this._readableState ? this._readableState.errored : null;
        }
      },
      closed: {
        __proto__: null,
        get() {
          return this._readableState ? this._readableState.closed : false;
        }
      },
      destroyed: {
        __proto__: null,
        enumerable: false,
        get() {
          return this._readableState ? this._readableState.destroyed : false;
        },
        set(value) {
          if (!this._readableState) {
            return;
          }
          this._readableState.destroyed = value;
        }
      },
      readableEnded: {
        __proto__: null,
        enumerable: false,
        get() {
          return this._readableState ? this._readableState.endEmitted : false;
        }
      }
    });
    ObjectDefineProperties(ReadableState.prototype, {
      // Legacy getter for `pipesCount`.
      pipesCount: {
        __proto__: null,
        get() {
          return this.pipes.length;
        }
      },
      // Legacy property for `paused`.
      paused: {
        __proto__: null,
        get() {
          return this[kPaused] !== false;
        },
        set(value) {
          this[kPaused] = !!value;
        }
      }
    });
    Readable2._fromList = fromList;
    function fromList(n, state) {
      if (state.length === 0) return null;
      let ret;
      if (state.objectMode) ret = state.buffer.shift();
      else if (!n || n >= state.length) {
        if (state.decoder) ret = state.buffer.join("");
        else if (state.buffer.length === 1) ret = state.buffer.first();
        else ret = state.buffer.concat(state.length);
        state.buffer.clear();
      } else {
        ret = state.buffer.consume(n, state.decoder);
      }
      return ret;
    }
    function endReadable(stream) {
      const state = stream._readableState;
      debug("endReadable", state.endEmitted);
      if (!state.endEmitted) {
        state.ended = true;
        process2.nextTick(endReadableNT, state, stream);
      }
    }
    function endReadableNT(state, stream) {
      debug("endReadableNT", state.endEmitted, state.length);
      if (!state.errored && !state.closeEmitted && !state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.emit("end");
        if (stream.writable && stream.allowHalfOpen === false) {
          process2.nextTick(endWritableNT, stream);
        } else if (state.autoDestroy) {
          const wState = stream._writableState;
          const autoDestroy = !wState || wState.autoDestroy && // We don't expect the writable to ever 'finish'
          // if writable is explicitly set to false.
          (wState.finished || wState.writable === false);
          if (autoDestroy) {
            stream.destroy();
          }
        }
      }
    }
    function endWritableNT(stream) {
      const writable = stream.writable && !stream.writableEnded && !stream.destroyed;
      if (writable) {
        stream.end();
      }
    }
    Readable2.from = function(iterable, opts) {
      return from(Readable2, iterable, opts);
    };
    var webStreamsAdapters;
    function lazyWebStreams() {
      if (webStreamsAdapters === void 0) webStreamsAdapters = {};
      return webStreamsAdapters;
    }
    Readable2.fromWeb = function(readableStream, options) {
      return lazyWebStreams().newStreamReadableFromReadableStream(readableStream, options);
    };
    Readable2.toWeb = function(streamReadable, options) {
      return lazyWebStreams().newReadableStreamFromStreamReadable(streamReadable, options);
    };
    Readable2.wrap = function(src, options) {
      var _ref, _src$readableObjectMo;
      return new Readable2({
        objectMode: (_ref = (_src$readableObjectMo = src.readableObjectMode) !== null && _src$readableObjectMo !== void 0 ? _src$readableObjectMo : src.objectMode) !== null && _ref !== void 0 ? _ref : true,
        ...options,
        destroy(err, callback) {
          destroyImpl.destroyer(src, err);
          callback(err);
        }
      }).wrap(src);
    };
  }
});

// ../../../../../node_modules/.deno/readable-stream@4.5.2/node_modules/readable-stream/lib/internal/streams/writable.js
var require_writable = __commonJS({
  "../../../../../node_modules/.deno/readable-stream@4.5.2/node_modules/readable-stream/lib/internal/streams/writable.js"(exports, module) {
    var process2 = require_process();
    var { ArrayPrototypeSlice, Error: Error2, FunctionPrototypeSymbolHasInstance, ObjectDefineProperty, ObjectDefineProperties, ObjectSetPrototypeOf, StringPrototypeToLowerCase, Symbol: Symbol2, SymbolHasInstance } = require_primordials();
    module.exports = Writable;
    Writable.WritableState = WritableState;
    var { EventEmitter: EE } = __require("node:events");
    var Stream2 = require_legacy().Stream;
    var { Buffer: Buffer2 } = __require("node:buffer");
    var destroyImpl = require_destroy();
    var { addAbortSignal } = require_add_abort_signal();
    var { getHighWaterMark, getDefaultHighWaterMark } = require_state();
    var { ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE2, ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK, ERR_STREAM_CANNOT_PIPE, ERR_STREAM_DESTROYED, ERR_STREAM_ALREADY_FINISHED, ERR_STREAM_NULL_VALUES, ERR_STREAM_WRITE_AFTER_END, ERR_UNKNOWN_ENCODING } = require_errors2().codes;
    var { errorOrDestroy } = destroyImpl;
    ObjectSetPrototypeOf(Writable.prototype, Stream2.prototype);
    ObjectSetPrototypeOf(Writable, Stream2);
    function nop() {
    }
    var kOnFinished = Symbol2("kOnFinished");
    function WritableState(options, stream, isDuplex) {
      if (typeof isDuplex !== "boolean") isDuplex = stream instanceof require_duplex();
      this.objectMode = !!(options && options.objectMode);
      if (isDuplex) this.objectMode = this.objectMode || !!(options && options.writableObjectMode);
      this.highWaterMark = options ? getHighWaterMark(this, options, "writableHighWaterMark", isDuplex) : getDefaultHighWaterMark(false);
      this.finalCalled = false;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      this.destroyed = false;
      const noDecode = !!(options && options.decodeStrings === false);
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options && options.defaultEncoding || "utf8";
      this.length = 0;
      this.writing = false;
      this.corked = 0;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = onwrite.bind(void 0, stream);
      this.writecb = null;
      this.writelen = 0;
      this.afterWriteTickInfo = null;
      resetBuffer(this);
      this.pendingcb = 0;
      this.constructed = true;
      this.prefinished = false;
      this.errorEmitted = false;
      this.emitClose = !options || options.emitClose !== false;
      this.autoDestroy = !options || options.autoDestroy !== false;
      this.errored = null;
      this.closed = false;
      this.closeEmitted = false;
      this[kOnFinished] = [];
    }
    function resetBuffer(state) {
      state.buffered = [];
      state.bufferedIndex = 0;
      state.allBuffers = true;
      state.allNoop = true;
    }
    WritableState.prototype.getBuffer = function getBuffer() {
      return ArrayPrototypeSlice(this.buffered, this.bufferedIndex);
    };
    ObjectDefineProperty(WritableState.prototype, "bufferedRequestCount", {
      __proto__: null,
      get() {
        return this.buffered.length - this.bufferedIndex;
      }
    });
    function Writable(options) {
      const isDuplex = this instanceof require_duplex();
      if (!isDuplex && !FunctionPrototypeSymbolHasInstance(Writable, this)) return new Writable(options);
      this._writableState = new WritableState(options, this, isDuplex);
      if (options) {
        if (typeof options.write === "function") this._write = options.write;
        if (typeof options.writev === "function") this._writev = options.writev;
        if (typeof options.destroy === "function") this._destroy = options.destroy;
        if (typeof options.final === "function") this._final = options.final;
        if (typeof options.construct === "function") this._construct = options.construct;
        if (options.signal) addAbortSignal(options.signal, this);
      }
      Stream2.call(this, options);
      destroyImpl.construct(this, () => {
        const state = this._writableState;
        if (!state.writing) {
          clearBuffer(this, state);
        }
        finishMaybe(this, state);
      });
    }
    ObjectDefineProperty(Writable, SymbolHasInstance, {
      __proto__: null,
      value: function(object) {
        if (FunctionPrototypeSymbolHasInstance(this, object)) return true;
        if (this !== Writable) return false;
        return object && object._writableState instanceof WritableState;
      }
    });
    Writable.prototype.pipe = function() {
      errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
    };
    function _write(stream, chunk, encoding, cb) {
      const state = stream._writableState;
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = state.defaultEncoding;
      } else {
        if (!encoding) encoding = state.defaultEncoding;
        else if (encoding !== "buffer" && !Buffer2.isEncoding(encoding)) throw new ERR_UNKNOWN_ENCODING(encoding);
        if (typeof cb !== "function") cb = nop;
      }
      if (chunk === null) {
        throw new ERR_STREAM_NULL_VALUES();
      } else if (!state.objectMode) {
        if (typeof chunk === "string") {
          if (state.decodeStrings !== false) {
            chunk = Buffer2.from(chunk, encoding);
            encoding = "buffer";
          }
        } else if (chunk instanceof Buffer2) {
          encoding = "buffer";
        } else if (Stream2._isUint8Array(chunk)) {
          chunk = Stream2._uint8ArrayToBuffer(chunk);
          encoding = "buffer";
        } else {
          throw new ERR_INVALID_ARG_TYPE2("chunk", [
            "string",
            "Buffer",
            "Uint8Array"
          ], chunk);
        }
      }
      let err;
      if (state.ending) {
        err = new ERR_STREAM_WRITE_AFTER_END();
      } else if (state.destroyed) {
        err = new ERR_STREAM_DESTROYED("write");
      }
      if (err) {
        process2.nextTick(cb, err);
        errorOrDestroy(stream, err, true);
        return err;
      }
      state.pendingcb++;
      return writeOrBuffer(stream, state, chunk, encoding, cb);
    }
    Writable.prototype.write = function(chunk, encoding, cb) {
      return _write(this, chunk, encoding, cb) === true;
    };
    Writable.prototype.cork = function() {
      this._writableState.corked++;
    };
    Writable.prototype.uncork = function() {
      const state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing) clearBuffer(this, state);
      }
    };
    Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      if (typeof encoding === "string") encoding = StringPrototypeToLowerCase(encoding);
      if (!Buffer2.isEncoding(encoding)) throw new ERR_UNKNOWN_ENCODING(encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    };
    function writeOrBuffer(stream, state, chunk, encoding, callback) {
      const len = state.objectMode ? 1 : chunk.length;
      state.length += len;
      const ret = state.length < state.highWaterMark;
      if (!ret) state.needDrain = true;
      if (state.writing || state.corked || state.errored || !state.constructed) {
        state.buffered.push({
          chunk,
          encoding,
          callback
        });
        if (state.allBuffers && encoding !== "buffer") {
          state.allBuffers = false;
        }
        if (state.allNoop && callback !== nop) {
          state.allNoop = false;
        }
      } else {
        state.writelen = len;
        state.writecb = callback;
        state.writing = true;
        state.sync = true;
        stream._write(chunk, encoding, state.onwrite);
        state.sync = false;
      }
      return ret && !state.errored && !state.destroyed;
    }
    function doWrite(stream, state, writev, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED("write"));
      else if (writev) stream._writev(chunk, state.onwrite);
      else stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    function onwriteError(stream, state, er, cb) {
      --state.pendingcb;
      cb(er);
      errorBuffer(state);
      errorOrDestroy(stream, er);
    }
    function onwrite(stream, er) {
      const state = stream._writableState;
      const sync = state.sync;
      const cb = state.writecb;
      if (typeof cb !== "function") {
        errorOrDestroy(stream, new ERR_MULTIPLE_CALLBACK());
        return;
      }
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
      if (er) {
        er.stack;
        if (!state.errored) {
          state.errored = er;
        }
        if (stream._readableState && !stream._readableState.errored) {
          stream._readableState.errored = er;
        }
        if (sync) {
          process2.nextTick(onwriteError, stream, state, er, cb);
        } else {
          onwriteError(stream, state, er, cb);
        }
      } else {
        if (state.buffered.length > state.bufferedIndex) {
          clearBuffer(stream, state);
        }
        if (sync) {
          if (state.afterWriteTickInfo !== null && state.afterWriteTickInfo.cb === cb) {
            state.afterWriteTickInfo.count++;
          } else {
            state.afterWriteTickInfo = {
              count: 1,
              cb,
              stream,
              state
            };
            process2.nextTick(afterWriteTick, state.afterWriteTickInfo);
          }
        } else {
          afterWrite(stream, state, 1, cb);
        }
      }
    }
    function afterWriteTick({ stream, state, count, cb }) {
      state.afterWriteTickInfo = null;
      return afterWrite(stream, state, count, cb);
    }
    function afterWrite(stream, state, count, cb) {
      const needDrain = !state.ending && !stream.destroyed && state.length === 0 && state.needDrain;
      if (needDrain) {
        state.needDrain = false;
        stream.emit("drain");
      }
      while (count-- > 0) {
        state.pendingcb--;
        cb();
      }
      if (state.destroyed) {
        errorBuffer(state);
      }
      finishMaybe(stream, state);
    }
    function errorBuffer(state) {
      if (state.writing) {
        return;
      }
      for (let n = state.bufferedIndex; n < state.buffered.length; ++n) {
        var _state$errored;
        const { chunk, callback } = state.buffered[n];
        const len = state.objectMode ? 1 : chunk.length;
        state.length -= len;
        callback((_state$errored = state.errored) !== null && _state$errored !== void 0 ? _state$errored : new ERR_STREAM_DESTROYED("write"));
      }
      const onfinishCallbacks = state[kOnFinished].splice(0);
      for (let i2 = 0; i2 < onfinishCallbacks.length; i2++) {
        var _state$errored2;
        onfinishCallbacks[i2]((_state$errored2 = state.errored) !== null && _state$errored2 !== void 0 ? _state$errored2 : new ERR_STREAM_DESTROYED("end"));
      }
      resetBuffer(state);
    }
    function clearBuffer(stream, state) {
      if (state.corked || state.bufferProcessing || state.destroyed || !state.constructed) {
        return;
      }
      const { buffered, bufferedIndex, objectMode } = state;
      const bufferedLength = buffered.length - bufferedIndex;
      if (!bufferedLength) {
        return;
      }
      let i2 = bufferedIndex;
      state.bufferProcessing = true;
      if (bufferedLength > 1 && stream._writev) {
        state.pendingcb -= bufferedLength - 1;
        const callback = state.allNoop ? nop : (err) => {
          for (let n = i2; n < buffered.length; ++n) {
            buffered[n].callback(err);
          }
        };
        const chunks = state.allNoop && i2 === 0 ? buffered : ArrayPrototypeSlice(buffered, i2);
        chunks.allBuffers = state.allBuffers;
        doWrite(stream, state, true, state.length, chunks, "", callback);
        resetBuffer(state);
      } else {
        do {
          const { chunk, encoding, callback } = buffered[i2];
          buffered[i2++] = null;
          const len = objectMode ? 1 : chunk.length;
          doWrite(stream, state, false, len, chunk, encoding, callback);
        } while (i2 < buffered.length && !state.writing);
        if (i2 === buffered.length) {
          resetBuffer(state);
        } else if (i2 > 256) {
          buffered.splice(0, i2);
          state.bufferedIndex = 0;
        } else {
          state.bufferedIndex = i2;
        }
      }
      state.bufferProcessing = false;
    }
    Writable.prototype._write = function(chunk, encoding, cb) {
      if (this._writev) {
        this._writev([
          {
            chunk,
            encoding
          }
        ], cb);
      } else {
        throw new ERR_METHOD_NOT_IMPLEMENTED("_write()");
      }
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function(chunk, encoding, cb) {
      const state = this._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      let err;
      if (chunk !== null && chunk !== void 0) {
        const ret = _write(this, chunk, encoding);
        if (ret instanceof Error2) {
          err = ret;
        }
      }
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (err) {
      } else if (!state.errored && !state.ending) {
        state.ending = true;
        finishMaybe(this, state, true);
        state.ended = true;
      } else if (state.finished) {
        err = new ERR_STREAM_ALREADY_FINISHED("end");
      } else if (state.destroyed) {
        err = new ERR_STREAM_DESTROYED("end");
      }
      if (typeof cb === "function") {
        if (err || state.finished) {
          process2.nextTick(cb, err);
        } else {
          state[kOnFinished].push(cb);
        }
      }
      return this;
    };
    function needFinish(state) {
      return state.ending && !state.destroyed && state.constructed && state.length === 0 && !state.errored && state.buffered.length === 0 && !state.finished && !state.writing && !state.errorEmitted && !state.closeEmitted;
    }
    function callFinal(stream, state) {
      let called = false;
      function onFinish(err) {
        if (called) {
          errorOrDestroy(stream, err !== null && err !== void 0 ? err : ERR_MULTIPLE_CALLBACK());
          return;
        }
        called = true;
        state.pendingcb--;
        if (err) {
          const onfinishCallbacks = state[kOnFinished].splice(0);
          for (let i2 = 0; i2 < onfinishCallbacks.length; i2++) {
            onfinishCallbacks[i2](err);
          }
          errorOrDestroy(stream, err, state.sync);
        } else if (needFinish(state)) {
          state.prefinished = true;
          stream.emit("prefinish");
          state.pendingcb++;
          process2.nextTick(finish, stream, state);
        }
      }
      state.sync = true;
      state.pendingcb++;
      try {
        stream._final(onFinish);
      } catch (err) {
        onFinish(err);
      }
      state.sync = false;
    }
    function prefinish(stream, state) {
      if (!state.prefinished && !state.finalCalled) {
        if (typeof stream._final === "function" && !state.destroyed) {
          state.finalCalled = true;
          callFinal(stream, state);
        } else {
          state.prefinished = true;
          stream.emit("prefinish");
        }
      }
    }
    function finishMaybe(stream, state, sync) {
      if (needFinish(state)) {
        prefinish(stream, state);
        if (state.pendingcb === 0) {
          if (sync) {
            state.pendingcb++;
            process2.nextTick((stream2, state2) => {
              if (needFinish(state2)) {
                finish(stream2, state2);
              } else {
                state2.pendingcb--;
              }
            }, stream, state);
          } else if (needFinish(state)) {
            state.pendingcb++;
            finish(stream, state);
          }
        }
      }
    }
    function finish(stream, state) {
      state.pendingcb--;
      state.finished = true;
      const onfinishCallbacks = state[kOnFinished].splice(0);
      for (let i2 = 0; i2 < onfinishCallbacks.length; i2++) {
        onfinishCallbacks[i2]();
      }
      stream.emit("finish");
      if (state.autoDestroy) {
        const rState = stream._readableState;
        const autoDestroy = !rState || rState.autoDestroy && // We don't expect the readable to ever 'end'
        // if readable is explicitly set to false.
        (rState.endEmitted || rState.readable === false);
        if (autoDestroy) {
          stream.destroy();
        }
      }
    }
    ObjectDefineProperties(Writable.prototype, {
      closed: {
        __proto__: null,
        get() {
          return this._writableState ? this._writableState.closed : false;
        }
      },
      destroyed: {
        __proto__: null,
        get() {
          return this._writableState ? this._writableState.destroyed : false;
        },
        set(value) {
          if (this._writableState) {
            this._writableState.destroyed = value;
          }
        }
      },
      writable: {
        __proto__: null,
        get() {
          const w = this._writableState;
          return !!w && w.writable !== false && !w.destroyed && !w.errored && !w.ending && !w.ended;
        },
        set(val) {
          if (this._writableState) {
            this._writableState.writable = !!val;
          }
        }
      },
      writableFinished: {
        __proto__: null,
        get() {
          return this._writableState ? this._writableState.finished : false;
        }
      },
      writableObjectMode: {
        __proto__: null,
        get() {
          return this._writableState ? this._writableState.objectMode : false;
        }
      },
      writableBuffer: {
        __proto__: null,
        get() {
          return this._writableState && this._writableState.getBuffer();
        }
      },
      writableEnded: {
        __proto__: null,
        get() {
          return this._writableState ? this._writableState.ending : false;
        }
      },
      writableNeedDrain: {
        __proto__: null,
        get() {
          const wState = this._writableState;
          if (!wState) return false;
          return !wState.destroyed && !wState.ending && wState.needDrain;
        }
      },
      writableHighWaterMark: {
        __proto__: null,
        get() {
          return this._writableState && this._writableState.highWaterMark;
        }
      },
      writableCorked: {
        __proto__: null,
        get() {
          return this._writableState ? this._writableState.corked : 0;
        }
      },
      writableLength: {
        __proto__: null,
        get() {
          return this._writableState && this._writableState.length;
        }
      },
      errored: {
        __proto__: null,
        enumerable: false,
        get() {
          return this._writableState ? this._writableState.errored : null;
        }
      },
      writableAborted: {
        __proto__: null,
        enumerable: false,
        get: function() {
          return !!(this._writableState.writable !== false && (this._writableState.destroyed || this._writableState.errored) && !this._writableState.finished);
        }
      }
    });
    var destroy = destroyImpl.destroy;
    Writable.prototype.destroy = function(err, cb) {
      const state = this._writableState;
      if (!state.destroyed && (state.bufferedIndex < state.buffered.length || state[kOnFinished].length)) {
        process2.nextTick(errorBuffer, state);
      }
      destroy.call(this, err, cb);
      return this;
    };
    Writable.prototype._undestroy = destroyImpl.undestroy;
    Writable.prototype._destroy = function(err, cb) {
      cb(err);
    };
    Writable.prototype[EE.captureRejectionSymbol] = function(err) {
      this.destroy(err);
    };
    var webStreamsAdapters;
    function lazyWebStreams() {
      if (webStreamsAdapters === void 0) webStreamsAdapters = {};
      return webStreamsAdapters;
    }
    Writable.fromWeb = function(writableStream, options) {
      return lazyWebStreams().newStreamWritableFromWritableStream(writableStream, options);
    };
    Writable.toWeb = function(streamWritable) {
      return lazyWebStreams().newWritableStreamFromStreamWritable(streamWritable);
    };
  }
});

// ../../../../../node_modules/.deno/readable-stream@4.5.2/node_modules/readable-stream/lib/internal/streams/duplexify.js
var require_duplexify = __commonJS({
  "../../../../../node_modules/.deno/readable-stream@4.5.2/node_modules/readable-stream/lib/internal/streams/duplexify.js"(exports, module) {
    var process2 = require_process();
    var bufferModule = __require("node:buffer");
    var { isReadable, isWritable, isIterable, isNodeStream, isReadableNodeStream, isWritableNodeStream, isDuplexNodeStream, isReadableStream, isWritableStream } = require_utils24();
    var eos = require_end_of_stream();
    var { AbortError: AbortError2, codes: { ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE2, ERR_INVALID_RETURN_VALUE } } = require_errors2();
    var { destroyer } = require_destroy();
    var Duplex = require_duplex();
    var Readable2 = require_readable();
    var Writable = require_writable();
    var { createDeferredPromise } = require_util();
    var from = require_from();
    var Blob2 = globalThis.Blob || bufferModule.Blob;
    var isBlob2 = typeof Blob2 !== "undefined" ? function isBlob3(b) {
      return b instanceof Blob2;
    } : function isBlob3(b) {
      return false;
    };
    var AbortController = globalThis.AbortController || require_abort_controller().AbortController;
    var { FunctionPrototypeCall } = require_primordials();
    var Duplexify = class extends Duplex {
      constructor(options) {
        super(options);
        if ((options === null || options === void 0 ? void 0 : options.readable) === false) {
          this._readableState.readable = false;
          this._readableState.ended = true;
          this._readableState.endEmitted = true;
        }
        if ((options === null || options === void 0 ? void 0 : options.writable) === false) {
          this._writableState.writable = false;
          this._writableState.ending = true;
          this._writableState.ended = true;
          this._writableState.finished = true;
        }
      }
    };
    module.exports = function duplexify(body, name) {
      if (isDuplexNodeStream(body)) {
        return body;
      }
      if (isReadableNodeStream(body)) {
        return _duplexify({
          readable: body
        });
      }
      if (isWritableNodeStream(body)) {
        return _duplexify({
          writable: body
        });
      }
      if (isNodeStream(body)) {
        return _duplexify({
          writable: false,
          readable: false
        });
      }
      if (isReadableStream(body)) {
        return _duplexify({
          readable: Readable2.fromWeb(body)
        });
      }
      if (isWritableStream(body)) {
        return _duplexify({
          writable: Writable.fromWeb(body)
        });
      }
      if (typeof body === "function") {
        const { value, write, final, destroy } = fromAsyncGen(body);
        if (isIterable(value)) {
          return from(Duplexify, value, {
            // TODO (ronag): highWaterMark?
            objectMode: true,
            write,
            final,
            destroy
          });
        }
        const then2 = value === null || value === void 0 ? void 0 : value.then;
        if (typeof then2 === "function") {
          let d;
          const promise = FunctionPrototypeCall(then2, value, (val) => {
            if (val != null) {
              throw new ERR_INVALID_RETURN_VALUE("nully", "body", val);
            }
          }, (err) => {
            destroyer(d, err);
          });
          return d = new Duplexify({
            // TODO (ronag): highWaterMark?
            objectMode: true,
            readable: false,
            write,
            final(cb) {
              final(async () => {
                try {
                  await promise;
                  process2.nextTick(cb, null);
                } catch (err) {
                  process2.nextTick(cb, err);
                }
              });
            },
            destroy
          });
        }
        throw new ERR_INVALID_RETURN_VALUE("Iterable, AsyncIterable or AsyncFunction", name, value);
      }
      if (isBlob2(body)) {
        return duplexify(body.arrayBuffer());
      }
      if (isIterable(body)) {
        return from(Duplexify, body, {
          // TODO (ronag): highWaterMark?
          objectMode: true,
          writable: false
        });
      }
      if (isReadableStream(body === null || body === void 0 ? void 0 : body.readable) && isWritableStream(body === null || body === void 0 ? void 0 : body.writable)) {
        return Duplexify.fromWeb(body);
      }
      if (typeof (body === null || body === void 0 ? void 0 : body.writable) === "object" || typeof (body === null || body === void 0 ? void 0 : body.readable) === "object") {
        const readable = body !== null && body !== void 0 && body.readable ? isReadableNodeStream(body === null || body === void 0 ? void 0 : body.readable) ? body === null || body === void 0 ? void 0 : body.readable : duplexify(body.readable) : void 0;
        const writable = body !== null && body !== void 0 && body.writable ? isWritableNodeStream(body === null || body === void 0 ? void 0 : body.writable) ? body === null || body === void 0 ? void 0 : body.writable : duplexify(body.writable) : void 0;
        return _duplexify({
          readable,
          writable
        });
      }
      const then = body === null || body === void 0 ? void 0 : body.then;
      if (typeof then === "function") {
        let d;
        FunctionPrototypeCall(then, body, (val) => {
          if (val != null) {
            d.push(val);
          }
          d.push(null);
        }, (err) => {
          destroyer(d, err);
        });
        return d = new Duplexify({
          objectMode: true,
          writable: false,
          read() {
          }
        });
      }
      throw new ERR_INVALID_ARG_TYPE2(name, [
        "Blob",
        "ReadableStream",
        "WritableStream",
        "Stream",
        "Iterable",
        "AsyncIterable",
        "Function",
        "{ readable, writable } pair",
        "Promise"
      ], body);
    };
    function fromAsyncGen(fn) {
      let { promise, resolve } = createDeferredPromise();
      const ac = new AbortController();
      const signal = ac.signal;
      const value = fn(async function* () {
        while (true) {
          const _promise = promise;
          promise = null;
          const { chunk, done, cb } = await _promise;
          process2.nextTick(cb);
          if (done) return;
          if (signal.aborted) throw new AbortError2(void 0, {
            cause: signal.reason
          });
          ({ promise, resolve } = createDeferredPromise());
          yield chunk;
        }
      }(), {
        signal
      });
      return {
        value,
        write(chunk, encoding, cb) {
          const _resolve = resolve;
          resolve = null;
          _resolve({
            chunk,
            done: false,
            cb
          });
        },
        final(cb) {
          const _resolve = resolve;
          resolve = null;
          _resolve({
            done: true,
            cb
          });
        },
        destroy(err, cb) {
          ac.abort();
          cb(err);
        }
      };
    }
    function _duplexify(pair) {
      const r = pair.readable && typeof pair.readable.read !== "function" ? Readable2.wrap(pair.readable) : pair.readable;
      const w = pair.writable;
      let readable = !!isReadable(r);
      let writable = !!isWritable(w);
      let ondrain;
      let onfinish;
      let onreadable;
      let onclose;
      let d;
      function onfinished(err) {
        const cb = onclose;
        onclose = null;
        if (cb) {
          cb(err);
        } else if (err) {
          d.destroy(err);
        }
      }
      d = new Duplexify({
        // TODO (ronag): highWaterMark?
        readableObjectMode: !!(r !== null && r !== void 0 && r.readableObjectMode),
        writableObjectMode: !!(w !== null && w !== void 0 && w.writableObjectMode),
        readable,
        writable
      });
      if (writable) {
        eos(w, (err) => {
          writable = false;
          if (err) {
            destroyer(r, err);
          }
          onfinished(err);
        });
        d._write = function(chunk, encoding, callback) {
          if (w.write(chunk, encoding)) {
            callback();
          } else {
            ondrain = callback;
          }
        };
        d._final = function(callback) {
          w.end();
          onfinish = callback;
        };
        w.on("drain", function() {
          if (ondrain) {
            const cb = ondrain;
            ondrain = null;
            cb();
          }
        });
        w.on("finish", function() {
          if (onfinish) {
            const cb = onfinish;
            onfinish = null;
            cb();
          }
        });
      }
      if (readable) {
        eos(r, (err) => {
          readable = false;
          if (err) {
            destroyer(r, err);
          }
          onfinished(err);
        });
        r.on("readable", function() {
          if (onreadable) {
            const cb = onreadable;
            onreadable = null;
            cb();
          }
        });
        r.on("end", function() {
          d.push(null);
        });
        d._read = function() {
          while (true) {
            const buf = r.read();
            if (buf === null) {
              onreadable = d._read;
              return;
            }
            if (!d.push(buf)) {
              return;
            }
          }
        };
      }
      d._destroy = function(err, callback) {
        if (!err && onclose !== null) {
          err = new AbortError2();
        }
        onreadable = null;
        ondrain = null;
        onfinish = null;
        if (onclose === null) {
          callback(err);
        } else {
          onclose = callback;
          destroyer(w, err);
          destroyer(r, err);
        }
      };
      return d;
    }
  }
});

// ../../../../../node_modules/.deno/readable-stream@4.5.2/node_modules/readable-stream/lib/internal/streams/duplex.js
var require_duplex = __commonJS({
  "../../../../../node_modules/.deno/readable-stream@4.5.2/node_modules/readable-stream/lib/internal/streams/duplex.js"(exports, module) {
    "use strict";
    var { ObjectDefineProperties, ObjectGetOwnPropertyDescriptor, ObjectKeys, ObjectSetPrototypeOf } = require_primordials();
    module.exports = Duplex;
    var Readable2 = require_readable();
    var Writable = require_writable();
    ObjectSetPrototypeOf(Duplex.prototype, Readable2.prototype);
    ObjectSetPrototypeOf(Duplex, Readable2);
    {
      const keys = ObjectKeys(Writable.prototype);
      for (let i2 = 0; i2 < keys.length; i2++) {
        const method = keys[i2];
        if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
      }
    }
    function Duplex(options) {
      if (!(this instanceof Duplex)) return new Duplex(options);
      Readable2.call(this, options);
      Writable.call(this, options);
      if (options) {
        this.allowHalfOpen = options.allowHalfOpen !== false;
        if (options.readable === false) {
          this._readableState.readable = false;
          this._readableState.ended = true;
          this._readableState.endEmitted = true;
        }
        if (options.writable === false) {
          this._writableState.writable = false;
          this._writableState.ending = true;
          this._writableState.ended = true;
          this._writableState.finished = true;
        }
      } else {
        this.allowHalfOpen = true;
      }
    }
    ObjectDefineProperties(Duplex.prototype, {
      writable: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writable")
      },
      writableHighWaterMark: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableHighWaterMark")
      },
      writableObjectMode: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableObjectMode")
      },
      writableBuffer: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableBuffer")
      },
      writableLength: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableLength")
      },
      writableFinished: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableFinished")
      },
      writableCorked: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableCorked")
      },
      writableEnded: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableEnded")
      },
      writableNeedDrain: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableNeedDrain")
      },
      destroyed: {
        __proto__: null,
        get() {
          if (this._readableState === void 0 || this._writableState === void 0) {
            return false;
          }
          return this._readableState.destroyed && this._writableState.destroyed;
        },
        set(value) {
          if (this._readableState && this._writableState) {
            this._readableState.destroyed = value;
            this._writableState.destroyed = value;
          }
        }
      }
    });
    var webStreamsAdapters;
    function lazyWebStreams() {
      if (webStreamsAdapters === void 0) webStreamsAdapters = {};
      return webStreamsAdapters;
    }
    Duplex.fromWeb = function(pair, options) {
      return lazyWebStreams().newStreamDuplexFromReadableWritablePair(pair, options);
    };
    Duplex.toWeb = function(duplex) {
      return lazyWebStreams().newReadableWritablePairFromDuplex(duplex);
    };
    var duplexify;
    Duplex.from = function(body) {
      if (!duplexify) {
        duplexify = require_duplexify();
      }
      return duplexify(body, "body");
    };
  }
});

// ../../../../../node_modules/.deno/readable-stream@4.5.2/node_modules/readable-stream/lib/internal/streams/transform.js
var require_transform = __commonJS({
  "../../../../../node_modules/.deno/readable-stream@4.5.2/node_modules/readable-stream/lib/internal/streams/transform.js"(exports, module) {
    "use strict";
    var { ObjectSetPrototypeOf, Symbol: Symbol2 } = require_primordials();
    module.exports = Transform;
    var { ERR_METHOD_NOT_IMPLEMENTED } = require_errors2().codes;
    var Duplex = require_duplex();
    var { getHighWaterMark } = require_state();
    ObjectSetPrototypeOf(Transform.prototype, Duplex.prototype);
    ObjectSetPrototypeOf(Transform, Duplex);
    var kCallback = Symbol2("kCallback");
    function Transform(options) {
      if (!(this instanceof Transform)) return new Transform(options);
      const readableHighWaterMark = options ? getHighWaterMark(this, options, "readableHighWaterMark", true) : null;
      if (readableHighWaterMark === 0) {
        options = {
          ...options,
          highWaterMark: null,
          readableHighWaterMark,
          // TODO (ronag): 0 is not optimal since we have
          // a "bug" where we check needDrain before calling _write and not after.
          // Refs: https://github.com/nodejs/node/pull/32887
          // Refs: https://github.com/nodejs/node/pull/35941
          writableHighWaterMark: options.writableHighWaterMark || 0
        };
      }
      Duplex.call(this, options);
      this._readableState.sync = false;
      this[kCallback] = null;
      if (options) {
        if (typeof options.transform === "function") this._transform = options.transform;
        if (typeof options.flush === "function") this._flush = options.flush;
      }
      this.on("prefinish", prefinish);
    }
    function final(cb) {
      if (typeof this._flush === "function" && !this.destroyed) {
        this._flush((er, data) => {
          if (er) {
            if (cb) {
              cb(er);
            } else {
              this.destroy(er);
            }
            return;
          }
          if (data != null) {
            this.push(data);
          }
          this.push(null);
          if (cb) {
            cb();
          }
        });
      } else {
        this.push(null);
        if (cb) {
          cb();
        }
      }
    }
    function prefinish() {
      if (this._final !== final) {
        final.call(this);
      }
    }
    Transform.prototype._final = final;
    Transform.prototype._transform = function(chunk, encoding, callback) {
      throw new ERR_METHOD_NOT_IMPLEMENTED("_transform()");
    };
    Transform.prototype._write = function(chunk, encoding, callback) {
      const rState = this._readableState;
      const wState = this._writableState;
      const length = rState.length;
      this._transform(chunk, encoding, (err, val) => {
        if (err) {
          callback(err);
          return;
        }
        if (val != null) {
          this.push(val);
        }
        if (wState.ended || // Backwards compat.
        length === rState.length || // Backwards compat.
        rState.length < rState.highWaterMark) {
          callback();
        } else {
          this[kCallback] = callback;
        }
      });
    };
    Transform.prototype._read = function() {
      if (this[kCallback]) {
        const callback = this[kCallback];
        this[kCallback] = null;
        callback();
      }
    };
  }
});

// ../../../../../node_modules/.deno/readable-stream@4.5.2/node_modules/readable-stream/lib/internal/streams/passthrough.js
var require_passthrough = __commonJS({
  "../../../../../node_modules/.deno/readable-stream@4.5.2/node_modules/readable-stream/lib/internal/streams/passthrough.js"(exports, module) {
    "use strict";
    var { ObjectSetPrototypeOf } = require_primordials();
    module.exports = PassThrough2;
    var Transform = require_transform();
    ObjectSetPrototypeOf(PassThrough2.prototype, Transform.prototype);
    ObjectSetPrototypeOf(PassThrough2, Transform);
    function PassThrough2(options) {
      if (!(this instanceof PassThrough2)) return new PassThrough2(options);
      Transform.call(this, options);
    }
    PassThrough2.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
  }
});

// ../../../../../node_modules/.deno/readable-stream@4.5.2/node_modules/readable-stream/lib/internal/streams/pipeline.js
var require_pipeline = __commonJS({
  "../../../../../node_modules/.deno/readable-stream@4.5.2/node_modules/readable-stream/lib/internal/streams/pipeline.js"(exports, module) {
    var process2 = require_process();
    var { ArrayIsArray, Promise: Promise2, SymbolAsyncIterator, SymbolDispose } = require_primordials();
    var eos = require_end_of_stream();
    var { once } = require_util();
    var destroyImpl = require_destroy();
    var Duplex = require_duplex();
    var { aggregateTwoErrors, codes: { ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE2, ERR_INVALID_RETURN_VALUE, ERR_MISSING_ARGS, ERR_STREAM_DESTROYED, ERR_STREAM_PREMATURE_CLOSE }, AbortError: AbortError2 } = require_errors2();
    var { validateFunction, validateAbortSignal } = require_validators();
    var { isIterable, isReadable, isReadableNodeStream, isNodeStream, isTransformStream, isWebStream, isReadableStream, isReadableFinished } = require_utils24();
    var AbortController = globalThis.AbortController || require_abort_controller().AbortController;
    var PassThrough2;
    var Readable2;
    var addAbortListener;
    function destroyer(stream, reading, writing) {
      let finished = false;
      stream.on("close", () => {
        finished = true;
      });
      const cleanup = eos(stream, {
        readable: reading,
        writable: writing
      }, (err) => {
        finished = !err;
      });
      return {
        destroy: (err) => {
          if (finished) return;
          finished = true;
          destroyImpl.destroyer(stream, err || new ERR_STREAM_DESTROYED("pipe"));
        },
        cleanup
      };
    }
    function popCallback(streams) {
      validateFunction(streams[streams.length - 1], "streams[stream.length - 1]");
      return streams.pop();
    }
    function makeAsyncIterable(val) {
      if (isIterable(val)) {
        return val;
      } else if (isReadableNodeStream(val)) {
        return fromReadable(val);
      }
      throw new ERR_INVALID_ARG_TYPE2("val", [
        "Readable",
        "Iterable",
        "AsyncIterable"
      ], val);
    }
    async function* fromReadable(val) {
      if (!Readable2) {
        Readable2 = require_readable();
      }
      yield* Readable2.prototype[SymbolAsyncIterator].call(val);
    }
    async function pumpToNode(iterable, writable, finish, { end }) {
      let error;
      let onresolve = null;
      const resume = (err) => {
        if (err) {
          error = err;
        }
        if (onresolve) {
          const callback = onresolve;
          onresolve = null;
          callback();
        }
      };
      const wait = () => new Promise2((resolve, reject) => {
        if (error) {
          reject(error);
        } else {
          onresolve = () => {
            if (error) {
              reject(error);
            } else {
              resolve();
            }
          };
        }
      });
      writable.on("drain", resume);
      const cleanup = eos(writable, {
        readable: false
      }, resume);
      try {
        if (writable.writableNeedDrain) {
          await wait();
        }
        for await (const chunk of iterable) {
          if (!writable.write(chunk)) {
            await wait();
          }
        }
        if (end) {
          writable.end();
          await wait();
        }
        finish();
      } catch (err) {
        finish(error !== err ? aggregateTwoErrors(error, err) : err);
      } finally {
        cleanup();
        writable.off("drain", resume);
      }
    }
    async function pumpToWeb(readable, writable, finish, { end }) {
      if (isTransformStream(writable)) {
        writable = writable.writable;
      }
      const writer = writable.getWriter();
      try {
        for await (const chunk of readable) {
          await writer.ready;
          writer.write(chunk).catch(() => {
          });
        }
        await writer.ready;
        if (end) {
          await writer.close();
        }
        finish();
      } catch (err) {
        try {
          await writer.abort(err);
          finish(err);
        } catch (err2) {
          finish(err2);
        }
      }
    }
    function pipeline(...streams) {
      return pipelineImpl(streams, once(popCallback(streams)));
    }
    function pipelineImpl(streams, callback, opts) {
      if (streams.length === 1 && ArrayIsArray(streams[0])) {
        streams = streams[0];
      }
      if (streams.length < 2) {
        throw new ERR_MISSING_ARGS("streams");
      }
      const ac = new AbortController();
      const signal = ac.signal;
      const outerSignal = opts === null || opts === void 0 ? void 0 : opts.signal;
      const lastStreamCleanup = [];
      validateAbortSignal(outerSignal, "options.signal");
      function abort() {
        finishImpl(new AbortError2());
      }
      addAbortListener = addAbortListener || require_util().addAbortListener;
      let disposable;
      if (outerSignal) {
        disposable = addAbortListener(outerSignal, abort);
      }
      let error;
      let value;
      const destroys = [];
      let finishCount = 0;
      function finish(err) {
        finishImpl(err, --finishCount === 0);
      }
      function finishImpl(err, final) {
        var _disposable;
        if (err && (!error || error.code === "ERR_STREAM_PREMATURE_CLOSE")) {
          error = err;
        }
        if (!error && !final) {
          return;
        }
        while (destroys.length) {
          destroys.shift()(error);
        }
        ;
        (_disposable = disposable) === null || _disposable === void 0 ? void 0 : _disposable[SymbolDispose]();
        ac.abort();
        if (final) {
          if (!error) {
            lastStreamCleanup.forEach((fn) => fn());
          }
          process2.nextTick(callback, error, value);
        }
      }
      let ret;
      for (let i2 = 0; i2 < streams.length; i2++) {
        const stream = streams[i2];
        const reading = i2 < streams.length - 1;
        const writing = i2 > 0;
        const end = reading || (opts === null || opts === void 0 ? void 0 : opts.end) !== false;
        const isLastStream = i2 === streams.length - 1;
        if (isNodeStream(stream)) {
          let onError2 = function(err) {
            if (err && err.name !== "AbortError" && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
              finish(err);
            }
          };
          var onError = onError2;
          if (end) {
            const { destroy, cleanup } = destroyer(stream, reading, writing);
            destroys.push(destroy);
            if (isReadable(stream) && isLastStream) {
              lastStreamCleanup.push(cleanup);
            }
          }
          stream.on("error", onError2);
          if (isReadable(stream) && isLastStream) {
            lastStreamCleanup.push(() => {
              stream.removeListener("error", onError2);
            });
          }
        }
        if (i2 === 0) {
          if (typeof stream === "function") {
            ret = stream({
              signal
            });
            if (!isIterable(ret)) {
              throw new ERR_INVALID_RETURN_VALUE("Iterable, AsyncIterable or Stream", "source", ret);
            }
          } else if (isIterable(stream) || isReadableNodeStream(stream) || isTransformStream(stream)) {
            ret = stream;
          } else {
            ret = Duplex.from(stream);
          }
        } else if (typeof stream === "function") {
          if (isTransformStream(ret)) {
            var _ret;
            ret = makeAsyncIterable((_ret = ret) === null || _ret === void 0 ? void 0 : _ret.readable);
          } else {
            ret = makeAsyncIterable(ret);
          }
          ret = stream(ret, {
            signal
          });
          if (reading) {
            if (!isIterable(ret, true)) {
              throw new ERR_INVALID_RETURN_VALUE("AsyncIterable", `transform[${i2 - 1}]`, ret);
            }
          } else {
            var _ret2;
            if (!PassThrough2) {
              PassThrough2 = require_passthrough();
            }
            const pt = new PassThrough2({
              objectMode: true
            });
            const then = (_ret2 = ret) === null || _ret2 === void 0 ? void 0 : _ret2.then;
            if (typeof then === "function") {
              finishCount++;
              then.call(ret, (val) => {
                value = val;
                if (val != null) {
                  pt.write(val);
                }
                if (end) {
                  pt.end();
                }
                process2.nextTick(finish);
              }, (err) => {
                pt.destroy(err);
                process2.nextTick(finish, err);
              });
            } else if (isIterable(ret, true)) {
              finishCount++;
              pumpToNode(ret, pt, finish, {
                end
              });
            } else if (isReadableStream(ret) || isTransformStream(ret)) {
              const toRead = ret.readable || ret;
              finishCount++;
              pumpToNode(toRead, pt, finish, {
                end
              });
            } else {
              throw new ERR_INVALID_RETURN_VALUE("AsyncIterable or Promise", "destination", ret);
            }
            ret = pt;
            const { destroy, cleanup } = destroyer(ret, false, true);
            destroys.push(destroy);
            if (isLastStream) {
              lastStreamCleanup.push(cleanup);
            }
          }
        } else if (isNodeStream(stream)) {
          if (isReadableNodeStream(ret)) {
            finishCount += 2;
            const cleanup = pipe(ret, stream, finish, {
              end
            });
            if (isReadable(stream) && isLastStream) {
              lastStreamCleanup.push(cleanup);
            }
          } else if (isTransformStream(ret) || isReadableStream(ret)) {
            const toRead = ret.readable || ret;
            finishCount++;
            pumpToNode(toRead, stream, finish, {
              end
            });
          } else if (isIterable(ret)) {
            finishCount++;
            pumpToNode(ret, stream, finish, {
              end
            });
          } else {
            throw new ERR_INVALID_ARG_TYPE2("val", [
              "Readable",
              "Iterable",
              "AsyncIterable",
              "ReadableStream",
              "TransformStream"
            ], ret);
          }
          ret = stream;
        } else if (isWebStream(stream)) {
          if (isReadableNodeStream(ret)) {
            finishCount++;
            pumpToWeb(makeAsyncIterable(ret), stream, finish, {
              end
            });
          } else if (isReadableStream(ret) || isIterable(ret)) {
            finishCount++;
            pumpToWeb(ret, stream, finish, {
              end
            });
          } else if (isTransformStream(ret)) {
            finishCount++;
            pumpToWeb(ret.readable, stream, finish, {
              end
            });
          } else {
            throw new ERR_INVALID_ARG_TYPE2("val", [
              "Readable",
              "Iterable",
              "AsyncIterable",
              "ReadableStream",
              "TransformStream"
            ], ret);
          }
          ret = stream;
        } else {
          ret = Duplex.from(stream);
        }
      }
      if (signal !== null && signal !== void 0 && signal.aborted || outerSignal !== null && outerSignal !== void 0 && outerSignal.aborted) {
        process2.nextTick(abort);
      }
      return ret;
    }
    function pipe(src, dst, finish, { end }) {
      let ended = false;
      dst.on("close", () => {
        if (!ended) {
          finish(new ERR_STREAM_PREMATURE_CLOSE());
        }
      });
      src.pipe(dst, {
        end: false
      });
      if (end) {
        let endFn2 = function() {
          ended = true;
          dst.end();
        };
        var endFn = endFn2;
        if (isReadableFinished(src)) {
          process2.nextTick(endFn2);
        } else {
          src.once("end", endFn2);
        }
      } else {
        finish();
      }
      eos(src, {
        readable: true,
        writable: false
      }, (err) => {
        const rState = src._readableState;
        if (err && err.code === "ERR_STREAM_PREMATURE_CLOSE" && rState && rState.ended && !rState.errored && !rState.errorEmitted) {
          src.once("end", finish).once("error", finish);
        } else {
          finish(err);
        }
      });
      return eos(dst, {
        readable: false,
        writable: true
      }, finish);
    }
    module.exports = {
      pipelineImpl,
      pipeline
    };
  }
});

// ../../../../../node_modules/.deno/readable-stream@4.5.2/node_modules/readable-stream/lib/internal/streams/compose.js
var require_compose = __commonJS({
  "../../../../../node_modules/.deno/readable-stream@4.5.2/node_modules/readable-stream/lib/internal/streams/compose.js"(exports, module) {
    "use strict";
    var { pipeline } = require_pipeline();
    var Duplex = require_duplex();
    var { destroyer } = require_destroy();
    var { isNodeStream, isReadable, isWritable, isWebStream, isTransformStream, isWritableStream, isReadableStream } = require_utils24();
    var { AbortError: AbortError2, codes: { ERR_INVALID_ARG_VALUE, ERR_MISSING_ARGS } } = require_errors2();
    var eos = require_end_of_stream();
    module.exports = function compose(...streams) {
      if (streams.length === 0) {
        throw new ERR_MISSING_ARGS("streams");
      }
      if (streams.length === 1) {
        return Duplex.from(streams[0]);
      }
      const orgStreams = [
        ...streams
      ];
      if (typeof streams[0] === "function") {
        streams[0] = Duplex.from(streams[0]);
      }
      if (typeof streams[streams.length - 1] === "function") {
        const idx = streams.length - 1;
        streams[idx] = Duplex.from(streams[idx]);
      }
      for (let n = 0; n < streams.length; ++n) {
        if (!isNodeStream(streams[n]) && !isWebStream(streams[n])) {
          continue;
        }
        if (n < streams.length - 1 && !(isReadable(streams[n]) || isReadableStream(streams[n]) || isTransformStream(streams[n]))) {
          throw new ERR_INVALID_ARG_VALUE(`streams[${n}]`, orgStreams[n], "must be readable");
        }
        if (n > 0 && !(isWritable(streams[n]) || isWritableStream(streams[n]) || isTransformStream(streams[n]))) {
          throw new ERR_INVALID_ARG_VALUE(`streams[${n}]`, orgStreams[n], "must be writable");
        }
      }
      let ondrain;
      let onfinish;
      let onreadable;
      let onclose;
      let d;
      function onfinished(err) {
        const cb = onclose;
        onclose = null;
        if (cb) {
          cb(err);
        } else if (err) {
          d.destroy(err);
        } else if (!readable && !writable) {
          d.destroy();
        }
      }
      const head = streams[0];
      const tail = pipeline(streams, onfinished);
      const writable = !!(isWritable(head) || isWritableStream(head) || isTransformStream(head));
      const readable = !!(isReadable(tail) || isReadableStream(tail) || isTransformStream(tail));
      d = new Duplex({
        // TODO (ronag): highWaterMark?
        writableObjectMode: !!(head !== null && head !== void 0 && head.writableObjectMode),
        readableObjectMode: !!(tail !== null && tail !== void 0 && tail.readableObjectMode),
        writable,
        readable
      });
      if (writable) {
        if (isNodeStream(head)) {
          d._write = function(chunk, encoding, callback) {
            if (head.write(chunk, encoding)) {
              callback();
            } else {
              ondrain = callback;
            }
          };
          d._final = function(callback) {
            head.end();
            onfinish = callback;
          };
          head.on("drain", function() {
            if (ondrain) {
              const cb = ondrain;
              ondrain = null;
              cb();
            }
          });
        } else if (isWebStream(head)) {
          const writable2 = isTransformStream(head) ? head.writable : head;
          const writer = writable2.getWriter();
          d._write = async function(chunk, encoding, callback) {
            try {
              await writer.ready;
              writer.write(chunk).catch(() => {
              });
              callback();
            } catch (err) {
              callback(err);
            }
          };
          d._final = async function(callback) {
            try {
              await writer.ready;
              writer.close().catch(() => {
              });
              onfinish = callback;
            } catch (err) {
              callback(err);
            }
          };
        }
        const toRead = isTransformStream(tail) ? tail.readable : tail;
        eos(toRead, () => {
          if (onfinish) {
            const cb = onfinish;
            onfinish = null;
            cb();
          }
        });
      }
      if (readable) {
        if (isNodeStream(tail)) {
          tail.on("readable", function() {
            if (onreadable) {
              const cb = onreadable;
              onreadable = null;
              cb();
            }
          });
          tail.on("end", function() {
            d.push(null);
          });
          d._read = function() {
            while (true) {
              const buf = tail.read();
              if (buf === null) {
                onreadable = d._read;
                return;
              }
              if (!d.push(buf)) {
                return;
              }
            }
          };
        } else if (isWebStream(tail)) {
          const readable2 = isTransformStream(tail) ? tail.readable : tail;
          const reader = readable2.getReader();
          d._read = async function() {
            while (true) {
              try {
                const { value, done } = await reader.read();
                if (!d.push(value)) {
                  return;
                }
                if (done) {
                  d.push(null);
                  return;
                }
              } catch {
                return;
              }
            }
          };
        }
      }
      d._destroy = function(err, callback) {
        if (!err && onclose !== null) {
          err = new AbortError2();
        }
        onreadable = null;
        ondrain = null;
        onfinish = null;
        if (onclose === null) {
          callback(err);
        } else {
          onclose = callback;
          if (isNodeStream(tail)) {
            destroyer(tail, err);
          }
        }
      };
      return d;
    };
  }
});

// ../../../../../node_modules/.deno/readable-stream@4.5.2/node_modules/readable-stream/lib/internal/streams/operators.js
var require_operators = __commonJS({
  "../../../../../node_modules/.deno/readable-stream@4.5.2/node_modules/readable-stream/lib/internal/streams/operators.js"(exports, module) {
    "use strict";
    var AbortController = globalThis.AbortController || require_abort_controller().AbortController;
    var { codes: { ERR_INVALID_ARG_VALUE, ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE2, ERR_MISSING_ARGS, ERR_OUT_OF_RANGE }, AbortError: AbortError2 } = require_errors2();
    var { validateAbortSignal, validateInteger, validateObject } = require_validators();
    var kWeakHandler = require_primordials().Symbol("kWeak");
    var kResistStopPropagation = require_primordials().Symbol("kResistStopPropagation");
    var { finished } = require_end_of_stream();
    var staticCompose = require_compose();
    var { addAbortSignalNoValidate } = require_add_abort_signal();
    var { isWritable, isNodeStream } = require_utils24();
    var { deprecate } = require_util();
    var { ArrayPrototypePush, Boolean: Boolean2, MathFloor, Number: Number2, NumberIsNaN, Promise: Promise2, PromiseReject, PromiseResolve, PromisePrototypeThen, Symbol: Symbol2 } = require_primordials();
    var kEmpty = Symbol2("kEmpty");
    var kEof = Symbol2("kEof");
    function compose(stream, options) {
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      if (isNodeStream(stream) && !isWritable(stream)) {
        throw new ERR_INVALID_ARG_VALUE("stream", stream, "must be writable");
      }
      const composedStream = staticCompose(this, stream);
      if (options !== null && options !== void 0 && options.signal) {
        addAbortSignalNoValidate(options.signal, composedStream);
      }
      return composedStream;
    }
    function map(fn, options) {
      if (typeof fn !== "function") {
        throw new ERR_INVALID_ARG_TYPE2("fn", [
          "Function",
          "AsyncFunction"
        ], fn);
      }
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      let concurrency = 1;
      if ((options === null || options === void 0 ? void 0 : options.concurrency) != null) {
        concurrency = MathFloor(options.concurrency);
      }
      let highWaterMark = concurrency - 1;
      if ((options === null || options === void 0 ? void 0 : options.highWaterMark) != null) {
        highWaterMark = MathFloor(options.highWaterMark);
      }
      validateInteger(concurrency, "options.concurrency", 1);
      validateInteger(highWaterMark, "options.highWaterMark", 0);
      highWaterMark += concurrency;
      return async function* map2() {
        const signal = require_util().AbortSignalAny([
          options === null || options === void 0 ? void 0 : options.signal
        ].filter(Boolean2));
        const stream = this;
        const queue = [];
        const signalOpt = {
          signal
        };
        let next;
        let resume;
        let done = false;
        let cnt = 0;
        function onCatch() {
          done = true;
          afterItemProcessed();
        }
        function afterItemProcessed() {
          cnt -= 1;
          maybeResume();
        }
        function maybeResume() {
          if (resume && !done && cnt < concurrency && queue.length < highWaterMark) {
            resume();
            resume = null;
          }
        }
        async function pump() {
          try {
            for await (let val of stream) {
              if (done) {
                return;
              }
              if (signal.aborted) {
                throw new AbortError2();
              }
              try {
                val = fn(val, signalOpt);
                if (val === kEmpty) {
                  continue;
                }
                val = PromiseResolve(val);
              } catch (err) {
                val = PromiseReject(err);
              }
              cnt += 1;
              PromisePrototypeThen(val, afterItemProcessed, onCatch);
              queue.push(val);
              if (next) {
                next();
                next = null;
              }
              if (!done && (queue.length >= highWaterMark || cnt >= concurrency)) {
                await new Promise2((resolve) => {
                  resume = resolve;
                });
              }
            }
            queue.push(kEof);
          } catch (err) {
            const val = PromiseReject(err);
            PromisePrototypeThen(val, afterItemProcessed, onCatch);
            queue.push(val);
          } finally {
            done = true;
            if (next) {
              next();
              next = null;
            }
          }
        }
        pump();
        try {
          while (true) {
            while (queue.length > 0) {
              const val = await queue[0];
              if (val === kEof) {
                return;
              }
              if (signal.aborted) {
                throw new AbortError2();
              }
              if (val !== kEmpty) {
                yield val;
              }
              queue.shift();
              maybeResume();
            }
            await new Promise2((resolve) => {
              next = resolve;
            });
          }
        } finally {
          done = true;
          if (resume) {
            resume();
            resume = null;
          }
        }
      }.call(this);
    }
    function asIndexedPairs(options = void 0) {
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      return async function* asIndexedPairs2() {
        let index = 0;
        for await (const val of this) {
          var _options$signal;
          if (options !== null && options !== void 0 && (_options$signal = options.signal) !== null && _options$signal !== void 0 && _options$signal.aborted) {
            throw new AbortError2({
              cause: options.signal.reason
            });
          }
          yield [
            index++,
            val
          ];
        }
      }.call(this);
    }
    async function some(fn, options = void 0) {
      for await (const unused of filter.call(this, fn, options)) {
        return true;
      }
      return false;
    }
    async function every(fn, options = void 0) {
      if (typeof fn !== "function") {
        throw new ERR_INVALID_ARG_TYPE2("fn", [
          "Function",
          "AsyncFunction"
        ], fn);
      }
      return !await some.call(this, async (...args) => {
        return !await fn(...args);
      }, options);
    }
    async function find2(fn, options) {
      for await (const result of filter.call(this, fn, options)) {
        return result;
      }
      return void 0;
    }
    async function forEach(fn, options) {
      if (typeof fn !== "function") {
        throw new ERR_INVALID_ARG_TYPE2("fn", [
          "Function",
          "AsyncFunction"
        ], fn);
      }
      async function forEachFn(value, options2) {
        await fn(value, options2);
        return kEmpty;
      }
      for await (const unused of map.call(this, forEachFn, options)) ;
    }
    function filter(fn, options) {
      if (typeof fn !== "function") {
        throw new ERR_INVALID_ARG_TYPE2("fn", [
          "Function",
          "AsyncFunction"
        ], fn);
      }
      async function filterFn(value, options2) {
        if (await fn(value, options2)) {
          return value;
        }
        return kEmpty;
      }
      return map.call(this, filterFn, options);
    }
    var ReduceAwareErrMissingArgs = class extends ERR_MISSING_ARGS {
      constructor() {
        super("reduce");
        this.message = "Reduce of an empty stream requires an initial value";
      }
    };
    async function reduce(reducer, initialValue, options) {
      var _options$signal2;
      if (typeof reducer !== "function") {
        throw new ERR_INVALID_ARG_TYPE2("reducer", [
          "Function",
          "AsyncFunction"
        ], reducer);
      }
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      let hasInitialValue = arguments.length > 1;
      if (options !== null && options !== void 0 && (_options$signal2 = options.signal) !== null && _options$signal2 !== void 0 && _options$signal2.aborted) {
        const err = new AbortError2(void 0, {
          cause: options.signal.reason
        });
        this.once("error", () => {
        });
        await finished(this.destroy(err));
        throw err;
      }
      const ac = new AbortController();
      const signal = ac.signal;
      if (options !== null && options !== void 0 && options.signal) {
        const opts = {
          once: true,
          [kWeakHandler]: this,
          [kResistStopPropagation]: true
        };
        options.signal.addEventListener("abort", () => ac.abort(), opts);
      }
      let gotAnyItemFromStream = false;
      try {
        for await (const value of this) {
          var _options$signal3;
          gotAnyItemFromStream = true;
          if (options !== null && options !== void 0 && (_options$signal3 = options.signal) !== null && _options$signal3 !== void 0 && _options$signal3.aborted) {
            throw new AbortError2();
          }
          if (!hasInitialValue) {
            initialValue = value;
            hasInitialValue = true;
          } else {
            initialValue = await reducer(initialValue, value, {
              signal
            });
          }
        }
        if (!gotAnyItemFromStream && !hasInitialValue) {
          throw new ReduceAwareErrMissingArgs();
        }
      } finally {
        ac.abort();
      }
      return initialValue;
    }
    async function toArray(options) {
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      const result = [];
      for await (const val of this) {
        var _options$signal4;
        if (options !== null && options !== void 0 && (_options$signal4 = options.signal) !== null && _options$signal4 !== void 0 && _options$signal4.aborted) {
          throw new AbortError2(void 0, {
            cause: options.signal.reason
          });
        }
        ArrayPrototypePush(result, val);
      }
      return result;
    }
    function flatMap(fn, options) {
      const values = map.call(this, fn, options);
      return async function* flatMap2() {
        for await (const val of values) {
          yield* val;
        }
      }.call(this);
    }
    function toIntegerOrInfinity(number) {
      number = Number2(number);
      if (NumberIsNaN(number)) {
        return 0;
      }
      if (number < 0) {
        throw new ERR_OUT_OF_RANGE("number", ">= 0", number);
      }
      return number;
    }
    function drop(number, options = void 0) {
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      number = toIntegerOrInfinity(number);
      return async function* drop2() {
        var _options$signal5;
        if (options !== null && options !== void 0 && (_options$signal5 = options.signal) !== null && _options$signal5 !== void 0 && _options$signal5.aborted) {
          throw new AbortError2();
        }
        for await (const val of this) {
          var _options$signal6;
          if (options !== null && options !== void 0 && (_options$signal6 = options.signal) !== null && _options$signal6 !== void 0 && _options$signal6.aborted) {
            throw new AbortError2();
          }
          if (number-- <= 0) {
            yield val;
          }
        }
      }.call(this);
    }
    function take(number, options = void 0) {
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      number = toIntegerOrInfinity(number);
      return async function* take2() {
        var _options$signal7;
        if (options !== null && options !== void 0 && (_options$signal7 = options.signal) !== null && _options$signal7 !== void 0 && _options$signal7.aborted) {
          throw new AbortError2();
        }
        for await (const val of this) {
          var _options$signal8;
          if (options !== null && options !== void 0 && (_options$signal8 = options.signal) !== null && _options$signal8 !== void 0 && _options$signal8.aborted) {
            throw new AbortError2();
          }
          if (number-- > 0) {
            yield val;
          }
          if (number <= 0) {
            return;
          }
        }
      }.call(this);
    }
    module.exports.streamReturningOperators = {
      asIndexedPairs: deprecate(asIndexedPairs, "readable.asIndexedPairs will be removed in a future version."),
      drop,
      filter,
      flatMap,
      map,
      take,
      compose
    };
    module.exports.promiseReturningOperators = {
      every,
      forEach,
      reduce,
      toArray,
      some,
      find: find2
    };
  }
});

// ../../../../../node_modules/.deno/readable-stream@4.5.2/node_modules/readable-stream/lib/stream/promises.js
var require_promises = __commonJS({
  "../../../../../node_modules/.deno/readable-stream@4.5.2/node_modules/readable-stream/lib/stream/promises.js"(exports, module) {
    "use strict";
    var { ArrayPrototypePop, Promise: Promise2 } = require_primordials();
    var { isIterable, isNodeStream, isWebStream } = require_utils24();
    var { pipelineImpl: pl } = require_pipeline();
    var { finished } = require_end_of_stream();
    require_stream();
    function pipeline(...streams) {
      return new Promise2((resolve, reject) => {
        let signal;
        let end;
        const lastArg = streams[streams.length - 1];
        if (lastArg && typeof lastArg === "object" && !isNodeStream(lastArg) && !isIterable(lastArg) && !isWebStream(lastArg)) {
          const options = ArrayPrototypePop(streams);
          signal = options.signal;
          end = options.end;
        }
        pl(streams, (err, value) => {
          if (err) {
            reject(err);
          } else {
            resolve(value);
          }
        }, {
          signal,
          end
        });
      });
    }
    module.exports = {
      finished,
      pipeline
    };
  }
});

// ../../../../../node_modules/.deno/readable-stream@4.5.2/node_modules/readable-stream/lib/stream.js
var require_stream = __commonJS({
  "../../../../../node_modules/.deno/readable-stream@4.5.2/node_modules/readable-stream/lib/stream.js"(exports, module) {
    var { Buffer: Buffer2 } = __require("node:buffer");
    var { ObjectDefineProperty, ObjectKeys, ReflectApply } = require_primordials();
    var { promisify: { custom: customPromisify } } = require_util();
    var { streamReturningOperators, promiseReturningOperators } = require_operators();
    var { codes: { ERR_ILLEGAL_CONSTRUCTOR } } = require_errors2();
    var compose = require_compose();
    var { setDefaultHighWaterMark, getDefaultHighWaterMark } = require_state();
    var { pipeline } = require_pipeline();
    var { destroyer } = require_destroy();
    var eos = require_end_of_stream();
    var promises = require_promises();
    var utils = require_utils24();
    var Stream2 = module.exports = require_legacy().Stream;
    Stream2.isDestroyed = utils.isDestroyed;
    Stream2.isDisturbed = utils.isDisturbed;
    Stream2.isErrored = utils.isErrored;
    Stream2.isReadable = utils.isReadable;
    Stream2.isWritable = utils.isWritable;
    Stream2.Readable = require_readable();
    for (const key of ObjectKeys(streamReturningOperators)) {
      let fn2 = function(...args) {
        if (new.target) {
          throw ERR_ILLEGAL_CONSTRUCTOR();
        }
        return Stream2.Readable.from(ReflectApply(op, this, args));
      };
      fn = fn2;
      const op = streamReturningOperators[key];
      ObjectDefineProperty(fn2, "name", {
        __proto__: null,
        value: op.name
      });
      ObjectDefineProperty(fn2, "length", {
        __proto__: null,
        value: op.length
      });
      ObjectDefineProperty(Stream2.Readable.prototype, key, {
        __proto__: null,
        value: fn2,
        enumerable: false,
        configurable: true,
        writable: true
      });
    }
    var fn;
    for (const key of ObjectKeys(promiseReturningOperators)) {
      let fn2 = function(...args) {
        if (new.target) {
          throw ERR_ILLEGAL_CONSTRUCTOR();
        }
        return ReflectApply(op, this, args);
      };
      fn = fn2;
      const op = promiseReturningOperators[key];
      ObjectDefineProperty(fn2, "name", {
        __proto__: null,
        value: op.name
      });
      ObjectDefineProperty(fn2, "length", {
        __proto__: null,
        value: op.length
      });
      ObjectDefineProperty(Stream2.Readable.prototype, key, {
        __proto__: null,
        value: fn2,
        enumerable: false,
        configurable: true,
        writable: true
      });
    }
    var fn;
    Stream2.Writable = require_writable();
    Stream2.Duplex = require_duplex();
    Stream2.Transform = require_transform();
    Stream2.PassThrough = require_passthrough();
    Stream2.pipeline = pipeline;
    var { addAbortSignal } = require_add_abort_signal();
    Stream2.addAbortSignal = addAbortSignal;
    Stream2.finished = eos;
    Stream2.destroy = destroyer;
    Stream2.compose = compose;
    Stream2.setDefaultHighWaterMark = setDefaultHighWaterMark;
    Stream2.getDefaultHighWaterMark = getDefaultHighWaterMark;
    ObjectDefineProperty(Stream2, "promises", {
      __proto__: null,
      configurable: true,
      enumerable: true,
      get() {
        return promises;
      }
    });
    ObjectDefineProperty(pipeline, customPromisify, {
      __proto__: null,
      enumerable: true,
      get() {
        return promises.pipeline;
      }
    });
    ObjectDefineProperty(eos, customPromisify, {
      __proto__: null,
      enumerable: true,
      get() {
        return promises.finished;
      }
    });
    Stream2.Stream = Stream2;
    Stream2._isUint8Array = function isUint8Array(value) {
      return value instanceof Uint8Array;
    };
    Stream2._uint8ArrayToBuffer = function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);
    };
  }
});

// ../../../../../node_modules/.deno/readable-stream@4.5.2/node_modules/readable-stream/lib/ours/index.js
var require_ours = __commonJS({
  "../../../../../node_modules/.deno/readable-stream@4.5.2/node_modules/readable-stream/lib/ours/index.js"(exports, module) {
    "use strict";
    var Stream2 = __require("node:stream");
    if (Stream2 && process.env.READABLE_STREAM === "disable") {
      const promises = Stream2.promises;
      module.exports._uint8ArrayToBuffer = Stream2._uint8ArrayToBuffer;
      module.exports._isUint8Array = Stream2._isUint8Array;
      module.exports.isDisturbed = Stream2.isDisturbed;
      module.exports.isErrored = Stream2.isErrored;
      module.exports.isReadable = Stream2.isReadable;
      module.exports.Readable = Stream2.Readable;
      module.exports.Writable = Stream2.Writable;
      module.exports.Duplex = Stream2.Duplex;
      module.exports.Transform = Stream2.Transform;
      module.exports.PassThrough = Stream2.PassThrough;
      module.exports.addAbortSignal = Stream2.addAbortSignal;
      module.exports.finished = Stream2.finished;
      module.exports.destroy = Stream2.destroy;
      module.exports.pipeline = Stream2.pipeline;
      module.exports.compose = Stream2.compose;
      Object.defineProperty(Stream2, "promises", {
        configurable: true,
        enumerable: true,
        get() {
          return promises;
        }
      });
      module.exports.Stream = Stream2.Stream;
    } else {
      const CustomStream = require_stream();
      const promises = require_promises();
      const originalDestroy = CustomStream.Readable.destroy;
      module.exports = CustomStream.Readable;
      module.exports._uint8ArrayToBuffer = CustomStream._uint8ArrayToBuffer;
      module.exports._isUint8Array = CustomStream._isUint8Array;
      module.exports.isDisturbed = CustomStream.isDisturbed;
      module.exports.isErrored = CustomStream.isErrored;
      module.exports.isReadable = CustomStream.isReadable;
      module.exports.Readable = CustomStream.Readable;
      module.exports.Writable = CustomStream.Writable;
      module.exports.Duplex = CustomStream.Duplex;
      module.exports.Transform = CustomStream.Transform;
      module.exports.PassThrough = CustomStream.PassThrough;
      module.exports.addAbortSignal = CustomStream.addAbortSignal;
      module.exports.finished = CustomStream.finished;
      module.exports.destroy = CustomStream.destroy;
      module.exports.destroy = originalDestroy;
      module.exports.pipeline = CustomStream.pipeline;
      module.exports.compose = CustomStream.compose;
      Object.defineProperty(CustomStream, "promises", {
        configurable: true,
        enumerable: true,
        get() {
          return promises;
        }
      });
      module.exports.Stream = CustomStream.Stream;
    }
    module.exports.default = module.exports;
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/input/io/get-stream/buffer-stream.js
var require_buffer_stream = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/input/io/get-stream/buffer-stream.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = bufferStream;
    var readable_stream_1 = require_ours();
    function bufferStream(opts) {
      opts = Object.assign({}, opts);
      const array = opts.array;
      let encoding = opts.encoding;
      const buffer = encoding === "buffer";
      let objectMode = false;
      if (array) {
        objectMode = !(encoding || buffer);
      } else {
        encoding = encoding || "utf8";
      }
      if (buffer) {
        encoding = void 0;
      }
      let len = 0;
      const ret = [];
      const stream = new readable_stream_1.PassThrough({
        objectMode
      });
      if (encoding) {
        stream.setEncoding(encoding);
      }
      stream.on("data", (chunk) => {
        ret.push(chunk);
        if (objectMode) {
          len = ret.length;
        } else {
          len += chunk.length;
        }
      });
      stream.getBufferedValue = () => {
        if (array) {
          return ret;
        }
        return buffer ? Buffer.concat(ret, len) : ret.join("");
      };
      stream.getBufferedLength = () => len;
      return stream;
    }
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/input/io/get-stream/index.js
var require_get_stream = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/input/io/get-stream/index.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : {
        "default": mod
      };
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.getStream = getStream;
    exports.buffer = buffer;
    exports.array = array;
    var buffer_stream_1 = __importDefault(require_buffer_stream());
    function getStream(inputStream_1) {
      return __awaiter(this, arguments, void 0, function* (inputStream, opts = {}) {
        var _a;
        if (!inputStream) {
          return yield Promise.reject(new Error("Expected a stream"));
        }
        opts = Object.assign({
          maxBuffer: Number.POSITIVE_INFINITY
        }, opts);
        const maxBuffer = (_a = opts.maxBuffer) !== null && _a !== void 0 ? _a : Number.POSITIVE_INFINITY;
        let stream;
        let clean;
        const p = new Promise((resolve, reject) => {
          const error = (err) => {
            if (err) {
              err.bufferedData = stream.getBufferedValue();
            }
            reject(err);
          };
          stream = (0, buffer_stream_1.default)(opts);
          inputStream.once("error", error);
          inputStream.pipe(stream);
          stream.on("data", () => {
            if (stream.getBufferedLength() > maxBuffer) {
              reject(new Error("maxBuffer exceeded"));
            }
          });
          stream.once("error", error);
          stream.on("end", resolve);
          clean = () => {
            if (inputStream.unpipe) {
              inputStream.unpipe(stream);
            }
          };
        });
        return yield p.then(clean, clean).then(() => stream.getBufferedValue());
      });
    }
    function buffer(stream, opts = {}) {
      void getStream(stream, Object.assign({}, opts, {
        encoding: "buffer"
      }));
    }
    function array(stream, opts = {}) {
      void getStream(stream, Object.assign({}, opts, {
        array: true
      }));
    }
  }
});

// ../../../../../node_modules/.deno/@glideapps+ts-necessities@2.2.3/node_modules/@glideapps/ts-necessities/dist/default-map.js
var require_default_map = __commonJS({
  "../../../../../node_modules/.deno/@glideapps+ts-necessities@2.2.3/node_modules/@glideapps/ts-necessities/dist/default-map.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.DefaultMap = void 0;
    var DefaultMap = class extends Map {
      /**
         *
         * @param _defaultFunc Must return the default value for key `k`.  Will only be called when necessary.
         * @param initKVPs An array of [key, value] arrays to initialize the map with.
         */
      constructor(_defaultFunc, initKVPs) {
        super(initKVPs);
        this._defaultFunc = _defaultFunc;
      }
      /**
         * Returns the value for `k`.  If `k` is not present, creates
         * the default value via [[_defaultFunc]], sets that default
         * as the value for `k` and returns it.
         */
      get(k) {
        let v = super.get(k);
        if (v === void 0) {
          if (this.has(k)) return v;
          v = this._defaultFunc(k);
          this.set(k, v);
        }
        return v;
      }
      /**
         * Sets the value for `k` to `f(v)` where `v` is the previous
         * value for `k`, or the default if not present.  Returns the new
         * value.
         *
         * These two lines are equivalent:
         *
         * ```
         * m.set("foo", m.get("foo") + 1);
         * m.update("foo", x => x + 1);
         * ```
         */
      update(k, f) {
        const v = f(this.get(k));
        this.set(k, v);
        return v;
      }
    };
    exports.DefaultMap = DefaultMap;
  }
});

// ../../../../../node_modules/.deno/@glideapps+ts-necessities@2.2.3/node_modules/@glideapps/ts-necessities/dist/branded-strings.js
var require_branded_strings = __commonJS({
  "../../../../../node_modules/.deno/@glideapps+ts-necessities@2.2.3/node_modules/@glideapps/ts-necessities/dist/branded-strings.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.makeBrandString = exports.brandString = void 0;
    function brandString(s) {
      return s;
    }
    exports.brandString = brandString;
    function makeBrandString() {
      return brandString;
    }
    exports.makeBrandString = makeBrandString;
  }
});

// ../../../../../node_modules/.deno/@glideapps+ts-necessities@2.2.3/node_modules/@glideapps/ts-necessities/dist/index.js
var require_dist3 = __commonJS({
  "../../../../../node_modules/.deno/@glideapps+ts-necessities@2.2.3/node_modules/@glideapps/ts-necessities/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.makeBrandString = exports.brandString = exports.DefaultMap = exports.exceptionToError = exports.exceptionToString = exports.filterUndefined = exports.mapFilterUndefined = exports.hasOwnProperty = exports.isArray = exports.isEnumValue = exports.definedMap = exports.reduceTwo = exports.sleep = exports.dontAwait = exports.defined = exports.assertNever = exports.assert = exports.panic = exports.proveNever = exports.proveType = void 0;
    function proveType(_val) {
    }
    exports.proveType = proveType;
    function proveNever(_never, message, result) {
      console.trace(message);
      return result;
    }
    exports.proveNever = proveNever;
    function panic(message = "This should not happen") {
      console.trace(message);
      debugger;
      throw new Error(message);
    }
    exports.panic = panic;
    function assert(fact, message = "Assertion failed") {
      if (fact) return;
      return panic(message);
    }
    exports.assert = assert;
    function assertNever(_never, message = "`never` happened") {
      return panic(message);
    }
    exports.assertNever = assertNever;
    function defined(v, reason) {
      if (v === void 0) {
        return panic("Value was undefined but should be defined" + (reason !== void 0 ? ` because: ${reason}` : ""));
      }
      return v;
    }
    exports.defined = defined;
    function dontAwait(p) {
      if (!(p instanceof Promise)) return;
      p.catch((e) => {
        console.trace("Unhandled error from unawaited promise", e);
        throw e;
      });
    }
    exports.dontAwait = dontAwait;
    function sleep(ms) {
      return new Promise((resolve) => {
        setTimeout(resolve, ms);
      });
    }
    exports.sleep = sleep;
    function reduceTwo(a, b, f) {
      if (a === void 0) return b;
      if (b === void 0) return a;
      return f(a, b);
    }
    exports.reduceTwo = reduceTwo;
    function definedMap(x, f) {
      if (x === void 0) return void 0;
      return f(x);
    }
    exports.definedMap = definedMap;
    function isEnumValue(e, x) {
      return Object.keys(e).map((k) => e[k]).some((v) => v === x);
    }
    exports.isEnumValue = isEnumValue;
    function isArray(x) {
      return Array.isArray(x);
    }
    exports.isArray = isArray;
    function hasOwnProperty(obj2, name) {
      if (obj2 === void 0 || obj2 === null) return false;
      return Object.prototype.hasOwnProperty.call(obj2, name);
    }
    exports.hasOwnProperty = hasOwnProperty;
    function mapFilterUndefined(iterable, f) {
      const result = [];
      let i2 = 0;
      for (const x of iterable) {
        const y = f(x, i2);
        i2 += 1;
        if (y === void 0) continue;
        result.push(y);
      }
      return result;
    }
    exports.mapFilterUndefined = mapFilterUndefined;
    function filterUndefined(arr) {
      const result = [];
      for (const x of arr) {
        if (x !== void 0) {
          result.push(x);
        }
      }
      return result;
    }
    exports.filterUndefined = filterUndefined;
    function exceptionToString(e) {
      if (e === void 0) return "";
      try {
        return e.toString();
      } catch (f) {
        try {
          return `Exception can't be stringified: ${exceptionToString(f)}`;
        } catch (_a) {
          return "Exception can't be stringified";
        }
      }
    }
    exports.exceptionToString = exceptionToString;
    function exceptionToError(e) {
      if (e instanceof Error) {
        return e;
      } else {
        return new Error(exceptionToString(e));
      }
    }
    exports.exceptionToError = exceptionToError;
    var default_map_1 = require_default_map();
    Object.defineProperty(exports, "DefaultMap", {
      enumerable: true,
      get: function() {
        return default_map_1.DefaultMap;
      }
    });
    var branded_strings_1 = require_branded_strings();
    Object.defineProperty(exports, "brandString", {
      enumerable: true,
      get: function() {
        return branded_strings_1.brandString;
      }
    });
    Object.defineProperty(exports, "makeBrandString", {
      enumerable: true,
      get: function() {
        return branded_strings_1.makeBrandString;
      }
    });
  }
});

// ../../../../../node_modules/.deno/browser-or-node@3.0.0/node_modules/browser-or-node/dist/index.js
var require_dist4 = __commonJS({
  "../../../../../node_modules/.deno/browser-or-node@3.0.0/node_modules/browser-or-node/dist/index.js"(exports, module) {
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all) __defProp2(target, name, {
        get: all[name],
        enumerable: true
      });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from)) if (!__hasOwnProp2.call(to, key) && key !== except) __defProp2(to, key, {
          get: () => from[key],
          enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable
        });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", {
      value: true
    }), mod);
    var src_exports = {};
    __export2(src_exports, {
      isBrowser: () => isBrowser,
      isBun: () => isBun,
      isDeno: () => isDeno,
      isJsDom: () => isJsDom,
      isNode: () => isNode,
      isWebWorker: () => isWebWorker
    });
    module.exports = __toCommonJS2(src_exports);
    var isBrowser = typeof window !== "undefined" && typeof window.document !== "undefined";
    var isNode = (
      // @ts-expect-error
      typeof process !== "undefined" && // @ts-expect-error
      process.versions != null && // @ts-expect-error
      process.versions.node != null
    );
    var isWebWorker = typeof self === "object" && self.constructor && self.constructor.name === "DedicatedWorkerGlobalScope";
    var isJsDom = typeof window !== "undefined" && window.name === "nodejs" || typeof navigator !== "undefined" && "userAgent" in navigator && typeof navigator.userAgent === "string" && (navigator.userAgent.includes("Node.js") || navigator.userAgent.includes("jsdom"));
    var isDeno = (
      // @ts-expect-error
      typeof Deno !== "undefined" && // @ts-expect-error
      typeof Deno.version !== "undefined" && // @ts-expect-error
      typeof Deno.version.deno !== "undefined"
    );
    var isBun = typeof process !== "undefined" && process.versions != null && process.versions.bun != null;
  }
});

// ../../../../../node_modules/.deno/is-url@1.2.4/node_modules/is-url/index.js
var require_is_url = __commonJS({
  "../../../../../node_modules/.deno/is-url@1.2.4/node_modules/is-url/index.js"(exports, module) {
    module.exports = isUrl;
    var protocolAndDomainRE = /^(?:\w+:)?\/\/(\S+)$/;
    var localhostDomainRE = /^localhost[\:?\d]*(?:[^\:?\d]\S*)?$/;
    var nonLocalhostDomainRE = /^[^\s\.]+\.\S{2,}$/;
    function isUrl(string) {
      if (typeof string !== "string") {
        return false;
      }
      var match2 = string.match(protocolAndDomainRE);
      if (!match2) {
        return false;
      }
      var everythingAfterProtocol = match2[1];
      if (!everythingAfterProtocol) {
        return false;
      }
      if (localhostDomainRE.test(everythingAfterProtocol) || nonLocalhostDomainRE.test(everythingAfterProtocol)) {
        return true;
      }
      return false;
    }
  }
});

// ../../../../../node_modules/.deno/webidl-conversions@3.0.1/node_modules/webidl-conversions/lib/index.js
var require_lib = __commonJS({
  "../../../../../node_modules/.deno/webidl-conversions@3.0.1/node_modules/webidl-conversions/lib/index.js"(exports, module) {
    "use strict";
    var conversions = {};
    module.exports = conversions;
    function sign(x) {
      return x < 0 ? -1 : 1;
    }
    function evenRound(x) {
      if (x % 1 === 0.5 && (x & 1) === 0) {
        return Math.floor(x);
      } else {
        return Math.round(x);
      }
    }
    function createNumberConversion(bitLength, typeOpts) {
      if (!typeOpts.unsigned) {
        --bitLength;
      }
      const lowerBound = typeOpts.unsigned ? 0 : -Math.pow(2, bitLength);
      const upperBound = Math.pow(2, bitLength) - 1;
      const moduloVal = typeOpts.moduloBitLength ? Math.pow(2, typeOpts.moduloBitLength) : Math.pow(2, bitLength);
      const moduloBound = typeOpts.moduloBitLength ? Math.pow(2, typeOpts.moduloBitLength - 1) : Math.pow(2, bitLength - 1);
      return function(V, opts) {
        if (!opts) opts = {};
        let x = +V;
        if (opts.enforceRange) {
          if (!Number.isFinite(x)) {
            throw new TypeError("Argument is not a finite number");
          }
          x = sign(x) * Math.floor(Math.abs(x));
          if (x < lowerBound || x > upperBound) {
            throw new TypeError("Argument is not in byte range");
          }
          return x;
        }
        if (!isNaN(x) && opts.clamp) {
          x = evenRound(x);
          if (x < lowerBound) x = lowerBound;
          if (x > upperBound) x = upperBound;
          return x;
        }
        if (!Number.isFinite(x) || x === 0) {
          return 0;
        }
        x = sign(x) * Math.floor(Math.abs(x));
        x = x % moduloVal;
        if (!typeOpts.unsigned && x >= moduloBound) {
          return x - moduloVal;
        } else if (typeOpts.unsigned) {
          if (x < 0) {
            x += moduloVal;
          } else if (x === -0) {
            return 0;
          }
        }
        return x;
      };
    }
    conversions["void"] = function() {
      return void 0;
    };
    conversions["boolean"] = function(val) {
      return !!val;
    };
    conversions["byte"] = createNumberConversion(8, {
      unsigned: false
    });
    conversions["octet"] = createNumberConversion(8, {
      unsigned: true
    });
    conversions["short"] = createNumberConversion(16, {
      unsigned: false
    });
    conversions["unsigned short"] = createNumberConversion(16, {
      unsigned: true
    });
    conversions["long"] = createNumberConversion(32, {
      unsigned: false
    });
    conversions["unsigned long"] = createNumberConversion(32, {
      unsigned: true
    });
    conversions["long long"] = createNumberConversion(32, {
      unsigned: false,
      moduloBitLength: 64
    });
    conversions["unsigned long long"] = createNumberConversion(32, {
      unsigned: true,
      moduloBitLength: 64
    });
    conversions["double"] = function(V) {
      const x = +V;
      if (!Number.isFinite(x)) {
        throw new TypeError("Argument is not a finite floating-point value");
      }
      return x;
    };
    conversions["unrestricted double"] = function(V) {
      const x = +V;
      if (isNaN(x)) {
        throw new TypeError("Argument is NaN");
      }
      return x;
    };
    conversions["float"] = conversions["double"];
    conversions["unrestricted float"] = conversions["unrestricted double"];
    conversions["DOMString"] = function(V, opts) {
      if (!opts) opts = {};
      if (opts.treatNullAsEmptyString && V === null) {
        return "";
      }
      return String(V);
    };
    conversions["ByteString"] = function(V, opts) {
      const x = String(V);
      let c = void 0;
      for (let i2 = 0; (c = x.codePointAt(i2)) !== void 0; ++i2) {
        if (c > 255) {
          throw new TypeError("Argument is not a valid bytestring");
        }
      }
      return x;
    };
    conversions["USVString"] = function(V) {
      const S = String(V);
      const n = S.length;
      const U = [];
      for (let i2 = 0; i2 < n; ++i2) {
        const c = S.charCodeAt(i2);
        if (c < 55296 || c > 57343) {
          U.push(String.fromCodePoint(c));
        } else if (56320 <= c && c <= 57343) {
          U.push(String.fromCodePoint(65533));
        } else {
          if (i2 === n - 1) {
            U.push(String.fromCodePoint(65533));
          } else {
            const d = S.charCodeAt(i2 + 1);
            if (56320 <= d && d <= 57343) {
              const a = c & 1023;
              const b = d & 1023;
              U.push(String.fromCodePoint((2 << 15) + (2 << 9) * a + b));
              ++i2;
            } else {
              U.push(String.fromCodePoint(65533));
            }
          }
        }
      }
      return U.join("");
    };
    conversions["Date"] = function(V, opts) {
      if (!(V instanceof Date)) {
        throw new TypeError("Argument is not a Date object");
      }
      if (isNaN(V)) {
        return void 0;
      }
      return V;
    };
    conversions["RegExp"] = function(V, opts) {
      if (!(V instanceof RegExp)) {
        V = new RegExp(V);
      }
      return V;
    };
  }
});

// ../../../../../node_modules/.deno/whatwg-url@5.0.0/node_modules/whatwg-url/lib/utils.js
var require_utils25 = __commonJS({
  "../../../../../node_modules/.deno/whatwg-url@5.0.0/node_modules/whatwg-url/lib/utils.js"(exports, module) {
    "use strict";
    module.exports.mixin = function mixin(target, source) {
      const keys = Object.getOwnPropertyNames(source);
      for (let i2 = 0; i2 < keys.length; ++i2) {
        Object.defineProperty(target, keys[i2], Object.getOwnPropertyDescriptor(source, keys[i2]));
      }
    };
    module.exports.wrapperSymbol = Symbol("wrapper");
    module.exports.implSymbol = Symbol("impl");
    module.exports.wrapperForImpl = function(impl) {
      return impl[module.exports.wrapperSymbol];
    };
    module.exports.implForWrapper = function(wrapper) {
      return wrapper[module.exports.implSymbol];
    };
  }
});

// ../../../../../node_modules/.deno/tr46@0.0.3/node_modules/tr46/lib/mappingTable.json
var require_mappingTable = __commonJS({
  "../../../../../node_modules/.deno/tr46@0.0.3/node_modules/tr46/lib/mappingTable.json"(exports, module) {
    module.exports = [[[0, 44], "disallowed_STD3_valid"], [[45, 46], "valid"], [[47, 47], "disallowed_STD3_valid"], [[48, 57], "valid"], [[58, 64], "disallowed_STD3_valid"], [[65, 65], "mapped", [97]], [[66, 66], "mapped", [98]], [[67, 67], "mapped", [99]], [[68, 68], "mapped", [100]], [[69, 69], "mapped", [101]], [[70, 70], "mapped", [102]], [[71, 71], "mapped", [103]], [[72, 72], "mapped", [104]], [[73, 73], "mapped", [105]], [[74, 74], "mapped", [106]], [[75, 75], "mapped", [107]], [[76, 76], "mapped", [108]], [[77, 77], "mapped", [109]], [[78, 78], "mapped", [110]], [[79, 79], "mapped", [111]], [[80, 80], "mapped", [112]], [[81, 81], "mapped", [113]], [[82, 82], "mapped", [114]], [[83, 83], "mapped", [115]], [[84, 84], "mapped", [116]], [[85, 85], "mapped", [117]], [[86, 86], "mapped", [118]], [[87, 87], "mapped", [119]], [[88, 88], "mapped", [120]], [[89, 89], "mapped", [121]], [[90, 90], "mapped", [122]], [[91, 96], "disallowed_STD3_valid"], [[97, 122], "valid"], [[123, 127], "disallowed_STD3_valid"], [[128, 159], "disallowed"], [[160, 160], "disallowed_STD3_mapped", [32]], [[161, 167], "valid", [], "NV8"], [[168, 168], "disallowed_STD3_mapped", [32, 776]], [[169, 169], "valid", [], "NV8"], [[170, 170], "mapped", [97]], [[171, 172], "valid", [], "NV8"], [[173, 173], "ignored"], [[174, 174], "valid", [], "NV8"], [[175, 175], "disallowed_STD3_mapped", [32, 772]], [[176, 177], "valid", [], "NV8"], [[178, 178], "mapped", [50]], [[179, 179], "mapped", [51]], [[180, 180], "disallowed_STD3_mapped", [32, 769]], [[181, 181], "mapped", [956]], [[182, 182], "valid", [], "NV8"], [[183, 183], "valid"], [[184, 184], "disallowed_STD3_mapped", [32, 807]], [[185, 185], "mapped", [49]], [[186, 186], "mapped", [111]], [[187, 187], "valid", [], "NV8"], [[188, 188], "mapped", [49, 8260, 52]], [[189, 189], "mapped", [49, 8260, 50]], [[190, 190], "mapped", [51, 8260, 52]], [[191, 191], "valid", [], "NV8"], [[192, 192], "mapped", [224]], [[193, 193], "mapped", [225]], [[194, 194], "mapped", [226]], [[195, 195], "mapped", [227]], [[196, 196], "mapped", [228]], [[197, 197], "mapped", [229]], [[198, 198], "mapped", [230]], [[199, 199], "mapped", [231]], [[200, 200], "mapped", [232]], [[201, 201], "mapped", [233]], [[202, 202], "mapped", [234]], [[203, 203], "mapped", [235]], [[204, 204], "mapped", [236]], [[205, 205], "mapped", [237]], [[206, 206], "mapped", [238]], [[207, 207], "mapped", [239]], [[208, 208], "mapped", [240]], [[209, 209], "mapped", [241]], [[210, 210], "mapped", [242]], [[211, 211], "mapped", [243]], [[212, 212], "mapped", [244]], [[213, 213], "mapped", [245]], [[214, 214], "mapped", [246]], [[215, 215], "valid", [], "NV8"], [[216, 216], "mapped", [248]], [[217, 217], "mapped", [249]], [[218, 218], "mapped", [250]], [[219, 219], "mapped", [251]], [[220, 220], "mapped", [252]], [[221, 221], "mapped", [253]], [[222, 222], "mapped", [254]], [[223, 223], "deviation", [115, 115]], [[224, 246], "valid"], [[247, 247], "valid", [], "NV8"], [[248, 255], "valid"], [[256, 256], "mapped", [257]], [[257, 257], "valid"], [[258, 258], "mapped", [259]], [[259, 259], "valid"], [[260, 260], "mapped", [261]], [[261, 261], "valid"], [[262, 262], "mapped", [263]], [[263, 263], "valid"], [[264, 264], "mapped", [265]], [[265, 265], "valid"], [[266, 266], "mapped", [267]], [[267, 267], "valid"], [[268, 268], "mapped", [269]], [[269, 269], "valid"], [[270, 270], "mapped", [271]], [[271, 271], "valid"], [[272, 272], "mapped", [273]], [[273, 273], "valid"], [[274, 274], "mapped", [275]], [[275, 275], "valid"], [[276, 276], "mapped", [277]], [[277, 277], "valid"], [[278, 278], "mapped", [279]], [[279, 279], "valid"], [[280, 280], "mapped", [281]], [[281, 281], "valid"], [[282, 282], "mapped", [283]], [[283, 283], "valid"], [[284, 284], "mapped", [285]], [[285, 285], "valid"], [[286, 286], "mapped", [287]], [[287, 287], "valid"], [[288, 288], "mapped", [289]], [[289, 289], "valid"], [[290, 290], "mapped", [291]], [[291, 291], "valid"], [[292, 292], "mapped", [293]], [[293, 293], "valid"], [[294, 294], "mapped", [295]], [[295, 295], "valid"], [[296, 296], "mapped", [297]], [[297, 297], "valid"], [[298, 298], "mapped", [299]], [[299, 299], "valid"], [[300, 300], "mapped", [301]], [[301, 301], "valid"], [[302, 302], "mapped", [303]], [[303, 303], "valid"], [[304, 304], "mapped", [105, 775]], [[305, 305], "valid"], [[306, 307], "mapped", [105, 106]], [[308, 308], "mapped", [309]], [[309, 309], "valid"], [[310, 310], "mapped", [311]], [[311, 312], "valid"], [[313, 313], "mapped", [314]], [[314, 314], "valid"], [[315, 315], "mapped", [316]], [[316, 316], "valid"], [[317, 317], "mapped", [318]], [[318, 318], "valid"], [[319, 320], "mapped", [108, 183]], [[321, 321], "mapped", [322]], [[322, 322], "valid"], [[323, 323], "mapped", [324]], [[324, 324], "valid"], [[325, 325], "mapped", [326]], [[326, 326], "valid"], [[327, 327], "mapped", [328]], [[328, 328], "valid"], [[329, 329], "mapped", [700, 110]], [[330, 330], "mapped", [331]], [[331, 331], "valid"], [[332, 332], "mapped", [333]], [[333, 333], "valid"], [[334, 334], "mapped", [335]], [[335, 335], "valid"], [[336, 336], "mapped", [337]], [[337, 337], "valid"], [[338, 338], "mapped", [339]], [[339, 339], "valid"], [[340, 340], "mapped", [341]], [[341, 341], "valid"], [[342, 342], "mapped", [343]], [[343, 343], "valid"], [[344, 344], "mapped", [345]], [[345, 345], "valid"], [[346, 346], "mapped", [347]], [[347, 347], "valid"], [[348, 348], "mapped", [349]], [[349, 349], "valid"], [[350, 350], "mapped", [351]], [[351, 351], "valid"], [[352, 352], "mapped", [353]], [[353, 353], "valid"], [[354, 354], "mapped", [355]], [[355, 355], "valid"], [[356, 356], "mapped", [357]], [[357, 357], "valid"], [[358, 358], "mapped", [359]], [[359, 359], "valid"], [[360, 360], "mapped", [361]], [[361, 361], "valid"], [[362, 362], "mapped", [363]], [[363, 363], "valid"], [[364, 364], "mapped", [365]], [[365, 365], "valid"], [[366, 366], "mapped", [367]], [[367, 367], "valid"], [[368, 368], "mapped", [369]], [[369, 369], "valid"], [[370, 370], "mapped", [371]], [[371, 371], "valid"], [[372, 372], "mapped", [373]], [[373, 373], "valid"], [[374, 374], "mapped", [375]], [[375, 375], "valid"], [[376, 376], "mapped", [255]], [[377, 377], "mapped", [378]], [[378, 378], "valid"], [[379, 379], "mapped", [380]], [[380, 380], "valid"], [[381, 381], "mapped", [382]], [[382, 382], "valid"], [[383, 383], "mapped", [115]], [[384, 384], "valid"], [[385, 385], "mapped", [595]], [[386, 386], "mapped", [387]], [[387, 387], "valid"], [[388, 388], "mapped", [389]], [[389, 389], "valid"], [[390, 390], "mapped", [596]], [[391, 391], "mapped", [392]], [[392, 392], "valid"], [[393, 393], "mapped", [598]], [[394, 394], "mapped", [599]], [[395, 395], "mapped", [396]], [[396, 397], "valid"], [[398, 398], "mapped", [477]], [[399, 399], "mapped", [601]], [[400, 400], "mapped", [603]], [[401, 401], "mapped", [402]], [[402, 402], "valid"], [[403, 403], "mapped", [608]], [[404, 404], "mapped", [611]], [[405, 405], "valid"], [[406, 406], "mapped", [617]], [[407, 407], "mapped", [616]], [[408, 408], "mapped", [409]], [[409, 411], "valid"], [[412, 412], "mapped", [623]], [[413, 413], "mapped", [626]], [[414, 414], "valid"], [[415, 415], "mapped", [629]], [[416, 416], "mapped", [417]], [[417, 417], "valid"], [[418, 418], "mapped", [419]], [[419, 419], "valid"], [[420, 420], "mapped", [421]], [[421, 421], "valid"], [[422, 422], "mapped", [640]], [[423, 423], "mapped", [424]], [[424, 424], "valid"], [[425, 425], "mapped", [643]], [[426, 427], "valid"], [[428, 428], "mapped", [429]], [[429, 429], "valid"], [[430, 430], "mapped", [648]], [[431, 431], "mapped", [432]], [[432, 432], "valid"], [[433, 433], "mapped", [650]], [[434, 434], "mapped", [651]], [[435, 435], "mapped", [436]], [[436, 436], "valid"], [[437, 437], "mapped", [438]], [[438, 438], "valid"], [[439, 439], "mapped", [658]], [[440, 440], "mapped", [441]], [[441, 443], "valid"], [[444, 444], "mapped", [445]], [[445, 451], "valid"], [[452, 454], "mapped", [100, 382]], [[455, 457], "mapped", [108, 106]], [[458, 460], "mapped", [110, 106]], [[461, 461], "mapped", [462]], [[462, 462], "valid"], [[463, 463], "mapped", [464]], [[464, 464], "valid"], [[465, 465], "mapped", [466]], [[466, 466], "valid"], [[467, 467], "mapped", [468]], [[468, 468], "valid"], [[469, 469], "mapped", [470]], [[470, 470], "valid"], [[471, 471], "mapped", [472]], [[472, 472], "valid"], [[473, 473], "mapped", [474]], [[474, 474], "valid"], [[475, 475], "mapped", [476]], [[476, 477], "valid"], [[478, 478], "mapped", [479]], [[479, 479], "valid"], [[480, 480], "mapped", [481]], [[481, 481], "valid"], [[482, 482], "mapped", [483]], [[483, 483], "valid"], [[484, 484], "mapped", [485]], [[485, 485], "valid"], [[486, 486], "mapped", [487]], [[487, 487], "valid"], [[488, 488], "mapped", [489]], [[489, 489], "valid"], [[490, 490], "mapped", [491]], [[491, 491], "valid"], [[492, 492], "mapped", [493]], [[493, 493], "valid"], [[494, 494], "mapped", [495]], [[495, 496], "valid"], [[497, 499], "mapped", [100, 122]], [[500, 500], "mapped", [501]], [[501, 501], "valid"], [[502, 502], "mapped", [405]], [[503, 503], "mapped", [447]], [[504, 504], "mapped", [505]], [[505, 505], "valid"], [[506, 506], "mapped", [507]], [[507, 507], "valid"], [[508, 508], "mapped", [509]], [[509, 509], "valid"], [[510, 510], "mapped", [511]], [[511, 511], "valid"], [[512, 512], "mapped", [513]], [[513, 513], "valid"], [[514, 514], "mapped", [515]], [[515, 515], "valid"], [[516, 516], "mapped", [517]], [[517, 517], "valid"], [[518, 518], "mapped", [519]], [[519, 519], "valid"], [[520, 520], "mapped", [521]], [[521, 521], "valid"], [[522, 522], "mapped", [523]], [[523, 523], "valid"], [[524, 524], "mapped", [525]], [[525, 525], "valid"], [[526, 526], "mapped", [527]], [[527, 527], "valid"], [[528, 528], "mapped", [529]], [[529, 529], "valid"], [[530, 530], "mapped", [531]], [[531, 531], "valid"], [[532, 532], "mapped", [533]], [[533, 533], "valid"], [[534, 534], "mapped", [535]], [[535, 535], "valid"], [[536, 536], "mapped", [537]], [[537, 537], "valid"], [[538, 538], "mapped", [539]], [[539, 539], "valid"], [[540, 540], "mapped", [541]], [[541, 541], "valid"], [[542, 542], "mapped", [543]], [[543, 543], "valid"], [[544, 544], "mapped", [414]], [[545, 545], "valid"], [[546, 546], "mapped", [547]], [[547, 547], "valid"], [[548, 548], "mapped", [549]], [[549, 549], "valid"], [[550, 550], "mapped", [551]], [[551, 551], "valid"], [[552, 552], "mapped", [553]], [[553, 553], "valid"], [[554, 554], "mapped", [555]], [[555, 555], "valid"], [[556, 556], "mapped", [557]], [[557, 557], "valid"], [[558, 558], "mapped", [559]], [[559, 559], "valid"], [[560, 560], "mapped", [561]], [[561, 561], "valid"], [[562, 562], "mapped", [563]], [[563, 563], "valid"], [[564, 566], "valid"], [[567, 569], "valid"], [[570, 570], "mapped", [11365]], [[571, 571], "mapped", [572]], [[572, 572], "valid"], [[573, 573], "mapped", [410]], [[574, 574], "mapped", [11366]], [[575, 576], "valid"], [[577, 577], "mapped", [578]], [[578, 578], "valid"], [[579, 579], "mapped", [384]], [[580, 580], "mapped", [649]], [[581, 581], "mapped", [652]], [[582, 582], "mapped", [583]], [[583, 583], "valid"], [[584, 584], "mapped", [585]], [[585, 585], "valid"], [[586, 586], "mapped", [587]], [[587, 587], "valid"], [[588, 588], "mapped", [589]], [[589, 589], "valid"], [[590, 590], "mapped", [591]], [[591, 591], "valid"], [[592, 680], "valid"], [[681, 685], "valid"], [[686, 687], "valid"], [[688, 688], "mapped", [104]], [[689, 689], "mapped", [614]], [[690, 690], "mapped", [106]], [[691, 691], "mapped", [114]], [[692, 692], "mapped", [633]], [[693, 693], "mapped", [635]], [[694, 694], "mapped", [641]], [[695, 695], "mapped", [119]], [[696, 696], "mapped", [121]], [[697, 705], "valid"], [[706, 709], "valid", [], "NV8"], [[710, 721], "valid"], [[722, 727], "valid", [], "NV8"], [[728, 728], "disallowed_STD3_mapped", [32, 774]], [[729, 729], "disallowed_STD3_mapped", [32, 775]], [[730, 730], "disallowed_STD3_mapped", [32, 778]], [[731, 731], "disallowed_STD3_mapped", [32, 808]], [[732, 732], "disallowed_STD3_mapped", [32, 771]], [[733, 733], "disallowed_STD3_mapped", [32, 779]], [[734, 734], "valid", [], "NV8"], [[735, 735], "valid", [], "NV8"], [[736, 736], "mapped", [611]], [[737, 737], "mapped", [108]], [[738, 738], "mapped", [115]], [[739, 739], "mapped", [120]], [[740, 740], "mapped", [661]], [[741, 745], "valid", [], "NV8"], [[746, 747], "valid", [], "NV8"], [[748, 748], "valid"], [[749, 749], "valid", [], "NV8"], [[750, 750], "valid"], [[751, 767], "valid", [], "NV8"], [[768, 831], "valid"], [[832, 832], "mapped", [768]], [[833, 833], "mapped", [769]], [[834, 834], "valid"], [[835, 835], "mapped", [787]], [[836, 836], "mapped", [776, 769]], [[837, 837], "mapped", [953]], [[838, 846], "valid"], [[847, 847], "ignored"], [[848, 855], "valid"], [[856, 860], "valid"], [[861, 863], "valid"], [[864, 865], "valid"], [[866, 866], "valid"], [[867, 879], "valid"], [[880, 880], "mapped", [881]], [[881, 881], "valid"], [[882, 882], "mapped", [883]], [[883, 883], "valid"], [[884, 884], "mapped", [697]], [[885, 885], "valid"], [[886, 886], "mapped", [887]], [[887, 887], "valid"], [[888, 889], "disallowed"], [[890, 890], "disallowed_STD3_mapped", [32, 953]], [[891, 893], "valid"], [[894, 894], "disallowed_STD3_mapped", [59]], [[895, 895], "mapped", [1011]], [[896, 899], "disallowed"], [[900, 900], "disallowed_STD3_mapped", [32, 769]], [[901, 901], "disallowed_STD3_mapped", [32, 776, 769]], [[902, 902], "mapped", [940]], [[903, 903], "mapped", [183]], [[904, 904], "mapped", [941]], [[905, 905], "mapped", [942]], [[906, 906], "mapped", [943]], [[907, 907], "disallowed"], [[908, 908], "mapped", [972]], [[909, 909], "disallowed"], [[910, 910], "mapped", [973]], [[911, 911], "mapped", [974]], [[912, 912], "valid"], [[913, 913], "mapped", [945]], [[914, 914], "mapped", [946]], [[915, 915], "mapped", [947]], [[916, 916], "mapped", [948]], [[917, 917], "mapped", [949]], [[918, 918], "mapped", [950]], [[919, 919], "mapped", [951]], [[920, 920], "mapped", [952]], [[921, 921], "mapped", [953]], [[922, 922], "mapped", [954]], [[923, 923], "mapped", [955]], [[924, 924], "mapped", [956]], [[925, 925], "mapped", [957]], [[926, 926], "mapped", [958]], [[927, 927], "mapped", [959]], [[928, 928], "mapped", [960]], [[929, 929], "mapped", [961]], [[930, 930], "disallowed"], [[931, 931], "mapped", [963]], [[932, 932], "mapped", [964]], [[933, 933], "mapped", [965]], [[934, 934], "mapped", [966]], [[935, 935], "mapped", [967]], [[936, 936], "mapped", [968]], [[937, 937], "mapped", [969]], [[938, 938], "mapped", [970]], [[939, 939], "mapped", [971]], [[940, 961], "valid"], [[962, 962], "deviation", [963]], [[963, 974], "valid"], [[975, 975], "mapped", [983]], [[976, 976], "mapped", [946]], [[977, 977], "mapped", [952]], [[978, 978], "mapped", [965]], [[979, 979], "mapped", [973]], [[980, 980], "mapped", [971]], [[981, 981], "mapped", [966]], [[982, 982], "mapped", [960]], [[983, 983], "valid"], [[984, 984], "mapped", [985]], [[985, 985], "valid"], [[986, 986], "mapped", [987]], [[987, 987], "valid"], [[988, 988], "mapped", [989]], [[989, 989], "valid"], [[990, 990], "mapped", [991]], [[991, 991], "valid"], [[992, 992], "mapped", [993]], [[993, 993], "valid"], [[994, 994], "mapped", [995]], [[995, 995], "valid"], [[996, 996], "mapped", [997]], [[997, 997], "valid"], [[998, 998], "mapped", [999]], [[999, 999], "valid"], [[1e3, 1e3], "mapped", [1001]], [[1001, 1001], "valid"], [[1002, 1002], "mapped", [1003]], [[1003, 1003], "valid"], [[1004, 1004], "mapped", [1005]], [[1005, 1005], "valid"], [[1006, 1006], "mapped", [1007]], [[1007, 1007], "valid"], [[1008, 1008], "mapped", [954]], [[1009, 1009], "mapped", [961]], [[1010, 1010], "mapped", [963]], [[1011, 1011], "valid"], [[1012, 1012], "mapped", [952]], [[1013, 1013], "mapped", [949]], [[1014, 1014], "valid", [], "NV8"], [[1015, 1015], "mapped", [1016]], [[1016, 1016], "valid"], [[1017, 1017], "mapped", [963]], [[1018, 1018], "mapped", [1019]], [[1019, 1019], "valid"], [[1020, 1020], "valid"], [[1021, 1021], "mapped", [891]], [[1022, 1022], "mapped", [892]], [[1023, 1023], "mapped", [893]], [[1024, 1024], "mapped", [1104]], [[1025, 1025], "mapped", [1105]], [[1026, 1026], "mapped", [1106]], [[1027, 1027], "mapped", [1107]], [[1028, 1028], "mapped", [1108]], [[1029, 1029], "mapped", [1109]], [[1030, 1030], "mapped", [1110]], [[1031, 1031], "mapped", [1111]], [[1032, 1032], "mapped", [1112]], [[1033, 1033], "mapped", [1113]], [[1034, 1034], "mapped", [1114]], [[1035, 1035], "mapped", [1115]], [[1036, 1036], "mapped", [1116]], [[1037, 1037], "mapped", [1117]], [[1038, 1038], "mapped", [1118]], [[1039, 1039], "mapped", [1119]], [[1040, 1040], "mapped", [1072]], [[1041, 1041], "mapped", [1073]], [[1042, 1042], "mapped", [1074]], [[1043, 1043], "mapped", [1075]], [[1044, 1044], "mapped", [1076]], [[1045, 1045], "mapped", [1077]], [[1046, 1046], "mapped", [1078]], [[1047, 1047], "mapped", [1079]], [[1048, 1048], "mapped", [1080]], [[1049, 1049], "mapped", [1081]], [[1050, 1050], "mapped", [1082]], [[1051, 1051], "mapped", [1083]], [[1052, 1052], "mapped", [1084]], [[1053, 1053], "mapped", [1085]], [[1054, 1054], "mapped", [1086]], [[1055, 1055], "mapped", [1087]], [[1056, 1056], "mapped", [1088]], [[1057, 1057], "mapped", [1089]], [[1058, 1058], "mapped", [1090]], [[1059, 1059], "mapped", [1091]], [[1060, 1060], "mapped", [1092]], [[1061, 1061], "mapped", [1093]], [[1062, 1062], "mapped", [1094]], [[1063, 1063], "mapped", [1095]], [[1064, 1064], "mapped", [1096]], [[1065, 1065], "mapped", [1097]], [[1066, 1066], "mapped", [1098]], [[1067, 1067], "mapped", [1099]], [[1068, 1068], "mapped", [1100]], [[1069, 1069], "mapped", [1101]], [[1070, 1070], "mapped", [1102]], [[1071, 1071], "mapped", [1103]], [[1072, 1103], "valid"], [[1104, 1104], "valid"], [[1105, 1116], "valid"], [[1117, 1117], "valid"], [[1118, 1119], "valid"], [[1120, 1120], "mapped", [1121]], [[1121, 1121], "valid"], [[1122, 1122], "mapped", [1123]], [[1123, 1123], "valid"], [[1124, 1124], "mapped", [1125]], [[1125, 1125], "valid"], [[1126, 1126], "mapped", [1127]], [[1127, 1127], "valid"], [[1128, 1128], "mapped", [1129]], [[1129, 1129], "valid"], [[1130, 1130], "mapped", [1131]], [[1131, 1131], "valid"], [[1132, 1132], "mapped", [1133]], [[1133, 1133], "valid"], [[1134, 1134], "mapped", [1135]], [[1135, 1135], "valid"], [[1136, 1136], "mapped", [1137]], [[1137, 1137], "valid"], [[1138, 1138], "mapped", [1139]], [[1139, 1139], "valid"], [[1140, 1140], "mapped", [1141]], [[1141, 1141], "valid"], [[1142, 1142], "mapped", [1143]], [[1143, 1143], "valid"], [[1144, 1144], "mapped", [1145]], [[1145, 1145], "valid"], [[1146, 1146], "mapped", [1147]], [[1147, 1147], "valid"], [[1148, 1148], "mapped", [1149]], [[1149, 1149], "valid"], [[1150, 1150], "mapped", [1151]], [[1151, 1151], "valid"], [[1152, 1152], "mapped", [1153]], [[1153, 1153], "valid"], [[1154, 1154], "valid", [], "NV8"], [[1155, 1158], "valid"], [[1159, 1159], "valid"], [[1160, 1161], "valid", [], "NV8"], [[1162, 1162], "mapped", [1163]], [[1163, 1163], "valid"], [[1164, 1164], "mapped", [1165]], [[1165, 1165], "valid"], [[1166, 1166], "mapped", [1167]], [[1167, 1167], "valid"], [[1168, 1168], "mapped", [1169]], [[1169, 1169], "valid"], [[1170, 1170], "mapped", [1171]], [[1171, 1171], "valid"], [[1172, 1172], "mapped", [1173]], [[1173, 1173], "valid"], [[1174, 1174], "mapped", [1175]], [[1175, 1175], "valid"], [[1176, 1176], "mapped", [1177]], [[1177, 1177], "valid"], [[1178, 1178], "mapped", [1179]], [[1179, 1179], "valid"], [[1180, 1180], "mapped", [1181]], [[1181, 1181], "valid"], [[1182, 1182], "mapped", [1183]], [[1183, 1183], "valid"], [[1184, 1184], "mapped", [1185]], [[1185, 1185], "valid"], [[1186, 1186], "mapped", [1187]], [[1187, 1187], "valid"], [[1188, 1188], "mapped", [1189]], [[1189, 1189], "valid"], [[1190, 1190], "mapped", [1191]], [[1191, 1191], "valid"], [[1192, 1192], "mapped", [1193]], [[1193, 1193], "valid"], [[1194, 1194], "mapped", [1195]], [[1195, 1195], "valid"], [[1196, 1196], "mapped", [1197]], [[1197, 1197], "valid"], [[1198, 1198], "mapped", [1199]], [[1199, 1199], "valid"], [[1200, 1200], "mapped", [1201]], [[1201, 1201], "valid"], [[1202, 1202], "mapped", [1203]], [[1203, 1203], "valid"], [[1204, 1204], "mapped", [1205]], [[1205, 1205], "valid"], [[1206, 1206], "mapped", [1207]], [[1207, 1207], "valid"], [[1208, 1208], "mapped", [1209]], [[1209, 1209], "valid"], [[1210, 1210], "mapped", [1211]], [[1211, 1211], "valid"], [[1212, 1212], "mapped", [1213]], [[1213, 1213], "valid"], [[1214, 1214], "mapped", [1215]], [[1215, 1215], "valid"], [[1216, 1216], "disallowed"], [[1217, 1217], "mapped", [1218]], [[1218, 1218], "valid"], [[1219, 1219], "mapped", [1220]], [[1220, 1220], "valid"], [[1221, 1221], "mapped", [1222]], [[1222, 1222], "valid"], [[1223, 1223], "mapped", [1224]], [[1224, 1224], "valid"], [[1225, 1225], "mapped", [1226]], [[1226, 1226], "valid"], [[1227, 1227], "mapped", [1228]], [[1228, 1228], "valid"], [[1229, 1229], "mapped", [1230]], [[1230, 1230], "valid"], [[1231, 1231], "valid"], [[1232, 1232], "mapped", [1233]], [[1233, 1233], "valid"], [[1234, 1234], "mapped", [1235]], [[1235, 1235], "valid"], [[1236, 1236], "mapped", [1237]], [[1237, 1237], "valid"], [[1238, 1238], "mapped", [1239]], [[1239, 1239], "valid"], [[1240, 1240], "mapped", [1241]], [[1241, 1241], "valid"], [[1242, 1242], "mapped", [1243]], [[1243, 1243], "valid"], [[1244, 1244], "mapped", [1245]], [[1245, 1245], "valid"], [[1246, 1246], "mapped", [1247]], [[1247, 1247], "valid"], [[1248, 1248], "mapped", [1249]], [[1249, 1249], "valid"], [[1250, 1250], "mapped", [1251]], [[1251, 1251], "valid"], [[1252, 1252], "mapped", [1253]], [[1253, 1253], "valid"], [[1254, 1254], "mapped", [1255]], [[1255, 1255], "valid"], [[1256, 1256], "mapped", [1257]], [[1257, 1257], "valid"], [[1258, 1258], "mapped", [1259]], [[1259, 1259], "valid"], [[1260, 1260], "mapped", [1261]], [[1261, 1261], "valid"], [[1262, 1262], "mapped", [1263]], [[1263, 1263], "valid"], [[1264, 1264], "mapped", [1265]], [[1265, 1265], "valid"], [[1266, 1266], "mapped", [1267]], [[1267, 1267], "valid"], [[1268, 1268], "mapped", [1269]], [[1269, 1269], "valid"], [[1270, 1270], "mapped", [1271]], [[1271, 1271], "valid"], [[1272, 1272], "mapped", [1273]], [[1273, 1273], "valid"], [[1274, 1274], "mapped", [1275]], [[1275, 1275], "valid"], [[1276, 1276], "mapped", [1277]], [[1277, 1277], "valid"], [[1278, 1278], "mapped", [1279]], [[1279, 1279], "valid"], [[1280, 1280], "mapped", [1281]], [[1281, 1281], "valid"], [[1282, 1282], "mapped", [1283]], [[1283, 1283], "valid"], [[1284, 1284], "mapped", [1285]], [[1285, 1285], "valid"], [[1286, 1286], "mapped", [1287]], [[1287, 1287], "valid"], [[1288, 1288], "mapped", [1289]], [[1289, 1289], "valid"], [[1290, 1290], "mapped", [1291]], [[1291, 1291], "valid"], [[1292, 1292], "mapped", [1293]], [[1293, 1293], "valid"], [[1294, 1294], "mapped", [1295]], [[1295, 1295], "valid"], [[1296, 1296], "mapped", [1297]], [[1297, 1297], "valid"], [[1298, 1298], "mapped", [1299]], [[1299, 1299], "valid"], [[1300, 1300], "mapped", [1301]], [[1301, 1301], "valid"], [[1302, 1302], "mapped", [1303]], [[1303, 1303], "valid"], [[1304, 1304], "mapped", [1305]], [[1305, 1305], "valid"], [[1306, 1306], "mapped", [1307]], [[1307, 1307], "valid"], [[1308, 1308], "mapped", [1309]], [[1309, 1309], "valid"], [[1310, 1310], "mapped", [1311]], [[1311, 1311], "valid"], [[1312, 1312], "mapped", [1313]], [[1313, 1313], "valid"], [[1314, 1314], "mapped", [1315]], [[1315, 1315], "valid"], [[1316, 1316], "mapped", [1317]], [[1317, 1317], "valid"], [[1318, 1318], "mapped", [1319]], [[1319, 1319], "valid"], [[1320, 1320], "mapped", [1321]], [[1321, 1321], "valid"], [[1322, 1322], "mapped", [1323]], [[1323, 1323], "valid"], [[1324, 1324], "mapped", [1325]], [[1325, 1325], "valid"], [[1326, 1326], "mapped", [1327]], [[1327, 1327], "valid"], [[1328, 1328], "disallowed"], [[1329, 1329], "mapped", [1377]], [[1330, 1330], "mapped", [1378]], [[1331, 1331], "mapped", [1379]], [[1332, 1332], "mapped", [1380]], [[1333, 1333], "mapped", [1381]], [[1334, 1334], "mapped", [1382]], [[1335, 1335], "mapped", [1383]], [[1336, 1336], "mapped", [1384]], [[1337, 1337], "mapped", [1385]], [[1338, 1338], "mapped", [1386]], [[1339, 1339], "mapped", [1387]], [[1340, 1340], "mapped", [1388]], [[1341, 1341], "mapped", [1389]], [[1342, 1342], "mapped", [1390]], [[1343, 1343], "mapped", [1391]], [[1344, 1344], "mapped", [1392]], [[1345, 1345], "mapped", [1393]], [[1346, 1346], "mapped", [1394]], [[1347, 1347], "mapped", [1395]], [[1348, 1348], "mapped", [1396]], [[1349, 1349], "mapped", [1397]], [[1350, 1350], "mapped", [1398]], [[1351, 1351], "mapped", [1399]], [[1352, 1352], "mapped", [1400]], [[1353, 1353], "mapped", [1401]], [[1354, 1354], "mapped", [1402]], [[1355, 1355], "mapped", [1403]], [[1356, 1356], "mapped", [1404]], [[1357, 1357], "mapped", [1405]], [[1358, 1358], "mapped", [1406]], [[1359, 1359], "mapped", [1407]], [[1360, 1360], "mapped", [1408]], [[1361, 1361], "mapped", [1409]], [[1362, 1362], "mapped", [1410]], [[1363, 1363], "mapped", [1411]], [[1364, 1364], "mapped", [1412]], [[1365, 1365], "mapped", [1413]], [[1366, 1366], "mapped", [1414]], [[1367, 1368], "disallowed"], [[1369, 1369], "valid"], [[1370, 1375], "valid", [], "NV8"], [[1376, 1376], "disallowed"], [[1377, 1414], "valid"], [[1415, 1415], "mapped", [1381, 1410]], [[1416, 1416], "disallowed"], [[1417, 1417], "valid", [], "NV8"], [[1418, 1418], "valid", [], "NV8"], [[1419, 1420], "disallowed"], [[1421, 1422], "valid", [], "NV8"], [[1423, 1423], "valid", [], "NV8"], [[1424, 1424], "disallowed"], [[1425, 1441], "valid"], [[1442, 1442], "valid"], [[1443, 1455], "valid"], [[1456, 1465], "valid"], [[1466, 1466], "valid"], [[1467, 1469], "valid"], [[1470, 1470], "valid", [], "NV8"], [[1471, 1471], "valid"], [[1472, 1472], "valid", [], "NV8"], [[1473, 1474], "valid"], [[1475, 1475], "valid", [], "NV8"], [[1476, 1476], "valid"], [[1477, 1477], "valid"], [[1478, 1478], "valid", [], "NV8"], [[1479, 1479], "valid"], [[1480, 1487], "disallowed"], [[1488, 1514], "valid"], [[1515, 1519], "disallowed"], [[1520, 1524], "valid"], [[1525, 1535], "disallowed"], [[1536, 1539], "disallowed"], [[1540, 1540], "disallowed"], [[1541, 1541], "disallowed"], [[1542, 1546], "valid", [], "NV8"], [[1547, 1547], "valid", [], "NV8"], [[1548, 1548], "valid", [], "NV8"], [[1549, 1551], "valid", [], "NV8"], [[1552, 1557], "valid"], [[1558, 1562], "valid"], [[1563, 1563], "valid", [], "NV8"], [[1564, 1564], "disallowed"], [[1565, 1565], "disallowed"], [[1566, 1566], "valid", [], "NV8"], [[1567, 1567], "valid", [], "NV8"], [[1568, 1568], "valid"], [[1569, 1594], "valid"], [[1595, 1599], "valid"], [[1600, 1600], "valid", [], "NV8"], [[1601, 1618], "valid"], [[1619, 1621], "valid"], [[1622, 1624], "valid"], [[1625, 1630], "valid"], [[1631, 1631], "valid"], [[1632, 1641], "valid"], [[1642, 1645], "valid", [], "NV8"], [[1646, 1647], "valid"], [[1648, 1652], "valid"], [[1653, 1653], "mapped", [1575, 1652]], [[1654, 1654], "mapped", [1608, 1652]], [[1655, 1655], "mapped", [1735, 1652]], [[1656, 1656], "mapped", [1610, 1652]], [[1657, 1719], "valid"], [[1720, 1721], "valid"], [[1722, 1726], "valid"], [[1727, 1727], "valid"], [[1728, 1742], "valid"], [[1743, 1743], "valid"], [[1744, 1747], "valid"], [[1748, 1748], "valid", [], "NV8"], [[1749, 1756], "valid"], [[1757, 1757], "disallowed"], [[1758, 1758], "valid", [], "NV8"], [[1759, 1768], "valid"], [[1769, 1769], "valid", [], "NV8"], [[1770, 1773], "valid"], [[1774, 1775], "valid"], [[1776, 1785], "valid"], [[1786, 1790], "valid"], [[1791, 1791], "valid"], [[1792, 1805], "valid", [], "NV8"], [[1806, 1806], "disallowed"], [[1807, 1807], "disallowed"], [[1808, 1836], "valid"], [[1837, 1839], "valid"], [[1840, 1866], "valid"], [[1867, 1868], "disallowed"], [[1869, 1871], "valid"], [[1872, 1901], "valid"], [[1902, 1919], "valid"], [[1920, 1968], "valid"], [[1969, 1969], "valid"], [[1970, 1983], "disallowed"], [[1984, 2037], "valid"], [[2038, 2042], "valid", [], "NV8"], [[2043, 2047], "disallowed"], [[2048, 2093], "valid"], [[2094, 2095], "disallowed"], [[2096, 2110], "valid", [], "NV8"], [[2111, 2111], "disallowed"], [[2112, 2139], "valid"], [[2140, 2141], "disallowed"], [[2142, 2142], "valid", [], "NV8"], [[2143, 2207], "disallowed"], [[2208, 2208], "valid"], [[2209, 2209], "valid"], [[2210, 2220], "valid"], [[2221, 2226], "valid"], [[2227, 2228], "valid"], [[2229, 2274], "disallowed"], [[2275, 2275], "valid"], [[2276, 2302], "valid"], [[2303, 2303], "valid"], [[2304, 2304], "valid"], [[2305, 2307], "valid"], [[2308, 2308], "valid"], [[2309, 2361], "valid"], [[2362, 2363], "valid"], [[2364, 2381], "valid"], [[2382, 2382], "valid"], [[2383, 2383], "valid"], [[2384, 2388], "valid"], [[2389, 2389], "valid"], [[2390, 2391], "valid"], [[2392, 2392], "mapped", [2325, 2364]], [[2393, 2393], "mapped", [2326, 2364]], [[2394, 2394], "mapped", [2327, 2364]], [[2395, 2395], "mapped", [2332, 2364]], [[2396, 2396], "mapped", [2337, 2364]], [[2397, 2397], "mapped", [2338, 2364]], [[2398, 2398], "mapped", [2347, 2364]], [[2399, 2399], "mapped", [2351, 2364]], [[2400, 2403], "valid"], [[2404, 2405], "valid", [], "NV8"], [[2406, 2415], "valid"], [[2416, 2416], "valid", [], "NV8"], [[2417, 2418], "valid"], [[2419, 2423], "valid"], [[2424, 2424], "valid"], [[2425, 2426], "valid"], [[2427, 2428], "valid"], [[2429, 2429], "valid"], [[2430, 2431], "valid"], [[2432, 2432], "valid"], [[2433, 2435], "valid"], [[2436, 2436], "disallowed"], [[2437, 2444], "valid"], [[2445, 2446], "disallowed"], [[2447, 2448], "valid"], [[2449, 2450], "disallowed"], [[2451, 2472], "valid"], [[2473, 2473], "disallowed"], [[2474, 2480], "valid"], [[2481, 2481], "disallowed"], [[2482, 2482], "valid"], [[2483, 2485], "disallowed"], [[2486, 2489], "valid"], [[2490, 2491], "disallowed"], [[2492, 2492], "valid"], [[2493, 2493], "valid"], [[2494, 2500], "valid"], [[2501, 2502], "disallowed"], [[2503, 2504], "valid"], [[2505, 2506], "disallowed"], [[2507, 2509], "valid"], [[2510, 2510], "valid"], [[2511, 2518], "disallowed"], [[2519, 2519], "valid"], [[2520, 2523], "disallowed"], [[2524, 2524], "mapped", [2465, 2492]], [[2525, 2525], "mapped", [2466, 2492]], [[2526, 2526], "disallowed"], [[2527, 2527], "mapped", [2479, 2492]], [[2528, 2531], "valid"], [[2532, 2533], "disallowed"], [[2534, 2545], "valid"], [[2546, 2554], "valid", [], "NV8"], [[2555, 2555], "valid", [], "NV8"], [[2556, 2560], "disallowed"], [[2561, 2561], "valid"], [[2562, 2562], "valid"], [[2563, 2563], "valid"], [[2564, 2564], "disallowed"], [[2565, 2570], "valid"], [[2571, 2574], "disallowed"], [[2575, 2576], "valid"], [[2577, 2578], "disallowed"], [[2579, 2600], "valid"], [[2601, 2601], "disallowed"], [[2602, 2608], "valid"], [[2609, 2609], "disallowed"], [[2610, 2610], "valid"], [[2611, 2611], "mapped", [2610, 2620]], [[2612, 2612], "disallowed"], [[2613, 2613], "valid"], [[2614, 2614], "mapped", [2616, 2620]], [[2615, 2615], "disallowed"], [[2616, 2617], "valid"], [[2618, 2619], "disallowed"], [[2620, 2620], "valid"], [[2621, 2621], "disallowed"], [[2622, 2626], "valid"], [[2627, 2630], "disallowed"], [[2631, 2632], "valid"], [[2633, 2634], "disallowed"], [[2635, 2637], "valid"], [[2638, 2640], "disallowed"], [[2641, 2641], "valid"], [[2642, 2648], "disallowed"], [[2649, 2649], "mapped", [2582, 2620]], [[2650, 2650], "mapped", [2583, 2620]], [[2651, 2651], "mapped", [2588, 2620]], [[2652, 2652], "valid"], [[2653, 2653], "disallowed"], [[2654, 2654], "mapped", [2603, 2620]], [[2655, 2661], "disallowed"], [[2662, 2676], "valid"], [[2677, 2677], "valid"], [[2678, 2688], "disallowed"], [[2689, 2691], "valid"], [[2692, 2692], "disallowed"], [[2693, 2699], "valid"], [[2700, 2700], "valid"], [[2701, 2701], "valid"], [[2702, 2702], "disallowed"], [[2703, 2705], "valid"], [[2706, 2706], "disallowed"], [[2707, 2728], "valid"], [[2729, 2729], "disallowed"], [[2730, 2736], "valid"], [[2737, 2737], "disallowed"], [[2738, 2739], "valid"], [[2740, 2740], "disallowed"], [[2741, 2745], "valid"], [[2746, 2747], "disallowed"], [[2748, 2757], "valid"], [[2758, 2758], "disallowed"], [[2759, 2761], "valid"], [[2762, 2762], "disallowed"], [[2763, 2765], "valid"], [[2766, 2767], "disallowed"], [[2768, 2768], "valid"], [[2769, 2783], "disallowed"], [[2784, 2784], "valid"], [[2785, 2787], "valid"], [[2788, 2789], "disallowed"], [[2790, 2799], "valid"], [[2800, 2800], "valid", [], "NV8"], [[2801, 2801], "valid", [], "NV8"], [[2802, 2808], "disallowed"], [[2809, 2809], "valid"], [[2810, 2816], "disallowed"], [[2817, 2819], "valid"], [[2820, 2820], "disallowed"], [[2821, 2828], "valid"], [[2829, 2830], "disallowed"], [[2831, 2832], "valid"], [[2833, 2834], "disallowed"], [[2835, 2856], "valid"], [[2857, 2857], "disallowed"], [[2858, 2864], "valid"], [[2865, 2865], "disallowed"], [[2866, 2867], "valid"], [[2868, 2868], "disallowed"], [[2869, 2869], "valid"], [[2870, 2873], "valid"], [[2874, 2875], "disallowed"], [[2876, 2883], "valid"], [[2884, 2884], "valid"], [[2885, 2886], "disallowed"], [[2887, 2888], "valid"], [[2889, 2890], "disallowed"], [[2891, 2893], "valid"], [[2894, 2901], "disallowed"], [[2902, 2903], "valid"], [[2904, 2907], "disallowed"], [[2908, 2908], "mapped", [2849, 2876]], [[2909, 2909], "mapped", [2850, 2876]], [[2910, 2910], "disallowed"], [[2911, 2913], "valid"], [[2914, 2915], "valid"], [[2916, 2917], "disallowed"], [[2918, 2927], "valid"], [[2928, 2928], "valid", [], "NV8"], [[2929, 2929], "valid"], [[2930, 2935], "valid", [], "NV8"], [[2936, 2945], "disallowed"], [[2946, 2947], "valid"], [[2948, 2948], "disallowed"], [[2949, 2954], "valid"], [[2955, 2957], "disallowed"], [[2958, 2960], "valid"], [[2961, 2961], "disallowed"], [[2962, 2965], "valid"], [[2966, 2968], "disallowed"], [[2969, 2970], "valid"], [[2971, 2971], "disallowed"], [[2972, 2972], "valid"], [[2973, 2973], "disallowed"], [[2974, 2975], "valid"], [[2976, 2978], "disallowed"], [[2979, 2980], "valid"], [[2981, 2983], "disallowed"], [[2984, 2986], "valid"], [[2987, 2989], "disallowed"], [[2990, 2997], "valid"], [[2998, 2998], "valid"], [[2999, 3001], "valid"], [[3002, 3005], "disallowed"], [[3006, 3010], "valid"], [[3011, 3013], "disallowed"], [[3014, 3016], "valid"], [[3017, 3017], "disallowed"], [[3018, 3021], "valid"], [[3022, 3023], "disallowed"], [[3024, 3024], "valid"], [[3025, 3030], "disallowed"], [[3031, 3031], "valid"], [[3032, 3045], "disallowed"], [[3046, 3046], "valid"], [[3047, 3055], "valid"], [[3056, 3058], "valid", [], "NV8"], [[3059, 3066], "valid", [], "NV8"], [[3067, 3071], "disallowed"], [[3072, 3072], "valid"], [[3073, 3075], "valid"], [[3076, 3076], "disallowed"], [[3077, 3084], "valid"], [[3085, 3085], "disallowed"], [[3086, 3088], "valid"], [[3089, 3089], "disallowed"], [[3090, 3112], "valid"], [[3113, 3113], "disallowed"], [[3114, 3123], "valid"], [[3124, 3124], "valid"], [[3125, 3129], "valid"], [[3130, 3132], "disallowed"], [[3133, 3133], "valid"], [[3134, 3140], "valid"], [[3141, 3141], "disallowed"], [[3142, 3144], "valid"], [[3145, 3145], "disallowed"], [[3146, 3149], "valid"], [[3150, 3156], "disallowed"], [[3157, 3158], "valid"], [[3159, 3159], "disallowed"], [[3160, 3161], "valid"], [[3162, 3162], "valid"], [[3163, 3167], "disallowed"], [[3168, 3169], "valid"], [[3170, 3171], "valid"], [[3172, 3173], "disallowed"], [[3174, 3183], "valid"], [[3184, 3191], "disallowed"], [[3192, 3199], "valid", [], "NV8"], [[3200, 3200], "disallowed"], [[3201, 3201], "valid"], [[3202, 3203], "valid"], [[3204, 3204], "disallowed"], [[3205, 3212], "valid"], [[3213, 3213], "disallowed"], [[3214, 3216], "valid"], [[3217, 3217], "disallowed"], [[3218, 3240], "valid"], [[3241, 3241], "disallowed"], [[3242, 3251], "valid"], [[3252, 3252], "disallowed"], [[3253, 3257], "valid"], [[3258, 3259], "disallowed"], [[3260, 3261], "valid"], [[3262, 3268], "valid"], [[3269, 3269], "disallowed"], [[3270, 3272], "valid"], [[3273, 3273], "disallowed"], [[3274, 3277], "valid"], [[3278, 3284], "disallowed"], [[3285, 3286], "valid"], [[3287, 3293], "disallowed"], [[3294, 3294], "valid"], [[3295, 3295], "disallowed"], [[3296, 3297], "valid"], [[3298, 3299], "valid"], [[3300, 3301], "disallowed"], [[3302, 3311], "valid"], [[3312, 3312], "disallowed"], [[3313, 3314], "valid"], [[3315, 3328], "disallowed"], [[3329, 3329], "valid"], [[3330, 3331], "valid"], [[3332, 3332], "disallowed"], [[3333, 3340], "valid"], [[3341, 3341], "disallowed"], [[3342, 3344], "valid"], [[3345, 3345], "disallowed"], [[3346, 3368], "valid"], [[3369, 3369], "valid"], [[3370, 3385], "valid"], [[3386, 3386], "valid"], [[3387, 3388], "disallowed"], [[3389, 3389], "valid"], [[3390, 3395], "valid"], [[3396, 3396], "valid"], [[3397, 3397], "disallowed"], [[3398, 3400], "valid"], [[3401, 3401], "disallowed"], [[3402, 3405], "valid"], [[3406, 3406], "valid"], [[3407, 3414], "disallowed"], [[3415, 3415], "valid"], [[3416, 3422], "disallowed"], [[3423, 3423], "valid"], [[3424, 3425], "valid"], [[3426, 3427], "valid"], [[3428, 3429], "disallowed"], [[3430, 3439], "valid"], [[3440, 3445], "valid", [], "NV8"], [[3446, 3448], "disallowed"], [[3449, 3449], "valid", [], "NV8"], [[3450, 3455], "valid"], [[3456, 3457], "disallowed"], [[3458, 3459], "valid"], [[3460, 3460], "disallowed"], [[3461, 3478], "valid"], [[3479, 3481], "disallowed"], [[3482, 3505], "valid"], [[3506, 3506], "disallowed"], [[3507, 3515], "valid"], [[3516, 3516], "disallowed"], [[3517, 3517], "valid"], [[3518, 3519], "disallowed"], [[3520, 3526], "valid"], [[3527, 3529], "disallowed"], [[3530, 3530], "valid"], [[3531, 3534], "disallowed"], [[3535, 3540], "valid"], [[3541, 3541], "disallowed"], [[3542, 3542], "valid"], [[3543, 3543], "disallowed"], [[3544, 3551], "valid"], [[3552, 3557], "disallowed"], [[3558, 3567], "valid"], [[3568, 3569], "disallowed"], [[3570, 3571], "valid"], [[3572, 3572], "valid", [], "NV8"], [[3573, 3584], "disallowed"], [[3585, 3634], "valid"], [[3635, 3635], "mapped", [3661, 3634]], [[3636, 3642], "valid"], [[3643, 3646], "disallowed"], [[3647, 3647], "valid", [], "NV8"], [[3648, 3662], "valid"], [[3663, 3663], "valid", [], "NV8"], [[3664, 3673], "valid"], [[3674, 3675], "valid", [], "NV8"], [[3676, 3712], "disallowed"], [[3713, 3714], "valid"], [[3715, 3715], "disallowed"], [[3716, 3716], "valid"], [[3717, 3718], "disallowed"], [[3719, 3720], "valid"], [[3721, 3721], "disallowed"], [[3722, 3722], "valid"], [[3723, 3724], "disallowed"], [[3725, 3725], "valid"], [[3726, 3731], "disallowed"], [[3732, 3735], "valid"], [[3736, 3736], "disallowed"], [[3737, 3743], "valid"], [[3744, 3744], "disallowed"], [[3745, 3747], "valid"], [[3748, 3748], "disallowed"], [[3749, 3749], "valid"], [[3750, 3750], "disallowed"], [[3751, 3751], "valid"], [[3752, 3753], "disallowed"], [[3754, 3755], "valid"], [[3756, 3756], "disallowed"], [[3757, 3762], "valid"], [[3763, 3763], "mapped", [3789, 3762]], [[3764, 3769], "valid"], [[3770, 3770], "disallowed"], [[3771, 3773], "valid"], [[3774, 3775], "disallowed"], [[3776, 3780], "valid"], [[3781, 3781], "disallowed"], [[3782, 3782], "valid"], [[3783, 3783], "disallowed"], [[3784, 3789], "valid"], [[3790, 3791], "disallowed"], [[3792, 3801], "valid"], [[3802, 3803], "disallowed"], [[3804, 3804], "mapped", [3755, 3737]], [[3805, 3805], "mapped", [3755, 3745]], [[3806, 3807], "valid"], [[3808, 3839], "disallowed"], [[3840, 3840], "valid"], [[3841, 3850], "valid", [], "NV8"], [[3851, 3851], "valid"], [[3852, 3852], "mapped", [3851]], [[3853, 3863], "valid", [], "NV8"], [[3864, 3865], "valid"], [[3866, 3871], "valid", [], "NV8"], [[3872, 3881], "valid"], [[3882, 3892], "valid", [], "NV8"], [[3893, 3893], "valid"], [[3894, 3894], "valid", [], "NV8"], [[3895, 3895], "valid"], [[3896, 3896], "valid", [], "NV8"], [[3897, 3897], "valid"], [[3898, 3901], "valid", [], "NV8"], [[3902, 3906], "valid"], [[3907, 3907], "mapped", [3906, 4023]], [[3908, 3911], "valid"], [[3912, 3912], "disallowed"], [[3913, 3916], "valid"], [[3917, 3917], "mapped", [3916, 4023]], [[3918, 3921], "valid"], [[3922, 3922], "mapped", [3921, 4023]], [[3923, 3926], "valid"], [[3927, 3927], "mapped", [3926, 4023]], [[3928, 3931], "valid"], [[3932, 3932], "mapped", [3931, 4023]], [[3933, 3944], "valid"], [[3945, 3945], "mapped", [3904, 4021]], [[3946, 3946], "valid"], [[3947, 3948], "valid"], [[3949, 3952], "disallowed"], [[3953, 3954], "valid"], [[3955, 3955], "mapped", [3953, 3954]], [[3956, 3956], "valid"], [[3957, 3957], "mapped", [3953, 3956]], [[3958, 3958], "mapped", [4018, 3968]], [[3959, 3959], "mapped", [4018, 3953, 3968]], [[3960, 3960], "mapped", [4019, 3968]], [[3961, 3961], "mapped", [4019, 3953, 3968]], [[3962, 3968], "valid"], [[3969, 3969], "mapped", [3953, 3968]], [[3970, 3972], "valid"], [[3973, 3973], "valid", [], "NV8"], [[3974, 3979], "valid"], [[3980, 3983], "valid"], [[3984, 3986], "valid"], [[3987, 3987], "mapped", [3986, 4023]], [[3988, 3989], "valid"], [[3990, 3990], "valid"], [[3991, 3991], "valid"], [[3992, 3992], "disallowed"], [[3993, 3996], "valid"], [[3997, 3997], "mapped", [3996, 4023]], [[3998, 4001], "valid"], [[4002, 4002], "mapped", [4001, 4023]], [[4003, 4006], "valid"], [[4007, 4007], "mapped", [4006, 4023]], [[4008, 4011], "valid"], [[4012, 4012], "mapped", [4011, 4023]], [[4013, 4013], "valid"], [[4014, 4016], "valid"], [[4017, 4023], "valid"], [[4024, 4024], "valid"], [[4025, 4025], "mapped", [3984, 4021]], [[4026, 4028], "valid"], [[4029, 4029], "disallowed"], [[4030, 4037], "valid", [], "NV8"], [[4038, 4038], "valid"], [[4039, 4044], "valid", [], "NV8"], [[4045, 4045], "disallowed"], [[4046, 4046], "valid", [], "NV8"], [[4047, 4047], "valid", [], "NV8"], [[4048, 4049], "valid", [], "NV8"], [[4050, 4052], "valid", [], "NV8"], [[4053, 4056], "valid", [], "NV8"], [[4057, 4058], "valid", [], "NV8"], [[4059, 4095], "disallowed"], [[4096, 4129], "valid"], [[4130, 4130], "valid"], [[4131, 4135], "valid"], [[4136, 4136], "valid"], [[4137, 4138], "valid"], [[4139, 4139], "valid"], [[4140, 4146], "valid"], [[4147, 4149], "valid"], [[4150, 4153], "valid"], [[4154, 4159], "valid"], [[4160, 4169], "valid"], [[4170, 4175], "valid", [], "NV8"], [[4176, 4185], "valid"], [[4186, 4249], "valid"], [[4250, 4253], "valid"], [[4254, 4255], "valid", [], "NV8"], [[4256, 4293], "disallowed"], [[4294, 4294], "disallowed"], [[4295, 4295], "mapped", [11559]], [[4296, 4300], "disallowed"], [[4301, 4301], "mapped", [11565]], [[4302, 4303], "disallowed"], [[4304, 4342], "valid"], [[4343, 4344], "valid"], [[4345, 4346], "valid"], [[4347, 4347], "valid", [], "NV8"], [[4348, 4348], "mapped", [4316]], [[4349, 4351], "valid"], [[4352, 4441], "valid", [], "NV8"], [[4442, 4446], "valid", [], "NV8"], [[4447, 4448], "disallowed"], [[4449, 4514], "valid", [], "NV8"], [[4515, 4519], "valid", [], "NV8"], [[4520, 4601], "valid", [], "NV8"], [[4602, 4607], "valid", [], "NV8"], [[4608, 4614], "valid"], [[4615, 4615], "valid"], [[4616, 4678], "valid"], [[4679, 4679], "valid"], [[4680, 4680], "valid"], [[4681, 4681], "disallowed"], [[4682, 4685], "valid"], [[4686, 4687], "disallowed"], [[4688, 4694], "valid"], [[4695, 4695], "disallowed"], [[4696, 4696], "valid"], [[4697, 4697], "disallowed"], [[4698, 4701], "valid"], [[4702, 4703], "disallowed"], [[4704, 4742], "valid"], [[4743, 4743], "valid"], [[4744, 4744], "valid"], [[4745, 4745], "disallowed"], [[4746, 4749], "valid"], [[4750, 4751], "disallowed"], [[4752, 4782], "valid"], [[4783, 4783], "valid"], [[4784, 4784], "valid"], [[4785, 4785], "disallowed"], [[4786, 4789], "valid"], [[4790, 4791], "disallowed"], [[4792, 4798], "valid"], [[4799, 4799], "disallowed"], [[4800, 4800], "valid"], [[4801, 4801], "disallowed"], [[4802, 4805], "valid"], [[4806, 4807], "disallowed"], [[4808, 4814], "valid"], [[4815, 4815], "valid"], [[4816, 4822], "valid"], [[4823, 4823], "disallowed"], [[4824, 4846], "valid"], [[4847, 4847], "valid"], [[4848, 4878], "valid"], [[4879, 4879], "valid"], [[4880, 4880], "valid"], [[4881, 4881], "disallowed"], [[4882, 4885], "valid"], [[4886, 4887], "disallowed"], [[4888, 4894], "valid"], [[4895, 4895], "valid"], [[4896, 4934], "valid"], [[4935, 4935], "valid"], [[4936, 4954], "valid"], [[4955, 4956], "disallowed"], [[4957, 4958], "valid"], [[4959, 4959], "valid"], [[4960, 4960], "valid", [], "NV8"], [[4961, 4988], "valid", [], "NV8"], [[4989, 4991], "disallowed"], [[4992, 5007], "valid"], [[5008, 5017], "valid", [], "NV8"], [[5018, 5023], "disallowed"], [[5024, 5108], "valid"], [[5109, 5109], "valid"], [[5110, 5111], "disallowed"], [[5112, 5112], "mapped", [5104]], [[5113, 5113], "mapped", [5105]], [[5114, 5114], "mapped", [5106]], [[5115, 5115], "mapped", [5107]], [[5116, 5116], "mapped", [5108]], [[5117, 5117], "mapped", [5109]], [[5118, 5119], "disallowed"], [[5120, 5120], "valid", [], "NV8"], [[5121, 5740], "valid"], [[5741, 5742], "valid", [], "NV8"], [[5743, 5750], "valid"], [[5751, 5759], "valid"], [[5760, 5760], "disallowed"], [[5761, 5786], "valid"], [[5787, 5788], "valid", [], "NV8"], [[5789, 5791], "disallowed"], [[5792, 5866], "valid"], [[5867, 5872], "valid", [], "NV8"], [[5873, 5880], "valid"], [[5881, 5887], "disallowed"], [[5888, 5900], "valid"], [[5901, 5901], "disallowed"], [[5902, 5908], "valid"], [[5909, 5919], "disallowed"], [[5920, 5940], "valid"], [[5941, 5942], "valid", [], "NV8"], [[5943, 5951], "disallowed"], [[5952, 5971], "valid"], [[5972, 5983], "disallowed"], [[5984, 5996], "valid"], [[5997, 5997], "disallowed"], [[5998, 6e3], "valid"], [[6001, 6001], "disallowed"], [[6002, 6003], "valid"], [[6004, 6015], "disallowed"], [[6016, 6067], "valid"], [[6068, 6069], "disallowed"], [[6070, 6099], "valid"], [[6100, 6102], "valid", [], "NV8"], [[6103, 6103], "valid"], [[6104, 6107], "valid", [], "NV8"], [[6108, 6108], "valid"], [[6109, 6109], "valid"], [[6110, 6111], "disallowed"], [[6112, 6121], "valid"], [[6122, 6127], "disallowed"], [[6128, 6137], "valid", [], "NV8"], [[6138, 6143], "disallowed"], [[6144, 6149], "valid", [], "NV8"], [[6150, 6150], "disallowed"], [[6151, 6154], "valid", [], "NV8"], [[6155, 6157], "ignored"], [[6158, 6158], "disallowed"], [[6159, 6159], "disallowed"], [[6160, 6169], "valid"], [[6170, 6175], "disallowed"], [[6176, 6263], "valid"], [[6264, 6271], "disallowed"], [[6272, 6313], "valid"], [[6314, 6314], "valid"], [[6315, 6319], "disallowed"], [[6320, 6389], "valid"], [[6390, 6399], "disallowed"], [[6400, 6428], "valid"], [[6429, 6430], "valid"], [[6431, 6431], "disallowed"], [[6432, 6443], "valid"], [[6444, 6447], "disallowed"], [[6448, 6459], "valid"], [[6460, 6463], "disallowed"], [[6464, 6464], "valid", [], "NV8"], [[6465, 6467], "disallowed"], [[6468, 6469], "valid", [], "NV8"], [[6470, 6509], "valid"], [[6510, 6511], "disallowed"], [[6512, 6516], "valid"], [[6517, 6527], "disallowed"], [[6528, 6569], "valid"], [[6570, 6571], "valid"], [[6572, 6575], "disallowed"], [[6576, 6601], "valid"], [[6602, 6607], "disallowed"], [[6608, 6617], "valid"], [[6618, 6618], "valid", [], "XV8"], [[6619, 6621], "disallowed"], [[6622, 6623], "valid", [], "NV8"], [[6624, 6655], "valid", [], "NV8"], [[6656, 6683], "valid"], [[6684, 6685], "disallowed"], [[6686, 6687], "valid", [], "NV8"], [[6688, 6750], "valid"], [[6751, 6751], "disallowed"], [[6752, 6780], "valid"], [[6781, 6782], "disallowed"], [[6783, 6793], "valid"], [[6794, 6799], "disallowed"], [[6800, 6809], "valid"], [[6810, 6815], "disallowed"], [[6816, 6822], "valid", [], "NV8"], [[6823, 6823], "valid"], [[6824, 6829], "valid", [], "NV8"], [[6830, 6831], "disallowed"], [[6832, 6845], "valid"], [[6846, 6846], "valid", [], "NV8"], [[6847, 6911], "disallowed"], [[6912, 6987], "valid"], [[6988, 6991], "disallowed"], [[6992, 7001], "valid"], [[7002, 7018], "valid", [], "NV8"], [[7019, 7027], "valid"], [[7028, 7036], "valid", [], "NV8"], [[7037, 7039], "disallowed"], [[7040, 7082], "valid"], [[7083, 7085], "valid"], [[7086, 7097], "valid"], [[7098, 7103], "valid"], [[7104, 7155], "valid"], [[7156, 7163], "disallowed"], [[7164, 7167], "valid", [], "NV8"], [[7168, 7223], "valid"], [[7224, 7226], "disallowed"], [[7227, 7231], "valid", [], "NV8"], [[7232, 7241], "valid"], [[7242, 7244], "disallowed"], [[7245, 7293], "valid"], [[7294, 7295], "valid", [], "NV8"], [[7296, 7359], "disallowed"], [[7360, 7367], "valid", [], "NV8"], [[7368, 7375], "disallowed"], [[7376, 7378], "valid"], [[7379, 7379], "valid", [], "NV8"], [[7380, 7410], "valid"], [[7411, 7414], "valid"], [[7415, 7415], "disallowed"], [[7416, 7417], "valid"], [[7418, 7423], "disallowed"], [[7424, 7467], "valid"], [[7468, 7468], "mapped", [97]], [[7469, 7469], "mapped", [230]], [[7470, 7470], "mapped", [98]], [[7471, 7471], "valid"], [[7472, 7472], "mapped", [100]], [[7473, 7473], "mapped", [101]], [[7474, 7474], "mapped", [477]], [[7475, 7475], "mapped", [103]], [[7476, 7476], "mapped", [104]], [[7477, 7477], "mapped", [105]], [[7478, 7478], "mapped", [106]], [[7479, 7479], "mapped", [107]], [[7480, 7480], "mapped", [108]], [[7481, 7481], "mapped", [109]], [[7482, 7482], "mapped", [110]], [[7483, 7483], "valid"], [[7484, 7484], "mapped", [111]], [[7485, 7485], "mapped", [547]], [[7486, 7486], "mapped", [112]], [[7487, 7487], "mapped", [114]], [[7488, 7488], "mapped", [116]], [[7489, 7489], "mapped", [117]], [[7490, 7490], "mapped", [119]], [[7491, 7491], "mapped", [97]], [[7492, 7492], "mapped", [592]], [[7493, 7493], "mapped", [593]], [[7494, 7494], "mapped", [7426]], [[7495, 7495], "mapped", [98]], [[7496, 7496], "mapped", [100]], [[7497, 7497], "mapped", [101]], [[7498, 7498], "mapped", [601]], [[7499, 7499], "mapped", [603]], [[7500, 7500], "mapped", [604]], [[7501, 7501], "mapped", [103]], [[7502, 7502], "valid"], [[7503, 7503], "mapped", [107]], [[7504, 7504], "mapped", [109]], [[7505, 7505], "mapped", [331]], [[7506, 7506], "mapped", [111]], [[7507, 7507], "mapped", [596]], [[7508, 7508], "mapped", [7446]], [[7509, 7509], "mapped", [7447]], [[7510, 7510], "mapped", [112]], [[7511, 7511], "mapped", [116]], [[7512, 7512], "mapped", [117]], [[7513, 7513], "mapped", [7453]], [[7514, 7514], "mapped", [623]], [[7515, 7515], "mapped", [118]], [[7516, 7516], "mapped", [7461]], [[7517, 7517], "mapped", [946]], [[7518, 7518], "mapped", [947]], [[7519, 7519], "mapped", [948]], [[7520, 7520], "mapped", [966]], [[7521, 7521], "mapped", [967]], [[7522, 7522], "mapped", [105]], [[7523, 7523], "mapped", [114]], [[7524, 7524], "mapped", [117]], [[7525, 7525], "mapped", [118]], [[7526, 7526], "mapped", [946]], [[7527, 7527], "mapped", [947]], [[7528, 7528], "mapped", [961]], [[7529, 7529], "mapped", [966]], [[7530, 7530], "mapped", [967]], [[7531, 7531], "valid"], [[7532, 7543], "valid"], [[7544, 7544], "mapped", [1085]], [[7545, 7578], "valid"], [[7579, 7579], "mapped", [594]], [[7580, 7580], "mapped", [99]], [[7581, 7581], "mapped", [597]], [[7582, 7582], "mapped", [240]], [[7583, 7583], "mapped", [604]], [[7584, 7584], "mapped", [102]], [[7585, 7585], "mapped", [607]], [[7586, 7586], "mapped", [609]], [[7587, 7587], "mapped", [613]], [[7588, 7588], "mapped", [616]], [[7589, 7589], "mapped", [617]], [[7590, 7590], "mapped", [618]], [[7591, 7591], "mapped", [7547]], [[7592, 7592], "mapped", [669]], [[7593, 7593], "mapped", [621]], [[7594, 7594], "mapped", [7557]], [[7595, 7595], "mapped", [671]], [[7596, 7596], "mapped", [625]], [[7597, 7597], "mapped", [624]], [[7598, 7598], "mapped", [626]], [[7599, 7599], "mapped", [627]], [[7600, 7600], "mapped", [628]], [[7601, 7601], "mapped", [629]], [[7602, 7602], "mapped", [632]], [[7603, 7603], "mapped", [642]], [[7604, 7604], "mapped", [643]], [[7605, 7605], "mapped", [427]], [[7606, 7606], "mapped", [649]], [[7607, 7607], "mapped", [650]], [[7608, 7608], "mapped", [7452]], [[7609, 7609], "mapped", [651]], [[7610, 7610], "mapped", [652]], [[7611, 7611], "mapped", [122]], [[7612, 7612], "mapped", [656]], [[7613, 7613], "mapped", [657]], [[7614, 7614], "mapped", [658]], [[7615, 7615], "mapped", [952]], [[7616, 7619], "valid"], [[7620, 7626], "valid"], [[7627, 7654], "valid"], [[7655, 7669], "valid"], [[7670, 7675], "disallowed"], [[7676, 7676], "valid"], [[7677, 7677], "valid"], [[7678, 7679], "valid"], [[7680, 7680], "mapped", [7681]], [[7681, 7681], "valid"], [[7682, 7682], "mapped", [7683]], [[7683, 7683], "valid"], [[7684, 7684], "mapped", [7685]], [[7685, 7685], "valid"], [[7686, 7686], "mapped", [7687]], [[7687, 7687], "valid"], [[7688, 7688], "mapped", [7689]], [[7689, 7689], "valid"], [[7690, 7690], "mapped", [7691]], [[7691, 7691], "valid"], [[7692, 7692], "mapped", [7693]], [[7693, 7693], "valid"], [[7694, 7694], "mapped", [7695]], [[7695, 7695], "valid"], [[7696, 7696], "mapped", [7697]], [[7697, 7697], "valid"], [[7698, 7698], "mapped", [7699]], [[7699, 7699], "valid"], [[7700, 7700], "mapped", [7701]], [[7701, 7701], "valid"], [[7702, 7702], "mapped", [7703]], [[7703, 7703], "valid"], [[7704, 7704], "mapped", [7705]], [[7705, 7705], "valid"], [[7706, 7706], "mapped", [7707]], [[7707, 7707], "valid"], [[7708, 7708], "mapped", [7709]], [[7709, 7709], "valid"], [[7710, 7710], "mapped", [7711]], [[7711, 7711], "valid"], [[7712, 7712], "mapped", [7713]], [[7713, 7713], "valid"], [[7714, 7714], "mapped", [7715]], [[7715, 7715], "valid"], [[7716, 7716], "mapped", [7717]], [[7717, 7717], "valid"], [[7718, 7718], "mapped", [7719]], [[7719, 7719], "valid"], [[7720, 7720], "mapped", [7721]], [[7721, 7721], "valid"], [[7722, 7722], "mapped", [7723]], [[7723, 7723], "valid"], [[7724, 7724], "mapped", [7725]], [[7725, 7725], "valid"], [[7726, 7726], "mapped", [7727]], [[7727, 7727], "valid"], [[7728, 7728], "mapped", [7729]], [[7729, 7729], "valid"], [[7730, 7730], "mapped", [7731]], [[7731, 7731], "valid"], [[7732, 7732], "mapped", [7733]], [[7733, 7733], "valid"], [[7734, 7734], "mapped", [7735]], [[7735, 7735], "valid"], [[7736, 7736], "mapped", [7737]], [[7737, 7737], "valid"], [[7738, 7738], "mapped", [7739]], [[7739, 7739], "valid"], [[7740, 7740], "mapped", [7741]], [[7741, 7741], "valid"], [[7742, 7742], "mapped", [7743]], [[7743, 7743], "valid"], [[7744, 7744], "mapped", [7745]], [[7745, 7745], "valid"], [[7746, 7746], "mapped", [7747]], [[7747, 7747], "valid"], [[7748, 7748], "mapped", [7749]], [[7749, 7749], "valid"], [[7750, 7750], "mapped", [7751]], [[7751, 7751], "valid"], [[7752, 7752], "mapped", [7753]], [[7753, 7753], "valid"], [[7754, 7754], "mapped", [7755]], [[7755, 7755], "valid"], [[7756, 7756], "mapped", [7757]], [[7757, 7757], "valid"], [[7758, 7758], "mapped", [7759]], [[7759, 7759], "valid"], [[7760, 7760], "mapped", [7761]], [[7761, 7761], "valid"], [[7762, 7762], "mapped", [7763]], [[7763, 7763], "valid"], [[7764, 7764], "mapped", [7765]], [[7765, 7765], "valid"], [[7766, 7766], "mapped", [7767]], [[7767, 7767], "valid"], [[7768, 7768], "mapped", [7769]], [[7769, 7769], "valid"], [[7770, 7770], "mapped", [7771]], [[7771, 7771], "valid"], [[7772, 7772], "mapped", [7773]], [[7773, 7773], "valid"], [[7774, 7774], "mapped", [7775]], [[7775, 7775], "valid"], [[7776, 7776], "mapped", [7777]], [[7777, 7777], "valid"], [[7778, 7778], "mapped", [7779]], [[7779, 7779], "valid"], [[7780, 7780], "mapped", [7781]], [[7781, 7781], "valid"], [[7782, 7782], "mapped", [7783]], [[7783, 7783], "valid"], [[7784, 7784], "mapped", [7785]], [[7785, 7785], "valid"], [[7786, 7786], "mapped", [7787]], [[7787, 7787], "valid"], [[7788, 7788], "mapped", [7789]], [[7789, 7789], "valid"], [[7790, 7790], "mapped", [7791]], [[7791, 7791], "valid"], [[7792, 7792], "mapped", [7793]], [[7793, 7793], "valid"], [[7794, 7794], "mapped", [7795]], [[7795, 7795], "valid"], [[7796, 7796], "mapped", [7797]], [[7797, 7797], "valid"], [[7798, 7798], "mapped", [7799]], [[7799, 7799], "valid"], [[7800, 7800], "mapped", [7801]], [[7801, 7801], "valid"], [[7802, 7802], "mapped", [7803]], [[7803, 7803], "valid"], [[7804, 7804], "mapped", [7805]], [[7805, 7805], "valid"], [[7806, 7806], "mapped", [7807]], [[7807, 7807], "valid"], [[7808, 7808], "mapped", [7809]], [[7809, 7809], "valid"], [[7810, 7810], "mapped", [7811]], [[7811, 7811], "valid"], [[7812, 7812], "mapped", [7813]], [[7813, 7813], "valid"], [[7814, 7814], "mapped", [7815]], [[7815, 7815], "valid"], [[7816, 7816], "mapped", [7817]], [[7817, 7817], "valid"], [[7818, 7818], "mapped", [7819]], [[7819, 7819], "valid"], [[7820, 7820], "mapped", [7821]], [[7821, 7821], "valid"], [[7822, 7822], "mapped", [7823]], [[7823, 7823], "valid"], [[7824, 7824], "mapped", [7825]], [[7825, 7825], "valid"], [[7826, 7826], "mapped", [7827]], [[7827, 7827], "valid"], [[7828, 7828], "mapped", [7829]], [[7829, 7833], "valid"], [[7834, 7834], "mapped", [97, 702]], [[7835, 7835], "mapped", [7777]], [[7836, 7837], "valid"], [[7838, 7838], "mapped", [115, 115]], [[7839, 7839], "valid"], [[7840, 7840], "mapped", [7841]], [[7841, 7841], "valid"], [[7842, 7842], "mapped", [7843]], [[7843, 7843], "valid"], [[7844, 7844], "mapped", [7845]], [[7845, 7845], "valid"], [[7846, 7846], "mapped", [7847]], [[7847, 7847], "valid"], [[7848, 7848], "mapped", [7849]], [[7849, 7849], "valid"], [[7850, 7850], "mapped", [7851]], [[7851, 7851], "valid"], [[7852, 7852], "mapped", [7853]], [[7853, 7853], "valid"], [[7854, 7854], "mapped", [7855]], [[7855, 7855], "valid"], [[7856, 7856], "mapped", [7857]], [[7857, 7857], "valid"], [[7858, 7858], "mapped", [7859]], [[7859, 7859], "valid"], [[7860, 7860], "mapped", [7861]], [[7861, 7861], "valid"], [[7862, 7862], "mapped", [7863]], [[7863, 7863], "valid"], [[7864, 7864], "mapped", [7865]], [[7865, 7865], "valid"], [[7866, 7866], "mapped", [7867]], [[7867, 7867], "valid"], [[7868, 7868], "mapped", [7869]], [[7869, 7869], "valid"], [[7870, 7870], "mapped", [7871]], [[7871, 7871], "valid"], [[7872, 7872], "mapped", [7873]], [[7873, 7873], "valid"], [[7874, 7874], "mapped", [7875]], [[7875, 7875], "valid"], [[7876, 7876], "mapped", [7877]], [[7877, 7877], "valid"], [[7878, 7878], "mapped", [7879]], [[7879, 7879], "valid"], [[7880, 7880], "mapped", [7881]], [[7881, 7881], "valid"], [[7882, 7882], "mapped", [7883]], [[7883, 7883], "valid"], [[7884, 7884], "mapped", [7885]], [[7885, 7885], "valid"], [[7886, 7886], "mapped", [7887]], [[7887, 7887], "valid"], [[7888, 7888], "mapped", [7889]], [[7889, 7889], "valid"], [[7890, 7890], "mapped", [7891]], [[7891, 7891], "valid"], [[7892, 7892], "mapped", [7893]], [[7893, 7893], "valid"], [[7894, 7894], "mapped", [7895]], [[7895, 7895], "valid"], [[7896, 7896], "mapped", [7897]], [[7897, 7897], "valid"], [[7898, 7898], "mapped", [7899]], [[7899, 7899], "valid"], [[7900, 7900], "mapped", [7901]], [[7901, 7901], "valid"], [[7902, 7902], "mapped", [7903]], [[7903, 7903], "valid"], [[7904, 7904], "mapped", [7905]], [[7905, 7905], "valid"], [[7906, 7906], "mapped", [7907]], [[7907, 7907], "valid"], [[7908, 7908], "mapped", [7909]], [[7909, 7909], "valid"], [[7910, 7910], "mapped", [7911]], [[7911, 7911], "valid"], [[7912, 7912], "mapped", [7913]], [[7913, 7913], "valid"], [[7914, 7914], "mapped", [7915]], [[7915, 7915], "valid"], [[7916, 7916], "mapped", [7917]], [[7917, 7917], "valid"], [[7918, 7918], "mapped", [7919]], [[7919, 7919], "valid"], [[7920, 7920], "mapped", [7921]], [[7921, 7921], "valid"], [[7922, 7922], "mapped", [7923]], [[7923, 7923], "valid"], [[7924, 7924], "mapped", [7925]], [[7925, 7925], "valid"], [[7926, 7926], "mapped", [7927]], [[7927, 7927], "valid"], [[7928, 7928], "mapped", [7929]], [[7929, 7929], "valid"], [[7930, 7930], "mapped", [7931]], [[7931, 7931], "valid"], [[7932, 7932], "mapped", [7933]], [[7933, 7933], "valid"], [[7934, 7934], "mapped", [7935]], [[7935, 7935], "valid"], [[7936, 7943], "valid"], [[7944, 7944], "mapped", [7936]], [[7945, 7945], "mapped", [7937]], [[7946, 7946], "mapped", [7938]], [[7947, 7947], "mapped", [7939]], [[7948, 7948], "mapped", [7940]], [[7949, 7949], "mapped", [7941]], [[7950, 7950], "mapped", [7942]], [[7951, 7951], "mapped", [7943]], [[7952, 7957], "valid"], [[7958, 7959], "disallowed"], [[7960, 7960], "mapped", [7952]], [[7961, 7961], "mapped", [7953]], [[7962, 7962], "mapped", [7954]], [[7963, 7963], "mapped", [7955]], [[7964, 7964], "mapped", [7956]], [[7965, 7965], "mapped", [7957]], [[7966, 7967], "disallowed"], [[7968, 7975], "valid"], [[7976, 7976], "mapped", [7968]], [[7977, 7977], "mapped", [7969]], [[7978, 7978], "mapped", [7970]], [[7979, 7979], "mapped", [7971]], [[7980, 7980], "mapped", [7972]], [[7981, 7981], "mapped", [7973]], [[7982, 7982], "mapped", [7974]], [[7983, 7983], "mapped", [7975]], [[7984, 7991], "valid"], [[7992, 7992], "mapped", [7984]], [[7993, 7993], "mapped", [7985]], [[7994, 7994], "mapped", [7986]], [[7995, 7995], "mapped", [7987]], [[7996, 7996], "mapped", [7988]], [[7997, 7997], "mapped", [7989]], [[7998, 7998], "mapped", [7990]], [[7999, 7999], "mapped", [7991]], [[8e3, 8005], "valid"], [[8006, 8007], "disallowed"], [[8008, 8008], "mapped", [8e3]], [[8009, 8009], "mapped", [8001]], [[8010, 8010], "mapped", [8002]], [[8011, 8011], "mapped", [8003]], [[8012, 8012], "mapped", [8004]], [[8013, 8013], "mapped", [8005]], [[8014, 8015], "disallowed"], [[8016, 8023], "valid"], [[8024, 8024], "disallowed"], [[8025, 8025], "mapped", [8017]], [[8026, 8026], "disallowed"], [[8027, 8027], "mapped", [8019]], [[8028, 8028], "disallowed"], [[8029, 8029], "mapped", [8021]], [[8030, 8030], "disallowed"], [[8031, 8031], "mapped", [8023]], [[8032, 8039], "valid"], [[8040, 8040], "mapped", [8032]], [[8041, 8041], "mapped", [8033]], [[8042, 8042], "mapped", [8034]], [[8043, 8043], "mapped", [8035]], [[8044, 8044], "mapped", [8036]], [[8045, 8045], "mapped", [8037]], [[8046, 8046], "mapped", [8038]], [[8047, 8047], "mapped", [8039]], [[8048, 8048], "valid"], [[8049, 8049], "mapped", [940]], [[8050, 8050], "valid"], [[8051, 8051], "mapped", [941]], [[8052, 8052], "valid"], [[8053, 8053], "mapped", [942]], [[8054, 8054], "valid"], [[8055, 8055], "mapped", [943]], [[8056, 8056], "valid"], [[8057, 8057], "mapped", [972]], [[8058, 8058], "valid"], [[8059, 8059], "mapped", [973]], [[8060, 8060], "valid"], [[8061, 8061], "mapped", [974]], [[8062, 8063], "disallowed"], [[8064, 8064], "mapped", [7936, 953]], [[8065, 8065], "mapped", [7937, 953]], [[8066, 8066], "mapped", [7938, 953]], [[8067, 8067], "mapped", [7939, 953]], [[8068, 8068], "mapped", [7940, 953]], [[8069, 8069], "mapped", [7941, 953]], [[8070, 8070], "mapped", [7942, 953]], [[8071, 8071], "mapped", [7943, 953]], [[8072, 8072], "mapped", [7936, 953]], [[8073, 8073], "mapped", [7937, 953]], [[8074, 8074], "mapped", [7938, 953]], [[8075, 8075], "mapped", [7939, 953]], [[8076, 8076], "mapped", [7940, 953]], [[8077, 8077], "mapped", [7941, 953]], [[8078, 8078], "mapped", [7942, 953]], [[8079, 8079], "mapped", [7943, 953]], [[8080, 8080], "mapped", [7968, 953]], [[8081, 8081], "mapped", [7969, 953]], [[8082, 8082], "mapped", [7970, 953]], [[8083, 8083], "mapped", [7971, 953]], [[8084, 8084], "mapped", [7972, 953]], [[8085, 8085], "mapped", [7973, 953]], [[8086, 8086], "mapped", [7974, 953]], [[8087, 8087], "mapped", [7975, 953]], [[8088, 8088], "mapped", [7968, 953]], [[8089, 8089], "mapped", [7969, 953]], [[8090, 8090], "mapped", [7970, 953]], [[8091, 8091], "mapped", [7971, 953]], [[8092, 8092], "mapped", [7972, 953]], [[8093, 8093], "mapped", [7973, 953]], [[8094, 8094], "mapped", [7974, 953]], [[8095, 8095], "mapped", [7975, 953]], [[8096, 8096], "mapped", [8032, 953]], [[8097, 8097], "mapped", [8033, 953]], [[8098, 8098], "mapped", [8034, 953]], [[8099, 8099], "mapped", [8035, 953]], [[8100, 8100], "mapped", [8036, 953]], [[8101, 8101], "mapped", [8037, 953]], [[8102, 8102], "mapped", [8038, 953]], [[8103, 8103], "mapped", [8039, 953]], [[8104, 8104], "mapped", [8032, 953]], [[8105, 8105], "mapped", [8033, 953]], [[8106, 8106], "mapped", [8034, 953]], [[8107, 8107], "mapped", [8035, 953]], [[8108, 8108], "mapped", [8036, 953]], [[8109, 8109], "mapped", [8037, 953]], [[8110, 8110], "mapped", [8038, 953]], [[8111, 8111], "mapped", [8039, 953]], [[8112, 8113], "valid"], [[8114, 8114], "mapped", [8048, 953]], [[8115, 8115], "mapped", [945, 953]], [[8116, 8116], "mapped", [940, 953]], [[8117, 8117], "disallowed"], [[8118, 8118], "valid"], [[8119, 8119], "mapped", [8118, 953]], [[8120, 8120], "mapped", [8112]], [[8121, 8121], "mapped", [8113]], [[8122, 8122], "mapped", [8048]], [[8123, 8123], "mapped", [940]], [[8124, 8124], "mapped", [945, 953]], [[8125, 8125], "disallowed_STD3_mapped", [32, 787]], [[8126, 8126], "mapped", [953]], [[8127, 8127], "disallowed_STD3_mapped", [32, 787]], [[8128, 8128], "disallowed_STD3_mapped", [32, 834]], [[8129, 8129], "disallowed_STD3_mapped", [32, 776, 834]], [[8130, 8130], "mapped", [8052, 953]], [[8131, 8131], "mapped", [951, 953]], [[8132, 8132], "mapped", [942, 953]], [[8133, 8133], "disallowed"], [[8134, 8134], "valid"], [[8135, 8135], "mapped", [8134, 953]], [[8136, 8136], "mapped", [8050]], [[8137, 8137], "mapped", [941]], [[8138, 8138], "mapped", [8052]], [[8139, 8139], "mapped", [942]], [[8140, 8140], "mapped", [951, 953]], [[8141, 8141], "disallowed_STD3_mapped", [32, 787, 768]], [[8142, 8142], "disallowed_STD3_mapped", [32, 787, 769]], [[8143, 8143], "disallowed_STD3_mapped", [32, 787, 834]], [[8144, 8146], "valid"], [[8147, 8147], "mapped", [912]], [[8148, 8149], "disallowed"], [[8150, 8151], "valid"], [[8152, 8152], "mapped", [8144]], [[8153, 8153], "mapped", [8145]], [[8154, 8154], "mapped", [8054]], [[8155, 8155], "mapped", [943]], [[8156, 8156], "disallowed"], [[8157, 8157], "disallowed_STD3_mapped", [32, 788, 768]], [[8158, 8158], "disallowed_STD3_mapped", [32, 788, 769]], [[8159, 8159], "disallowed_STD3_mapped", [32, 788, 834]], [[8160, 8162], "valid"], [[8163, 8163], "mapped", [944]], [[8164, 8167], "valid"], [[8168, 8168], "mapped", [8160]], [[8169, 8169], "mapped", [8161]], [[8170, 8170], "mapped", [8058]], [[8171, 8171], "mapped", [973]], [[8172, 8172], "mapped", [8165]], [[8173, 8173], "disallowed_STD3_mapped", [32, 776, 768]], [[8174, 8174], "disallowed_STD3_mapped", [32, 776, 769]], [[8175, 8175], "disallowed_STD3_mapped", [96]], [[8176, 8177], "disallowed"], [[8178, 8178], "mapped", [8060, 953]], [[8179, 8179], "mapped", [969, 953]], [[8180, 8180], "mapped", [974, 953]], [[8181, 8181], "disallowed"], [[8182, 8182], "valid"], [[8183, 8183], "mapped", [8182, 953]], [[8184, 8184], "mapped", [8056]], [[8185, 8185], "mapped", [972]], [[8186, 8186], "mapped", [8060]], [[8187, 8187], "mapped", [974]], [[8188, 8188], "mapped", [969, 953]], [[8189, 8189], "disallowed_STD3_mapped", [32, 769]], [[8190, 8190], "disallowed_STD3_mapped", [32, 788]], [[8191, 8191], "disallowed"], [[8192, 8202], "disallowed_STD3_mapped", [32]], [[8203, 8203], "ignored"], [[8204, 8205], "deviation", []], [[8206, 8207], "disallowed"], [[8208, 8208], "valid", [], "NV8"], [[8209, 8209], "mapped", [8208]], [[8210, 8214], "valid", [], "NV8"], [[8215, 8215], "disallowed_STD3_mapped", [32, 819]], [[8216, 8227], "valid", [], "NV8"], [[8228, 8230], "disallowed"], [[8231, 8231], "valid", [], "NV8"], [[8232, 8238], "disallowed"], [[8239, 8239], "disallowed_STD3_mapped", [32]], [[8240, 8242], "valid", [], "NV8"], [[8243, 8243], "mapped", [8242, 8242]], [[8244, 8244], "mapped", [8242, 8242, 8242]], [[8245, 8245], "valid", [], "NV8"], [[8246, 8246], "mapped", [8245, 8245]], [[8247, 8247], "mapped", [8245, 8245, 8245]], [[8248, 8251], "valid", [], "NV8"], [[8252, 8252], "disallowed_STD3_mapped", [33, 33]], [[8253, 8253], "valid", [], "NV8"], [[8254, 8254], "disallowed_STD3_mapped", [32, 773]], [[8255, 8262], "valid", [], "NV8"], [[8263, 8263], "disallowed_STD3_mapped", [63, 63]], [[8264, 8264], "disallowed_STD3_mapped", [63, 33]], [[8265, 8265], "disallowed_STD3_mapped", [33, 63]], [[8266, 8269], "valid", [], "NV8"], [[8270, 8274], "valid", [], "NV8"], [[8275, 8276], "valid", [], "NV8"], [[8277, 8278], "valid", [], "NV8"], [[8279, 8279], "mapped", [8242, 8242, 8242, 8242]], [[8280, 8286], "valid", [], "NV8"], [[8287, 8287], "disallowed_STD3_mapped", [32]], [[8288, 8288], "ignored"], [[8289, 8291], "disallowed"], [[8292, 8292], "ignored"], [[8293, 8293], "disallowed"], [[8294, 8297], "disallowed"], [[8298, 8303], "disallowed"], [[8304, 8304], "mapped", [48]], [[8305, 8305], "mapped", [105]], [[8306, 8307], "disallowed"], [[8308, 8308], "mapped", [52]], [[8309, 8309], "mapped", [53]], [[8310, 8310], "mapped", [54]], [[8311, 8311], "mapped", [55]], [[8312, 8312], "mapped", [56]], [[8313, 8313], "mapped", [57]], [[8314, 8314], "disallowed_STD3_mapped", [43]], [[8315, 8315], "mapped", [8722]], [[8316, 8316], "disallowed_STD3_mapped", [61]], [[8317, 8317], "disallowed_STD3_mapped", [40]], [[8318, 8318], "disallowed_STD3_mapped", [41]], [[8319, 8319], "mapped", [110]], [[8320, 8320], "mapped", [48]], [[8321, 8321], "mapped", [49]], [[8322, 8322], "mapped", [50]], [[8323, 8323], "mapped", [51]], [[8324, 8324], "mapped", [52]], [[8325, 8325], "mapped", [53]], [[8326, 8326], "mapped", [54]], [[8327, 8327], "mapped", [55]], [[8328, 8328], "mapped", [56]], [[8329, 8329], "mapped", [57]], [[8330, 8330], "disallowed_STD3_mapped", [43]], [[8331, 8331], "mapped", [8722]], [[8332, 8332], "disallowed_STD3_mapped", [61]], [[8333, 8333], "disallowed_STD3_mapped", [40]], [[8334, 8334], "disallowed_STD3_mapped", [41]], [[8335, 8335], "disallowed"], [[8336, 8336], "mapped", [97]], [[8337, 8337], "mapped", [101]], [[8338, 8338], "mapped", [111]], [[8339, 8339], "mapped", [120]], [[8340, 8340], "mapped", [601]], [[8341, 8341], "mapped", [104]], [[8342, 8342], "mapped", [107]], [[8343, 8343], "mapped", [108]], [[8344, 8344], "mapped", [109]], [[8345, 8345], "mapped", [110]], [[8346, 8346], "mapped", [112]], [[8347, 8347], "mapped", [115]], [[8348, 8348], "mapped", [116]], [[8349, 8351], "disallowed"], [[8352, 8359], "valid", [], "NV8"], [[8360, 8360], "mapped", [114, 115]], [[8361, 8362], "valid", [], "NV8"], [[8363, 8363], "valid", [], "NV8"], [[8364, 8364], "valid", [], "NV8"], [[8365, 8367], "valid", [], "NV8"], [[8368, 8369], "valid", [], "NV8"], [[8370, 8373], "valid", [], "NV8"], [[8374, 8376], "valid", [], "NV8"], [[8377, 8377], "valid", [], "NV8"], [[8378, 8378], "valid", [], "NV8"], [[8379, 8381], "valid", [], "NV8"], [[8382, 8382], "valid", [], "NV8"], [[8383, 8399], "disallowed"], [[8400, 8417], "valid", [], "NV8"], [[8418, 8419], "valid", [], "NV8"], [[8420, 8426], "valid", [], "NV8"], [[8427, 8427], "valid", [], "NV8"], [[8428, 8431], "valid", [], "NV8"], [[8432, 8432], "valid", [], "NV8"], [[8433, 8447], "disallowed"], [[8448, 8448], "disallowed_STD3_mapped", [97, 47, 99]], [[8449, 8449], "disallowed_STD3_mapped", [97, 47, 115]], [[8450, 8450], "mapped", [99]], [[8451, 8451], "mapped", [176, 99]], [[8452, 8452], "valid", [], "NV8"], [[8453, 8453], "disallowed_STD3_mapped", [99, 47, 111]], [[8454, 8454], "disallowed_STD3_mapped", [99, 47, 117]], [[8455, 8455], "mapped", [603]], [[8456, 8456], "valid", [], "NV8"], [[8457, 8457], "mapped", [176, 102]], [[8458, 8458], "mapped", [103]], [[8459, 8462], "mapped", [104]], [[8463, 8463], "mapped", [295]], [[8464, 8465], "mapped", [105]], [[8466, 8467], "mapped", [108]], [[8468, 8468], "valid", [], "NV8"], [[8469, 8469], "mapped", [110]], [[8470, 8470], "mapped", [110, 111]], [[8471, 8472], "valid", [], "NV8"], [[8473, 8473], "mapped", [112]], [[8474, 8474], "mapped", [113]], [[8475, 8477], "mapped", [114]], [[8478, 8479], "valid", [], "NV8"], [[8480, 8480], "mapped", [115, 109]], [[8481, 8481], "mapped", [116, 101, 108]], [[8482, 8482], "mapped", [116, 109]], [[8483, 8483], "valid", [], "NV8"], [[8484, 8484], "mapped", [122]], [[8485, 8485], "valid", [], "NV8"], [[8486, 8486], "mapped", [969]], [[8487, 8487], "valid", [], "NV8"], [[8488, 8488], "mapped", [122]], [[8489, 8489], "valid", [], "NV8"], [[8490, 8490], "mapped", [107]], [[8491, 8491], "mapped", [229]], [[8492, 8492], "mapped", [98]], [[8493, 8493], "mapped", [99]], [[8494, 8494], "valid", [], "NV8"], [[8495, 8496], "mapped", [101]], [[8497, 8497], "mapped", [102]], [[8498, 8498], "disallowed"], [[8499, 8499], "mapped", [109]], [[8500, 8500], "mapped", [111]], [[8501, 8501], "mapped", [1488]], [[8502, 8502], "mapped", [1489]], [[8503, 8503], "mapped", [1490]], [[8504, 8504], "mapped", [1491]], [[8505, 8505], "mapped", [105]], [[8506, 8506], "valid", [], "NV8"], [[8507, 8507], "mapped", [102, 97, 120]], [[8508, 8508], "mapped", [960]], [[8509, 8510], "mapped", [947]], [[8511, 8511], "mapped", [960]], [[8512, 8512], "mapped", [8721]], [[8513, 8516], "valid", [], "NV8"], [[8517, 8518], "mapped", [100]], [[8519, 8519], "mapped", [101]], [[8520, 8520], "mapped", [105]], [[8521, 8521], "mapped", [106]], [[8522, 8523], "valid", [], "NV8"], [[8524, 8524], "valid", [], "NV8"], [[8525, 8525], "valid", [], "NV8"], [[8526, 8526], "valid"], [[8527, 8527], "valid", [], "NV8"], [[8528, 8528], "mapped", [49, 8260, 55]], [[8529, 8529], "mapped", [49, 8260, 57]], [[8530, 8530], "mapped", [49, 8260, 49, 48]], [[8531, 8531], "mapped", [49, 8260, 51]], [[8532, 8532], "mapped", [50, 8260, 51]], [[8533, 8533], "mapped", [49, 8260, 53]], [[8534, 8534], "mapped", [50, 8260, 53]], [[8535, 8535], "mapped", [51, 8260, 53]], [[8536, 8536], "mapped", [52, 8260, 53]], [[8537, 8537], "mapped", [49, 8260, 54]], [[8538, 8538], "mapped", [53, 8260, 54]], [[8539, 8539], "mapped", [49, 8260, 56]], [[8540, 8540], "mapped", [51, 8260, 56]], [[8541, 8541], "mapped", [53, 8260, 56]], [[8542, 8542], "mapped", [55, 8260, 56]], [[8543, 8543], "mapped", [49, 8260]], [[8544, 8544], "mapped", [105]], [[8545, 8545], "mapped", [105, 105]], [[8546, 8546], "mapped", [105, 105, 105]], [[8547, 8547], "mapped", [105, 118]], [[8548, 8548], "mapped", [118]], [[8549, 8549], "mapped", [118, 105]], [[8550, 8550], "mapped", [118, 105, 105]], [[8551, 8551], "mapped", [118, 105, 105, 105]], [[8552, 8552], "mapped", [105, 120]], [[8553, 8553], "mapped", [120]], [[8554, 8554], "mapped", [120, 105]], [[8555, 8555], "mapped", [120, 105, 105]], [[8556, 8556], "mapped", [108]], [[8557, 8557], "mapped", [99]], [[8558, 8558], "mapped", [100]], [[8559, 8559], "mapped", [109]], [[8560, 8560], "mapped", [105]], [[8561, 8561], "mapped", [105, 105]], [[8562, 8562], "mapped", [105, 105, 105]], [[8563, 8563], "mapped", [105, 118]], [[8564, 8564], "mapped", [118]], [[8565, 8565], "mapped", [118, 105]], [[8566, 8566], "mapped", [118, 105, 105]], [[8567, 8567], "mapped", [118, 105, 105, 105]], [[8568, 8568], "mapped", [105, 120]], [[8569, 8569], "mapped", [120]], [[8570, 8570], "mapped", [120, 105]], [[8571, 8571], "mapped", [120, 105, 105]], [[8572, 8572], "mapped", [108]], [[8573, 8573], "mapped", [99]], [[8574, 8574], "mapped", [100]], [[8575, 8575], "mapped", [109]], [[8576, 8578], "valid", [], "NV8"], [[8579, 8579], "disallowed"], [[8580, 8580], "valid"], [[8581, 8584], "valid", [], "NV8"], [[8585, 8585], "mapped", [48, 8260, 51]], [[8586, 8587], "valid", [], "NV8"], [[8588, 8591], "disallowed"], [[8592, 8682], "valid", [], "NV8"], [[8683, 8691], "valid", [], "NV8"], [[8692, 8703], "valid", [], "NV8"], [[8704, 8747], "valid", [], "NV8"], [[8748, 8748], "mapped", [8747, 8747]], [[8749, 8749], "mapped", [8747, 8747, 8747]], [[8750, 8750], "valid", [], "NV8"], [[8751, 8751], "mapped", [8750, 8750]], [[8752, 8752], "mapped", [8750, 8750, 8750]], [[8753, 8799], "valid", [], "NV8"], [[8800, 8800], "disallowed_STD3_valid"], [[8801, 8813], "valid", [], "NV8"], [[8814, 8815], "disallowed_STD3_valid"], [[8816, 8945], "valid", [], "NV8"], [[8946, 8959], "valid", [], "NV8"], [[8960, 8960], "valid", [], "NV8"], [[8961, 8961], "valid", [], "NV8"], [[8962, 9e3], "valid", [], "NV8"], [[9001, 9001], "mapped", [12296]], [[9002, 9002], "mapped", [12297]], [[9003, 9082], "valid", [], "NV8"], [[9083, 9083], "valid", [], "NV8"], [[9084, 9084], "valid", [], "NV8"], [[9085, 9114], "valid", [], "NV8"], [[9115, 9166], "valid", [], "NV8"], [[9167, 9168], "valid", [], "NV8"], [[9169, 9179], "valid", [], "NV8"], [[9180, 9191], "valid", [], "NV8"], [[9192, 9192], "valid", [], "NV8"], [[9193, 9203], "valid", [], "NV8"], [[9204, 9210], "valid", [], "NV8"], [[9211, 9215], "disallowed"], [[9216, 9252], "valid", [], "NV8"], [[9253, 9254], "valid", [], "NV8"], [[9255, 9279], "disallowed"], [[9280, 9290], "valid", [], "NV8"], [[9291, 9311], "disallowed"], [[9312, 9312], "mapped", [49]], [[9313, 9313], "mapped", [50]], [[9314, 9314], "mapped", [51]], [[9315, 9315], "mapped", [52]], [[9316, 9316], "mapped", [53]], [[9317, 9317], "mapped", [54]], [[9318, 9318], "mapped", [55]], [[9319, 9319], "mapped", [56]], [[9320, 9320], "mapped", [57]], [[9321, 9321], "mapped", [49, 48]], [[9322, 9322], "mapped", [49, 49]], [[9323, 9323], "mapped", [49, 50]], [[9324, 9324], "mapped", [49, 51]], [[9325, 9325], "mapped", [49, 52]], [[9326, 9326], "mapped", [49, 53]], [[9327, 9327], "mapped", [49, 54]], [[9328, 9328], "mapped", [49, 55]], [[9329, 9329], "mapped", [49, 56]], [[9330, 9330], "mapped", [49, 57]], [[9331, 9331], "mapped", [50, 48]], [[9332, 9332], "disallowed_STD3_mapped", [40, 49, 41]], [[9333, 9333], "disallowed_STD3_mapped", [40, 50, 41]], [[9334, 9334], "disallowed_STD3_mapped", [40, 51, 41]], [[9335, 9335], "disallowed_STD3_mapped", [40, 52, 41]], [[9336, 9336], "disallowed_STD3_mapped", [40, 53, 41]], [[9337, 9337], "disallowed_STD3_mapped", [40, 54, 41]], [[9338, 9338], "disallowed_STD3_mapped", [40, 55, 41]], [[9339, 9339], "disallowed_STD3_mapped", [40, 56, 41]], [[9340, 9340], "disallowed_STD3_mapped", [40, 57, 41]], [[9341, 9341], "disallowed_STD3_mapped", [40, 49, 48, 41]], [[9342, 9342], "disallowed_STD3_mapped", [40, 49, 49, 41]], [[9343, 9343], "disallowed_STD3_mapped", [40, 49, 50, 41]], [[9344, 9344], "disallowed_STD3_mapped", [40, 49, 51, 41]], [[9345, 9345], "disallowed_STD3_mapped", [40, 49, 52, 41]], [[9346, 9346], "disallowed_STD3_mapped", [40, 49, 53, 41]], [[9347, 9347], "disallowed_STD3_mapped", [40, 49, 54, 41]], [[9348, 9348], "disallowed_STD3_mapped", [40, 49, 55, 41]], [[9349, 9349], "disallowed_STD3_mapped", [40, 49, 56, 41]], [[9350, 9350], "disallowed_STD3_mapped", [40, 49, 57, 41]], [[9351, 9351], "disallowed_STD3_mapped", [40, 50, 48, 41]], [[9352, 9371], "disallowed"], [[9372, 9372], "disallowed_STD3_mapped", [40, 97, 41]], [[9373, 9373], "disallowed_STD3_mapped", [40, 98, 41]], [[9374, 9374], "disallowed_STD3_mapped", [40, 99, 41]], [[9375, 9375], "disallowed_STD3_mapped", [40, 100, 41]], [[9376, 9376], "disallowed_STD3_mapped", [40, 101, 41]], [[9377, 9377], "disallowed_STD3_mapped", [40, 102, 41]], [[9378, 9378], "disallowed_STD3_mapped", [40, 103, 41]], [[9379, 9379], "disallowed_STD3_mapped", [40, 104, 41]], [[9380, 9380], "disallowed_STD3_mapped", [40, 105, 41]], [[9381, 9381], "disallowed_STD3_mapped", [40, 106, 41]], [[9382, 9382], "disallowed_STD3_mapped", [40, 107, 41]], [[9383, 9383], "disallowed_STD3_mapped", [40, 108, 41]], [[9384, 9384], "disallowed_STD3_mapped", [40, 109, 41]], [[9385, 9385], "disallowed_STD3_mapped", [40, 110, 41]], [[9386, 9386], "disallowed_STD3_mapped", [40, 111, 41]], [[9387, 9387], "disallowed_STD3_mapped", [40, 112, 41]], [[9388, 9388], "disallowed_STD3_mapped", [40, 113, 41]], [[9389, 9389], "disallowed_STD3_mapped", [40, 114, 41]], [[9390, 9390], "disallowed_STD3_mapped", [40, 115, 41]], [[9391, 9391], "disallowed_STD3_mapped", [40, 116, 41]], [[9392, 9392], "disallowed_STD3_mapped", [40, 117, 41]], [[9393, 9393], "disallowed_STD3_mapped", [40, 118, 41]], [[9394, 9394], "disallowed_STD3_mapped", [40, 119, 41]], [[9395, 9395], "disallowed_STD3_mapped", [40, 120, 41]], [[9396, 9396], "disallowed_STD3_mapped", [40, 121, 41]], [[9397, 9397], "disallowed_STD3_mapped", [40, 122, 41]], [[9398, 9398], "mapped", [97]], [[9399, 9399], "mapped", [98]], [[9400, 9400], "mapped", [99]], [[9401, 9401], "mapped", [100]], [[9402, 9402], "mapped", [101]], [[9403, 9403], "mapped", [102]], [[9404, 9404], "mapped", [103]], [[9405, 9405], "mapped", [104]], [[9406, 9406], "mapped", [105]], [[9407, 9407], "mapped", [106]], [[9408, 9408], "mapped", [107]], [[9409, 9409], "mapped", [108]], [[9410, 9410], "mapped", [109]], [[9411, 9411], "mapped", [110]], [[9412, 9412], "mapped", [111]], [[9413, 9413], "mapped", [112]], [[9414, 9414], "mapped", [113]], [[9415, 9415], "mapped", [114]], [[9416, 9416], "mapped", [115]], [[9417, 9417], "mapped", [116]], [[9418, 9418], "mapped", [117]], [[9419, 9419], "mapped", [118]], [[9420, 9420], "mapped", [119]], [[9421, 9421], "mapped", [120]], [[9422, 9422], "mapped", [121]], [[9423, 9423], "mapped", [122]], [[9424, 9424], "mapped", [97]], [[9425, 9425], "mapped", [98]], [[9426, 9426], "mapped", [99]], [[9427, 9427], "mapped", [100]], [[9428, 9428], "mapped", [101]], [[9429, 9429], "mapped", [102]], [[9430, 9430], "mapped", [103]], [[9431, 9431], "mapped", [104]], [[9432, 9432], "mapped", [105]], [[9433, 9433], "mapped", [106]], [[9434, 9434], "mapped", [107]], [[9435, 9435], "mapped", [108]], [[9436, 9436], "mapped", [109]], [[9437, 9437], "mapped", [110]], [[9438, 9438], "mapped", [111]], [[9439, 9439], "mapped", [112]], [[9440, 9440], "mapped", [113]], [[9441, 9441], "mapped", [114]], [[9442, 9442], "mapped", [115]], [[9443, 9443], "mapped", [116]], [[9444, 9444], "mapped", [117]], [[9445, 9445], "mapped", [118]], [[9446, 9446], "mapped", [119]], [[9447, 9447], "mapped", [120]], [[9448, 9448], "mapped", [121]], [[9449, 9449], "mapped", [122]], [[9450, 9450], "mapped", [48]], [[9451, 9470], "valid", [], "NV8"], [[9471, 9471], "valid", [], "NV8"], [[9472, 9621], "valid", [], "NV8"], [[9622, 9631], "valid", [], "NV8"], [[9632, 9711], "valid", [], "NV8"], [[9712, 9719], "valid", [], "NV8"], [[9720, 9727], "valid", [], "NV8"], [[9728, 9747], "valid", [], "NV8"], [[9748, 9749], "valid", [], "NV8"], [[9750, 9751], "valid", [], "NV8"], [[9752, 9752], "valid", [], "NV8"], [[9753, 9753], "valid", [], "NV8"], [[9754, 9839], "valid", [], "NV8"], [[9840, 9841], "valid", [], "NV8"], [[9842, 9853], "valid", [], "NV8"], [[9854, 9855], "valid", [], "NV8"], [[9856, 9865], "valid", [], "NV8"], [[9866, 9873], "valid", [], "NV8"], [[9874, 9884], "valid", [], "NV8"], [[9885, 9885], "valid", [], "NV8"], [[9886, 9887], "valid", [], "NV8"], [[9888, 9889], "valid", [], "NV8"], [[9890, 9905], "valid", [], "NV8"], [[9906, 9906], "valid", [], "NV8"], [[9907, 9916], "valid", [], "NV8"], [[9917, 9919], "valid", [], "NV8"], [[9920, 9923], "valid", [], "NV8"], [[9924, 9933], "valid", [], "NV8"], [[9934, 9934], "valid", [], "NV8"], [[9935, 9953], "valid", [], "NV8"], [[9954, 9954], "valid", [], "NV8"], [[9955, 9955], "valid", [], "NV8"], [[9956, 9959], "valid", [], "NV8"], [[9960, 9983], "valid", [], "NV8"], [[9984, 9984], "valid", [], "NV8"], [[9985, 9988], "valid", [], "NV8"], [[9989, 9989], "valid", [], "NV8"], [[9990, 9993], "valid", [], "NV8"], [[9994, 9995], "valid", [], "NV8"], [[9996, 10023], "valid", [], "NV8"], [[10024, 10024], "valid", [], "NV8"], [[10025, 10059], "valid", [], "NV8"], [[10060, 10060], "valid", [], "NV8"], [[10061, 10061], "valid", [], "NV8"], [[10062, 10062], "valid", [], "NV8"], [[10063, 10066], "valid", [], "NV8"], [[10067, 10069], "valid", [], "NV8"], [[10070, 10070], "valid", [], "NV8"], [[10071, 10071], "valid", [], "NV8"], [[10072, 10078], "valid", [], "NV8"], [[10079, 10080], "valid", [], "NV8"], [[10081, 10087], "valid", [], "NV8"], [[10088, 10101], "valid", [], "NV8"], [[10102, 10132], "valid", [], "NV8"], [[10133, 10135], "valid", [], "NV8"], [[10136, 10159], "valid", [], "NV8"], [[10160, 10160], "valid", [], "NV8"], [[10161, 10174], "valid", [], "NV8"], [[10175, 10175], "valid", [], "NV8"], [[10176, 10182], "valid", [], "NV8"], [[10183, 10186], "valid", [], "NV8"], [[10187, 10187], "valid", [], "NV8"], [[10188, 10188], "valid", [], "NV8"], [[10189, 10189], "valid", [], "NV8"], [[10190, 10191], "valid", [], "NV8"], [[10192, 10219], "valid", [], "NV8"], [[10220, 10223], "valid", [], "NV8"], [[10224, 10239], "valid", [], "NV8"], [[10240, 10495], "valid", [], "NV8"], [[10496, 10763], "valid", [], "NV8"], [[10764, 10764], "mapped", [8747, 8747, 8747, 8747]], [[10765, 10867], "valid", [], "NV8"], [[10868, 10868], "disallowed_STD3_mapped", [58, 58, 61]], [[10869, 10869], "disallowed_STD3_mapped", [61, 61]], [[10870, 10870], "disallowed_STD3_mapped", [61, 61, 61]], [[10871, 10971], "valid", [], "NV8"], [[10972, 10972], "mapped", [10973, 824]], [[10973, 11007], "valid", [], "NV8"], [[11008, 11021], "valid", [], "NV8"], [[11022, 11027], "valid", [], "NV8"], [[11028, 11034], "valid", [], "NV8"], [[11035, 11039], "valid", [], "NV8"], [[11040, 11043], "valid", [], "NV8"], [[11044, 11084], "valid", [], "NV8"], [[11085, 11087], "valid", [], "NV8"], [[11088, 11092], "valid", [], "NV8"], [[11093, 11097], "valid", [], "NV8"], [[11098, 11123], "valid", [], "NV8"], [[11124, 11125], "disallowed"], [[11126, 11157], "valid", [], "NV8"], [[11158, 11159], "disallowed"], [[11160, 11193], "valid", [], "NV8"], [[11194, 11196], "disallowed"], [[11197, 11208], "valid", [], "NV8"], [[11209, 11209], "disallowed"], [[11210, 11217], "valid", [], "NV8"], [[11218, 11243], "disallowed"], [[11244, 11247], "valid", [], "NV8"], [[11248, 11263], "disallowed"], [[11264, 11264], "mapped", [11312]], [[11265, 11265], "mapped", [11313]], [[11266, 11266], "mapped", [11314]], [[11267, 11267], "mapped", [11315]], [[11268, 11268], "mapped", [11316]], [[11269, 11269], "mapped", [11317]], [[11270, 11270], "mapped", [11318]], [[11271, 11271], "mapped", [11319]], [[11272, 11272], "mapped", [11320]], [[11273, 11273], "mapped", [11321]], [[11274, 11274], "mapped", [11322]], [[11275, 11275], "mapped", [11323]], [[11276, 11276], "mapped", [11324]], [[11277, 11277], "mapped", [11325]], [[11278, 11278], "mapped", [11326]], [[11279, 11279], "mapped", [11327]], [[11280, 11280], "mapped", [11328]], [[11281, 11281], "mapped", [11329]], [[11282, 11282], "mapped", [11330]], [[11283, 11283], "mapped", [11331]], [[11284, 11284], "mapped", [11332]], [[11285, 11285], "mapped", [11333]], [[11286, 11286], "mapped", [11334]], [[11287, 11287], "mapped", [11335]], [[11288, 11288], "mapped", [11336]], [[11289, 11289], "mapped", [11337]], [[11290, 11290], "mapped", [11338]], [[11291, 11291], "mapped", [11339]], [[11292, 11292], "mapped", [11340]], [[11293, 11293], "mapped", [11341]], [[11294, 11294], "mapped", [11342]], [[11295, 11295], "mapped", [11343]], [[11296, 11296], "mapped", [11344]], [[11297, 11297], "mapped", [11345]], [[11298, 11298], "mapped", [11346]], [[11299, 11299], "mapped", [11347]], [[11300, 11300], "mapped", [11348]], [[11301, 11301], "mapped", [11349]], [[11302, 11302], "mapped", [11350]], [[11303, 11303], "mapped", [11351]], [[11304, 11304], "mapped", [11352]], [[11305, 11305], "mapped", [11353]], [[11306, 11306], "mapped", [11354]], [[11307, 11307], "mapped", [11355]], [[11308, 11308], "mapped", [11356]], [[11309, 11309], "mapped", [11357]], [[11310, 11310], "mapped", [11358]], [[11311, 11311], "disallowed"], [[11312, 11358], "valid"], [[11359, 11359], "disallowed"], [[11360, 11360], "mapped", [11361]], [[11361, 11361], "valid"], [[11362, 11362], "mapped", [619]], [[11363, 11363], "mapped", [7549]], [[11364, 11364], "mapped", [637]], [[11365, 11366], "valid"], [[11367, 11367], "mapped", [11368]], [[11368, 11368], "valid"], [[11369, 11369], "mapped", [11370]], [[11370, 11370], "valid"], [[11371, 11371], "mapped", [11372]], [[11372, 11372], "valid"], [[11373, 11373], "mapped", [593]], [[11374, 11374], "mapped", [625]], [[11375, 11375], "mapped", [592]], [[11376, 11376], "mapped", [594]], [[11377, 11377], "valid"], [[11378, 11378], "mapped", [11379]], [[11379, 11379], "valid"], [[11380, 11380], "valid"], [[11381, 11381], "mapped", [11382]], [[11382, 11383], "valid"], [[11384, 11387], "valid"], [[11388, 11388], "mapped", [106]], [[11389, 11389], "mapped", [118]], [[11390, 11390], "mapped", [575]], [[11391, 11391], "mapped", [576]], [[11392, 11392], "mapped", [11393]], [[11393, 11393], "valid"], [[11394, 11394], "mapped", [11395]], [[11395, 11395], "valid"], [[11396, 11396], "mapped", [11397]], [[11397, 11397], "valid"], [[11398, 11398], "mapped", [11399]], [[11399, 11399], "valid"], [[11400, 11400], "mapped", [11401]], [[11401, 11401], "valid"], [[11402, 11402], "mapped", [11403]], [[11403, 11403], "valid"], [[11404, 11404], "mapped", [11405]], [[11405, 11405], "valid"], [[11406, 11406], "mapped", [11407]], [[11407, 11407], "valid"], [[11408, 11408], "mapped", [11409]], [[11409, 11409], "valid"], [[11410, 11410], "mapped", [11411]], [[11411, 11411], "valid"], [[11412, 11412], "mapped", [11413]], [[11413, 11413], "valid"], [[11414, 11414], "mapped", [11415]], [[11415, 11415], "valid"], [[11416, 11416], "mapped", [11417]], [[11417, 11417], "valid"], [[11418, 11418], "mapped", [11419]], [[11419, 11419], "valid"], [[11420, 11420], "mapped", [11421]], [[11421, 11421], "valid"], [[11422, 11422], "mapped", [11423]], [[11423, 11423], "valid"], [[11424, 11424], "mapped", [11425]], [[11425, 11425], "valid"], [[11426, 11426], "mapped", [11427]], [[11427, 11427], "valid"], [[11428, 11428], "mapped", [11429]], [[11429, 11429], "valid"], [[11430, 11430], "mapped", [11431]], [[11431, 11431], "valid"], [[11432, 11432], "mapped", [11433]], [[11433, 11433], "valid"], [[11434, 11434], "mapped", [11435]], [[11435, 11435], "valid"], [[11436, 11436], "mapped", [11437]], [[11437, 11437], "valid"], [[11438, 11438], "mapped", [11439]], [[11439, 11439], "valid"], [[11440, 11440], "mapped", [11441]], [[11441, 11441], "valid"], [[11442, 11442], "mapped", [11443]], [[11443, 11443], "valid"], [[11444, 11444], "mapped", [11445]], [[11445, 11445], "valid"], [[11446, 11446], "mapped", [11447]], [[11447, 11447], "valid"], [[11448, 11448], "mapped", [11449]], [[11449, 11449], "valid"], [[11450, 11450], "mapped", [11451]], [[11451, 11451], "valid"], [[11452, 11452], "mapped", [11453]], [[11453, 11453], "valid"], [[11454, 11454], "mapped", [11455]], [[11455, 11455], "valid"], [[11456, 11456], "mapped", [11457]], [[11457, 11457], "valid"], [[11458, 11458], "mapped", [11459]], [[11459, 11459], "valid"], [[11460, 11460], "mapped", [11461]], [[11461, 11461], "valid"], [[11462, 11462], "mapped", [11463]], [[11463, 11463], "valid"], [[11464, 11464], "mapped", [11465]], [[11465, 11465], "valid"], [[11466, 11466], "mapped", [11467]], [[11467, 11467], "valid"], [[11468, 11468], "mapped", [11469]], [[11469, 11469], "valid"], [[11470, 11470], "mapped", [11471]], [[11471, 11471], "valid"], [[11472, 11472], "mapped", [11473]], [[11473, 11473], "valid"], [[11474, 11474], "mapped", [11475]], [[11475, 11475], "valid"], [[11476, 11476], "mapped", [11477]], [[11477, 11477], "valid"], [[11478, 11478], "mapped", [11479]], [[11479, 11479], "valid"], [[11480, 11480], "mapped", [11481]], [[11481, 11481], "valid"], [[11482, 11482], "mapped", [11483]], [[11483, 11483], "valid"], [[11484, 11484], "mapped", [11485]], [[11485, 11485], "valid"], [[11486, 11486], "mapped", [11487]], [[11487, 11487], "valid"], [[11488, 11488], "mapped", [11489]], [[11489, 11489], "valid"], [[11490, 11490], "mapped", [11491]], [[11491, 11492], "valid"], [[11493, 11498], "valid", [], "NV8"], [[11499, 11499], "mapped", [11500]], [[11500, 11500], "valid"], [[11501, 11501], "mapped", [11502]], [[11502, 11505], "valid"], [[11506, 11506], "mapped", [11507]], [[11507, 11507], "valid"], [[11508, 11512], "disallowed"], [[11513, 11519], "valid", [], "NV8"], [[11520, 11557], "valid"], [[11558, 11558], "disallowed"], [[11559, 11559], "valid"], [[11560, 11564], "disallowed"], [[11565, 11565], "valid"], [[11566, 11567], "disallowed"], [[11568, 11621], "valid"], [[11622, 11623], "valid"], [[11624, 11630], "disallowed"], [[11631, 11631], "mapped", [11617]], [[11632, 11632], "valid", [], "NV8"], [[11633, 11646], "disallowed"], [[11647, 11647], "valid"], [[11648, 11670], "valid"], [[11671, 11679], "disallowed"], [[11680, 11686], "valid"], [[11687, 11687], "disallowed"], [[11688, 11694], "valid"], [[11695, 11695], "disallowed"], [[11696, 11702], "valid"], [[11703, 11703], "disallowed"], [[11704, 11710], "valid"], [[11711, 11711], "disallowed"], [[11712, 11718], "valid"], [[11719, 11719], "disallowed"], [[11720, 11726], "valid"], [[11727, 11727], "disallowed"], [[11728, 11734], "valid"], [[11735, 11735], "disallowed"], [[11736, 11742], "valid"], [[11743, 11743], "disallowed"], [[11744, 11775], "valid"], [[11776, 11799], "valid", [], "NV8"], [[11800, 11803], "valid", [], "NV8"], [[11804, 11805], "valid", [], "NV8"], [[11806, 11822], "valid", [], "NV8"], [[11823, 11823], "valid"], [[11824, 11824], "valid", [], "NV8"], [[11825, 11825], "valid", [], "NV8"], [[11826, 11835], "valid", [], "NV8"], [[11836, 11842], "valid", [], "NV8"], [[11843, 11903], "disallowed"], [[11904, 11929], "valid", [], "NV8"], [[11930, 11930], "disallowed"], [[11931, 11934], "valid", [], "NV8"], [[11935, 11935], "mapped", [27597]], [[11936, 12018], "valid", [], "NV8"], [[12019, 12019], "mapped", [40863]], [[12020, 12031], "disallowed"], [[12032, 12032], "mapped", [19968]], [[12033, 12033], "mapped", [20008]], [[12034, 12034], "mapped", [20022]], [[12035, 12035], "mapped", [20031]], [[12036, 12036], "mapped", [20057]], [[12037, 12037], "mapped", [20101]], [[12038, 12038], "mapped", [20108]], [[12039, 12039], "mapped", [20128]], [[12040, 12040], "mapped", [20154]], [[12041, 12041], "mapped", [20799]], [[12042, 12042], "mapped", [20837]], [[12043, 12043], "mapped", [20843]], [[12044, 12044], "mapped", [20866]], [[12045, 12045], "mapped", [20886]], [[12046, 12046], "mapped", [20907]], [[12047, 12047], "mapped", [20960]], [[12048, 12048], "mapped", [20981]], [[12049, 12049], "mapped", [20992]], [[12050, 12050], "mapped", [21147]], [[12051, 12051], "mapped", [21241]], [[12052, 12052], "mapped", [21269]], [[12053, 12053], "mapped", [21274]], [[12054, 12054], "mapped", [21304]], [[12055, 12055], "mapped", [21313]], [[12056, 12056], "mapped", [21340]], [[12057, 12057], "mapped", [21353]], [[12058, 12058], "mapped", [21378]], [[12059, 12059], "mapped", [21430]], [[12060, 12060], "mapped", [21448]], [[12061, 12061], "mapped", [21475]], [[12062, 12062], "mapped", [22231]], [[12063, 12063], "mapped", [22303]], [[12064, 12064], "mapped", [22763]], [[12065, 12065], "mapped", [22786]], [[12066, 12066], "mapped", [22794]], [[12067, 12067], "mapped", [22805]], [[12068, 12068], "mapped", [22823]], [[12069, 12069], "mapped", [22899]], [[12070, 12070], "mapped", [23376]], [[12071, 12071], "mapped", [23424]], [[12072, 12072], "mapped", [23544]], [[12073, 12073], "mapped", [23567]], [[12074, 12074], "mapped", [23586]], [[12075, 12075], "mapped", [23608]], [[12076, 12076], "mapped", [23662]], [[12077, 12077], "mapped", [23665]], [[12078, 12078], "mapped", [24027]], [[12079, 12079], "mapped", [24037]], [[12080, 12080], "mapped", [24049]], [[12081, 12081], "mapped", [24062]], [[12082, 12082], "mapped", [24178]], [[12083, 12083], "mapped", [24186]], [[12084, 12084], "mapped", [24191]], [[12085, 12085], "mapped", [24308]], [[12086, 12086], "mapped", [24318]], [[12087, 12087], "mapped", [24331]], [[12088, 12088], "mapped", [24339]], [[12089, 12089], "mapped", [24400]], [[12090, 12090], "mapped", [24417]], [[12091, 12091], "mapped", [24435]], [[12092, 12092], "mapped", [24515]], [[12093, 12093], "mapped", [25096]], [[12094, 12094], "mapped", [25142]], [[12095, 12095], "mapped", [25163]], [[12096, 12096], "mapped", [25903]], [[12097, 12097], "mapped", [25908]], [[12098, 12098], "mapped", [25991]], [[12099, 12099], "mapped", [26007]], [[12100, 12100], "mapped", [26020]], [[12101, 12101], "mapped", [26041]], [[12102, 12102], "mapped", [26080]], [[12103, 12103], "mapped", [26085]], [[12104, 12104], "mapped", [26352]], [[12105, 12105], "mapped", [26376]], [[12106, 12106], "mapped", [26408]], [[12107, 12107], "mapped", [27424]], [[12108, 12108], "mapped", [27490]], [[12109, 12109], "mapped", [27513]], [[12110, 12110], "mapped", [27571]], [[12111, 12111], "mapped", [27595]], [[12112, 12112], "mapped", [27604]], [[12113, 12113], "mapped", [27611]], [[12114, 12114], "mapped", [27663]], [[12115, 12115], "mapped", [27668]], [[12116, 12116], "mapped", [27700]], [[12117, 12117], "mapped", [28779]], [[12118, 12118], "mapped", [29226]], [[12119, 12119], "mapped", [29238]], [[12120, 12120], "mapped", [29243]], [[12121, 12121], "mapped", [29247]], [[12122, 12122], "mapped", [29255]], [[12123, 12123], "mapped", [29273]], [[12124, 12124], "mapped", [29275]], [[12125, 12125], "mapped", [29356]], [[12126, 12126], "mapped", [29572]], [[12127, 12127], "mapped", [29577]], [[12128, 12128], "mapped", [29916]], [[12129, 12129], "mapped", [29926]], [[12130, 12130], "mapped", [29976]], [[12131, 12131], "mapped", [29983]], [[12132, 12132], "mapped", [29992]], [[12133, 12133], "mapped", [3e4]], [[12134, 12134], "mapped", [30091]], [[12135, 12135], "mapped", [30098]], [[12136, 12136], "mapped", [30326]], [[12137, 12137], "mapped", [30333]], [[12138, 12138], "mapped", [30382]], [[12139, 12139], "mapped", [30399]], [[12140, 12140], "mapped", [30446]], [[12141, 12141], "mapped", [30683]], [[12142, 12142], "mapped", [30690]], [[12143, 12143], "mapped", [30707]], [[12144, 12144], "mapped", [31034]], [[12145, 12145], "mapped", [31160]], [[12146, 12146], "mapped", [31166]], [[12147, 12147], "mapped", [31348]], [[12148, 12148], "mapped", [31435]], [[12149, 12149], "mapped", [31481]], [[12150, 12150], "mapped", [31859]], [[12151, 12151], "mapped", [31992]], [[12152, 12152], "mapped", [32566]], [[12153, 12153], "mapped", [32593]], [[12154, 12154], "mapped", [32650]], [[12155, 12155], "mapped", [32701]], [[12156, 12156], "mapped", [32769]], [[12157, 12157], "mapped", [32780]], [[12158, 12158], "mapped", [32786]], [[12159, 12159], "mapped", [32819]], [[12160, 12160], "mapped", [32895]], [[12161, 12161], "mapped", [32905]], [[12162, 12162], "mapped", [33251]], [[12163, 12163], "mapped", [33258]], [[12164, 12164], "mapped", [33267]], [[12165, 12165], "mapped", [33276]], [[12166, 12166], "mapped", [33292]], [[12167, 12167], "mapped", [33307]], [[12168, 12168], "mapped", [33311]], [[12169, 12169], "mapped", [33390]], [[12170, 12170], "mapped", [33394]], [[12171, 12171], "mapped", [33400]], [[12172, 12172], "mapped", [34381]], [[12173, 12173], "mapped", [34411]], [[12174, 12174], "mapped", [34880]], [[12175, 12175], "mapped", [34892]], [[12176, 12176], "mapped", [34915]], [[12177, 12177], "mapped", [35198]], [[12178, 12178], "mapped", [35211]], [[12179, 12179], "mapped", [35282]], [[12180, 12180], "mapped", [35328]], [[12181, 12181], "mapped", [35895]], [[12182, 12182], "mapped", [35910]], [[12183, 12183], "mapped", [35925]], [[12184, 12184], "mapped", [35960]], [[12185, 12185], "mapped", [35997]], [[12186, 12186], "mapped", [36196]], [[12187, 12187], "mapped", [36208]], [[12188, 12188], "mapped", [36275]], [[12189, 12189], "mapped", [36523]], [[12190, 12190], "mapped", [36554]], [[12191, 12191], "mapped", [36763]], [[12192, 12192], "mapped", [36784]], [[12193, 12193], "mapped", [36789]], [[12194, 12194], "mapped", [37009]], [[12195, 12195], "mapped", [37193]], [[12196, 12196], "mapped", [37318]], [[12197, 12197], "mapped", [37324]], [[12198, 12198], "mapped", [37329]], [[12199, 12199], "mapped", [38263]], [[12200, 12200], "mapped", [38272]], [[12201, 12201], "mapped", [38428]], [[12202, 12202], "mapped", [38582]], [[12203, 12203], "mapped", [38585]], [[12204, 12204], "mapped", [38632]], [[12205, 12205], "mapped", [38737]], [[12206, 12206], "mapped", [38750]], [[12207, 12207], "mapped", [38754]], [[12208, 12208], "mapped", [38761]], [[12209, 12209], "mapped", [38859]], [[12210, 12210], "mapped", [38893]], [[12211, 12211], "mapped", [38899]], [[12212, 12212], "mapped", [38913]], [[12213, 12213], "mapped", [39080]], [[12214, 12214], "mapped", [39131]], [[12215, 12215], "mapped", [39135]], [[12216, 12216], "mapped", [39318]], [[12217, 12217], "mapped", [39321]], [[12218, 12218], "mapped", [39340]], [[12219, 12219], "mapped", [39592]], [[12220, 12220], "mapped", [39640]], [[12221, 12221], "mapped", [39647]], [[12222, 12222], "mapped", [39717]], [[12223, 12223], "mapped", [39727]], [[12224, 12224], "mapped", [39730]], [[12225, 12225], "mapped", [39740]], [[12226, 12226], "mapped", [39770]], [[12227, 12227], "mapped", [40165]], [[12228, 12228], "mapped", [40565]], [[12229, 12229], "mapped", [40575]], [[12230, 12230], "mapped", [40613]], [[12231, 12231], "mapped", [40635]], [[12232, 12232], "mapped", [40643]], [[12233, 12233], "mapped", [40653]], [[12234, 12234], "mapped", [40657]], [[12235, 12235], "mapped", [40697]], [[12236, 12236], "mapped", [40701]], [[12237, 12237], "mapped", [40718]], [[12238, 12238], "mapped", [40723]], [[12239, 12239], "mapped", [40736]], [[12240, 12240], "mapped", [40763]], [[12241, 12241], "mapped", [40778]], [[12242, 12242], "mapped", [40786]], [[12243, 12243], "mapped", [40845]], [[12244, 12244], "mapped", [40860]], [[12245, 12245], "mapped", [40864]], [[12246, 12271], "disallowed"], [[12272, 12283], "disallowed"], [[12284, 12287], "disallowed"], [[12288, 12288], "disallowed_STD3_mapped", [32]], [[12289, 12289], "valid", [], "NV8"], [[12290, 12290], "mapped", [46]], [[12291, 12292], "valid", [], "NV8"], [[12293, 12295], "valid"], [[12296, 12329], "valid", [], "NV8"], [[12330, 12333], "valid"], [[12334, 12341], "valid", [], "NV8"], [[12342, 12342], "mapped", [12306]], [[12343, 12343], "valid", [], "NV8"], [[12344, 12344], "mapped", [21313]], [[12345, 12345], "mapped", [21316]], [[12346, 12346], "mapped", [21317]], [[12347, 12347], "valid", [], "NV8"], [[12348, 12348], "valid"], [[12349, 12349], "valid", [], "NV8"], [[12350, 12350], "valid", [], "NV8"], [[12351, 12351], "valid", [], "NV8"], [[12352, 12352], "disallowed"], [[12353, 12436], "valid"], [[12437, 12438], "valid"], [[12439, 12440], "disallowed"], [[12441, 12442], "valid"], [[12443, 12443], "disallowed_STD3_mapped", [32, 12441]], [[12444, 12444], "disallowed_STD3_mapped", [32, 12442]], [[12445, 12446], "valid"], [[12447, 12447], "mapped", [12424, 12426]], [[12448, 12448], "valid", [], "NV8"], [[12449, 12542], "valid"], [[12543, 12543], "mapped", [12467, 12488]], [[12544, 12548], "disallowed"], [[12549, 12588], "valid"], [[12589, 12589], "valid"], [[12590, 12592], "disallowed"], [[12593, 12593], "mapped", [4352]], [[12594, 12594], "mapped", [4353]], [[12595, 12595], "mapped", [4522]], [[12596, 12596], "mapped", [4354]], [[12597, 12597], "mapped", [4524]], [[12598, 12598], "mapped", [4525]], [[12599, 12599], "mapped", [4355]], [[12600, 12600], "mapped", [4356]], [[12601, 12601], "mapped", [4357]], [[12602, 12602], "mapped", [4528]], [[12603, 12603], "mapped", [4529]], [[12604, 12604], "mapped", [4530]], [[12605, 12605], "mapped", [4531]], [[12606, 12606], "mapped", [4532]], [[12607, 12607], "mapped", [4533]], [[12608, 12608], "mapped", [4378]], [[12609, 12609], "mapped", [4358]], [[12610, 12610], "mapped", [4359]], [[12611, 12611], "mapped", [4360]], [[12612, 12612], "mapped", [4385]], [[12613, 12613], "mapped", [4361]], [[12614, 12614], "mapped", [4362]], [[12615, 12615], "mapped", [4363]], [[12616, 12616], "mapped", [4364]], [[12617, 12617], "mapped", [4365]], [[12618, 12618], "mapped", [4366]], [[12619, 12619], "mapped", [4367]], [[12620, 12620], "mapped", [4368]], [[12621, 12621], "mapped", [4369]], [[12622, 12622], "mapped", [4370]], [[12623, 12623], "mapped", [4449]], [[12624, 12624], "mapped", [4450]], [[12625, 12625], "mapped", [4451]], [[12626, 12626], "mapped", [4452]], [[12627, 12627], "mapped", [4453]], [[12628, 12628], "mapped", [4454]], [[12629, 12629], "mapped", [4455]], [[12630, 12630], "mapped", [4456]], [[12631, 12631], "mapped", [4457]], [[12632, 12632], "mapped", [4458]], [[12633, 12633], "mapped", [4459]], [[12634, 12634], "mapped", [4460]], [[12635, 12635], "mapped", [4461]], [[12636, 12636], "mapped", [4462]], [[12637, 12637], "mapped", [4463]], [[12638, 12638], "mapped", [4464]], [[12639, 12639], "mapped", [4465]], [[12640, 12640], "mapped", [4466]], [[12641, 12641], "mapped", [4467]], [[12642, 12642], "mapped", [4468]], [[12643, 12643], "mapped", [4469]], [[12644, 12644], "disallowed"], [[12645, 12645], "mapped", [4372]], [[12646, 12646], "mapped", [4373]], [[12647, 12647], "mapped", [4551]], [[12648, 12648], "mapped", [4552]], [[12649, 12649], "mapped", [4556]], [[12650, 12650], "mapped", [4558]], [[12651, 12651], "mapped", [4563]], [[12652, 12652], "mapped", [4567]], [[12653, 12653], "mapped", [4569]], [[12654, 12654], "mapped", [4380]], [[12655, 12655], "mapped", [4573]], [[12656, 12656], "mapped", [4575]], [[12657, 12657], "mapped", [4381]], [[12658, 12658], "mapped", [4382]], [[12659, 12659], "mapped", [4384]], [[12660, 12660], "mapped", [4386]], [[12661, 12661], "mapped", [4387]], [[12662, 12662], "mapped", [4391]], [[12663, 12663], "mapped", [4393]], [[12664, 12664], "mapped", [4395]], [[12665, 12665], "mapped", [4396]], [[12666, 12666], "mapped", [4397]], [[12667, 12667], "mapped", [4398]], [[12668, 12668], "mapped", [4399]], [[12669, 12669], "mapped", [4402]], [[12670, 12670], "mapped", [4406]], [[12671, 12671], "mapped", [4416]], [[12672, 12672], "mapped", [4423]], [[12673, 12673], "mapped", [4428]], [[12674, 12674], "mapped", [4593]], [[12675, 12675], "mapped", [4594]], [[12676, 12676], "mapped", [4439]], [[12677, 12677], "mapped", [4440]], [[12678, 12678], "mapped", [4441]], [[12679, 12679], "mapped", [4484]], [[12680, 12680], "mapped", [4485]], [[12681, 12681], "mapped", [4488]], [[12682, 12682], "mapped", [4497]], [[12683, 12683], "mapped", [4498]], [[12684, 12684], "mapped", [4500]], [[12685, 12685], "mapped", [4510]], [[12686, 12686], "mapped", [4513]], [[12687, 12687], "disallowed"], [[12688, 12689], "valid", [], "NV8"], [[12690, 12690], "mapped", [19968]], [[12691, 12691], "mapped", [20108]], [[12692, 12692], "mapped", [19977]], [[12693, 12693], "mapped", [22235]], [[12694, 12694], "mapped", [19978]], [[12695, 12695], "mapped", [20013]], [[12696, 12696], "mapped", [19979]], [[12697, 12697], "mapped", [30002]], [[12698, 12698], "mapped", [20057]], [[12699, 12699], "mapped", [19993]], [[12700, 12700], "mapped", [19969]], [[12701, 12701], "mapped", [22825]], [[12702, 12702], "mapped", [22320]], [[12703, 12703], "mapped", [20154]], [[12704, 12727], "valid"], [[12728, 12730], "valid"], [[12731, 12735], "disallowed"], [[12736, 12751], "valid", [], "NV8"], [[12752, 12771], "valid", [], "NV8"], [[12772, 12783], "disallowed"], [[12784, 12799], "valid"], [[12800, 12800], "disallowed_STD3_mapped", [40, 4352, 41]], [[12801, 12801], "disallowed_STD3_mapped", [40, 4354, 41]], [[12802, 12802], "disallowed_STD3_mapped", [40, 4355, 41]], [[12803, 12803], "disallowed_STD3_mapped", [40, 4357, 41]], [[12804, 12804], "disallowed_STD3_mapped", [40, 4358, 41]], [[12805, 12805], "disallowed_STD3_mapped", [40, 4359, 41]], [[12806, 12806], "disallowed_STD3_mapped", [40, 4361, 41]], [[12807, 12807], "disallowed_STD3_mapped", [40, 4363, 41]], [[12808, 12808], "disallowed_STD3_mapped", [40, 4364, 41]], [[12809, 12809], "disallowed_STD3_mapped", [40, 4366, 41]], [[12810, 12810], "disallowed_STD3_mapped", [40, 4367, 41]], [[12811, 12811], "disallowed_STD3_mapped", [40, 4368, 41]], [[12812, 12812], "disallowed_STD3_mapped", [40, 4369, 41]], [[12813, 12813], "disallowed_STD3_mapped", [40, 4370, 41]], [[12814, 12814], "disallowed_STD3_mapped", [40, 44032, 41]], [[12815, 12815], "disallowed_STD3_mapped", [40, 45208, 41]], [[12816, 12816], "disallowed_STD3_mapped", [40, 45796, 41]], [[12817, 12817], "disallowed_STD3_mapped", [40, 46972, 41]], [[12818, 12818], "disallowed_STD3_mapped", [40, 47560, 41]], [[12819, 12819], "disallowed_STD3_mapped", [40, 48148, 41]], [[12820, 12820], "disallowed_STD3_mapped", [40, 49324, 41]], [[12821, 12821], "disallowed_STD3_mapped", [40, 50500, 41]], [[12822, 12822], "disallowed_STD3_mapped", [40, 51088, 41]], [[12823, 12823], "disallowed_STD3_mapped", [40, 52264, 41]], [[12824, 12824], "disallowed_STD3_mapped", [40, 52852, 41]], [[12825, 12825], "disallowed_STD3_mapped", [40, 53440, 41]], [[12826, 12826], "disallowed_STD3_mapped", [40, 54028, 41]], [[12827, 12827], "disallowed_STD3_mapped", [40, 54616, 41]], [[12828, 12828], "disallowed_STD3_mapped", [40, 51452, 41]], [[12829, 12829], "disallowed_STD3_mapped", [40, 50724, 51204, 41]], [[12830, 12830], "disallowed_STD3_mapped", [40, 50724, 54980, 41]], [[12831, 12831], "disallowed"], [[12832, 12832], "disallowed_STD3_mapped", [40, 19968, 41]], [[12833, 12833], "disallowed_STD3_mapped", [40, 20108, 41]], [[12834, 12834], "disallowed_STD3_mapped", [40, 19977, 41]], [[12835, 12835], "disallowed_STD3_mapped", [40, 22235, 41]], [[12836, 12836], "disallowed_STD3_mapped", [40, 20116, 41]], [[12837, 12837], "disallowed_STD3_mapped", [40, 20845, 41]], [[12838, 12838], "disallowed_STD3_mapped", [40, 19971, 41]], [[12839, 12839], "disallowed_STD3_mapped", [40, 20843, 41]], [[12840, 12840], "disallowed_STD3_mapped", [40, 20061, 41]], [[12841, 12841], "disallowed_STD3_mapped", [40, 21313, 41]], [[12842, 12842], "disallowed_STD3_mapped", [40, 26376, 41]], [[12843, 12843], "disallowed_STD3_mapped", [40, 28779, 41]], [[12844, 12844], "disallowed_STD3_mapped", [40, 27700, 41]], [[12845, 12845], "disallowed_STD3_mapped", [40, 26408, 41]], [[12846, 12846], "disallowed_STD3_mapped", [40, 37329, 41]], [[12847, 12847], "disallowed_STD3_mapped", [40, 22303, 41]], [[12848, 12848], "disallowed_STD3_mapped", [40, 26085, 41]], [[12849, 12849], "disallowed_STD3_mapped", [40, 26666, 41]], [[12850, 12850], "disallowed_STD3_mapped", [40, 26377, 41]], [[12851, 12851], "disallowed_STD3_mapped", [40, 31038, 41]], [[12852, 12852], "disallowed_STD3_mapped", [40, 21517, 41]], [[12853, 12853], "disallowed_STD3_mapped", [40, 29305, 41]], [[12854, 12854], "disallowed_STD3_mapped", [40, 36001, 41]], [[12855, 12855], "disallowed_STD3_mapped", [40, 31069, 41]], [[12856, 12856], "disallowed_STD3_mapped", [40, 21172, 41]], [[12857, 12857], "disallowed_STD3_mapped", [40, 20195, 41]], [[12858, 12858], "disallowed_STD3_mapped", [40, 21628, 41]], [[12859, 12859], "disallowed_STD3_mapped", [40, 23398, 41]], [[12860, 12860], "disallowed_STD3_mapped", [40, 30435, 41]], [[12861, 12861], "disallowed_STD3_mapped", [40, 20225, 41]], [[12862, 12862], "disallowed_STD3_mapped", [40, 36039, 41]], [[12863, 12863], "disallowed_STD3_mapped", [40, 21332, 41]], [[12864, 12864], "disallowed_STD3_mapped", [40, 31085, 41]], [[12865, 12865], "disallowed_STD3_mapped", [40, 20241, 41]], [[12866, 12866], "disallowed_STD3_mapped", [40, 33258, 41]], [[12867, 12867], "disallowed_STD3_mapped", [40, 33267, 41]], [[12868, 12868], "mapped", [21839]], [[12869, 12869], "mapped", [24188]], [[12870, 12870], "mapped", [25991]], [[12871, 12871], "mapped", [31631]], [[12872, 12879], "valid", [], "NV8"], [[12880, 12880], "mapped", [112, 116, 101]], [[12881, 12881], "mapped", [50, 49]], [[12882, 12882], "mapped", [50, 50]], [[12883, 12883], "mapped", [50, 51]], [[12884, 12884], "mapped", [50, 52]], [[12885, 12885], "mapped", [50, 53]], [[12886, 12886], "mapped", [50, 54]], [[12887, 12887], "mapped", [50, 55]], [[12888, 12888], "mapped", [50, 56]], [[12889, 12889], "mapped", [50, 57]], [[12890, 12890], "mapped", [51, 48]], [[12891, 12891], "mapped", [51, 49]], [[12892, 12892], "mapped", [51, 50]], [[12893, 12893], "mapped", [51, 51]], [[12894, 12894], "mapped", [51, 52]], [[12895, 12895], "mapped", [51, 53]], [[12896, 12896], "mapped", [4352]], [[12897, 12897], "mapped", [4354]], [[12898, 12898], "mapped", [4355]], [[12899, 12899], "mapped", [4357]], [[12900, 12900], "mapped", [4358]], [[12901, 12901], "mapped", [4359]], [[12902, 12902], "mapped", [4361]], [[12903, 12903], "mapped", [4363]], [[12904, 12904], "mapped", [4364]], [[12905, 12905], "mapped", [4366]], [[12906, 12906], "mapped", [4367]], [[12907, 12907], "mapped", [4368]], [[12908, 12908], "mapped", [4369]], [[12909, 12909], "mapped", [4370]], [[12910, 12910], "mapped", [44032]], [[12911, 12911], "mapped", [45208]], [[12912, 12912], "mapped", [45796]], [[12913, 12913], "mapped", [46972]], [[12914, 12914], "mapped", [47560]], [[12915, 12915], "mapped", [48148]], [[12916, 12916], "mapped", [49324]], [[12917, 12917], "mapped", [50500]], [[12918, 12918], "mapped", [51088]], [[12919, 12919], "mapped", [52264]], [[12920, 12920], "mapped", [52852]], [[12921, 12921], "mapped", [53440]], [[12922, 12922], "mapped", [54028]], [[12923, 12923], "mapped", [54616]], [[12924, 12924], "mapped", [52280, 44256]], [[12925, 12925], "mapped", [51452, 51032]], [[12926, 12926], "mapped", [50864]], [[12927, 12927], "valid", [], "NV8"], [[12928, 12928], "mapped", [19968]], [[12929, 12929], "mapped", [20108]], [[12930, 12930], "mapped", [19977]], [[12931, 12931], "mapped", [22235]], [[12932, 12932], "mapped", [20116]], [[12933, 12933], "mapped", [20845]], [[12934, 12934], "mapped", [19971]], [[12935, 12935], "mapped", [20843]], [[12936, 12936], "mapped", [20061]], [[12937, 12937], "mapped", [21313]], [[12938, 12938], "mapped", [26376]], [[12939, 12939], "mapped", [28779]], [[12940, 12940], "mapped", [27700]], [[12941, 12941], "mapped", [26408]], [[12942, 12942], "mapped", [37329]], [[12943, 12943], "mapped", [22303]], [[12944, 12944], "mapped", [26085]], [[12945, 12945], "mapped", [26666]], [[12946, 12946], "mapped", [26377]], [[12947, 12947], "mapped", [31038]], [[12948, 12948], "mapped", [21517]], [[12949, 12949], "mapped", [29305]], [[12950, 12950], "mapped", [36001]], [[12951, 12951], "mapped", [31069]], [[12952, 12952], "mapped", [21172]], [[12953, 12953], "mapped", [31192]], [[12954, 12954], "mapped", [30007]], [[12955, 12955], "mapped", [22899]], [[12956, 12956], "mapped", [36969]], [[12957, 12957], "mapped", [20778]], [[12958, 12958], "mapped", [21360]], [[12959, 12959], "mapped", [27880]], [[12960, 12960], "mapped", [38917]], [[12961, 12961], "mapped", [20241]], [[12962, 12962], "mapped", [20889]], [[12963, 12963], "mapped", [27491]], [[12964, 12964], "mapped", [19978]], [[12965, 12965], "mapped", [20013]], [[12966, 12966], "mapped", [19979]], [[12967, 12967], "mapped", [24038]], [[12968, 12968], "mapped", [21491]], [[12969, 12969], "mapped", [21307]], [[12970, 12970], "mapped", [23447]], [[12971, 12971], "mapped", [23398]], [[12972, 12972], "mapped", [30435]], [[12973, 12973], "mapped", [20225]], [[12974, 12974], "mapped", [36039]], [[12975, 12975], "mapped", [21332]], [[12976, 12976], "mapped", [22812]], [[12977, 12977], "mapped", [51, 54]], [[12978, 12978], "mapped", [51, 55]], [[12979, 12979], "mapped", [51, 56]], [[12980, 12980], "mapped", [51, 57]], [[12981, 12981], "mapped", [52, 48]], [[12982, 12982], "mapped", [52, 49]], [[12983, 12983], "mapped", [52, 50]], [[12984, 12984], "mapped", [52, 51]], [[12985, 12985], "mapped", [52, 52]], [[12986, 12986], "mapped", [52, 53]], [[12987, 12987], "mapped", [52, 54]], [[12988, 12988], "mapped", [52, 55]], [[12989, 12989], "mapped", [52, 56]], [[12990, 12990], "mapped", [52, 57]], [[12991, 12991], "mapped", [53, 48]], [[12992, 12992], "mapped", [49, 26376]], [[12993, 12993], "mapped", [50, 26376]], [[12994, 12994], "mapped", [51, 26376]], [[12995, 12995], "mapped", [52, 26376]], [[12996, 12996], "mapped", [53, 26376]], [[12997, 12997], "mapped", [54, 26376]], [[12998, 12998], "mapped", [55, 26376]], [[12999, 12999], "mapped", [56, 26376]], [[13e3, 13e3], "mapped", [57, 26376]], [[13001, 13001], "mapped", [49, 48, 26376]], [[13002, 13002], "mapped", [49, 49, 26376]], [[13003, 13003], "mapped", [49, 50, 26376]], [[13004, 13004], "mapped", [104, 103]], [[13005, 13005], "mapped", [101, 114, 103]], [[13006, 13006], "mapped", [101, 118]], [[13007, 13007], "mapped", [108, 116, 100]], [[13008, 13008], "mapped", [12450]], [[13009, 13009], "mapped", [12452]], [[13010, 13010], "mapped", [12454]], [[13011, 13011], "mapped", [12456]], [[13012, 13012], "mapped", [12458]], [[13013, 13013], "mapped", [12459]], [[13014, 13014], "mapped", [12461]], [[13015, 13015], "mapped", [12463]], [[13016, 13016], "mapped", [12465]], [[13017, 13017], "mapped", [12467]], [[13018, 13018], "mapped", [12469]], [[13019, 13019], "mapped", [12471]], [[13020, 13020], "mapped", [12473]], [[13021, 13021], "mapped", [12475]], [[13022, 13022], "mapped", [12477]], [[13023, 13023], "mapped", [12479]], [[13024, 13024], "mapped", [12481]], [[13025, 13025], "mapped", [12484]], [[13026, 13026], "mapped", [12486]], [[13027, 13027], "mapped", [12488]], [[13028, 13028], "mapped", [12490]], [[13029, 13029], "mapped", [12491]], [[13030, 13030], "mapped", [12492]], [[13031, 13031], "mapped", [12493]], [[13032, 13032], "mapped", [12494]], [[13033, 13033], "mapped", [12495]], [[13034, 13034], "mapped", [12498]], [[13035, 13035], "mapped", [12501]], [[13036, 13036], "mapped", [12504]], [[13037, 13037], "mapped", [12507]], [[13038, 13038], "mapped", [12510]], [[13039, 13039], "mapped", [12511]], [[13040, 13040], "mapped", [12512]], [[13041, 13041], "mapped", [12513]], [[13042, 13042], "mapped", [12514]], [[13043, 13043], "mapped", [12516]], [[13044, 13044], "mapped", [12518]], [[13045, 13045], "mapped", [12520]], [[13046, 13046], "mapped", [12521]], [[13047, 13047], "mapped", [12522]], [[13048, 13048], "mapped", [12523]], [[13049, 13049], "mapped", [12524]], [[13050, 13050], "mapped", [12525]], [[13051, 13051], "mapped", [12527]], [[13052, 13052], "mapped", [12528]], [[13053, 13053], "mapped", [12529]], [[13054, 13054], "mapped", [12530]], [[13055, 13055], "disallowed"], [[13056, 13056], "mapped", [12450, 12497, 12540, 12488]], [[13057, 13057], "mapped", [12450, 12523, 12501, 12449]], [[13058, 13058], "mapped", [12450, 12531, 12506, 12450]], [[13059, 13059], "mapped", [12450, 12540, 12523]], [[13060, 13060], "mapped", [12452, 12491, 12531, 12464]], [[13061, 13061], "mapped", [12452, 12531, 12481]], [[13062, 13062], "mapped", [12454, 12457, 12531]], [[13063, 13063], "mapped", [12456, 12473, 12463, 12540, 12489]], [[13064, 13064], "mapped", [12456, 12540, 12459, 12540]], [[13065, 13065], "mapped", [12458, 12531, 12473]], [[13066, 13066], "mapped", [12458, 12540, 12512]], [[13067, 13067], "mapped", [12459, 12452, 12522]], [[13068, 13068], "mapped", [12459, 12521, 12483, 12488]], [[13069, 13069], "mapped", [12459, 12525, 12522, 12540]], [[13070, 13070], "mapped", [12460, 12525, 12531]], [[13071, 13071], "mapped", [12460, 12531, 12510]], [[13072, 13072], "mapped", [12462, 12460]], [[13073, 13073], "mapped", [12462, 12491, 12540]], [[13074, 13074], "mapped", [12461, 12517, 12522, 12540]], [[13075, 13075], "mapped", [12462, 12523, 12480, 12540]], [[13076, 13076], "mapped", [12461, 12525]], [[13077, 13077], "mapped", [12461, 12525, 12464, 12521, 12512]], [[13078, 13078], "mapped", [12461, 12525, 12513, 12540, 12488, 12523]], [[13079, 13079], "mapped", [12461, 12525, 12527, 12483, 12488]], [[13080, 13080], "mapped", [12464, 12521, 12512]], [[13081, 13081], "mapped", [12464, 12521, 12512, 12488, 12531]], [[13082, 13082], "mapped", [12463, 12523, 12476, 12452, 12525]], [[13083, 13083], "mapped", [12463, 12525, 12540, 12493]], [[13084, 13084], "mapped", [12465, 12540, 12473]], [[13085, 13085], "mapped", [12467, 12523, 12490]], [[13086, 13086], "mapped", [12467, 12540, 12509]], [[13087, 13087], "mapped", [12469, 12452, 12463, 12523]], [[13088, 13088], "mapped", [12469, 12531, 12481, 12540, 12512]], [[13089, 13089], "mapped", [12471, 12522, 12531, 12464]], [[13090, 13090], "mapped", [12475, 12531, 12481]], [[13091, 13091], "mapped", [12475, 12531, 12488]], [[13092, 13092], "mapped", [12480, 12540, 12473]], [[13093, 13093], "mapped", [12487, 12471]], [[13094, 13094], "mapped", [12489, 12523]], [[13095, 13095], "mapped", [12488, 12531]], [[13096, 13096], "mapped", [12490, 12494]], [[13097, 13097], "mapped", [12494, 12483, 12488]], [[13098, 13098], "mapped", [12495, 12452, 12484]], [[13099, 13099], "mapped", [12497, 12540, 12475, 12531, 12488]], [[13100, 13100], "mapped", [12497, 12540, 12484]], [[13101, 13101], "mapped", [12496, 12540, 12524, 12523]], [[13102, 13102], "mapped", [12500, 12450, 12473, 12488, 12523]], [[13103, 13103], "mapped", [12500, 12463, 12523]], [[13104, 13104], "mapped", [12500, 12467]], [[13105, 13105], "mapped", [12499, 12523]], [[13106, 13106], "mapped", [12501, 12449, 12521, 12483, 12489]], [[13107, 13107], "mapped", [12501, 12451, 12540, 12488]], [[13108, 13108], "mapped", [12502, 12483, 12471, 12455, 12523]], [[13109, 13109], "mapped", [12501, 12521, 12531]], [[13110, 13110], "mapped", [12504, 12463, 12479, 12540, 12523]], [[13111, 13111], "mapped", [12506, 12477]], [[13112, 13112], "mapped", [12506, 12491, 12498]], [[13113, 13113], "mapped", [12504, 12523, 12484]], [[13114, 13114], "mapped", [12506, 12531, 12473]], [[13115, 13115], "mapped", [12506, 12540, 12472]], [[13116, 13116], "mapped", [12505, 12540, 12479]], [[13117, 13117], "mapped", [12509, 12452, 12531, 12488]], [[13118, 13118], "mapped", [12508, 12523, 12488]], [[13119, 13119], "mapped", [12507, 12531]], [[13120, 13120], "mapped", [12509, 12531, 12489]], [[13121, 13121], "mapped", [12507, 12540, 12523]], [[13122, 13122], "mapped", [12507, 12540, 12531]], [[13123, 13123], "mapped", [12510, 12452, 12463, 12525]], [[13124, 13124], "mapped", [12510, 12452, 12523]], [[13125, 13125], "mapped", [12510, 12483, 12495]], [[13126, 13126], "mapped", [12510, 12523, 12463]], [[13127, 13127], "mapped", [12510, 12531, 12471, 12519, 12531]], [[13128, 13128], "mapped", [12511, 12463, 12525, 12531]], [[13129, 13129], "mapped", [12511, 12522]], [[13130, 13130], "mapped", [12511, 12522, 12496, 12540, 12523]], [[13131, 13131], "mapped", [12513, 12460]], [[13132, 13132], "mapped", [12513, 12460, 12488, 12531]], [[13133, 13133], "mapped", [12513, 12540, 12488, 12523]], [[13134, 13134], "mapped", [12516, 12540, 12489]], [[13135, 13135], "mapped", [12516, 12540, 12523]], [[13136, 13136], "mapped", [12518, 12450, 12531]], [[13137, 13137], "mapped", [12522, 12483, 12488, 12523]], [[13138, 13138], "mapped", [12522, 12521]], [[13139, 13139], "mapped", [12523, 12500, 12540]], [[13140, 13140], "mapped", [12523, 12540, 12502, 12523]], [[13141, 13141], "mapped", [12524, 12512]], [[13142, 13142], "mapped", [12524, 12531, 12488, 12466, 12531]], [[13143, 13143], "mapped", [12527, 12483, 12488]], [[13144, 13144], "mapped", [48, 28857]], [[13145, 13145], "mapped", [49, 28857]], [[13146, 13146], "mapped", [50, 28857]], [[13147, 13147], "mapped", [51, 28857]], [[13148, 13148], "mapped", [52, 28857]], [[13149, 13149], "mapped", [53, 28857]], [[13150, 13150], "mapped", [54, 28857]], [[13151, 13151], "mapped", [55, 28857]], [[13152, 13152], "mapped", [56, 28857]], [[13153, 13153], "mapped", [57, 28857]], [[13154, 13154], "mapped", [49, 48, 28857]], [[13155, 13155], "mapped", [49, 49, 28857]], [[13156, 13156], "mapped", [49, 50, 28857]], [[13157, 13157], "mapped", [49, 51, 28857]], [[13158, 13158], "mapped", [49, 52, 28857]], [[13159, 13159], "mapped", [49, 53, 28857]], [[13160, 13160], "mapped", [49, 54, 28857]], [[13161, 13161], "mapped", [49, 55, 28857]], [[13162, 13162], "mapped", [49, 56, 28857]], [[13163, 13163], "mapped", [49, 57, 28857]], [[13164, 13164], "mapped", [50, 48, 28857]], [[13165, 13165], "mapped", [50, 49, 28857]], [[13166, 13166], "mapped", [50, 50, 28857]], [[13167, 13167], "mapped", [50, 51, 28857]], [[13168, 13168], "mapped", [50, 52, 28857]], [[13169, 13169], "mapped", [104, 112, 97]], [[13170, 13170], "mapped", [100, 97]], [[13171, 13171], "mapped", [97, 117]], [[13172, 13172], "mapped", [98, 97, 114]], [[13173, 13173], "mapped", [111, 118]], [[13174, 13174], "mapped", [112, 99]], [[13175, 13175], "mapped", [100, 109]], [[13176, 13176], "mapped", [100, 109, 50]], [[13177, 13177], "mapped", [100, 109, 51]], [[13178, 13178], "mapped", [105, 117]], [[13179, 13179], "mapped", [24179, 25104]], [[13180, 13180], "mapped", [26157, 21644]], [[13181, 13181], "mapped", [22823, 27491]], [[13182, 13182], "mapped", [26126, 27835]], [[13183, 13183], "mapped", [26666, 24335, 20250, 31038]], [[13184, 13184], "mapped", [112, 97]], [[13185, 13185], "mapped", [110, 97]], [[13186, 13186], "mapped", [956, 97]], [[13187, 13187], "mapped", [109, 97]], [[13188, 13188], "mapped", [107, 97]], [[13189, 13189], "mapped", [107, 98]], [[13190, 13190], "mapped", [109, 98]], [[13191, 13191], "mapped", [103, 98]], [[13192, 13192], "mapped", [99, 97, 108]], [[13193, 13193], "mapped", [107, 99, 97, 108]], [[13194, 13194], "mapped", [112, 102]], [[13195, 13195], "mapped", [110, 102]], [[13196, 13196], "mapped", [956, 102]], [[13197, 13197], "mapped", [956, 103]], [[13198, 13198], "mapped", [109, 103]], [[13199, 13199], "mapped", [107, 103]], [[13200, 13200], "mapped", [104, 122]], [[13201, 13201], "mapped", [107, 104, 122]], [[13202, 13202], "mapped", [109, 104, 122]], [[13203, 13203], "mapped", [103, 104, 122]], [[13204, 13204], "mapped", [116, 104, 122]], [[13205, 13205], "mapped", [956, 108]], [[13206, 13206], "mapped", [109, 108]], [[13207, 13207], "mapped", [100, 108]], [[13208, 13208], "mapped", [107, 108]], [[13209, 13209], "mapped", [102, 109]], [[13210, 13210], "mapped", [110, 109]], [[13211, 13211], "mapped", [956, 109]], [[13212, 13212], "mapped", [109, 109]], [[13213, 13213], "mapped", [99, 109]], [[13214, 13214], "mapped", [107, 109]], [[13215, 13215], "mapped", [109, 109, 50]], [[13216, 13216], "mapped", [99, 109, 50]], [[13217, 13217], "mapped", [109, 50]], [[13218, 13218], "mapped", [107, 109, 50]], [[13219, 13219], "mapped", [109, 109, 51]], [[13220, 13220], "mapped", [99, 109, 51]], [[13221, 13221], "mapped", [109, 51]], [[13222, 13222], "mapped", [107, 109, 51]], [[13223, 13223], "mapped", [109, 8725, 115]], [[13224, 13224], "mapped", [109, 8725, 115, 50]], [[13225, 13225], "mapped", [112, 97]], [[13226, 13226], "mapped", [107, 112, 97]], [[13227, 13227], "mapped", [109, 112, 97]], [[13228, 13228], "mapped", [103, 112, 97]], [[13229, 13229], "mapped", [114, 97, 100]], [[13230, 13230], "mapped", [114, 97, 100, 8725, 115]], [[13231, 13231], "mapped", [114, 97, 100, 8725, 115, 50]], [[13232, 13232], "mapped", [112, 115]], [[13233, 13233], "mapped", [110, 115]], [[13234, 13234], "mapped", [956, 115]], [[13235, 13235], "mapped", [109, 115]], [[13236, 13236], "mapped", [112, 118]], [[13237, 13237], "mapped", [110, 118]], [[13238, 13238], "mapped", [956, 118]], [[13239, 13239], "mapped", [109, 118]], [[13240, 13240], "mapped", [107, 118]], [[13241, 13241], "mapped", [109, 118]], [[13242, 13242], "mapped", [112, 119]], [[13243, 13243], "mapped", [110, 119]], [[13244, 13244], "mapped", [956, 119]], [[13245, 13245], "mapped", [109, 119]], [[13246, 13246], "mapped", [107, 119]], [[13247, 13247], "mapped", [109, 119]], [[13248, 13248], "mapped", [107, 969]], [[13249, 13249], "mapped", [109, 969]], [[13250, 13250], "disallowed"], [[13251, 13251], "mapped", [98, 113]], [[13252, 13252], "mapped", [99, 99]], [[13253, 13253], "mapped", [99, 100]], [[13254, 13254], "mapped", [99, 8725, 107, 103]], [[13255, 13255], "disallowed"], [[13256, 13256], "mapped", [100, 98]], [[13257, 13257], "mapped", [103, 121]], [[13258, 13258], "mapped", [104, 97]], [[13259, 13259], "mapped", [104, 112]], [[13260, 13260], "mapped", [105, 110]], [[13261, 13261], "mapped", [107, 107]], [[13262, 13262], "mapped", [107, 109]], [[13263, 13263], "mapped", [107, 116]], [[13264, 13264], "mapped", [108, 109]], [[13265, 13265], "mapped", [108, 110]], [[13266, 13266], "mapped", [108, 111, 103]], [[13267, 13267], "mapped", [108, 120]], [[13268, 13268], "mapped", [109, 98]], [[13269, 13269], "mapped", [109, 105, 108]], [[13270, 13270], "mapped", [109, 111, 108]], [[13271, 13271], "mapped", [112, 104]], [[13272, 13272], "disallowed"], [[13273, 13273], "mapped", [112, 112, 109]], [[13274, 13274], "mapped", [112, 114]], [[13275, 13275], "mapped", [115, 114]], [[13276, 13276], "mapped", [115, 118]], [[13277, 13277], "mapped", [119, 98]], [[13278, 13278], "mapped", [118, 8725, 109]], [[13279, 13279], "mapped", [97, 8725, 109]], [[13280, 13280], "mapped", [49, 26085]], [[13281, 13281], "mapped", [50, 26085]], [[13282, 13282], "mapped", [51, 26085]], [[13283, 13283], "mapped", [52, 26085]], [[13284, 13284], "mapped", [53, 26085]], [[13285, 13285], "mapped", [54, 26085]], [[13286, 13286], "mapped", [55, 26085]], [[13287, 13287], "mapped", [56, 26085]], [[13288, 13288], "mapped", [57, 26085]], [[13289, 13289], "mapped", [49, 48, 26085]], [[13290, 13290], "mapped", [49, 49, 26085]], [[13291, 13291], "mapped", [49, 50, 26085]], [[13292, 13292], "mapped", [49, 51, 26085]], [[13293, 13293], "mapped", [49, 52, 26085]], [[13294, 13294], "mapped", [49, 53, 26085]], [[13295, 13295], "mapped", [49, 54, 26085]], [[13296, 13296], "mapped", [49, 55, 26085]], [[13297, 13297], "mapped", [49, 56, 26085]], [[13298, 13298], "mapped", [49, 57, 26085]], [[13299, 13299], "mapped", [50, 48, 26085]], [[13300, 13300], "mapped", [50, 49, 26085]], [[13301, 13301], "mapped", [50, 50, 26085]], [[13302, 13302], "mapped", [50, 51, 26085]], [[13303, 13303], "mapped", [50, 52, 26085]], [[13304, 13304], "mapped", [50, 53, 26085]], [[13305, 13305], "mapped", [50, 54, 26085]], [[13306, 13306], "mapped", [50, 55, 26085]], [[13307, 13307], "mapped", [50, 56, 26085]], [[13308, 13308], "mapped", [50, 57, 26085]], [[13309, 13309], "mapped", [51, 48, 26085]], [[13310, 13310], "mapped", [51, 49, 26085]], [[13311, 13311], "mapped", [103, 97, 108]], [[13312, 19893], "valid"], [[19894, 19903], "disallowed"], [[19904, 19967], "valid", [], "NV8"], [[19968, 40869], "valid"], [[40870, 40891], "valid"], [[40892, 40899], "valid"], [[40900, 40907], "valid"], [[40908, 40908], "valid"], [[40909, 40917], "valid"], [[40918, 40959], "disallowed"], [[40960, 42124], "valid"], [[42125, 42127], "disallowed"], [[42128, 42145], "valid", [], "NV8"], [[42146, 42147], "valid", [], "NV8"], [[42148, 42163], "valid", [], "NV8"], [[42164, 42164], "valid", [], "NV8"], [[42165, 42176], "valid", [], "NV8"], [[42177, 42177], "valid", [], "NV8"], [[42178, 42180], "valid", [], "NV8"], [[42181, 42181], "valid", [], "NV8"], [[42182, 42182], "valid", [], "NV8"], [[42183, 42191], "disallowed"], [[42192, 42237], "valid"], [[42238, 42239], "valid", [], "NV8"], [[42240, 42508], "valid"], [[42509, 42511], "valid", [], "NV8"], [[42512, 42539], "valid"], [[42540, 42559], "disallowed"], [[42560, 42560], "mapped", [42561]], [[42561, 42561], "valid"], [[42562, 42562], "mapped", [42563]], [[42563, 42563], "valid"], [[42564, 42564], "mapped", [42565]], [[42565, 42565], "valid"], [[42566, 42566], "mapped", [42567]], [[42567, 42567], "valid"], [[42568, 42568], "mapped", [42569]], [[42569, 42569], "valid"], [[42570, 42570], "mapped", [42571]], [[42571, 42571], "valid"], [[42572, 42572], "mapped", [42573]], [[42573, 42573], "valid"], [[42574, 42574], "mapped", [42575]], [[42575, 42575], "valid"], [[42576, 42576], "mapped", [42577]], [[42577, 42577], "valid"], [[42578, 42578], "mapped", [42579]], [[42579, 42579], "valid"], [[42580, 42580], "mapped", [42581]], [[42581, 42581], "valid"], [[42582, 42582], "mapped", [42583]], [[42583, 42583], "valid"], [[42584, 42584], "mapped", [42585]], [[42585, 42585], "valid"], [[42586, 42586], "mapped", [42587]], [[42587, 42587], "valid"], [[42588, 42588], "mapped", [42589]], [[42589, 42589], "valid"], [[42590, 42590], "mapped", [42591]], [[42591, 42591], "valid"], [[42592, 42592], "mapped", [42593]], [[42593, 42593], "valid"], [[42594, 42594], "mapped", [42595]], [[42595, 42595], "valid"], [[42596, 42596], "mapped", [42597]], [[42597, 42597], "valid"], [[42598, 42598], "mapped", [42599]], [[42599, 42599], "valid"], [[42600, 42600], "mapped", [42601]], [[42601, 42601], "valid"], [[42602, 42602], "mapped", [42603]], [[42603, 42603], "valid"], [[42604, 42604], "mapped", [42605]], [[42605, 42607], "valid"], [[42608, 42611], "valid", [], "NV8"], [[42612, 42619], "valid"], [[42620, 42621], "valid"], [[42622, 42622], "valid", [], "NV8"], [[42623, 42623], "valid"], [[42624, 42624], "mapped", [42625]], [[42625, 42625], "valid"], [[42626, 42626], "mapped", [42627]], [[42627, 42627], "valid"], [[42628, 42628], "mapped", [42629]], [[42629, 42629], "valid"], [[42630, 42630], "mapped", [42631]], [[42631, 42631], "valid"], [[42632, 42632], "mapped", [42633]], [[42633, 42633], "valid"], [[42634, 42634], "mapped", [42635]], [[42635, 42635], "valid"], [[42636, 42636], "mapped", [42637]], [[42637, 42637], "valid"], [[42638, 42638], "mapped", [42639]], [[42639, 42639], "valid"], [[42640, 42640], "mapped", [42641]], [[42641, 42641], "valid"], [[42642, 42642], "mapped", [42643]], [[42643, 42643], "valid"], [[42644, 42644], "mapped", [42645]], [[42645, 42645], "valid"], [[42646, 42646], "mapped", [42647]], [[42647, 42647], "valid"], [[42648, 42648], "mapped", [42649]], [[42649, 42649], "valid"], [[42650, 42650], "mapped", [42651]], [[42651, 42651], "valid"], [[42652, 42652], "mapped", [1098]], [[42653, 42653], "mapped", [1100]], [[42654, 42654], "valid"], [[42655, 42655], "valid"], [[42656, 42725], "valid"], [[42726, 42735], "valid", [], "NV8"], [[42736, 42737], "valid"], [[42738, 42743], "valid", [], "NV8"], [[42744, 42751], "disallowed"], [[42752, 42774], "valid", [], "NV8"], [[42775, 42778], "valid"], [[42779, 42783], "valid"], [[42784, 42785], "valid", [], "NV8"], [[42786, 42786], "mapped", [42787]], [[42787, 42787], "valid"], [[42788, 42788], "mapped", [42789]], [[42789, 42789], "valid"], [[42790, 42790], "mapped", [42791]], [[42791, 42791], "valid"], [[42792, 42792], "mapped", [42793]], [[42793, 42793], "valid"], [[42794, 42794], "mapped", [42795]], [[42795, 42795], "valid"], [[42796, 42796], "mapped", [42797]], [[42797, 42797], "valid"], [[42798, 42798], "mapped", [42799]], [[42799, 42801], "valid"], [[42802, 42802], "mapped", [42803]], [[42803, 42803], "valid"], [[42804, 42804], "mapped", [42805]], [[42805, 42805], "valid"], [[42806, 42806], "mapped", [42807]], [[42807, 42807], "valid"], [[42808, 42808], "mapped", [42809]], [[42809, 42809], "valid"], [[42810, 42810], "mapped", [42811]], [[42811, 42811], "valid"], [[42812, 42812], "mapped", [42813]], [[42813, 42813], "valid"], [[42814, 42814], "mapped", [42815]], [[42815, 42815], "valid"], [[42816, 42816], "mapped", [42817]], [[42817, 42817], "valid"], [[42818, 42818], "mapped", [42819]], [[42819, 42819], "valid"], [[42820, 42820], "mapped", [42821]], [[42821, 42821], "valid"], [[42822, 42822], "mapped", [42823]], [[42823, 42823], "valid"], [[42824, 42824], "mapped", [42825]], [[42825, 42825], "valid"], [[42826, 42826], "mapped", [42827]], [[42827, 42827], "valid"], [[42828, 42828], "mapped", [42829]], [[42829, 42829], "valid"], [[42830, 42830], "mapped", [42831]], [[42831, 42831], "valid"], [[42832, 42832], "mapped", [42833]], [[42833, 42833], "valid"], [[42834, 42834], "mapped", [42835]], [[42835, 42835], "valid"], [[42836, 42836], "mapped", [42837]], [[42837, 42837], "valid"], [[42838, 42838], "mapped", [42839]], [[42839, 42839], "valid"], [[42840, 42840], "mapped", [42841]], [[42841, 42841], "valid"], [[42842, 42842], "mapped", [42843]], [[42843, 42843], "valid"], [[42844, 42844], "mapped", [42845]], [[42845, 42845], "valid"], [[42846, 42846], "mapped", [42847]], [[42847, 42847], "valid"], [[42848, 42848], "mapped", [42849]], [[42849, 42849], "valid"], [[42850, 42850], "mapped", [42851]], [[42851, 42851], "valid"], [[42852, 42852], "mapped", [42853]], [[42853, 42853], "valid"], [[42854, 42854], "mapped", [42855]], [[42855, 42855], "valid"], [[42856, 42856], "mapped", [42857]], [[42857, 42857], "valid"], [[42858, 42858], "mapped", [42859]], [[42859, 42859], "valid"], [[42860, 42860], "mapped", [42861]], [[42861, 42861], "valid"], [[42862, 42862], "mapped", [42863]], [[42863, 42863], "valid"], [[42864, 42864], "mapped", [42863]], [[42865, 42872], "valid"], [[42873, 42873], "mapped", [42874]], [[42874, 42874], "valid"], [[42875, 42875], "mapped", [42876]], [[42876, 42876], "valid"], [[42877, 42877], "mapped", [7545]], [[42878, 42878], "mapped", [42879]], [[42879, 42879], "valid"], [[42880, 42880], "mapped", [42881]], [[42881, 42881], "valid"], [[42882, 42882], "mapped", [42883]], [[42883, 42883], "valid"], [[42884, 42884], "mapped", [42885]], [[42885, 42885], "valid"], [[42886, 42886], "mapped", [42887]], [[42887, 42888], "valid"], [[42889, 42890], "valid", [], "NV8"], [[42891, 42891], "mapped", [42892]], [[42892, 42892], "valid"], [[42893, 42893], "mapped", [613]], [[42894, 42894], "valid"], [[42895, 42895], "valid"], [[42896, 42896], "mapped", [42897]], [[42897, 42897], "valid"], [[42898, 42898], "mapped", [42899]], [[42899, 42899], "valid"], [[42900, 42901], "valid"], [[42902, 42902], "mapped", [42903]], [[42903, 42903], "valid"], [[42904, 42904], "mapped", [42905]], [[42905, 42905], "valid"], [[42906, 42906], "mapped", [42907]], [[42907, 42907], "valid"], [[42908, 42908], "mapped", [42909]], [[42909, 42909], "valid"], [[42910, 42910], "mapped", [42911]], [[42911, 42911], "valid"], [[42912, 42912], "mapped", [42913]], [[42913, 42913], "valid"], [[42914, 42914], "mapped", [42915]], [[42915, 42915], "valid"], [[42916, 42916], "mapped", [42917]], [[42917, 42917], "valid"], [[42918, 42918], "mapped", [42919]], [[42919, 42919], "valid"], [[42920, 42920], "mapped", [42921]], [[42921, 42921], "valid"], [[42922, 42922], "mapped", [614]], [[42923, 42923], "mapped", [604]], [[42924, 42924], "mapped", [609]], [[42925, 42925], "mapped", [620]], [[42926, 42927], "disallowed"], [[42928, 42928], "mapped", [670]], [[42929, 42929], "mapped", [647]], [[42930, 42930], "mapped", [669]], [[42931, 42931], "mapped", [43859]], [[42932, 42932], "mapped", [42933]], [[42933, 42933], "valid"], [[42934, 42934], "mapped", [42935]], [[42935, 42935], "valid"], [[42936, 42998], "disallowed"], [[42999, 42999], "valid"], [[43e3, 43e3], "mapped", [295]], [[43001, 43001], "mapped", [339]], [[43002, 43002], "valid"], [[43003, 43007], "valid"], [[43008, 43047], "valid"], [[43048, 43051], "valid", [], "NV8"], [[43052, 43055], "disallowed"], [[43056, 43065], "valid", [], "NV8"], [[43066, 43071], "disallowed"], [[43072, 43123], "valid"], [[43124, 43127], "valid", [], "NV8"], [[43128, 43135], "disallowed"], [[43136, 43204], "valid"], [[43205, 43213], "disallowed"], [[43214, 43215], "valid", [], "NV8"], [[43216, 43225], "valid"], [[43226, 43231], "disallowed"], [[43232, 43255], "valid"], [[43256, 43258], "valid", [], "NV8"], [[43259, 43259], "valid"], [[43260, 43260], "valid", [], "NV8"], [[43261, 43261], "valid"], [[43262, 43263], "disallowed"], [[43264, 43309], "valid"], [[43310, 43311], "valid", [], "NV8"], [[43312, 43347], "valid"], [[43348, 43358], "disallowed"], [[43359, 43359], "valid", [], "NV8"], [[43360, 43388], "valid", [], "NV8"], [[43389, 43391], "disallowed"], [[43392, 43456], "valid"], [[43457, 43469], "valid", [], "NV8"], [[43470, 43470], "disallowed"], [[43471, 43481], "valid"], [[43482, 43485], "disallowed"], [[43486, 43487], "valid", [], "NV8"], [[43488, 43518], "valid"], [[43519, 43519], "disallowed"], [[43520, 43574], "valid"], [[43575, 43583], "disallowed"], [[43584, 43597], "valid"], [[43598, 43599], "disallowed"], [[43600, 43609], "valid"], [[43610, 43611], "disallowed"], [[43612, 43615], "valid", [], "NV8"], [[43616, 43638], "valid"], [[43639, 43641], "valid", [], "NV8"], [[43642, 43643], "valid"], [[43644, 43647], "valid"], [[43648, 43714], "valid"], [[43715, 43738], "disallowed"], [[43739, 43741], "valid"], [[43742, 43743], "valid", [], "NV8"], [[43744, 43759], "valid"], [[43760, 43761], "valid", [], "NV8"], [[43762, 43766], "valid"], [[43767, 43776], "disallowed"], [[43777, 43782], "valid"], [[43783, 43784], "disallowed"], [[43785, 43790], "valid"], [[43791, 43792], "disallowed"], [[43793, 43798], "valid"], [[43799, 43807], "disallowed"], [[43808, 43814], "valid"], [[43815, 43815], "disallowed"], [[43816, 43822], "valid"], [[43823, 43823], "disallowed"], [[43824, 43866], "valid"], [[43867, 43867], "valid", [], "NV8"], [[43868, 43868], "mapped", [42791]], [[43869, 43869], "mapped", [43831]], [[43870, 43870], "mapped", [619]], [[43871, 43871], "mapped", [43858]], [[43872, 43875], "valid"], [[43876, 43877], "valid"], [[43878, 43887], "disallowed"], [[43888, 43888], "mapped", [5024]], [[43889, 43889], "mapped", [5025]], [[43890, 43890], "mapped", [5026]], [[43891, 43891], "mapped", [5027]], [[43892, 43892], "mapped", [5028]], [[43893, 43893], "mapped", [5029]], [[43894, 43894], "mapped", [5030]], [[43895, 43895], "mapped", [5031]], [[43896, 43896], "mapped", [5032]], [[43897, 43897], "mapped", [5033]], [[43898, 43898], "mapped", [5034]], [[43899, 43899], "mapped", [5035]], [[43900, 43900], "mapped", [5036]], [[43901, 43901], "mapped", [5037]], [[43902, 43902], "mapped", [5038]], [[43903, 43903], "mapped", [5039]], [[43904, 43904], "mapped", [5040]], [[43905, 43905], "mapped", [5041]], [[43906, 43906], "mapped", [5042]], [[43907, 43907], "mapped", [5043]], [[43908, 43908], "mapped", [5044]], [[43909, 43909], "mapped", [5045]], [[43910, 43910], "mapped", [5046]], [[43911, 43911], "mapped", [5047]], [[43912, 43912], "mapped", [5048]], [[43913, 43913], "mapped", [5049]], [[43914, 43914], "mapped", [5050]], [[43915, 43915], "mapped", [5051]], [[43916, 43916], "mapped", [5052]], [[43917, 43917], "mapped", [5053]], [[43918, 43918], "mapped", [5054]], [[43919, 43919], "mapped", [5055]], [[43920, 43920], "mapped", [5056]], [[43921, 43921], "mapped", [5057]], [[43922, 43922], "mapped", [5058]], [[43923, 43923], "mapped", [5059]], [[43924, 43924], "mapped", [5060]], [[43925, 43925], "mapped", [5061]], [[43926, 43926], "mapped", [5062]], [[43927, 43927], "mapped", [5063]], [[43928, 43928], "mapped", [5064]], [[43929, 43929], "mapped", [5065]], [[43930, 43930], "mapped", [5066]], [[43931, 43931], "mapped", [5067]], [[43932, 43932], "mapped", [5068]], [[43933, 43933], "mapped", [5069]], [[43934, 43934], "mapped", [5070]], [[43935, 43935], "mapped", [5071]], [[43936, 43936], "mapped", [5072]], [[43937, 43937], "mapped", [5073]], [[43938, 43938], "mapped", [5074]], [[43939, 43939], "mapped", [5075]], [[43940, 43940], "mapped", [5076]], [[43941, 43941], "mapped", [5077]], [[43942, 43942], "mapped", [5078]], [[43943, 43943], "mapped", [5079]], [[43944, 43944], "mapped", [5080]], [[43945, 43945], "mapped", [5081]], [[43946, 43946], "mapped", [5082]], [[43947, 43947], "mapped", [5083]], [[43948, 43948], "mapped", [5084]], [[43949, 43949], "mapped", [5085]], [[43950, 43950], "mapped", [5086]], [[43951, 43951], "mapped", [5087]], [[43952, 43952], "mapped", [5088]], [[43953, 43953], "mapped", [5089]], [[43954, 43954], "mapped", [5090]], [[43955, 43955], "mapped", [5091]], [[43956, 43956], "mapped", [5092]], [[43957, 43957], "mapped", [5093]], [[43958, 43958], "mapped", [5094]], [[43959, 43959], "mapped", [5095]], [[43960, 43960], "mapped", [5096]], [[43961, 43961], "mapped", [5097]], [[43962, 43962], "mapped", [5098]], [[43963, 43963], "mapped", [5099]], [[43964, 43964], "mapped", [5100]], [[43965, 43965], "mapped", [5101]], [[43966, 43966], "mapped", [5102]], [[43967, 43967], "mapped", [5103]], [[43968, 44010], "valid"], [[44011, 44011], "valid", [], "NV8"], [[44012, 44013], "valid"], [[44014, 44015], "disallowed"], [[44016, 44025], "valid"], [[44026, 44031], "disallowed"], [[44032, 55203], "valid"], [[55204, 55215], "disallowed"], [[55216, 55238], "valid", [], "NV8"], [[55239, 55242], "disallowed"], [[55243, 55291], "valid", [], "NV8"], [[55292, 55295], "disallowed"], [[55296, 57343], "disallowed"], [[57344, 63743], "disallowed"], [[63744, 63744], "mapped", [35912]], [[63745, 63745], "mapped", [26356]], [[63746, 63746], "mapped", [36554]], [[63747, 63747], "mapped", [36040]], [[63748, 63748], "mapped", [28369]], [[63749, 63749], "mapped", [20018]], [[63750, 63750], "mapped", [21477]], [[63751, 63752], "mapped", [40860]], [[63753, 63753], "mapped", [22865]], [[63754, 63754], "mapped", [37329]], [[63755, 63755], "mapped", [21895]], [[63756, 63756], "mapped", [22856]], [[63757, 63757], "mapped", [25078]], [[63758, 63758], "mapped", [30313]], [[63759, 63759], "mapped", [32645]], [[63760, 63760], "mapped", [34367]], [[63761, 63761], "mapped", [34746]], [[63762, 63762], "mapped", [35064]], [[63763, 63763], "mapped", [37007]], [[63764, 63764], "mapped", [27138]], [[63765, 63765], "mapped", [27931]], [[63766, 63766], "mapped", [28889]], [[63767, 63767], "mapped", [29662]], [[63768, 63768], "mapped", [33853]], [[63769, 63769], "mapped", [37226]], [[63770, 63770], "mapped", [39409]], [[63771, 63771], "mapped", [20098]], [[63772, 63772], "mapped", [21365]], [[63773, 63773], "mapped", [27396]], [[63774, 63774], "mapped", [29211]], [[63775, 63775], "mapped", [34349]], [[63776, 63776], "mapped", [40478]], [[63777, 63777], "mapped", [23888]], [[63778, 63778], "mapped", [28651]], [[63779, 63779], "mapped", [34253]], [[63780, 63780], "mapped", [35172]], [[63781, 63781], "mapped", [25289]], [[63782, 63782], "mapped", [33240]], [[63783, 63783], "mapped", [34847]], [[63784, 63784], "mapped", [24266]], [[63785, 63785], "mapped", [26391]], [[63786, 63786], "mapped", [28010]], [[63787, 63787], "mapped", [29436]], [[63788, 63788], "mapped", [37070]], [[63789, 63789], "mapped", [20358]], [[63790, 63790], "mapped", [20919]], [[63791, 63791], "mapped", [21214]], [[63792, 63792], "mapped", [25796]], [[63793, 63793], "mapped", [27347]], [[63794, 63794], "mapped", [29200]], [[63795, 63795], "mapped", [30439]], [[63796, 63796], "mapped", [32769]], [[63797, 63797], "mapped", [34310]], [[63798, 63798], "mapped", [34396]], [[63799, 63799], "mapped", [36335]], [[63800, 63800], "mapped", [38706]], [[63801, 63801], "mapped", [39791]], [[63802, 63802], "mapped", [40442]], [[63803, 63803], "mapped", [30860]], [[63804, 63804], "mapped", [31103]], [[63805, 63805], "mapped", [32160]], [[63806, 63806], "mapped", [33737]], [[63807, 63807], "mapped", [37636]], [[63808, 63808], "mapped", [40575]], [[63809, 63809], "mapped", [35542]], [[63810, 63810], "mapped", [22751]], [[63811, 63811], "mapped", [24324]], [[63812, 63812], "mapped", [31840]], [[63813, 63813], "mapped", [32894]], [[63814, 63814], "mapped", [29282]], [[63815, 63815], "mapped", [30922]], [[63816, 63816], "mapped", [36034]], [[63817, 63817], "mapped", [38647]], [[63818, 63818], "mapped", [22744]], [[63819, 63819], "mapped", [23650]], [[63820, 63820], "mapped", [27155]], [[63821, 63821], "mapped", [28122]], [[63822, 63822], "mapped", [28431]], [[63823, 63823], "mapped", [32047]], [[63824, 63824], "mapped", [32311]], [[63825, 63825], "mapped", [38475]], [[63826, 63826], "mapped", [21202]], [[63827, 63827], "mapped", [32907]], [[63828, 63828], "mapped", [20956]], [[63829, 63829], "mapped", [20940]], [[63830, 63830], "mapped", [31260]], [[63831, 63831], "mapped", [32190]], [[63832, 63832], "mapped", [33777]], [[63833, 63833], "mapped", [38517]], [[63834, 63834], "mapped", [35712]], [[63835, 63835], "mapped", [25295]], [[63836, 63836], "mapped", [27138]], [[63837, 63837], "mapped", [35582]], [[63838, 63838], "mapped", [20025]], [[63839, 63839], "mapped", [23527]], [[63840, 63840], "mapped", [24594]], [[63841, 63841], "mapped", [29575]], [[63842, 63842], "mapped", [30064]], [[63843, 63843], "mapped", [21271]], [[63844, 63844], "mapped", [30971]], [[63845, 63845], "mapped", [20415]], [[63846, 63846], "mapped", [24489]], [[63847, 63847], "mapped", [19981]], [[63848, 63848], "mapped", [27852]], [[63849, 63849], "mapped", [25976]], [[63850, 63850], "mapped", [32034]], [[63851, 63851], "mapped", [21443]], [[63852, 63852], "mapped", [22622]], [[63853, 63853], "mapped", [30465]], [[63854, 63854], "mapped", [33865]], [[63855, 63855], "mapped", [35498]], [[63856, 63856], "mapped", [27578]], [[63857, 63857], "mapped", [36784]], [[63858, 63858], "mapped", [27784]], [[63859, 63859], "mapped", [25342]], [[63860, 63860], "mapped", [33509]], [[63861, 63861], "mapped", [25504]], [[63862, 63862], "mapped", [30053]], [[63863, 63863], "mapped", [20142]], [[63864, 63864], "mapped", [20841]], [[63865, 63865], "mapped", [20937]], [[63866, 63866], "mapped", [26753]], [[63867, 63867], "mapped", [31975]], [[63868, 63868], "mapped", [33391]], [[63869, 63869], "mapped", [35538]], [[63870, 63870], "mapped", [37327]], [[63871, 63871], "mapped", [21237]], [[63872, 63872], "mapped", [21570]], [[63873, 63873], "mapped", [22899]], [[63874, 63874], "mapped", [24300]], [[63875, 63875], "mapped", [26053]], [[63876, 63876], "mapped", [28670]], [[63877, 63877], "mapped", [31018]], [[63878, 63878], "mapped", [38317]], [[63879, 63879], "mapped", [39530]], [[63880, 63880], "mapped", [40599]], [[63881, 63881], "mapped", [40654]], [[63882, 63882], "mapped", [21147]], [[63883, 63883], "mapped", [26310]], [[63884, 63884], "mapped", [27511]], [[63885, 63885], "mapped", [36706]], [[63886, 63886], "mapped", [24180]], [[63887, 63887], "mapped", [24976]], [[63888, 63888], "mapped", [25088]], [[63889, 63889], "mapped", [25754]], [[63890, 63890], "mapped", [28451]], [[63891, 63891], "mapped", [29001]], [[63892, 63892], "mapped", [29833]], [[63893, 63893], "mapped", [31178]], [[63894, 63894], "mapped", [32244]], [[63895, 63895], "mapped", [32879]], [[63896, 63896], "mapped", [36646]], [[63897, 63897], "mapped", [34030]], [[63898, 63898], "mapped", [36899]], [[63899, 63899], "mapped", [37706]], [[63900, 63900], "mapped", [21015]], [[63901, 63901], "mapped", [21155]], [[63902, 63902], "mapped", [21693]], [[63903, 63903], "mapped", [28872]], [[63904, 63904], "mapped", [35010]], [[63905, 63905], "mapped", [35498]], [[63906, 63906], "mapped", [24265]], [[63907, 63907], "mapped", [24565]], [[63908, 63908], "mapped", [25467]], [[63909, 63909], "mapped", [27566]], [[63910, 63910], "mapped", [31806]], [[63911, 63911], "mapped", [29557]], [[63912, 63912], "mapped", [20196]], [[63913, 63913], "mapped", [22265]], [[63914, 63914], "mapped", [23527]], [[63915, 63915], "mapped", [23994]], [[63916, 63916], "mapped", [24604]], [[63917, 63917], "mapped", [29618]], [[63918, 63918], "mapped", [29801]], [[63919, 63919], "mapped", [32666]], [[63920, 63920], "mapped", [32838]], [[63921, 63921], "mapped", [37428]], [[63922, 63922], "mapped", [38646]], [[63923, 63923], "mapped", [38728]], [[63924, 63924], "mapped", [38936]], [[63925, 63925], "mapped", [20363]], [[63926, 63926], "mapped", [31150]], [[63927, 63927], "mapped", [37300]], [[63928, 63928], "mapped", [38584]], [[63929, 63929], "mapped", [24801]], [[63930, 63930], "mapped", [20102]], [[63931, 63931], "mapped", [20698]], [[63932, 63932], "mapped", [23534]], [[63933, 63933], "mapped", [23615]], [[63934, 63934], "mapped", [26009]], [[63935, 63935], "mapped", [27138]], [[63936, 63936], "mapped", [29134]], [[63937, 63937], "mapped", [30274]], [[63938, 63938], "mapped", [34044]], [[63939, 63939], "mapped", [36988]], [[63940, 63940], "mapped", [40845]], [[63941, 63941], "mapped", [26248]], [[63942, 63942], "mapped", [38446]], [[63943, 63943], "mapped", [21129]], [[63944, 63944], "mapped", [26491]], [[63945, 63945], "mapped", [26611]], [[63946, 63946], "mapped", [27969]], [[63947, 63947], "mapped", [28316]], [[63948, 63948], "mapped", [29705]], [[63949, 63949], "mapped", [30041]], [[63950, 63950], "mapped", [30827]], [[63951, 63951], "mapped", [32016]], [[63952, 63952], "mapped", [39006]], [[63953, 63953], "mapped", [20845]], [[63954, 63954], "mapped", [25134]], [[63955, 63955], "mapped", [38520]], [[63956, 63956], "mapped", [20523]], [[63957, 63957], "mapped", [23833]], [[63958, 63958], "mapped", [28138]], [[63959, 63959], "mapped", [36650]], [[63960, 63960], "mapped", [24459]], [[63961, 63961], "mapped", [24900]], [[63962, 63962], "mapped", [26647]], [[63963, 63963], "mapped", [29575]], [[63964, 63964], "mapped", [38534]], [[63965, 63965], "mapped", [21033]], [[63966, 63966], "mapped", [21519]], [[63967, 63967], "mapped", [23653]], [[63968, 63968], "mapped", [26131]], [[63969, 63969], "mapped", [26446]], [[63970, 63970], "mapped", [26792]], [[63971, 63971], "mapped", [27877]], [[63972, 63972], "mapped", [29702]], [[63973, 63973], "mapped", [30178]], [[63974, 63974], "mapped", [32633]], [[63975, 63975], "mapped", [35023]], [[63976, 63976], "mapped", [35041]], [[63977, 63977], "mapped", [37324]], [[63978, 63978], "mapped", [38626]], [[63979, 63979], "mapped", [21311]], [[63980, 63980], "mapped", [28346]], [[63981, 63981], "mapped", [21533]], [[63982, 63982], "mapped", [29136]], [[63983, 63983], "mapped", [29848]], [[63984, 63984], "mapped", [34298]], [[63985, 63985], "mapped", [38563]], [[63986, 63986], "mapped", [40023]], [[63987, 63987], "mapped", [40607]], [[63988, 63988], "mapped", [26519]], [[63989, 63989], "mapped", [28107]], [[63990, 63990], "mapped", [33256]], [[63991, 63991], "mapped", [31435]], [[63992, 63992], "mapped", [31520]], [[63993, 63993], "mapped", [31890]], [[63994, 63994], "mapped", [29376]], [[63995, 63995], "mapped", [28825]], [[63996, 63996], "mapped", [35672]], [[63997, 63997], "mapped", [20160]], [[63998, 63998], "mapped", [33590]], [[63999, 63999], "mapped", [21050]], [[64e3, 64e3], "mapped", [20999]], [[64001, 64001], "mapped", [24230]], [[64002, 64002], "mapped", [25299]], [[64003, 64003], "mapped", [31958]], [[64004, 64004], "mapped", [23429]], [[64005, 64005], "mapped", [27934]], [[64006, 64006], "mapped", [26292]], [[64007, 64007], "mapped", [36667]], [[64008, 64008], "mapped", [34892]], [[64009, 64009], "mapped", [38477]], [[64010, 64010], "mapped", [35211]], [[64011, 64011], "mapped", [24275]], [[64012, 64012], "mapped", [20800]], [[64013, 64013], "mapped", [21952]], [[64014, 64015], "valid"], [[64016, 64016], "mapped", [22618]], [[64017, 64017], "valid"], [[64018, 64018], "mapped", [26228]], [[64019, 64020], "valid"], [[64021, 64021], "mapped", [20958]], [[64022, 64022], "mapped", [29482]], [[64023, 64023], "mapped", [30410]], [[64024, 64024], "mapped", [31036]], [[64025, 64025], "mapped", [31070]], [[64026, 64026], "mapped", [31077]], [[64027, 64027], "mapped", [31119]], [[64028, 64028], "mapped", [38742]], [[64029, 64029], "mapped", [31934]], [[64030, 64030], "mapped", [32701]], [[64031, 64031], "valid"], [[64032, 64032], "mapped", [34322]], [[64033, 64033], "valid"], [[64034, 64034], "mapped", [35576]], [[64035, 64036], "valid"], [[64037, 64037], "mapped", [36920]], [[64038, 64038], "mapped", [37117]], [[64039, 64041], "valid"], [[64042, 64042], "mapped", [39151]], [[64043, 64043], "mapped", [39164]], [[64044, 64044], "mapped", [39208]], [[64045, 64045], "mapped", [40372]], [[64046, 64046], "mapped", [37086]], [[64047, 64047], "mapped", [38583]], [[64048, 64048], "mapped", [20398]], [[64049, 64049], "mapped", [20711]], [[64050, 64050], "mapped", [20813]], [[64051, 64051], "mapped", [21193]], [[64052, 64052], "mapped", [21220]], [[64053, 64053], "mapped", [21329]], [[64054, 64054], "mapped", [21917]], [[64055, 64055], "mapped", [22022]], [[64056, 64056], "mapped", [22120]], [[64057, 64057], "mapped", [22592]], [[64058, 64058], "mapped", [22696]], [[64059, 64059], "mapped", [23652]], [[64060, 64060], "mapped", [23662]], [[64061, 64061], "mapped", [24724]], [[64062, 64062], "mapped", [24936]], [[64063, 64063], "mapped", [24974]], [[64064, 64064], "mapped", [25074]], [[64065, 64065], "mapped", [25935]], [[64066, 64066], "mapped", [26082]], [[64067, 64067], "mapped", [26257]], [[64068, 64068], "mapped", [26757]], [[64069, 64069], "mapped", [28023]], [[64070, 64070], "mapped", [28186]], [[64071, 64071], "mapped", [28450]], [[64072, 64072], "mapped", [29038]], [[64073, 64073], "mapped", [29227]], [[64074, 64074], "mapped", [29730]], [[64075, 64075], "mapped", [30865]], [[64076, 64076], "mapped", [31038]], [[64077, 64077], "mapped", [31049]], [[64078, 64078], "mapped", [31048]], [[64079, 64079], "mapped", [31056]], [[64080, 64080], "mapped", [31062]], [[64081, 64081], "mapped", [31069]], [[64082, 64082], "mapped", [31117]], [[64083, 64083], "mapped", [31118]], [[64084, 64084], "mapped", [31296]], [[64085, 64085], "mapped", [31361]], [[64086, 64086], "mapped", [31680]], [[64087, 64087], "mapped", [32244]], [[64088, 64088], "mapped", [32265]], [[64089, 64089], "mapped", [32321]], [[64090, 64090], "mapped", [32626]], [[64091, 64091], "mapped", [32773]], [[64092, 64092], "mapped", [33261]], [[64093, 64094], "mapped", [33401]], [[64095, 64095], "mapped", [33879]], [[64096, 64096], "mapped", [35088]], [[64097, 64097], "mapped", [35222]], [[64098, 64098], "mapped", [35585]], [[64099, 64099], "mapped", [35641]], [[64100, 64100], "mapped", [36051]], [[64101, 64101], "mapped", [36104]], [[64102, 64102], "mapped", [36790]], [[64103, 64103], "mapped", [36920]], [[64104, 64104], "mapped", [38627]], [[64105, 64105], "mapped", [38911]], [[64106, 64106], "mapped", [38971]], [[64107, 64107], "mapped", [24693]], [[64108, 64108], "mapped", [148206]], [[64109, 64109], "mapped", [33304]], [[64110, 64111], "disallowed"], [[64112, 64112], "mapped", [20006]], [[64113, 64113], "mapped", [20917]], [[64114, 64114], "mapped", [20840]], [[64115, 64115], "mapped", [20352]], [[64116, 64116], "mapped", [20805]], [[64117, 64117], "mapped", [20864]], [[64118, 64118], "mapped", [21191]], [[64119, 64119], "mapped", [21242]], [[64120, 64120], "mapped", [21917]], [[64121, 64121], "mapped", [21845]], [[64122, 64122], "mapped", [21913]], [[64123, 64123], "mapped", [21986]], [[64124, 64124], "mapped", [22618]], [[64125, 64125], "mapped", [22707]], [[64126, 64126], "mapped", [22852]], [[64127, 64127], "mapped", [22868]], [[64128, 64128], "mapped", [23138]], [[64129, 64129], "mapped", [23336]], [[64130, 64130], "mapped", [24274]], [[64131, 64131], "mapped", [24281]], [[64132, 64132], "mapped", [24425]], [[64133, 64133], "mapped", [24493]], [[64134, 64134], "mapped", [24792]], [[64135, 64135], "mapped", [24910]], [[64136, 64136], "mapped", [24840]], [[64137, 64137], "mapped", [24974]], [[64138, 64138], "mapped", [24928]], [[64139, 64139], "mapped", [25074]], [[64140, 64140], "mapped", [25140]], [[64141, 64141], "mapped", [25540]], [[64142, 64142], "mapped", [25628]], [[64143, 64143], "mapped", [25682]], [[64144, 64144], "mapped", [25942]], [[64145, 64145], "mapped", [26228]], [[64146, 64146], "mapped", [26391]], [[64147, 64147], "mapped", [26395]], [[64148, 64148], "mapped", [26454]], [[64149, 64149], "mapped", [27513]], [[64150, 64150], "mapped", [27578]], [[64151, 64151], "mapped", [27969]], [[64152, 64152], "mapped", [28379]], [[64153, 64153], "mapped", [28363]], [[64154, 64154], "mapped", [28450]], [[64155, 64155], "mapped", [28702]], [[64156, 64156], "mapped", [29038]], [[64157, 64157], "mapped", [30631]], [[64158, 64158], "mapped", [29237]], [[64159, 64159], "mapped", [29359]], [[64160, 64160], "mapped", [29482]], [[64161, 64161], "mapped", [29809]], [[64162, 64162], "mapped", [29958]], [[64163, 64163], "mapped", [30011]], [[64164, 64164], "mapped", [30237]], [[64165, 64165], "mapped", [30239]], [[64166, 64166], "mapped", [30410]], [[64167, 64167], "mapped", [30427]], [[64168, 64168], "mapped", [30452]], [[64169, 64169], "mapped", [30538]], [[64170, 64170], "mapped", [30528]], [[64171, 64171], "mapped", [30924]], [[64172, 64172], "mapped", [31409]], [[64173, 64173], "mapped", [31680]], [[64174, 64174], "mapped", [31867]], [[64175, 64175], "mapped", [32091]], [[64176, 64176], "mapped", [32244]], [[64177, 64177], "mapped", [32574]], [[64178, 64178], "mapped", [32773]], [[64179, 64179], "mapped", [33618]], [[64180, 64180], "mapped", [33775]], [[64181, 64181], "mapped", [34681]], [[64182, 64182], "mapped", [35137]], [[64183, 64183], "mapped", [35206]], [[64184, 64184], "mapped", [35222]], [[64185, 64185], "mapped", [35519]], [[64186, 64186], "mapped", [35576]], [[64187, 64187], "mapped", [35531]], [[64188, 64188], "mapped", [35585]], [[64189, 64189], "mapped", [35582]], [[64190, 64190], "mapped", [35565]], [[64191, 64191], "mapped", [35641]], [[64192, 64192], "mapped", [35722]], [[64193, 64193], "mapped", [36104]], [[64194, 64194], "mapped", [36664]], [[64195, 64195], "mapped", [36978]], [[64196, 64196], "mapped", [37273]], [[64197, 64197], "mapped", [37494]], [[64198, 64198], "mapped", [38524]], [[64199, 64199], "mapped", [38627]], [[64200, 64200], "mapped", [38742]], [[64201, 64201], "mapped", [38875]], [[64202, 64202], "mapped", [38911]], [[64203, 64203], "mapped", [38923]], [[64204, 64204], "mapped", [38971]], [[64205, 64205], "mapped", [39698]], [[64206, 64206], "mapped", [40860]], [[64207, 64207], "mapped", [141386]], [[64208, 64208], "mapped", [141380]], [[64209, 64209], "mapped", [144341]], [[64210, 64210], "mapped", [15261]], [[64211, 64211], "mapped", [16408]], [[64212, 64212], "mapped", [16441]], [[64213, 64213], "mapped", [152137]], [[64214, 64214], "mapped", [154832]], [[64215, 64215], "mapped", [163539]], [[64216, 64216], "mapped", [40771]], [[64217, 64217], "mapped", [40846]], [[64218, 64255], "disallowed"], [[64256, 64256], "mapped", [102, 102]], [[64257, 64257], "mapped", [102, 105]], [[64258, 64258], "mapped", [102, 108]], [[64259, 64259], "mapped", [102, 102, 105]], [[64260, 64260], "mapped", [102, 102, 108]], [[64261, 64262], "mapped", [115, 116]], [[64263, 64274], "disallowed"], [[64275, 64275], "mapped", [1396, 1398]], [[64276, 64276], "mapped", [1396, 1381]], [[64277, 64277], "mapped", [1396, 1387]], [[64278, 64278], "mapped", [1406, 1398]], [[64279, 64279], "mapped", [1396, 1389]], [[64280, 64284], "disallowed"], [[64285, 64285], "mapped", [1497, 1460]], [[64286, 64286], "valid"], [[64287, 64287], "mapped", [1522, 1463]], [[64288, 64288], "mapped", [1506]], [[64289, 64289], "mapped", [1488]], [[64290, 64290], "mapped", [1491]], [[64291, 64291], "mapped", [1492]], [[64292, 64292], "mapped", [1499]], [[64293, 64293], "mapped", [1500]], [[64294, 64294], "mapped", [1501]], [[64295, 64295], "mapped", [1512]], [[64296, 64296], "mapped", [1514]], [[64297, 64297], "disallowed_STD3_mapped", [43]], [[64298, 64298], "mapped", [1513, 1473]], [[64299, 64299], "mapped", [1513, 1474]], [[64300, 64300], "mapped", [1513, 1468, 1473]], [[64301, 64301], "mapped", [1513, 1468, 1474]], [[64302, 64302], "mapped", [1488, 1463]], [[64303, 64303], "mapped", [1488, 1464]], [[64304, 64304], "mapped", [1488, 1468]], [[64305, 64305], "mapped", [1489, 1468]], [[64306, 64306], "mapped", [1490, 1468]], [[64307, 64307], "mapped", [1491, 1468]], [[64308, 64308], "mapped", [1492, 1468]], [[64309, 64309], "mapped", [1493, 1468]], [[64310, 64310], "mapped", [1494, 1468]], [[64311, 64311], "disallowed"], [[64312, 64312], "mapped", [1496, 1468]], [[64313, 64313], "mapped", [1497, 1468]], [[64314, 64314], "mapped", [1498, 1468]], [[64315, 64315], "mapped", [1499, 1468]], [[64316, 64316], "mapped", [1500, 1468]], [[64317, 64317], "disallowed"], [[64318, 64318], "mapped", [1502, 1468]], [[64319, 64319], "disallowed"], [[64320, 64320], "mapped", [1504, 1468]], [[64321, 64321], "mapped", [1505, 1468]], [[64322, 64322], "disallowed"], [[64323, 64323], "mapped", [1507, 1468]], [[64324, 64324], "mapped", [1508, 1468]], [[64325, 64325], "disallowed"], [[64326, 64326], "mapped", [1510, 1468]], [[64327, 64327], "mapped", [1511, 1468]], [[64328, 64328], "mapped", [1512, 1468]], [[64329, 64329], "mapped", [1513, 1468]], [[64330, 64330], "mapped", [1514, 1468]], [[64331, 64331], "mapped", [1493, 1465]], [[64332, 64332], "mapped", [1489, 1471]], [[64333, 64333], "mapped", [1499, 1471]], [[64334, 64334], "mapped", [1508, 1471]], [[64335, 64335], "mapped", [1488, 1500]], [[64336, 64337], "mapped", [1649]], [[64338, 64341], "mapped", [1659]], [[64342, 64345], "mapped", [1662]], [[64346, 64349], "mapped", [1664]], [[64350, 64353], "mapped", [1658]], [[64354, 64357], "mapped", [1663]], [[64358, 64361], "mapped", [1657]], [[64362, 64365], "mapped", [1700]], [[64366, 64369], "mapped", [1702]], [[64370, 64373], "mapped", [1668]], [[64374, 64377], "mapped", [1667]], [[64378, 64381], "mapped", [1670]], [[64382, 64385], "mapped", [1671]], [[64386, 64387], "mapped", [1677]], [[64388, 64389], "mapped", [1676]], [[64390, 64391], "mapped", [1678]], [[64392, 64393], "mapped", [1672]], [[64394, 64395], "mapped", [1688]], [[64396, 64397], "mapped", [1681]], [[64398, 64401], "mapped", [1705]], [[64402, 64405], "mapped", [1711]], [[64406, 64409], "mapped", [1715]], [[64410, 64413], "mapped", [1713]], [[64414, 64415], "mapped", [1722]], [[64416, 64419], "mapped", [1723]], [[64420, 64421], "mapped", [1728]], [[64422, 64425], "mapped", [1729]], [[64426, 64429], "mapped", [1726]], [[64430, 64431], "mapped", [1746]], [[64432, 64433], "mapped", [1747]], [[64434, 64449], "valid", [], "NV8"], [[64450, 64466], "disallowed"], [[64467, 64470], "mapped", [1709]], [[64471, 64472], "mapped", [1735]], [[64473, 64474], "mapped", [1734]], [[64475, 64476], "mapped", [1736]], [[64477, 64477], "mapped", [1735, 1652]], [[64478, 64479], "mapped", [1739]], [[64480, 64481], "mapped", [1733]], [[64482, 64483], "mapped", [1737]], [[64484, 64487], "mapped", [1744]], [[64488, 64489], "mapped", [1609]], [[64490, 64491], "mapped", [1574, 1575]], [[64492, 64493], "mapped", [1574, 1749]], [[64494, 64495], "mapped", [1574, 1608]], [[64496, 64497], "mapped", [1574, 1735]], [[64498, 64499], "mapped", [1574, 1734]], [[64500, 64501], "mapped", [1574, 1736]], [[64502, 64504], "mapped", [1574, 1744]], [[64505, 64507], "mapped", [1574, 1609]], [[64508, 64511], "mapped", [1740]], [[64512, 64512], "mapped", [1574, 1580]], [[64513, 64513], "mapped", [1574, 1581]], [[64514, 64514], "mapped", [1574, 1605]], [[64515, 64515], "mapped", [1574, 1609]], [[64516, 64516], "mapped", [1574, 1610]], [[64517, 64517], "mapped", [1576, 1580]], [[64518, 64518], "mapped", [1576, 1581]], [[64519, 64519], "mapped", [1576, 1582]], [[64520, 64520], "mapped", [1576, 1605]], [[64521, 64521], "mapped", [1576, 1609]], [[64522, 64522], "mapped", [1576, 1610]], [[64523, 64523], "mapped", [1578, 1580]], [[64524, 64524], "mapped", [1578, 1581]], [[64525, 64525], "mapped", [1578, 1582]], [[64526, 64526], "mapped", [1578, 1605]], [[64527, 64527], "mapped", [1578, 1609]], [[64528, 64528], "mapped", [1578, 1610]], [[64529, 64529], "mapped", [1579, 1580]], [[64530, 64530], "mapped", [1579, 1605]], [[64531, 64531], "mapped", [1579, 1609]], [[64532, 64532], "mapped", [1579, 1610]], [[64533, 64533], "mapped", [1580, 1581]], [[64534, 64534], "mapped", [1580, 1605]], [[64535, 64535], "mapped", [1581, 1580]], [[64536, 64536], "mapped", [1581, 1605]], [[64537, 64537], "mapped", [1582, 1580]], [[64538, 64538], "mapped", [1582, 1581]], [[64539, 64539], "mapped", [1582, 1605]], [[64540, 64540], "mapped", [1587, 1580]], [[64541, 64541], "mapped", [1587, 1581]], [[64542, 64542], "mapped", [1587, 1582]], [[64543, 64543], "mapped", [1587, 1605]], [[64544, 64544], "mapped", [1589, 1581]], [[64545, 64545], "mapped", [1589, 1605]], [[64546, 64546], "mapped", [1590, 1580]], [[64547, 64547], "mapped", [1590, 1581]], [[64548, 64548], "mapped", [1590, 1582]], [[64549, 64549], "mapped", [1590, 1605]], [[64550, 64550], "mapped", [1591, 1581]], [[64551, 64551], "mapped", [1591, 1605]], [[64552, 64552], "mapped", [1592, 1605]], [[64553, 64553], "mapped", [1593, 1580]], [[64554, 64554], "mapped", [1593, 1605]], [[64555, 64555], "mapped", [1594, 1580]], [[64556, 64556], "mapped", [1594, 1605]], [[64557, 64557], "mapped", [1601, 1580]], [[64558, 64558], "mapped", [1601, 1581]], [[64559, 64559], "mapped", [1601, 1582]], [[64560, 64560], "mapped", [1601, 1605]], [[64561, 64561], "mapped", [1601, 1609]], [[64562, 64562], "mapped", [1601, 1610]], [[64563, 64563], "mapped", [1602, 1581]], [[64564, 64564], "mapped", [1602, 1605]], [[64565, 64565], "mapped", [1602, 1609]], [[64566, 64566], "mapped", [1602, 1610]], [[64567, 64567], "mapped", [1603, 1575]], [[64568, 64568], "mapped", [1603, 1580]], [[64569, 64569], "mapped", [1603, 1581]], [[64570, 64570], "mapped", [1603, 1582]], [[64571, 64571], "mapped", [1603, 1604]], [[64572, 64572], "mapped", [1603, 1605]], [[64573, 64573], "mapped", [1603, 1609]], [[64574, 64574], "mapped", [1603, 1610]], [[64575, 64575], "mapped", [1604, 1580]], [[64576, 64576], "mapped", [1604, 1581]], [[64577, 64577], "mapped", [1604, 1582]], [[64578, 64578], "mapped", [1604, 1605]], [[64579, 64579], "mapped", [1604, 1609]], [[64580, 64580], "mapped", [1604, 1610]], [[64581, 64581], "mapped", [1605, 1580]], [[64582, 64582], "mapped", [1605, 1581]], [[64583, 64583], "mapped", [1605, 1582]], [[64584, 64584], "mapped", [1605, 1605]], [[64585, 64585], "mapped", [1605, 1609]], [[64586, 64586], "mapped", [1605, 1610]], [[64587, 64587], "mapped", [1606, 1580]], [[64588, 64588], "mapped", [1606, 1581]], [[64589, 64589], "mapped", [1606, 1582]], [[64590, 64590], "mapped", [1606, 1605]], [[64591, 64591], "mapped", [1606, 1609]], [[64592, 64592], "mapped", [1606, 1610]], [[64593, 64593], "mapped", [1607, 1580]], [[64594, 64594], "mapped", [1607, 1605]], [[64595, 64595], "mapped", [1607, 1609]], [[64596, 64596], "mapped", [1607, 1610]], [[64597, 64597], "mapped", [1610, 1580]], [[64598, 64598], "mapped", [1610, 1581]], [[64599, 64599], "mapped", [1610, 1582]], [[64600, 64600], "mapped", [1610, 1605]], [[64601, 64601], "mapped", [1610, 1609]], [[64602, 64602], "mapped", [1610, 1610]], [[64603, 64603], "mapped", [1584, 1648]], [[64604, 64604], "mapped", [1585, 1648]], [[64605, 64605], "mapped", [1609, 1648]], [[64606, 64606], "disallowed_STD3_mapped", [32, 1612, 1617]], [[64607, 64607], "disallowed_STD3_mapped", [32, 1613, 1617]], [[64608, 64608], "disallowed_STD3_mapped", [32, 1614, 1617]], [[64609, 64609], "disallowed_STD3_mapped", [32, 1615, 1617]], [[64610, 64610], "disallowed_STD3_mapped", [32, 1616, 1617]], [[64611, 64611], "disallowed_STD3_mapped", [32, 1617, 1648]], [[64612, 64612], "mapped", [1574, 1585]], [[64613, 64613], "mapped", [1574, 1586]], [[64614, 64614], "mapped", [1574, 1605]], [[64615, 64615], "mapped", [1574, 1606]], [[64616, 64616], "mapped", [1574, 1609]], [[64617, 64617], "mapped", [1574, 1610]], [[64618, 64618], "mapped", [1576, 1585]], [[64619, 64619], "mapped", [1576, 1586]], [[64620, 64620], "mapped", [1576, 1605]], [[64621, 64621], "mapped", [1576, 1606]], [[64622, 64622], "mapped", [1576, 1609]], [[64623, 64623], "mapped", [1576, 1610]], [[64624, 64624], "mapped", [1578, 1585]], [[64625, 64625], "mapped", [1578, 1586]], [[64626, 64626], "mapped", [1578, 1605]], [[64627, 64627], "mapped", [1578, 1606]], [[64628, 64628], "mapped", [1578, 1609]], [[64629, 64629], "mapped", [1578, 1610]], [[64630, 64630], "mapped", [1579, 1585]], [[64631, 64631], "mapped", [1579, 1586]], [[64632, 64632], "mapped", [1579, 1605]], [[64633, 64633], "mapped", [1579, 1606]], [[64634, 64634], "mapped", [1579, 1609]], [[64635, 64635], "mapped", [1579, 1610]], [[64636, 64636], "mapped", [1601, 1609]], [[64637, 64637], "mapped", [1601, 1610]], [[64638, 64638], "mapped", [1602, 1609]], [[64639, 64639], "mapped", [1602, 1610]], [[64640, 64640], "mapped", [1603, 1575]], [[64641, 64641], "mapped", [1603, 1604]], [[64642, 64642], "mapped", [1603, 1605]], [[64643, 64643], "mapped", [1603, 1609]], [[64644, 64644], "mapped", [1603, 1610]], [[64645, 64645], "mapped", [1604, 1605]], [[64646, 64646], "mapped", [1604, 1609]], [[64647, 64647], "mapped", [1604, 1610]], [[64648, 64648], "mapped", [1605, 1575]], [[64649, 64649], "mapped", [1605, 1605]], [[64650, 64650], "mapped", [1606, 1585]], [[64651, 64651], "mapped", [1606, 1586]], [[64652, 64652], "mapped", [1606, 1605]], [[64653, 64653], "mapped", [1606, 1606]], [[64654, 64654], "mapped", [1606, 1609]], [[64655, 64655], "mapped", [1606, 1610]], [[64656, 64656], "mapped", [1609, 1648]], [[64657, 64657], "mapped", [1610, 1585]], [[64658, 64658], "mapped", [1610, 1586]], [[64659, 64659], "mapped", [1610, 1605]], [[64660, 64660], "mapped", [1610, 1606]], [[64661, 64661], "mapped", [1610, 1609]], [[64662, 64662], "mapped", [1610, 1610]], [[64663, 64663], "mapped", [1574, 1580]], [[64664, 64664], "mapped", [1574, 1581]], [[64665, 64665], "mapped", [1574, 1582]], [[64666, 64666], "mapped", [1574, 1605]], [[64667, 64667], "mapped", [1574, 1607]], [[64668, 64668], "mapped", [1576, 1580]], [[64669, 64669], "mapped", [1576, 1581]], [[64670, 64670], "mapped", [1576, 1582]], [[64671, 64671], "mapped", [1576, 1605]], [[64672, 64672], "mapped", [1576, 1607]], [[64673, 64673], "mapped", [1578, 1580]], [[64674, 64674], "mapped", [1578, 1581]], [[64675, 64675], "mapped", [1578, 1582]], [[64676, 64676], "mapped", [1578, 1605]], [[64677, 64677], "mapped", [1578, 1607]], [[64678, 64678], "mapped", [1579, 1605]], [[64679, 64679], "mapped", [1580, 1581]], [[64680, 64680], "mapped", [1580, 1605]], [[64681, 64681], "mapped", [1581, 1580]], [[64682, 64682], "mapped", [1581, 1605]], [[64683, 64683], "mapped", [1582, 1580]], [[64684, 64684], "mapped", [1582, 1605]], [[64685, 64685], "mapped", [1587, 1580]], [[64686, 64686], "mapped", [1587, 1581]], [[64687, 64687], "mapped", [1587, 1582]], [[64688, 64688], "mapped", [1587, 1605]], [[64689, 64689], "mapped", [1589, 1581]], [[64690, 64690], "mapped", [1589, 1582]], [[64691, 64691], "mapped", [1589, 1605]], [[64692, 64692], "mapped", [1590, 1580]], [[64693, 64693], "mapped", [1590, 1581]], [[64694, 64694], "mapped", [1590, 1582]], [[64695, 64695], "mapped", [1590, 1605]], [[64696, 64696], "mapped", [1591, 1581]], [[64697, 64697], "mapped", [1592, 1605]], [[64698, 64698], "mapped", [1593, 1580]], [[64699, 64699], "mapped", [1593, 1605]], [[64700, 64700], "mapped", [1594, 1580]], [[64701, 64701], "mapped", [1594, 1605]], [[64702, 64702], "mapped", [1601, 1580]], [[64703, 64703], "mapped", [1601, 1581]], [[64704, 64704], "mapped", [1601, 1582]], [[64705, 64705], "mapped", [1601, 1605]], [[64706, 64706], "mapped", [1602, 1581]], [[64707, 64707], "mapped", [1602, 1605]], [[64708, 64708], "mapped", [1603, 1580]], [[64709, 64709], "mapped", [1603, 1581]], [[64710, 64710], "mapped", [1603, 1582]], [[64711, 64711], "mapped", [1603, 1604]], [[64712, 64712], "mapped", [1603, 1605]], [[64713, 64713], "mapped", [1604, 1580]], [[64714, 64714], "mapped", [1604, 1581]], [[64715, 64715], "mapped", [1604, 1582]], [[64716, 64716], "mapped", [1604, 1605]], [[64717, 64717], "mapped", [1604, 1607]], [[64718, 64718], "mapped", [1605, 1580]], [[64719, 64719], "mapped", [1605, 1581]], [[64720, 64720], "mapped", [1605, 1582]], [[64721, 64721], "mapped", [1605, 1605]], [[64722, 64722], "mapped", [1606, 1580]], [[64723, 64723], "mapped", [1606, 1581]], [[64724, 64724], "mapped", [1606, 1582]], [[64725, 64725], "mapped", [1606, 1605]], [[64726, 64726], "mapped", [1606, 1607]], [[64727, 64727], "mapped", [1607, 1580]], [[64728, 64728], "mapped", [1607, 1605]], [[64729, 64729], "mapped", [1607, 1648]], [[64730, 64730], "mapped", [1610, 1580]], [[64731, 64731], "mapped", [1610, 1581]], [[64732, 64732], "mapped", [1610, 1582]], [[64733, 64733], "mapped", [1610, 1605]], [[64734, 64734], "mapped", [1610, 1607]], [[64735, 64735], "mapped", [1574, 1605]], [[64736, 64736], "mapped", [1574, 1607]], [[64737, 64737], "mapped", [1576, 1605]], [[64738, 64738], "mapped", [1576, 1607]], [[64739, 64739], "mapped", [1578, 1605]], [[64740, 64740], "mapped", [1578, 1607]], [[64741, 64741], "mapped", [1579, 1605]], [[64742, 64742], "mapped", [1579, 1607]], [[64743, 64743], "mapped", [1587, 1605]], [[64744, 64744], "mapped", [1587, 1607]], [[64745, 64745], "mapped", [1588, 1605]], [[64746, 64746], "mapped", [1588, 1607]], [[64747, 64747], "mapped", [1603, 1604]], [[64748, 64748], "mapped", [1603, 1605]], [[64749, 64749], "mapped", [1604, 1605]], [[64750, 64750], "mapped", [1606, 1605]], [[64751, 64751], "mapped", [1606, 1607]], [[64752, 64752], "mapped", [1610, 1605]], [[64753, 64753], "mapped", [1610, 1607]], [[64754, 64754], "mapped", [1600, 1614, 1617]], [[64755, 64755], "mapped", [1600, 1615, 1617]], [[64756, 64756], "mapped", [1600, 1616, 1617]], [[64757, 64757], "mapped", [1591, 1609]], [[64758, 64758], "mapped", [1591, 1610]], [[64759, 64759], "mapped", [1593, 1609]], [[64760, 64760], "mapped", [1593, 1610]], [[64761, 64761], "mapped", [1594, 1609]], [[64762, 64762], "mapped", [1594, 1610]], [[64763, 64763], "mapped", [1587, 1609]], [[64764, 64764], "mapped", [1587, 1610]], [[64765, 64765], "mapped", [1588, 1609]], [[64766, 64766], "mapped", [1588, 1610]], [[64767, 64767], "mapped", [1581, 1609]], [[64768, 64768], "mapped", [1581, 1610]], [[64769, 64769], "mapped", [1580, 1609]], [[64770, 64770], "mapped", [1580, 1610]], [[64771, 64771], "mapped", [1582, 1609]], [[64772, 64772], "mapped", [1582, 1610]], [[64773, 64773], "mapped", [1589, 1609]], [[64774, 64774], "mapped", [1589, 1610]], [[64775, 64775], "mapped", [1590, 1609]], [[64776, 64776], "mapped", [1590, 1610]], [[64777, 64777], "mapped", [1588, 1580]], [[64778, 64778], "mapped", [1588, 1581]], [[64779, 64779], "mapped", [1588, 1582]], [[64780, 64780], "mapped", [1588, 1605]], [[64781, 64781], "mapped", [1588, 1585]], [[64782, 64782], "mapped", [1587, 1585]], [[64783, 64783], "mapped", [1589, 1585]], [[64784, 64784], "mapped", [1590, 1585]], [[64785, 64785], "mapped", [1591, 1609]], [[64786, 64786], "mapped", [1591, 1610]], [[64787, 64787], "mapped", [1593, 1609]], [[64788, 64788], "mapped", [1593, 1610]], [[64789, 64789], "mapped", [1594, 1609]], [[64790, 64790], "mapped", [1594, 1610]], [[64791, 64791], "mapped", [1587, 1609]], [[64792, 64792], "mapped", [1587, 1610]], [[64793, 64793], "mapped", [1588, 1609]], [[64794, 64794], "mapped", [1588, 1610]], [[64795, 64795], "mapped", [1581, 1609]], [[64796, 64796], "mapped", [1581, 1610]], [[64797, 64797], "mapped", [1580, 1609]], [[64798, 64798], "mapped", [1580, 1610]], [[64799, 64799], "mapped", [1582, 1609]], [[64800, 64800], "mapped", [1582, 1610]], [[64801, 64801], "mapped", [1589, 1609]], [[64802, 64802], "mapped", [1589, 1610]], [[64803, 64803], "mapped", [1590, 1609]], [[64804, 64804], "mapped", [1590, 1610]], [[64805, 64805], "mapped", [1588, 1580]], [[64806, 64806], "mapped", [1588, 1581]], [[64807, 64807], "mapped", [1588, 1582]], [[64808, 64808], "mapped", [1588, 1605]], [[64809, 64809], "mapped", [1588, 1585]], [[64810, 64810], "mapped", [1587, 1585]], [[64811, 64811], "mapped", [1589, 1585]], [[64812, 64812], "mapped", [1590, 1585]], [[64813, 64813], "mapped", [1588, 1580]], [[64814, 64814], "mapped", [1588, 1581]], [[64815, 64815], "mapped", [1588, 1582]], [[64816, 64816], "mapped", [1588, 1605]], [[64817, 64817], "mapped", [1587, 1607]], [[64818, 64818], "mapped", [1588, 1607]], [[64819, 64819], "mapped", [1591, 1605]], [[64820, 64820], "mapped", [1587, 1580]], [[64821, 64821], "mapped", [1587, 1581]], [[64822, 64822], "mapped", [1587, 1582]], [[64823, 64823], "mapped", [1588, 1580]], [[64824, 64824], "mapped", [1588, 1581]], [[64825, 64825], "mapped", [1588, 1582]], [[64826, 64826], "mapped", [1591, 1605]], [[64827, 64827], "mapped", [1592, 1605]], [[64828, 64829], "mapped", [1575, 1611]], [[64830, 64831], "valid", [], "NV8"], [[64832, 64847], "disallowed"], [[64848, 64848], "mapped", [1578, 1580, 1605]], [[64849, 64850], "mapped", [1578, 1581, 1580]], [[64851, 64851], "mapped", [1578, 1581, 1605]], [[64852, 64852], "mapped", [1578, 1582, 1605]], [[64853, 64853], "mapped", [1578, 1605, 1580]], [[64854, 64854], "mapped", [1578, 1605, 1581]], [[64855, 64855], "mapped", [1578, 1605, 1582]], [[64856, 64857], "mapped", [1580, 1605, 1581]], [[64858, 64858], "mapped", [1581, 1605, 1610]], [[64859, 64859], "mapped", [1581, 1605, 1609]], [[64860, 64860], "mapped", [1587, 1581, 1580]], [[64861, 64861], "mapped", [1587, 1580, 1581]], [[64862, 64862], "mapped", [1587, 1580, 1609]], [[64863, 64864], "mapped", [1587, 1605, 1581]], [[64865, 64865], "mapped", [1587, 1605, 1580]], [[64866, 64867], "mapped", [1587, 1605, 1605]], [[64868, 64869], "mapped", [1589, 1581, 1581]], [[64870, 64870], "mapped", [1589, 1605, 1605]], [[64871, 64872], "mapped", [1588, 1581, 1605]], [[64873, 64873], "mapped", [1588, 1580, 1610]], [[64874, 64875], "mapped", [1588, 1605, 1582]], [[64876, 64877], "mapped", [1588, 1605, 1605]], [[64878, 64878], "mapped", [1590, 1581, 1609]], [[64879, 64880], "mapped", [1590, 1582, 1605]], [[64881, 64882], "mapped", [1591, 1605, 1581]], [[64883, 64883], "mapped", [1591, 1605, 1605]], [[64884, 64884], "mapped", [1591, 1605, 1610]], [[64885, 64885], "mapped", [1593, 1580, 1605]], [[64886, 64887], "mapped", [1593, 1605, 1605]], [[64888, 64888], "mapped", [1593, 1605, 1609]], [[64889, 64889], "mapped", [1594, 1605, 1605]], [[64890, 64890], "mapped", [1594, 1605, 1610]], [[64891, 64891], "mapped", [1594, 1605, 1609]], [[64892, 64893], "mapped", [1601, 1582, 1605]], [[64894, 64894], "mapped", [1602, 1605, 1581]], [[64895, 64895], "mapped", [1602, 1605, 1605]], [[64896, 64896], "mapped", [1604, 1581, 1605]], [[64897, 64897], "mapped", [1604, 1581, 1610]], [[64898, 64898], "mapped", [1604, 1581, 1609]], [[64899, 64900], "mapped", [1604, 1580, 1580]], [[64901, 64902], "mapped", [1604, 1582, 1605]], [[64903, 64904], "mapped", [1604, 1605, 1581]], [[64905, 64905], "mapped", [1605, 1581, 1580]], [[64906, 64906], "mapped", [1605, 1581, 1605]], [[64907, 64907], "mapped", [1605, 1581, 1610]], [[64908, 64908], "mapped", [1605, 1580, 1581]], [[64909, 64909], "mapped", [1605, 1580, 1605]], [[64910, 64910], "mapped", [1605, 1582, 1580]], [[64911, 64911], "mapped", [1605, 1582, 1605]], [[64912, 64913], "disallowed"], [[64914, 64914], "mapped", [1605, 1580, 1582]], [[64915, 64915], "mapped", [1607, 1605, 1580]], [[64916, 64916], "mapped", [1607, 1605, 1605]], [[64917, 64917], "mapped", [1606, 1581, 1605]], [[64918, 64918], "mapped", [1606, 1581, 1609]], [[64919, 64920], "mapped", [1606, 1580, 1605]], [[64921, 64921], "mapped", [1606, 1580, 1609]], [[64922, 64922], "mapped", [1606, 1605, 1610]], [[64923, 64923], "mapped", [1606, 1605, 1609]], [[64924, 64925], "mapped", [1610, 1605, 1605]], [[64926, 64926], "mapped", [1576, 1582, 1610]], [[64927, 64927], "mapped", [1578, 1580, 1610]], [[64928, 64928], "mapped", [1578, 1580, 1609]], [[64929, 64929], "mapped", [1578, 1582, 1610]], [[64930, 64930], "mapped", [1578, 1582, 1609]], [[64931, 64931], "mapped", [1578, 1605, 1610]], [[64932, 64932], "mapped", [1578, 1605, 1609]], [[64933, 64933], "mapped", [1580, 1605, 1610]], [[64934, 64934], "mapped", [1580, 1581, 1609]], [[64935, 64935], "mapped", [1580, 1605, 1609]], [[64936, 64936], "mapped", [1587, 1582, 1609]], [[64937, 64937], "mapped", [1589, 1581, 1610]], [[64938, 64938], "mapped", [1588, 1581, 1610]], [[64939, 64939], "mapped", [1590, 1581, 1610]], [[64940, 64940], "mapped", [1604, 1580, 1610]], [[64941, 64941], "mapped", [1604, 1605, 1610]], [[64942, 64942], "mapped", [1610, 1581, 1610]], [[64943, 64943], "mapped", [1610, 1580, 1610]], [[64944, 64944], "mapped", [1610, 1605, 1610]], [[64945, 64945], "mapped", [1605, 1605, 1610]], [[64946, 64946], "mapped", [1602, 1605, 1610]], [[64947, 64947], "mapped", [1606, 1581, 1610]], [[64948, 64948], "mapped", [1602, 1605, 1581]], [[64949, 64949], "mapped", [1604, 1581, 1605]], [[64950, 64950], "mapped", [1593, 1605, 1610]], [[64951, 64951], "mapped", [1603, 1605, 1610]], [[64952, 64952], "mapped", [1606, 1580, 1581]], [[64953, 64953], "mapped", [1605, 1582, 1610]], [[64954, 64954], "mapped", [1604, 1580, 1605]], [[64955, 64955], "mapped", [1603, 1605, 1605]], [[64956, 64956], "mapped", [1604, 1580, 1605]], [[64957, 64957], "mapped", [1606, 1580, 1581]], [[64958, 64958], "mapped", [1580, 1581, 1610]], [[64959, 64959], "mapped", [1581, 1580, 1610]], [[64960, 64960], "mapped", [1605, 1580, 1610]], [[64961, 64961], "mapped", [1601, 1605, 1610]], [[64962, 64962], "mapped", [1576, 1581, 1610]], [[64963, 64963], "mapped", [1603, 1605, 1605]], [[64964, 64964], "mapped", [1593, 1580, 1605]], [[64965, 64965], "mapped", [1589, 1605, 1605]], [[64966, 64966], "mapped", [1587, 1582, 1610]], [[64967, 64967], "mapped", [1606, 1580, 1610]], [[64968, 64975], "disallowed"], [[64976, 65007], "disallowed"], [[65008, 65008], "mapped", [1589, 1604, 1746]], [[65009, 65009], "mapped", [1602, 1604, 1746]], [[65010, 65010], "mapped", [1575, 1604, 1604, 1607]], [[65011, 65011], "mapped", [1575, 1603, 1576, 1585]], [[65012, 65012], "mapped", [1605, 1581, 1605, 1583]], [[65013, 65013], "mapped", [1589, 1604, 1593, 1605]], [[65014, 65014], "mapped", [1585, 1587, 1608, 1604]], [[65015, 65015], "mapped", [1593, 1604, 1610, 1607]], [[65016, 65016], "mapped", [1608, 1587, 1604, 1605]], [[65017, 65017], "mapped", [1589, 1604, 1609]], [[65018, 65018], "disallowed_STD3_mapped", [1589, 1604, 1609, 32, 1575, 1604, 1604, 1607, 32, 1593, 1604, 1610, 1607, 32, 1608, 1587, 1604, 1605]], [[65019, 65019], "disallowed_STD3_mapped", [1580, 1604, 32, 1580, 1604, 1575, 1604, 1607]], [[65020, 65020], "mapped", [1585, 1740, 1575, 1604]], [[65021, 65021], "valid", [], "NV8"], [[65022, 65023], "disallowed"], [[65024, 65039], "ignored"], [[65040, 65040], "disallowed_STD3_mapped", [44]], [[65041, 65041], "mapped", [12289]], [[65042, 65042], "disallowed"], [[65043, 65043], "disallowed_STD3_mapped", [58]], [[65044, 65044], "disallowed_STD3_mapped", [59]], [[65045, 65045], "disallowed_STD3_mapped", [33]], [[65046, 65046], "disallowed_STD3_mapped", [63]], [[65047, 65047], "mapped", [12310]], [[65048, 65048], "mapped", [12311]], [[65049, 65049], "disallowed"], [[65050, 65055], "disallowed"], [[65056, 65059], "valid"], [[65060, 65062], "valid"], [[65063, 65069], "valid"], [[65070, 65071], "valid"], [[65072, 65072], "disallowed"], [[65073, 65073], "mapped", [8212]], [[65074, 65074], "mapped", [8211]], [[65075, 65076], "disallowed_STD3_mapped", [95]], [[65077, 65077], "disallowed_STD3_mapped", [40]], [[65078, 65078], "disallowed_STD3_mapped", [41]], [[65079, 65079], "disallowed_STD3_mapped", [123]], [[65080, 65080], "disallowed_STD3_mapped", [125]], [[65081, 65081], "mapped", [12308]], [[65082, 65082], "mapped", [12309]], [[65083, 65083], "mapped", [12304]], [[65084, 65084], "mapped", [12305]], [[65085, 65085], "mapped", [12298]], [[65086, 65086], "mapped", [12299]], [[65087, 65087], "mapped", [12296]], [[65088, 65088], "mapped", [12297]], [[65089, 65089], "mapped", [12300]], [[65090, 65090], "mapped", [12301]], [[65091, 65091], "mapped", [12302]], [[65092, 65092], "mapped", [12303]], [[65093, 65094], "valid", [], "NV8"], [[65095, 65095], "disallowed_STD3_mapped", [91]], [[65096, 65096], "disallowed_STD3_mapped", [93]], [[65097, 65100], "disallowed_STD3_mapped", [32, 773]], [[65101, 65103], "disallowed_STD3_mapped", [95]], [[65104, 65104], "disallowed_STD3_mapped", [44]], [[65105, 65105], "mapped", [12289]], [[65106, 65106], "disallowed"], [[65107, 65107], "disallowed"], [[65108, 65108], "disallowed_STD3_mapped", [59]], [[65109, 65109], "disallowed_STD3_mapped", [58]], [[65110, 65110], "disallowed_STD3_mapped", [63]], [[65111, 65111], "disallowed_STD3_mapped", [33]], [[65112, 65112], "mapped", [8212]], [[65113, 65113], "disallowed_STD3_mapped", [40]], [[65114, 65114], "disallowed_STD3_mapped", [41]], [[65115, 65115], "disallowed_STD3_mapped", [123]], [[65116, 65116], "disallowed_STD3_mapped", [125]], [[65117, 65117], "mapped", [12308]], [[65118, 65118], "mapped", [12309]], [[65119, 65119], "disallowed_STD3_mapped", [35]], [[65120, 65120], "disallowed_STD3_mapped", [38]], [[65121, 65121], "disallowed_STD3_mapped", [42]], [[65122, 65122], "disallowed_STD3_mapped", [43]], [[65123, 65123], "mapped", [45]], [[65124, 65124], "disallowed_STD3_mapped", [60]], [[65125, 65125], "disallowed_STD3_mapped", [62]], [[65126, 65126], "disallowed_STD3_mapped", [61]], [[65127, 65127], "disallowed"], [[65128, 65128], "disallowed_STD3_mapped", [92]], [[65129, 65129], "disallowed_STD3_mapped", [36]], [[65130, 65130], "disallowed_STD3_mapped", [37]], [[65131, 65131], "disallowed_STD3_mapped", [64]], [[65132, 65135], "disallowed"], [[65136, 65136], "disallowed_STD3_mapped", [32, 1611]], [[65137, 65137], "mapped", [1600, 1611]], [[65138, 65138], "disallowed_STD3_mapped", [32, 1612]], [[65139, 65139], "valid"], [[65140, 65140], "disallowed_STD3_mapped", [32, 1613]], [[65141, 65141], "disallowed"], [[65142, 65142], "disallowed_STD3_mapped", [32, 1614]], [[65143, 65143], "mapped", [1600, 1614]], [[65144, 65144], "disallowed_STD3_mapped", [32, 1615]], [[65145, 65145], "mapped", [1600, 1615]], [[65146, 65146], "disallowed_STD3_mapped", [32, 1616]], [[65147, 65147], "mapped", [1600, 1616]], [[65148, 65148], "disallowed_STD3_mapped", [32, 1617]], [[65149, 65149], "mapped", [1600, 1617]], [[65150, 65150], "disallowed_STD3_mapped", [32, 1618]], [[65151, 65151], "mapped", [1600, 1618]], [[65152, 65152], "mapped", [1569]], [[65153, 65154], "mapped", [1570]], [[65155, 65156], "mapped", [1571]], [[65157, 65158], "mapped", [1572]], [[65159, 65160], "mapped", [1573]], [[65161, 65164], "mapped", [1574]], [[65165, 65166], "mapped", [1575]], [[65167, 65170], "mapped", [1576]], [[65171, 65172], "mapped", [1577]], [[65173, 65176], "mapped", [1578]], [[65177, 65180], "mapped", [1579]], [[65181, 65184], "mapped", [1580]], [[65185, 65188], "mapped", [1581]], [[65189, 65192], "mapped", [1582]], [[65193, 65194], "mapped", [1583]], [[65195, 65196], "mapped", [1584]], [[65197, 65198], "mapped", [1585]], [[65199, 65200], "mapped", [1586]], [[65201, 65204], "mapped", [1587]], [[65205, 65208], "mapped", [1588]], [[65209, 65212], "mapped", [1589]], [[65213, 65216], "mapped", [1590]], [[65217, 65220], "mapped", [1591]], [[65221, 65224], "mapped", [1592]], [[65225, 65228], "mapped", [1593]], [[65229, 65232], "mapped", [1594]], [[65233, 65236], "mapped", [1601]], [[65237, 65240], "mapped", [1602]], [[65241, 65244], "mapped", [1603]], [[65245, 65248], "mapped", [1604]], [[65249, 65252], "mapped", [1605]], [[65253, 65256], "mapped", [1606]], [[65257, 65260], "mapped", [1607]], [[65261, 65262], "mapped", [1608]], [[65263, 65264], "mapped", [1609]], [[65265, 65268], "mapped", [1610]], [[65269, 65270], "mapped", [1604, 1570]], [[65271, 65272], "mapped", [1604, 1571]], [[65273, 65274], "mapped", [1604, 1573]], [[65275, 65276], "mapped", [1604, 1575]], [[65277, 65278], "disallowed"], [[65279, 65279], "ignored"], [[65280, 65280], "disallowed"], [[65281, 65281], "disallowed_STD3_mapped", [33]], [[65282, 65282], "disallowed_STD3_mapped", [34]], [[65283, 65283], "disallowed_STD3_mapped", [35]], [[65284, 65284], "disallowed_STD3_mapped", [36]], [[65285, 65285], "disallowed_STD3_mapped", [37]], [[65286, 65286], "disallowed_STD3_mapped", [38]], [[65287, 65287], "disallowed_STD3_mapped", [39]], [[65288, 65288], "disallowed_STD3_mapped", [40]], [[65289, 65289], "disallowed_STD3_mapped", [41]], [[65290, 65290], "disallowed_STD3_mapped", [42]], [[65291, 65291], "disallowed_STD3_mapped", [43]], [[65292, 65292], "disallowed_STD3_mapped", [44]], [[65293, 65293], "mapped", [45]], [[65294, 65294], "mapped", [46]], [[65295, 65295], "disallowed_STD3_mapped", [47]], [[65296, 65296], "mapped", [48]], [[65297, 65297], "mapped", [49]], [[65298, 65298], "mapped", [50]], [[65299, 65299], "mapped", [51]], [[65300, 65300], "mapped", [52]], [[65301, 65301], "mapped", [53]], [[65302, 65302], "mapped", [54]], [[65303, 65303], "mapped", [55]], [[65304, 65304], "mapped", [56]], [[65305, 65305], "mapped", [57]], [[65306, 65306], "disallowed_STD3_mapped", [58]], [[65307, 65307], "disallowed_STD3_mapped", [59]], [[65308, 65308], "disallowed_STD3_mapped", [60]], [[65309, 65309], "disallowed_STD3_mapped", [61]], [[65310, 65310], "disallowed_STD3_mapped", [62]], [[65311, 65311], "disallowed_STD3_mapped", [63]], [[65312, 65312], "disallowed_STD3_mapped", [64]], [[65313, 65313], "mapped", [97]], [[65314, 65314], "mapped", [98]], [[65315, 65315], "mapped", [99]], [[65316, 65316], "mapped", [100]], [[65317, 65317], "mapped", [101]], [[65318, 65318], "mapped", [102]], [[65319, 65319], "mapped", [103]], [[65320, 65320], "mapped", [104]], [[65321, 65321], "mapped", [105]], [[65322, 65322], "mapped", [106]], [[65323, 65323], "mapped", [107]], [[65324, 65324], "mapped", [108]], [[65325, 65325], "mapped", [109]], [[65326, 65326], "mapped", [110]], [[65327, 65327], "mapped", [111]], [[65328, 65328], "mapped", [112]], [[65329, 65329], "mapped", [113]], [[65330, 65330], "mapped", [114]], [[65331, 65331], "mapped", [115]], [[65332, 65332], "mapped", [116]], [[65333, 65333], "mapped", [117]], [[65334, 65334], "mapped", [118]], [[65335, 65335], "mapped", [119]], [[65336, 65336], "mapped", [120]], [[65337, 65337], "mapped", [121]], [[65338, 65338], "mapped", [122]], [[65339, 65339], "disallowed_STD3_mapped", [91]], [[65340, 65340], "disallowed_STD3_mapped", [92]], [[65341, 65341], "disallowed_STD3_mapped", [93]], [[65342, 65342], "disallowed_STD3_mapped", [94]], [[65343, 65343], "disallowed_STD3_mapped", [95]], [[65344, 65344], "disallowed_STD3_mapped", [96]], [[65345, 65345], "mapped", [97]], [[65346, 65346], "mapped", [98]], [[65347, 65347], "mapped", [99]], [[65348, 65348], "mapped", [100]], [[65349, 65349], "mapped", [101]], [[65350, 65350], "mapped", [102]], [[65351, 65351], "mapped", [103]], [[65352, 65352], "mapped", [104]], [[65353, 65353], "mapped", [105]], [[65354, 65354], "mapped", [106]], [[65355, 65355], "mapped", [107]], [[65356, 65356], "mapped", [108]], [[65357, 65357], "mapped", [109]], [[65358, 65358], "mapped", [110]], [[65359, 65359], "mapped", [111]], [[65360, 65360], "mapped", [112]], [[65361, 65361], "mapped", [113]], [[65362, 65362], "mapped", [114]], [[65363, 65363], "mapped", [115]], [[65364, 65364], "mapped", [116]], [[65365, 65365], "mapped", [117]], [[65366, 65366], "mapped", [118]], [[65367, 65367], "mapped", [119]], [[65368, 65368], "mapped", [120]], [[65369, 65369], "mapped", [121]], [[65370, 65370], "mapped", [122]], [[65371, 65371], "disallowed_STD3_mapped", [123]], [[65372, 65372], "disallowed_STD3_mapped", [124]], [[65373, 65373], "disallowed_STD3_mapped", [125]], [[65374, 65374], "disallowed_STD3_mapped", [126]], [[65375, 65375], "mapped", [10629]], [[65376, 65376], "mapped", [10630]], [[65377, 65377], "mapped", [46]], [[65378, 65378], "mapped", [12300]], [[65379, 65379], "mapped", [12301]], [[65380, 65380], "mapped", [12289]], [[65381, 65381], "mapped", [12539]], [[65382, 65382], "mapped", [12530]], [[65383, 65383], "mapped", [12449]], [[65384, 65384], "mapped", [12451]], [[65385, 65385], "mapped", [12453]], [[65386, 65386], "mapped", [12455]], [[65387, 65387], "mapped", [12457]], [[65388, 65388], "mapped", [12515]], [[65389, 65389], "mapped", [12517]], [[65390, 65390], "mapped", [12519]], [[65391, 65391], "mapped", [12483]], [[65392, 65392], "mapped", [12540]], [[65393, 65393], "mapped", [12450]], [[65394, 65394], "mapped", [12452]], [[65395, 65395], "mapped", [12454]], [[65396, 65396], "mapped", [12456]], [[65397, 65397], "mapped", [12458]], [[65398, 65398], "mapped", [12459]], [[65399, 65399], "mapped", [12461]], [[65400, 65400], "mapped", [12463]], [[65401, 65401], "mapped", [12465]], [[65402, 65402], "mapped", [12467]], [[65403, 65403], "mapped", [12469]], [[65404, 65404], "mapped", [12471]], [[65405, 65405], "mapped", [12473]], [[65406, 65406], "mapped", [12475]], [[65407, 65407], "mapped", [12477]], [[65408, 65408], "mapped", [12479]], [[65409, 65409], "mapped", [12481]], [[65410, 65410], "mapped", [12484]], [[65411, 65411], "mapped", [12486]], [[65412, 65412], "mapped", [12488]], [[65413, 65413], "mapped", [12490]], [[65414, 65414], "mapped", [12491]], [[65415, 65415], "mapped", [12492]], [[65416, 65416], "mapped", [12493]], [[65417, 65417], "mapped", [12494]], [[65418, 65418], "mapped", [12495]], [[65419, 65419], "mapped", [12498]], [[65420, 65420], "mapped", [12501]], [[65421, 65421], "mapped", [12504]], [[65422, 65422], "mapped", [12507]], [[65423, 65423], "mapped", [12510]], [[65424, 65424], "mapped", [12511]], [[65425, 65425], "mapped", [12512]], [[65426, 65426], "mapped", [12513]], [[65427, 65427], "mapped", [12514]], [[65428, 65428], "mapped", [12516]], [[65429, 65429], "mapped", [12518]], [[65430, 65430], "mapped", [12520]], [[65431, 65431], "mapped", [12521]], [[65432, 65432], "mapped", [12522]], [[65433, 65433], "mapped", [12523]], [[65434, 65434], "mapped", [12524]], [[65435, 65435], "mapped", [12525]], [[65436, 65436], "mapped", [12527]], [[65437, 65437], "mapped", [12531]], [[65438, 65438], "mapped", [12441]], [[65439, 65439], "mapped", [12442]], [[65440, 65440], "disallowed"], [[65441, 65441], "mapped", [4352]], [[65442, 65442], "mapped", [4353]], [[65443, 65443], "mapped", [4522]], [[65444, 65444], "mapped", [4354]], [[65445, 65445], "mapped", [4524]], [[65446, 65446], "mapped", [4525]], [[65447, 65447], "mapped", [4355]], [[65448, 65448], "mapped", [4356]], [[65449, 65449], "mapped", [4357]], [[65450, 65450], "mapped", [4528]], [[65451, 65451], "mapped", [4529]], [[65452, 65452], "mapped", [4530]], [[65453, 65453], "mapped", [4531]], [[65454, 65454], "mapped", [4532]], [[65455, 65455], "mapped", [4533]], [[65456, 65456], "mapped", [4378]], [[65457, 65457], "mapped", [4358]], [[65458, 65458], "mapped", [4359]], [[65459, 65459], "mapped", [4360]], [[65460, 65460], "mapped", [4385]], [[65461, 65461], "mapped", [4361]], [[65462, 65462], "mapped", [4362]], [[65463, 65463], "mapped", [4363]], [[65464, 65464], "mapped", [4364]], [[65465, 65465], "mapped", [4365]], [[65466, 65466], "mapped", [4366]], [[65467, 65467], "mapped", [4367]], [[65468, 65468], "mapped", [4368]], [[65469, 65469], "mapped", [4369]], [[65470, 65470], "mapped", [4370]], [[65471, 65473], "disallowed"], [[65474, 65474], "mapped", [4449]], [[65475, 65475], "mapped", [4450]], [[65476, 65476], "mapped", [4451]], [[65477, 65477], "mapped", [4452]], [[65478, 65478], "mapped", [4453]], [[65479, 65479], "mapped", [4454]], [[65480, 65481], "disallowed"], [[65482, 65482], "mapped", [4455]], [[65483, 65483], "mapped", [4456]], [[65484, 65484], "mapped", [4457]], [[65485, 65485], "mapped", [4458]], [[65486, 65486], "mapped", [4459]], [[65487, 65487], "mapped", [4460]], [[65488, 65489], "disallowed"], [[65490, 65490], "mapped", [4461]], [[65491, 65491], "mapped", [4462]], [[65492, 65492], "mapped", [4463]], [[65493, 65493], "mapped", [4464]], [[65494, 65494], "mapped", [4465]], [[65495, 65495], "mapped", [4466]], [[65496, 65497], "disallowed"], [[65498, 65498], "mapped", [4467]], [[65499, 65499], "mapped", [4468]], [[65500, 65500], "mapped", [4469]], [[65501, 65503], "disallowed"], [[65504, 65504], "mapped", [162]], [[65505, 65505], "mapped", [163]], [[65506, 65506], "mapped", [172]], [[65507, 65507], "disallowed_STD3_mapped", [32, 772]], [[65508, 65508], "mapped", [166]], [[65509, 65509], "mapped", [165]], [[65510, 65510], "mapped", [8361]], [[65511, 65511], "disallowed"], [[65512, 65512], "mapped", [9474]], [[65513, 65513], "mapped", [8592]], [[65514, 65514], "mapped", [8593]], [[65515, 65515], "mapped", [8594]], [[65516, 65516], "mapped", [8595]], [[65517, 65517], "mapped", [9632]], [[65518, 65518], "mapped", [9675]], [[65519, 65528], "disallowed"], [[65529, 65531], "disallowed"], [[65532, 65532], "disallowed"], [[65533, 65533], "disallowed"], [[65534, 65535], "disallowed"], [[65536, 65547], "valid"], [[65548, 65548], "disallowed"], [[65549, 65574], "valid"], [[65575, 65575], "disallowed"], [[65576, 65594], "valid"], [[65595, 65595], "disallowed"], [[65596, 65597], "valid"], [[65598, 65598], "disallowed"], [[65599, 65613], "valid"], [[65614, 65615], "disallowed"], [[65616, 65629], "valid"], [[65630, 65663], "disallowed"], [[65664, 65786], "valid"], [[65787, 65791], "disallowed"], [[65792, 65794], "valid", [], "NV8"], [[65795, 65798], "disallowed"], [[65799, 65843], "valid", [], "NV8"], [[65844, 65846], "disallowed"], [[65847, 65855], "valid", [], "NV8"], [[65856, 65930], "valid", [], "NV8"], [[65931, 65932], "valid", [], "NV8"], [[65933, 65935], "disallowed"], [[65936, 65947], "valid", [], "NV8"], [[65948, 65951], "disallowed"], [[65952, 65952], "valid", [], "NV8"], [[65953, 65999], "disallowed"], [[66e3, 66044], "valid", [], "NV8"], [[66045, 66045], "valid"], [[66046, 66175], "disallowed"], [[66176, 66204], "valid"], [[66205, 66207], "disallowed"], [[66208, 66256], "valid"], [[66257, 66271], "disallowed"], [[66272, 66272], "valid"], [[66273, 66299], "valid", [], "NV8"], [[66300, 66303], "disallowed"], [[66304, 66334], "valid"], [[66335, 66335], "valid"], [[66336, 66339], "valid", [], "NV8"], [[66340, 66351], "disallowed"], [[66352, 66368], "valid"], [[66369, 66369], "valid", [], "NV8"], [[66370, 66377], "valid"], [[66378, 66378], "valid", [], "NV8"], [[66379, 66383], "disallowed"], [[66384, 66426], "valid"], [[66427, 66431], "disallowed"], [[66432, 66461], "valid"], [[66462, 66462], "disallowed"], [[66463, 66463], "valid", [], "NV8"], [[66464, 66499], "valid"], [[66500, 66503], "disallowed"], [[66504, 66511], "valid"], [[66512, 66517], "valid", [], "NV8"], [[66518, 66559], "disallowed"], [[66560, 66560], "mapped", [66600]], [[66561, 66561], "mapped", [66601]], [[66562, 66562], "mapped", [66602]], [[66563, 66563], "mapped", [66603]], [[66564, 66564], "mapped", [66604]], [[66565, 66565], "mapped", [66605]], [[66566, 66566], "mapped", [66606]], [[66567, 66567], "mapped", [66607]], [[66568, 66568], "mapped", [66608]], [[66569, 66569], "mapped", [66609]], [[66570, 66570], "mapped", [66610]], [[66571, 66571], "mapped", [66611]], [[66572, 66572], "mapped", [66612]], [[66573, 66573], "mapped", [66613]], [[66574, 66574], "mapped", [66614]], [[66575, 66575], "mapped", [66615]], [[66576, 66576], "mapped", [66616]], [[66577, 66577], "mapped", [66617]], [[66578, 66578], "mapped", [66618]], [[66579, 66579], "mapped", [66619]], [[66580, 66580], "mapped", [66620]], [[66581, 66581], "mapped", [66621]], [[66582, 66582], "mapped", [66622]], [[66583, 66583], "mapped", [66623]], [[66584, 66584], "mapped", [66624]], [[66585, 66585], "mapped", [66625]], [[66586, 66586], "mapped", [66626]], [[66587, 66587], "mapped", [66627]], [[66588, 66588], "mapped", [66628]], [[66589, 66589], "mapped", [66629]], [[66590, 66590], "mapped", [66630]], [[66591, 66591], "mapped", [66631]], [[66592, 66592], "mapped", [66632]], [[66593, 66593], "mapped", [66633]], [[66594, 66594], "mapped", [66634]], [[66595, 66595], "mapped", [66635]], [[66596, 66596], "mapped", [66636]], [[66597, 66597], "mapped", [66637]], [[66598, 66598], "mapped", [66638]], [[66599, 66599], "mapped", [66639]], [[66600, 66637], "valid"], [[66638, 66717], "valid"], [[66718, 66719], "disallowed"], [[66720, 66729], "valid"], [[66730, 66815], "disallowed"], [[66816, 66855], "valid"], [[66856, 66863], "disallowed"], [[66864, 66915], "valid"], [[66916, 66926], "disallowed"], [[66927, 66927], "valid", [], "NV8"], [[66928, 67071], "disallowed"], [[67072, 67382], "valid"], [[67383, 67391], "disallowed"], [[67392, 67413], "valid"], [[67414, 67423], "disallowed"], [[67424, 67431], "valid"], [[67432, 67583], "disallowed"], [[67584, 67589], "valid"], [[67590, 67591], "disallowed"], [[67592, 67592], "valid"], [[67593, 67593], "disallowed"], [[67594, 67637], "valid"], [[67638, 67638], "disallowed"], [[67639, 67640], "valid"], [[67641, 67643], "disallowed"], [[67644, 67644], "valid"], [[67645, 67646], "disallowed"], [[67647, 67647], "valid"], [[67648, 67669], "valid"], [[67670, 67670], "disallowed"], [[67671, 67679], "valid", [], "NV8"], [[67680, 67702], "valid"], [[67703, 67711], "valid", [], "NV8"], [[67712, 67742], "valid"], [[67743, 67750], "disallowed"], [[67751, 67759], "valid", [], "NV8"], [[67760, 67807], "disallowed"], [[67808, 67826], "valid"], [[67827, 67827], "disallowed"], [[67828, 67829], "valid"], [[67830, 67834], "disallowed"], [[67835, 67839], "valid", [], "NV8"], [[67840, 67861], "valid"], [[67862, 67865], "valid", [], "NV8"], [[67866, 67867], "valid", [], "NV8"], [[67868, 67870], "disallowed"], [[67871, 67871], "valid", [], "NV8"], [[67872, 67897], "valid"], [[67898, 67902], "disallowed"], [[67903, 67903], "valid", [], "NV8"], [[67904, 67967], "disallowed"], [[67968, 68023], "valid"], [[68024, 68027], "disallowed"], [[68028, 68029], "valid", [], "NV8"], [[68030, 68031], "valid"], [[68032, 68047], "valid", [], "NV8"], [[68048, 68049], "disallowed"], [[68050, 68095], "valid", [], "NV8"], [[68096, 68099], "valid"], [[68100, 68100], "disallowed"], [[68101, 68102], "valid"], [[68103, 68107], "disallowed"], [[68108, 68115], "valid"], [[68116, 68116], "disallowed"], [[68117, 68119], "valid"], [[68120, 68120], "disallowed"], [[68121, 68147], "valid"], [[68148, 68151], "disallowed"], [[68152, 68154], "valid"], [[68155, 68158], "disallowed"], [[68159, 68159], "valid"], [[68160, 68167], "valid", [], "NV8"], [[68168, 68175], "disallowed"], [[68176, 68184], "valid", [], "NV8"], [[68185, 68191], "disallowed"], [[68192, 68220], "valid"], [[68221, 68223], "valid", [], "NV8"], [[68224, 68252], "valid"], [[68253, 68255], "valid", [], "NV8"], [[68256, 68287], "disallowed"], [[68288, 68295], "valid"], [[68296, 68296], "valid", [], "NV8"], [[68297, 68326], "valid"], [[68327, 68330], "disallowed"], [[68331, 68342], "valid", [], "NV8"], [[68343, 68351], "disallowed"], [[68352, 68405], "valid"], [[68406, 68408], "disallowed"], [[68409, 68415], "valid", [], "NV8"], [[68416, 68437], "valid"], [[68438, 68439], "disallowed"], [[68440, 68447], "valid", [], "NV8"], [[68448, 68466], "valid"], [[68467, 68471], "disallowed"], [[68472, 68479], "valid", [], "NV8"], [[68480, 68497], "valid"], [[68498, 68504], "disallowed"], [[68505, 68508], "valid", [], "NV8"], [[68509, 68520], "disallowed"], [[68521, 68527], "valid", [], "NV8"], [[68528, 68607], "disallowed"], [[68608, 68680], "valid"], [[68681, 68735], "disallowed"], [[68736, 68736], "mapped", [68800]], [[68737, 68737], "mapped", [68801]], [[68738, 68738], "mapped", [68802]], [[68739, 68739], "mapped", [68803]], [[68740, 68740], "mapped", [68804]], [[68741, 68741], "mapped", [68805]], [[68742, 68742], "mapped", [68806]], [[68743, 68743], "mapped", [68807]], [[68744, 68744], "mapped", [68808]], [[68745, 68745], "mapped", [68809]], [[68746, 68746], "mapped", [68810]], [[68747, 68747], "mapped", [68811]], [[68748, 68748], "mapped", [68812]], [[68749, 68749], "mapped", [68813]], [[68750, 68750], "mapped", [68814]], [[68751, 68751], "mapped", [68815]], [[68752, 68752], "mapped", [68816]], [[68753, 68753], "mapped", [68817]], [[68754, 68754], "mapped", [68818]], [[68755, 68755], "mapped", [68819]], [[68756, 68756], "mapped", [68820]], [[68757, 68757], "mapped", [68821]], [[68758, 68758], "mapped", [68822]], [[68759, 68759], "mapped", [68823]], [[68760, 68760], "mapped", [68824]], [[68761, 68761], "mapped", [68825]], [[68762, 68762], "mapped", [68826]], [[68763, 68763], "mapped", [68827]], [[68764, 68764], "mapped", [68828]], [[68765, 68765], "mapped", [68829]], [[68766, 68766], "mapped", [68830]], [[68767, 68767], "mapped", [68831]], [[68768, 68768], "mapped", [68832]], [[68769, 68769], "mapped", [68833]], [[68770, 68770], "mapped", [68834]], [[68771, 68771], "mapped", [68835]], [[68772, 68772], "mapped", [68836]], [[68773, 68773], "mapped", [68837]], [[68774, 68774], "mapped", [68838]], [[68775, 68775], "mapped", [68839]], [[68776, 68776], "mapped", [68840]], [[68777, 68777], "mapped", [68841]], [[68778, 68778], "mapped", [68842]], [[68779, 68779], "mapped", [68843]], [[68780, 68780], "mapped", [68844]], [[68781, 68781], "mapped", [68845]], [[68782, 68782], "mapped", [68846]], [[68783, 68783], "mapped", [68847]], [[68784, 68784], "mapped", [68848]], [[68785, 68785], "mapped", [68849]], [[68786, 68786], "mapped", [68850]], [[68787, 68799], "disallowed"], [[68800, 68850], "valid"], [[68851, 68857], "disallowed"], [[68858, 68863], "valid", [], "NV8"], [[68864, 69215], "disallowed"], [[69216, 69246], "valid", [], "NV8"], [[69247, 69631], "disallowed"], [[69632, 69702], "valid"], [[69703, 69709], "valid", [], "NV8"], [[69710, 69713], "disallowed"], [[69714, 69733], "valid", [], "NV8"], [[69734, 69743], "valid"], [[69744, 69758], "disallowed"], [[69759, 69759], "valid"], [[69760, 69818], "valid"], [[69819, 69820], "valid", [], "NV8"], [[69821, 69821], "disallowed"], [[69822, 69825], "valid", [], "NV8"], [[69826, 69839], "disallowed"], [[69840, 69864], "valid"], [[69865, 69871], "disallowed"], [[69872, 69881], "valid"], [[69882, 69887], "disallowed"], [[69888, 69940], "valid"], [[69941, 69941], "disallowed"], [[69942, 69951], "valid"], [[69952, 69955], "valid", [], "NV8"], [[69956, 69967], "disallowed"], [[69968, 70003], "valid"], [[70004, 70005], "valid", [], "NV8"], [[70006, 70006], "valid"], [[70007, 70015], "disallowed"], [[70016, 70084], "valid"], [[70085, 70088], "valid", [], "NV8"], [[70089, 70089], "valid", [], "NV8"], [[70090, 70092], "valid"], [[70093, 70093], "valid", [], "NV8"], [[70094, 70095], "disallowed"], [[70096, 70105], "valid"], [[70106, 70106], "valid"], [[70107, 70107], "valid", [], "NV8"], [[70108, 70108], "valid"], [[70109, 70111], "valid", [], "NV8"], [[70112, 70112], "disallowed"], [[70113, 70132], "valid", [], "NV8"], [[70133, 70143], "disallowed"], [[70144, 70161], "valid"], [[70162, 70162], "disallowed"], [[70163, 70199], "valid"], [[70200, 70205], "valid", [], "NV8"], [[70206, 70271], "disallowed"], [[70272, 70278], "valid"], [[70279, 70279], "disallowed"], [[70280, 70280], "valid"], [[70281, 70281], "disallowed"], [[70282, 70285], "valid"], [[70286, 70286], "disallowed"], [[70287, 70301], "valid"], [[70302, 70302], "disallowed"], [[70303, 70312], "valid"], [[70313, 70313], "valid", [], "NV8"], [[70314, 70319], "disallowed"], [[70320, 70378], "valid"], [[70379, 70383], "disallowed"], [[70384, 70393], "valid"], [[70394, 70399], "disallowed"], [[70400, 70400], "valid"], [[70401, 70403], "valid"], [[70404, 70404], "disallowed"], [[70405, 70412], "valid"], [[70413, 70414], "disallowed"], [[70415, 70416], "valid"], [[70417, 70418], "disallowed"], [[70419, 70440], "valid"], [[70441, 70441], "disallowed"], [[70442, 70448], "valid"], [[70449, 70449], "disallowed"], [[70450, 70451], "valid"], [[70452, 70452], "disallowed"], [[70453, 70457], "valid"], [[70458, 70459], "disallowed"], [[70460, 70468], "valid"], [[70469, 70470], "disallowed"], [[70471, 70472], "valid"], [[70473, 70474], "disallowed"], [[70475, 70477], "valid"], [[70478, 70479], "disallowed"], [[70480, 70480], "valid"], [[70481, 70486], "disallowed"], [[70487, 70487], "valid"], [[70488, 70492], "disallowed"], [[70493, 70499], "valid"], [[70500, 70501], "disallowed"], [[70502, 70508], "valid"], [[70509, 70511], "disallowed"], [[70512, 70516], "valid"], [[70517, 70783], "disallowed"], [[70784, 70853], "valid"], [[70854, 70854], "valid", [], "NV8"], [[70855, 70855], "valid"], [[70856, 70863], "disallowed"], [[70864, 70873], "valid"], [[70874, 71039], "disallowed"], [[71040, 71093], "valid"], [[71094, 71095], "disallowed"], [[71096, 71104], "valid"], [[71105, 71113], "valid", [], "NV8"], [[71114, 71127], "valid", [], "NV8"], [[71128, 71133], "valid"], [[71134, 71167], "disallowed"], [[71168, 71232], "valid"], [[71233, 71235], "valid", [], "NV8"], [[71236, 71236], "valid"], [[71237, 71247], "disallowed"], [[71248, 71257], "valid"], [[71258, 71295], "disallowed"], [[71296, 71351], "valid"], [[71352, 71359], "disallowed"], [[71360, 71369], "valid"], [[71370, 71423], "disallowed"], [[71424, 71449], "valid"], [[71450, 71452], "disallowed"], [[71453, 71467], "valid"], [[71468, 71471], "disallowed"], [[71472, 71481], "valid"], [[71482, 71487], "valid", [], "NV8"], [[71488, 71839], "disallowed"], [[71840, 71840], "mapped", [71872]], [[71841, 71841], "mapped", [71873]], [[71842, 71842], "mapped", [71874]], [[71843, 71843], "mapped", [71875]], [[71844, 71844], "mapped", [71876]], [[71845, 71845], "mapped", [71877]], [[71846, 71846], "mapped", [71878]], [[71847, 71847], "mapped", [71879]], [[71848, 71848], "mapped", [71880]], [[71849, 71849], "mapped", [71881]], [[71850, 71850], "mapped", [71882]], [[71851, 71851], "mapped", [71883]], [[71852, 71852], "mapped", [71884]], [[71853, 71853], "mapped", [71885]], [[71854, 71854], "mapped", [71886]], [[71855, 71855], "mapped", [71887]], [[71856, 71856], "mapped", [71888]], [[71857, 71857], "mapped", [71889]], [[71858, 71858], "mapped", [71890]], [[71859, 71859], "mapped", [71891]], [[71860, 71860], "mapped", [71892]], [[71861, 71861], "mapped", [71893]], [[71862, 71862], "mapped", [71894]], [[71863, 71863], "mapped", [71895]], [[71864, 71864], "mapped", [71896]], [[71865, 71865], "mapped", [71897]], [[71866, 71866], "mapped", [71898]], [[71867, 71867], "mapped", [71899]], [[71868, 71868], "mapped", [71900]], [[71869, 71869], "mapped", [71901]], [[71870, 71870], "mapped", [71902]], [[71871, 71871], "mapped", [71903]], [[71872, 71913], "valid"], [[71914, 71922], "valid", [], "NV8"], [[71923, 71934], "disallowed"], [[71935, 71935], "valid"], [[71936, 72383], "disallowed"], [[72384, 72440], "valid"], [[72441, 73727], "disallowed"], [[73728, 74606], "valid"], [[74607, 74648], "valid"], [[74649, 74649], "valid"], [[74650, 74751], "disallowed"], [[74752, 74850], "valid", [], "NV8"], [[74851, 74862], "valid", [], "NV8"], [[74863, 74863], "disallowed"], [[74864, 74867], "valid", [], "NV8"], [[74868, 74868], "valid", [], "NV8"], [[74869, 74879], "disallowed"], [[74880, 75075], "valid"], [[75076, 77823], "disallowed"], [[77824, 78894], "valid"], [[78895, 82943], "disallowed"], [[82944, 83526], "valid"], [[83527, 92159], "disallowed"], [[92160, 92728], "valid"], [[92729, 92735], "disallowed"], [[92736, 92766], "valid"], [[92767, 92767], "disallowed"], [[92768, 92777], "valid"], [[92778, 92781], "disallowed"], [[92782, 92783], "valid", [], "NV8"], [[92784, 92879], "disallowed"], [[92880, 92909], "valid"], [[92910, 92911], "disallowed"], [[92912, 92916], "valid"], [[92917, 92917], "valid", [], "NV8"], [[92918, 92927], "disallowed"], [[92928, 92982], "valid"], [[92983, 92991], "valid", [], "NV8"], [[92992, 92995], "valid"], [[92996, 92997], "valid", [], "NV8"], [[92998, 93007], "disallowed"], [[93008, 93017], "valid"], [[93018, 93018], "disallowed"], [[93019, 93025], "valid", [], "NV8"], [[93026, 93026], "disallowed"], [[93027, 93047], "valid"], [[93048, 93052], "disallowed"], [[93053, 93071], "valid"], [[93072, 93951], "disallowed"], [[93952, 94020], "valid"], [[94021, 94031], "disallowed"], [[94032, 94078], "valid"], [[94079, 94094], "disallowed"], [[94095, 94111], "valid"], [[94112, 110591], "disallowed"], [[110592, 110593], "valid"], [[110594, 113663], "disallowed"], [[113664, 113770], "valid"], [[113771, 113775], "disallowed"], [[113776, 113788], "valid"], [[113789, 113791], "disallowed"], [[113792, 113800], "valid"], [[113801, 113807], "disallowed"], [[113808, 113817], "valid"], [[113818, 113819], "disallowed"], [[113820, 113820], "valid", [], "NV8"], [[113821, 113822], "valid"], [[113823, 113823], "valid", [], "NV8"], [[113824, 113827], "ignored"], [[113828, 118783], "disallowed"], [[118784, 119029], "valid", [], "NV8"], [[119030, 119039], "disallowed"], [[119040, 119078], "valid", [], "NV8"], [[119079, 119080], "disallowed"], [[119081, 119081], "valid", [], "NV8"], [[119082, 119133], "valid", [], "NV8"], [[119134, 119134], "mapped", [119127, 119141]], [[119135, 119135], "mapped", [119128, 119141]], [[119136, 119136], "mapped", [119128, 119141, 119150]], [[119137, 119137], "mapped", [119128, 119141, 119151]], [[119138, 119138], "mapped", [119128, 119141, 119152]], [[119139, 119139], "mapped", [119128, 119141, 119153]], [[119140, 119140], "mapped", [119128, 119141, 119154]], [[119141, 119154], "valid", [], "NV8"], [[119155, 119162], "disallowed"], [[119163, 119226], "valid", [], "NV8"], [[119227, 119227], "mapped", [119225, 119141]], [[119228, 119228], "mapped", [119226, 119141]], [[119229, 119229], "mapped", [119225, 119141, 119150]], [[119230, 119230], "mapped", [119226, 119141, 119150]], [[119231, 119231], "mapped", [119225, 119141, 119151]], [[119232, 119232], "mapped", [119226, 119141, 119151]], [[119233, 119261], "valid", [], "NV8"], [[119262, 119272], "valid", [], "NV8"], [[119273, 119295], "disallowed"], [[119296, 119365], "valid", [], "NV8"], [[119366, 119551], "disallowed"], [[119552, 119638], "valid", [], "NV8"], [[119639, 119647], "disallowed"], [[119648, 119665], "valid", [], "NV8"], [[119666, 119807], "disallowed"], [[119808, 119808], "mapped", [97]], [[119809, 119809], "mapped", [98]], [[119810, 119810], "mapped", [99]], [[119811, 119811], "mapped", [100]], [[119812, 119812], "mapped", [101]], [[119813, 119813], "mapped", [102]], [[119814, 119814], "mapped", [103]], [[119815, 119815], "mapped", [104]], [[119816, 119816], "mapped", [105]], [[119817, 119817], "mapped", [106]], [[119818, 119818], "mapped", [107]], [[119819, 119819], "mapped", [108]], [[119820, 119820], "mapped", [109]], [[119821, 119821], "mapped", [110]], [[119822, 119822], "mapped", [111]], [[119823, 119823], "mapped", [112]], [[119824, 119824], "mapped", [113]], [[119825, 119825], "mapped", [114]], [[119826, 119826], "mapped", [115]], [[119827, 119827], "mapped", [116]], [[119828, 119828], "mapped", [117]], [[119829, 119829], "mapped", [118]], [[119830, 119830], "mapped", [119]], [[119831, 119831], "mapped", [120]], [[119832, 119832], "mapped", [121]], [[119833, 119833], "mapped", [122]], [[119834, 119834], "mapped", [97]], [[119835, 119835], "mapped", [98]], [[119836, 119836], "mapped", [99]], [[119837, 119837], "mapped", [100]], [[119838, 119838], "mapped", [101]], [[119839, 119839], "mapped", [102]], [[119840, 119840], "mapped", [103]], [[119841, 119841], "mapped", [104]], [[119842, 119842], "mapped", [105]], [[119843, 119843], "mapped", [106]], [[119844, 119844], "mapped", [107]], [[119845, 119845], "mapped", [108]], [[119846, 119846], "mapped", [109]], [[119847, 119847], "mapped", [110]], [[119848, 119848], "mapped", [111]], [[119849, 119849], "mapped", [112]], [[119850, 119850], "mapped", [113]], [[119851, 119851], "mapped", [114]], [[119852, 119852], "mapped", [115]], [[119853, 119853], "mapped", [116]], [[119854, 119854], "mapped", [117]], [[119855, 119855], "mapped", [118]], [[119856, 119856], "mapped", [119]], [[119857, 119857], "mapped", [120]], [[119858, 119858], "mapped", [121]], [[119859, 119859], "mapped", [122]], [[119860, 119860], "mapped", [97]], [[119861, 119861], "mapped", [98]], [[119862, 119862], "mapped", [99]], [[119863, 119863], "mapped", [100]], [[119864, 119864], "mapped", [101]], [[119865, 119865], "mapped", [102]], [[119866, 119866], "mapped", [103]], [[119867, 119867], "mapped", [104]], [[119868, 119868], "mapped", [105]], [[119869, 119869], "mapped", [106]], [[119870, 119870], "mapped", [107]], [[119871, 119871], "mapped", [108]], [[119872, 119872], "mapped", [109]], [[119873, 119873], "mapped", [110]], [[119874, 119874], "mapped", [111]], [[119875, 119875], "mapped", [112]], [[119876, 119876], "mapped", [113]], [[119877, 119877], "mapped", [114]], [[119878, 119878], "mapped", [115]], [[119879, 119879], "mapped", [116]], [[119880, 119880], "mapped", [117]], [[119881, 119881], "mapped", [118]], [[119882, 119882], "mapped", [119]], [[119883, 119883], "mapped", [120]], [[119884, 119884], "mapped", [121]], [[119885, 119885], "mapped", [122]], [[119886, 119886], "mapped", [97]], [[119887, 119887], "mapped", [98]], [[119888, 119888], "mapped", [99]], [[119889, 119889], "mapped", [100]], [[119890, 119890], "mapped", [101]], [[119891, 119891], "mapped", [102]], [[119892, 119892], "mapped", [103]], [[119893, 119893], "disallowed"], [[119894, 119894], "mapped", [105]], [[119895, 119895], "mapped", [106]], [[119896, 119896], "mapped", [107]], [[119897, 119897], "mapped", [108]], [[119898, 119898], "mapped", [109]], [[119899, 119899], "mapped", [110]], [[119900, 119900], "mapped", [111]], [[119901, 119901], "mapped", [112]], [[119902, 119902], "mapped", [113]], [[119903, 119903], "mapped", [114]], [[119904, 119904], "mapped", [115]], [[119905, 119905], "mapped", [116]], [[119906, 119906], "mapped", [117]], [[119907, 119907], "mapped", [118]], [[119908, 119908], "mapped", [119]], [[119909, 119909], "mapped", [120]], [[119910, 119910], "mapped", [121]], [[119911, 119911], "mapped", [122]], [[119912, 119912], "mapped", [97]], [[119913, 119913], "mapped", [98]], [[119914, 119914], "mapped", [99]], [[119915, 119915], "mapped", [100]], [[119916, 119916], "mapped", [101]], [[119917, 119917], "mapped", [102]], [[119918, 119918], "mapped", [103]], [[119919, 119919], "mapped", [104]], [[119920, 119920], "mapped", [105]], [[119921, 119921], "mapped", [106]], [[119922, 119922], "mapped", [107]], [[119923, 119923], "mapped", [108]], [[119924, 119924], "mapped", [109]], [[119925, 119925], "mapped", [110]], [[119926, 119926], "mapped", [111]], [[119927, 119927], "mapped", [112]], [[119928, 119928], "mapped", [113]], [[119929, 119929], "mapped", [114]], [[119930, 119930], "mapped", [115]], [[119931, 119931], "mapped", [116]], [[119932, 119932], "mapped", [117]], [[119933, 119933], "mapped", [118]], [[119934, 119934], "mapped", [119]], [[119935, 119935], "mapped", [120]], [[119936, 119936], "mapped", [121]], [[119937, 119937], "mapped", [122]], [[119938, 119938], "mapped", [97]], [[119939, 119939], "mapped", [98]], [[119940, 119940], "mapped", [99]], [[119941, 119941], "mapped", [100]], [[119942, 119942], "mapped", [101]], [[119943, 119943], "mapped", [102]], [[119944, 119944], "mapped", [103]], [[119945, 119945], "mapped", [104]], [[119946, 119946], "mapped", [105]], [[119947, 119947], "mapped", [106]], [[119948, 119948], "mapped", [107]], [[119949, 119949], "mapped", [108]], [[119950, 119950], "mapped", [109]], [[119951, 119951], "mapped", [110]], [[119952, 119952], "mapped", [111]], [[119953, 119953], "mapped", [112]], [[119954, 119954], "mapped", [113]], [[119955, 119955], "mapped", [114]], [[119956, 119956], "mapped", [115]], [[119957, 119957], "mapped", [116]], [[119958, 119958], "mapped", [117]], [[119959, 119959], "mapped", [118]], [[119960, 119960], "mapped", [119]], [[119961, 119961], "mapped", [120]], [[119962, 119962], "mapped", [121]], [[119963, 119963], "mapped", [122]], [[119964, 119964], "mapped", [97]], [[119965, 119965], "disallowed"], [[119966, 119966], "mapped", [99]], [[119967, 119967], "mapped", [100]], [[119968, 119969], "disallowed"], [[119970, 119970], "mapped", [103]], [[119971, 119972], "disallowed"], [[119973, 119973], "mapped", [106]], [[119974, 119974], "mapped", [107]], [[119975, 119976], "disallowed"], [[119977, 119977], "mapped", [110]], [[119978, 119978], "mapped", [111]], [[119979, 119979], "mapped", [112]], [[119980, 119980], "mapped", [113]], [[119981, 119981], "disallowed"], [[119982, 119982], "mapped", [115]], [[119983, 119983], "mapped", [116]], [[119984, 119984], "mapped", [117]], [[119985, 119985], "mapped", [118]], [[119986, 119986], "mapped", [119]], [[119987, 119987], "mapped", [120]], [[119988, 119988], "mapped", [121]], [[119989, 119989], "mapped", [122]], [[119990, 119990], "mapped", [97]], [[119991, 119991], "mapped", [98]], [[119992, 119992], "mapped", [99]], [[119993, 119993], "mapped", [100]], [[119994, 119994], "disallowed"], [[119995, 119995], "mapped", [102]], [[119996, 119996], "disallowed"], [[119997, 119997], "mapped", [104]], [[119998, 119998], "mapped", [105]], [[119999, 119999], "mapped", [106]], [[12e4, 12e4], "mapped", [107]], [[120001, 120001], "mapped", [108]], [[120002, 120002], "mapped", [109]], [[120003, 120003], "mapped", [110]], [[120004, 120004], "disallowed"], [[120005, 120005], "mapped", [112]], [[120006, 120006], "mapped", [113]], [[120007, 120007], "mapped", [114]], [[120008, 120008], "mapped", [115]], [[120009, 120009], "mapped", [116]], [[120010, 120010], "mapped", [117]], [[120011, 120011], "mapped", [118]], [[120012, 120012], "mapped", [119]], [[120013, 120013], "mapped", [120]], [[120014, 120014], "mapped", [121]], [[120015, 120015], "mapped", [122]], [[120016, 120016], "mapped", [97]], [[120017, 120017], "mapped", [98]], [[120018, 120018], "mapped", [99]], [[120019, 120019], "mapped", [100]], [[120020, 120020], "mapped", [101]], [[120021, 120021], "mapped", [102]], [[120022, 120022], "mapped", [103]], [[120023, 120023], "mapped", [104]], [[120024, 120024], "mapped", [105]], [[120025, 120025], "mapped", [106]], [[120026, 120026], "mapped", [107]], [[120027, 120027], "mapped", [108]], [[120028, 120028], "mapped", [109]], [[120029, 120029], "mapped", [110]], [[120030, 120030], "mapped", [111]], [[120031, 120031], "mapped", [112]], [[120032, 120032], "mapped", [113]], [[120033, 120033], "mapped", [114]], [[120034, 120034], "mapped", [115]], [[120035, 120035], "mapped", [116]], [[120036, 120036], "mapped", [117]], [[120037, 120037], "mapped", [118]], [[120038, 120038], "mapped", [119]], [[120039, 120039], "mapped", [120]], [[120040, 120040], "mapped", [121]], [[120041, 120041], "mapped", [122]], [[120042, 120042], "mapped", [97]], [[120043, 120043], "mapped", [98]], [[120044, 120044], "mapped", [99]], [[120045, 120045], "mapped", [100]], [[120046, 120046], "mapped", [101]], [[120047, 120047], "mapped", [102]], [[120048, 120048], "mapped", [103]], [[120049, 120049], "mapped", [104]], [[120050, 120050], "mapped", [105]], [[120051, 120051], "mapped", [106]], [[120052, 120052], "mapped", [107]], [[120053, 120053], "mapped", [108]], [[120054, 120054], "mapped", [109]], [[120055, 120055], "mapped", [110]], [[120056, 120056], "mapped", [111]], [[120057, 120057], "mapped", [112]], [[120058, 120058], "mapped", [113]], [[120059, 120059], "mapped", [114]], [[120060, 120060], "mapped", [115]], [[120061, 120061], "mapped", [116]], [[120062, 120062], "mapped", [117]], [[120063, 120063], "mapped", [118]], [[120064, 120064], "mapped", [119]], [[120065, 120065], "mapped", [120]], [[120066, 120066], "mapped", [121]], [[120067, 120067], "mapped", [122]], [[120068, 120068], "mapped", [97]], [[120069, 120069], "mapped", [98]], [[120070, 120070], "disallowed"], [[120071, 120071], "mapped", [100]], [[120072, 120072], "mapped", [101]], [[120073, 120073], "mapped", [102]], [[120074, 120074], "mapped", [103]], [[120075, 120076], "disallowed"], [[120077, 120077], "mapped", [106]], [[120078, 120078], "mapped", [107]], [[120079, 120079], "mapped", [108]], [[120080, 120080], "mapped", [109]], [[120081, 120081], "mapped", [110]], [[120082, 120082], "mapped", [111]], [[120083, 120083], "mapped", [112]], [[120084, 120084], "mapped", [113]], [[120085, 120085], "disallowed"], [[120086, 120086], "mapped", [115]], [[120087, 120087], "mapped", [116]], [[120088, 120088], "mapped", [117]], [[120089, 120089], "mapped", [118]], [[120090, 120090], "mapped", [119]], [[120091, 120091], "mapped", [120]], [[120092, 120092], "mapped", [121]], [[120093, 120093], "disallowed"], [[120094, 120094], "mapped", [97]], [[120095, 120095], "mapped", [98]], [[120096, 120096], "mapped", [99]], [[120097, 120097], "mapped", [100]], [[120098, 120098], "mapped", [101]], [[120099, 120099], "mapped", [102]], [[120100, 120100], "mapped", [103]], [[120101, 120101], "mapped", [104]], [[120102, 120102], "mapped", [105]], [[120103, 120103], "mapped", [106]], [[120104, 120104], "mapped", [107]], [[120105, 120105], "mapped", [108]], [[120106, 120106], "mapped", [109]], [[120107, 120107], "mapped", [110]], [[120108, 120108], "mapped", [111]], [[120109, 120109], "mapped", [112]], [[120110, 120110], "mapped", [113]], [[120111, 120111], "mapped", [114]], [[120112, 120112], "mapped", [115]], [[120113, 120113], "mapped", [116]], [[120114, 120114], "mapped", [117]], [[120115, 120115], "mapped", [118]], [[120116, 120116], "mapped", [119]], [[120117, 120117], "mapped", [120]], [[120118, 120118], "mapped", [121]], [[120119, 120119], "mapped", [122]], [[120120, 120120], "mapped", [97]], [[120121, 120121], "mapped", [98]], [[120122, 120122], "disallowed"], [[120123, 120123], "mapped", [100]], [[120124, 120124], "mapped", [101]], [[120125, 120125], "mapped", [102]], [[120126, 120126], "mapped", [103]], [[120127, 120127], "disallowed"], [[120128, 120128], "mapped", [105]], [[120129, 120129], "mapped", [106]], [[120130, 120130], "mapped", [107]], [[120131, 120131], "mapped", [108]], [[120132, 120132], "mapped", [109]], [[120133, 120133], "disallowed"], [[120134, 120134], "mapped", [111]], [[120135, 120137], "disallowed"], [[120138, 120138], "mapped", [115]], [[120139, 120139], "mapped", [116]], [[120140, 120140], "mapped", [117]], [[120141, 120141], "mapped", [118]], [[120142, 120142], "mapped", [119]], [[120143, 120143], "mapped", [120]], [[120144, 120144], "mapped", [121]], [[120145, 120145], "disallowed"], [[120146, 120146], "mapped", [97]], [[120147, 120147], "mapped", [98]], [[120148, 120148], "mapped", [99]], [[120149, 120149], "mapped", [100]], [[120150, 120150], "mapped", [101]], [[120151, 120151], "mapped", [102]], [[120152, 120152], "mapped", [103]], [[120153, 120153], "mapped", [104]], [[120154, 120154], "mapped", [105]], [[120155, 120155], "mapped", [106]], [[120156, 120156], "mapped", [107]], [[120157, 120157], "mapped", [108]], [[120158, 120158], "mapped", [109]], [[120159, 120159], "mapped", [110]], [[120160, 120160], "mapped", [111]], [[120161, 120161], "mapped", [112]], [[120162, 120162], "mapped", [113]], [[120163, 120163], "mapped", [114]], [[120164, 120164], "mapped", [115]], [[120165, 120165], "mapped", [116]], [[120166, 120166], "mapped", [117]], [[120167, 120167], "mapped", [118]], [[120168, 120168], "mapped", [119]], [[120169, 120169], "mapped", [120]], [[120170, 120170], "mapped", [121]], [[120171, 120171], "mapped", [122]], [[120172, 120172], "mapped", [97]], [[120173, 120173], "mapped", [98]], [[120174, 120174], "mapped", [99]], [[120175, 120175], "mapped", [100]], [[120176, 120176], "mapped", [101]], [[120177, 120177], "mapped", [102]], [[120178, 120178], "mapped", [103]], [[120179, 120179], "mapped", [104]], [[120180, 120180], "mapped", [105]], [[120181, 120181], "mapped", [106]], [[120182, 120182], "mapped", [107]], [[120183, 120183], "mapped", [108]], [[120184, 120184], "mapped", [109]], [[120185, 120185], "mapped", [110]], [[120186, 120186], "mapped", [111]], [[120187, 120187], "mapped", [112]], [[120188, 120188], "mapped", [113]], [[120189, 120189], "mapped", [114]], [[120190, 120190], "mapped", [115]], [[120191, 120191], "mapped", [116]], [[120192, 120192], "mapped", [117]], [[120193, 120193], "mapped", [118]], [[120194, 120194], "mapped", [119]], [[120195, 120195], "mapped", [120]], [[120196, 120196], "mapped", [121]], [[120197, 120197], "mapped", [122]], [[120198, 120198], "mapped", [97]], [[120199, 120199], "mapped", [98]], [[120200, 120200], "mapped", [99]], [[120201, 120201], "mapped", [100]], [[120202, 120202], "mapped", [101]], [[120203, 120203], "mapped", [102]], [[120204, 120204], "mapped", [103]], [[120205, 120205], "mapped", [104]], [[120206, 120206], "mapped", [105]], [[120207, 120207], "mapped", [106]], [[120208, 120208], "mapped", [107]], [[120209, 120209], "mapped", [108]], [[120210, 120210], "mapped", [109]], [[120211, 120211], "mapped", [110]], [[120212, 120212], "mapped", [111]], [[120213, 120213], "mapped", [112]], [[120214, 120214], "mapped", [113]], [[120215, 120215], "mapped", [114]], [[120216, 120216], "mapped", [115]], [[120217, 120217], "mapped", [116]], [[120218, 120218], "mapped", [117]], [[120219, 120219], "mapped", [118]], [[120220, 120220], "mapped", [119]], [[120221, 120221], "mapped", [120]], [[120222, 120222], "mapped", [121]], [[120223, 120223], "mapped", [122]], [[120224, 120224], "mapped", [97]], [[120225, 120225], "mapped", [98]], [[120226, 120226], "mapped", [99]], [[120227, 120227], "mapped", [100]], [[120228, 120228], "mapped", [101]], [[120229, 120229], "mapped", [102]], [[120230, 120230], "mapped", [103]], [[120231, 120231], "mapped", [104]], [[120232, 120232], "mapped", [105]], [[120233, 120233], "mapped", [106]], [[120234, 120234], "mapped", [107]], [[120235, 120235], "mapped", [108]], [[120236, 120236], "mapped", [109]], [[120237, 120237], "mapped", [110]], [[120238, 120238], "mapped", [111]], [[120239, 120239], "mapped", [112]], [[120240, 120240], "mapped", [113]], [[120241, 120241], "mapped", [114]], [[120242, 120242], "mapped", [115]], [[120243, 120243], "mapped", [116]], [[120244, 120244], "mapped", [117]], [[120245, 120245], "mapped", [118]], [[120246, 120246], "mapped", [119]], [[120247, 120247], "mapped", [120]], [[120248, 120248], "mapped", [121]], [[120249, 120249], "mapped", [122]], [[120250, 120250], "mapped", [97]], [[120251, 120251], "mapped", [98]], [[120252, 120252], "mapped", [99]], [[120253, 120253], "mapped", [100]], [[120254, 120254], "mapped", [101]], [[120255, 120255], "mapped", [102]], [[120256, 120256], "mapped", [103]], [[120257, 120257], "mapped", [104]], [[120258, 120258], "mapped", [105]], [[120259, 120259], "mapped", [106]], [[120260, 120260], "mapped", [107]], [[120261, 120261], "mapped", [108]], [[120262, 120262], "mapped", [109]], [[120263, 120263], "mapped", [110]], [[120264, 120264], "mapped", [111]], [[120265, 120265], "mapped", [112]], [[120266, 120266], "mapped", [113]], [[120267, 120267], "mapped", [114]], [[120268, 120268], "mapped", [115]], [[120269, 120269], "mapped", [116]], [[120270, 120270], "mapped", [117]], [[120271, 120271], "mapped", [118]], [[120272, 120272], "mapped", [119]], [[120273, 120273], "mapped", [120]], [[120274, 120274], "mapped", [121]], [[120275, 120275], "mapped", [122]], [[120276, 120276], "mapped", [97]], [[120277, 120277], "mapped", [98]], [[120278, 120278], "mapped", [99]], [[120279, 120279], "mapped", [100]], [[120280, 120280], "mapped", [101]], [[120281, 120281], "mapped", [102]], [[120282, 120282], "mapped", [103]], [[120283, 120283], "mapped", [104]], [[120284, 120284], "mapped", [105]], [[120285, 120285], "mapped", [106]], [[120286, 120286], "mapped", [107]], [[120287, 120287], "mapped", [108]], [[120288, 120288], "mapped", [109]], [[120289, 120289], "mapped", [110]], [[120290, 120290], "mapped", [111]], [[120291, 120291], "mapped", [112]], [[120292, 120292], "mapped", [113]], [[120293, 120293], "mapped", [114]], [[120294, 120294], "mapped", [115]], [[120295, 120295], "mapped", [116]], [[120296, 120296], "mapped", [117]], [[120297, 120297], "mapped", [118]], [[120298, 120298], "mapped", [119]], [[120299, 120299], "mapped", [120]], [[120300, 120300], "mapped", [121]], [[120301, 120301], "mapped", [122]], [[120302, 120302], "mapped", [97]], [[120303, 120303], "mapped", [98]], [[120304, 120304], "mapped", [99]], [[120305, 120305], "mapped", [100]], [[120306, 120306], "mapped", [101]], [[120307, 120307], "mapped", [102]], [[120308, 120308], "mapped", [103]], [[120309, 120309], "mapped", [104]], [[120310, 120310], "mapped", [105]], [[120311, 120311], "mapped", [106]], [[120312, 120312], "mapped", [107]], [[120313, 120313], "mapped", [108]], [[120314, 120314], "mapped", [109]], [[120315, 120315], "mapped", [110]], [[120316, 120316], "mapped", [111]], [[120317, 120317], "mapped", [112]], [[120318, 120318], "mapped", [113]], [[120319, 120319], "mapped", [114]], [[120320, 120320], "mapped", [115]], [[120321, 120321], "mapped", [116]], [[120322, 120322], "mapped", [117]], [[120323, 120323], "mapped", [118]], [[120324, 120324], "mapped", [119]], [[120325, 120325], "mapped", [120]], [[120326, 120326], "mapped", [121]], [[120327, 120327], "mapped", [122]], [[120328, 120328], "mapped", [97]], [[120329, 120329], "mapped", [98]], [[120330, 120330], "mapped", [99]], [[120331, 120331], "mapped", [100]], [[120332, 120332], "mapped", [101]], [[120333, 120333], "mapped", [102]], [[120334, 120334], "mapped", [103]], [[120335, 120335], "mapped", [104]], [[120336, 120336], "mapped", [105]], [[120337, 120337], "mapped", [106]], [[120338, 120338], "mapped", [107]], [[120339, 120339], "mapped", [108]], [[120340, 120340], "mapped", [109]], [[120341, 120341], "mapped", [110]], [[120342, 120342], "mapped", [111]], [[120343, 120343], "mapped", [112]], [[120344, 120344], "mapped", [113]], [[120345, 120345], "mapped", [114]], [[120346, 120346], "mapped", [115]], [[120347, 120347], "mapped", [116]], [[120348, 120348], "mapped", [117]], [[120349, 120349], "mapped", [118]], [[120350, 120350], "mapped", [119]], [[120351, 120351], "mapped", [120]], [[120352, 120352], "mapped", [121]], [[120353, 120353], "mapped", [122]], [[120354, 120354], "mapped", [97]], [[120355, 120355], "mapped", [98]], [[120356, 120356], "mapped", [99]], [[120357, 120357], "mapped", [100]], [[120358, 120358], "mapped", [101]], [[120359, 120359], "mapped", [102]], [[120360, 120360], "mapped", [103]], [[120361, 120361], "mapped", [104]], [[120362, 120362], "mapped", [105]], [[120363, 120363], "mapped", [106]], [[120364, 120364], "mapped", [107]], [[120365, 120365], "mapped", [108]], [[120366, 120366], "mapped", [109]], [[120367, 120367], "mapped", [110]], [[120368, 120368], "mapped", [111]], [[120369, 120369], "mapped", [112]], [[120370, 120370], "mapped", [113]], [[120371, 120371], "mapped", [114]], [[120372, 120372], "mapped", [115]], [[120373, 120373], "mapped", [116]], [[120374, 120374], "mapped", [117]], [[120375, 120375], "mapped", [118]], [[120376, 120376], "mapped", [119]], [[120377, 120377], "mapped", [120]], [[120378, 120378], "mapped", [121]], [[120379, 120379], "mapped", [122]], [[120380, 120380], "mapped", [97]], [[120381, 120381], "mapped", [98]], [[120382, 120382], "mapped", [99]], [[120383, 120383], "mapped", [100]], [[120384, 120384], "mapped", [101]], [[120385, 120385], "mapped", [102]], [[120386, 120386], "mapped", [103]], [[120387, 120387], "mapped", [104]], [[120388, 120388], "mapped", [105]], [[120389, 120389], "mapped", [106]], [[120390, 120390], "mapped", [107]], [[120391, 120391], "mapped", [108]], [[120392, 120392], "mapped", [109]], [[120393, 120393], "mapped", [110]], [[120394, 120394], "mapped", [111]], [[120395, 120395], "mapped", [112]], [[120396, 120396], "mapped", [113]], [[120397, 120397], "mapped", [114]], [[120398, 120398], "mapped", [115]], [[120399, 120399], "mapped", [116]], [[120400, 120400], "mapped", [117]], [[120401, 120401], "mapped", [118]], [[120402, 120402], "mapped", [119]], [[120403, 120403], "mapped", [120]], [[120404, 120404], "mapped", [121]], [[120405, 120405], "mapped", [122]], [[120406, 120406], "mapped", [97]], [[120407, 120407], "mapped", [98]], [[120408, 120408], "mapped", [99]], [[120409, 120409], "mapped", [100]], [[120410, 120410], "mapped", [101]], [[120411, 120411], "mapped", [102]], [[120412, 120412], "mapped", [103]], [[120413, 120413], "mapped", [104]], [[120414, 120414], "mapped", [105]], [[120415, 120415], "mapped", [106]], [[120416, 120416], "mapped", [107]], [[120417, 120417], "mapped", [108]], [[120418, 120418], "mapped", [109]], [[120419, 120419], "mapped", [110]], [[120420, 120420], "mapped", [111]], [[120421, 120421], "mapped", [112]], [[120422, 120422], "mapped", [113]], [[120423, 120423], "mapped", [114]], [[120424, 120424], "mapped", [115]], [[120425, 120425], "mapped", [116]], [[120426, 120426], "mapped", [117]], [[120427, 120427], "mapped", [118]], [[120428, 120428], "mapped", [119]], [[120429, 120429], "mapped", [120]], [[120430, 120430], "mapped", [121]], [[120431, 120431], "mapped", [122]], [[120432, 120432], "mapped", [97]], [[120433, 120433], "mapped", [98]], [[120434, 120434], "mapped", [99]], [[120435, 120435], "mapped", [100]], [[120436, 120436], "mapped", [101]], [[120437, 120437], "mapped", [102]], [[120438, 120438], "mapped", [103]], [[120439, 120439], "mapped", [104]], [[120440, 120440], "mapped", [105]], [[120441, 120441], "mapped", [106]], [[120442, 120442], "mapped", [107]], [[120443, 120443], "mapped", [108]], [[120444, 120444], "mapped", [109]], [[120445, 120445], "mapped", [110]], [[120446, 120446], "mapped", [111]], [[120447, 120447], "mapped", [112]], [[120448, 120448], "mapped", [113]], [[120449, 120449], "mapped", [114]], [[120450, 120450], "mapped", [115]], [[120451, 120451], "mapped", [116]], [[120452, 120452], "mapped", [117]], [[120453, 120453], "mapped", [118]], [[120454, 120454], "mapped", [119]], [[120455, 120455], "mapped", [120]], [[120456, 120456], "mapped", [121]], [[120457, 120457], "mapped", [122]], [[120458, 120458], "mapped", [97]], [[120459, 120459], "mapped", [98]], [[120460, 120460], "mapped", [99]], [[120461, 120461], "mapped", [100]], [[120462, 120462], "mapped", [101]], [[120463, 120463], "mapped", [102]], [[120464, 120464], "mapped", [103]], [[120465, 120465], "mapped", [104]], [[120466, 120466], "mapped", [105]], [[120467, 120467], "mapped", [106]], [[120468, 120468], "mapped", [107]], [[120469, 120469], "mapped", [108]], [[120470, 120470], "mapped", [109]], [[120471, 120471], "mapped", [110]], [[120472, 120472], "mapped", [111]], [[120473, 120473], "mapped", [112]], [[120474, 120474], "mapped", [113]], [[120475, 120475], "mapped", [114]], [[120476, 120476], "mapped", [115]], [[120477, 120477], "mapped", [116]], [[120478, 120478], "mapped", [117]], [[120479, 120479], "mapped", [118]], [[120480, 120480], "mapped", [119]], [[120481, 120481], "mapped", [120]], [[120482, 120482], "mapped", [121]], [[120483, 120483], "mapped", [122]], [[120484, 120484], "mapped", [305]], [[120485, 120485], "mapped", [567]], [[120486, 120487], "disallowed"], [[120488, 120488], "mapped", [945]], [[120489, 120489], "mapped", [946]], [[120490, 120490], "mapped", [947]], [[120491, 120491], "mapped", [948]], [[120492, 120492], "mapped", [949]], [[120493, 120493], "mapped", [950]], [[120494, 120494], "mapped", [951]], [[120495, 120495], "mapped", [952]], [[120496, 120496], "mapped", [953]], [[120497, 120497], "mapped", [954]], [[120498, 120498], "mapped", [955]], [[120499, 120499], "mapped", [956]], [[120500, 120500], "mapped", [957]], [[120501, 120501], "mapped", [958]], [[120502, 120502], "mapped", [959]], [[120503, 120503], "mapped", [960]], [[120504, 120504], "mapped", [961]], [[120505, 120505], "mapped", [952]], [[120506, 120506], "mapped", [963]], [[120507, 120507], "mapped", [964]], [[120508, 120508], "mapped", [965]], [[120509, 120509], "mapped", [966]], [[120510, 120510], "mapped", [967]], [[120511, 120511], "mapped", [968]], [[120512, 120512], "mapped", [969]], [[120513, 120513], "mapped", [8711]], [[120514, 120514], "mapped", [945]], [[120515, 120515], "mapped", [946]], [[120516, 120516], "mapped", [947]], [[120517, 120517], "mapped", [948]], [[120518, 120518], "mapped", [949]], [[120519, 120519], "mapped", [950]], [[120520, 120520], "mapped", [951]], [[120521, 120521], "mapped", [952]], [[120522, 120522], "mapped", [953]], [[120523, 120523], "mapped", [954]], [[120524, 120524], "mapped", [955]], [[120525, 120525], "mapped", [956]], [[120526, 120526], "mapped", [957]], [[120527, 120527], "mapped", [958]], [[120528, 120528], "mapped", [959]], [[120529, 120529], "mapped", [960]], [[120530, 120530], "mapped", [961]], [[120531, 120532], "mapped", [963]], [[120533, 120533], "mapped", [964]], [[120534, 120534], "mapped", [965]], [[120535, 120535], "mapped", [966]], [[120536, 120536], "mapped", [967]], [[120537, 120537], "mapped", [968]], [[120538, 120538], "mapped", [969]], [[120539, 120539], "mapped", [8706]], [[120540, 120540], "mapped", [949]], [[120541, 120541], "mapped", [952]], [[120542, 120542], "mapped", [954]], [[120543, 120543], "mapped", [966]], [[120544, 120544], "mapped", [961]], [[120545, 120545], "mapped", [960]], [[120546, 120546], "mapped", [945]], [[120547, 120547], "mapped", [946]], [[120548, 120548], "mapped", [947]], [[120549, 120549], "mapped", [948]], [[120550, 120550], "mapped", [949]], [[120551, 120551], "mapped", [950]], [[120552, 120552], "mapped", [951]], [[120553, 120553], "mapped", [952]], [[120554, 120554], "mapped", [953]], [[120555, 120555], "mapped", [954]], [[120556, 120556], "mapped", [955]], [[120557, 120557], "mapped", [956]], [[120558, 120558], "mapped", [957]], [[120559, 120559], "mapped", [958]], [[120560, 120560], "mapped", [959]], [[120561, 120561], "mapped", [960]], [[120562, 120562], "mapped", [961]], [[120563, 120563], "mapped", [952]], [[120564, 120564], "mapped", [963]], [[120565, 120565], "mapped", [964]], [[120566, 120566], "mapped", [965]], [[120567, 120567], "mapped", [966]], [[120568, 120568], "mapped", [967]], [[120569, 120569], "mapped", [968]], [[120570, 120570], "mapped", [969]], [[120571, 120571], "mapped", [8711]], [[120572, 120572], "mapped", [945]], [[120573, 120573], "mapped", [946]], [[120574, 120574], "mapped", [947]], [[120575, 120575], "mapped", [948]], [[120576, 120576], "mapped", [949]], [[120577, 120577], "mapped", [950]], [[120578, 120578], "mapped", [951]], [[120579, 120579], "mapped", [952]], [[120580, 120580], "mapped", [953]], [[120581, 120581], "mapped", [954]], [[120582, 120582], "mapped", [955]], [[120583, 120583], "mapped", [956]], [[120584, 120584], "mapped", [957]], [[120585, 120585], "mapped", [958]], [[120586, 120586], "mapped", [959]], [[120587, 120587], "mapped", [960]], [[120588, 120588], "mapped", [961]], [[120589, 120590], "mapped", [963]], [[120591, 120591], "mapped", [964]], [[120592, 120592], "mapped", [965]], [[120593, 120593], "mapped", [966]], [[120594, 120594], "mapped", [967]], [[120595, 120595], "mapped", [968]], [[120596, 120596], "mapped", [969]], [[120597, 120597], "mapped", [8706]], [[120598, 120598], "mapped", [949]], [[120599, 120599], "mapped", [952]], [[120600, 120600], "mapped", [954]], [[120601, 120601], "mapped", [966]], [[120602, 120602], "mapped", [961]], [[120603, 120603], "mapped", [960]], [[120604, 120604], "mapped", [945]], [[120605, 120605], "mapped", [946]], [[120606, 120606], "mapped", [947]], [[120607, 120607], "mapped", [948]], [[120608, 120608], "mapped", [949]], [[120609, 120609], "mapped", [950]], [[120610, 120610], "mapped", [951]], [[120611, 120611], "mapped", [952]], [[120612, 120612], "mapped", [953]], [[120613, 120613], "mapped", [954]], [[120614, 120614], "mapped", [955]], [[120615, 120615], "mapped", [956]], [[120616, 120616], "mapped", [957]], [[120617, 120617], "mapped", [958]], [[120618, 120618], "mapped", [959]], [[120619, 120619], "mapped", [960]], [[120620, 120620], "mapped", [961]], [[120621, 120621], "mapped", [952]], [[120622, 120622], "mapped", [963]], [[120623, 120623], "mapped", [964]], [[120624, 120624], "mapped", [965]], [[120625, 120625], "mapped", [966]], [[120626, 120626], "mapped", [967]], [[120627, 120627], "mapped", [968]], [[120628, 120628], "mapped", [969]], [[120629, 120629], "mapped", [8711]], [[120630, 120630], "mapped", [945]], [[120631, 120631], "mapped", [946]], [[120632, 120632], "mapped", [947]], [[120633, 120633], "mapped", [948]], [[120634, 120634], "mapped", [949]], [[120635, 120635], "mapped", [950]], [[120636, 120636], "mapped", [951]], [[120637, 120637], "mapped", [952]], [[120638, 120638], "mapped", [953]], [[120639, 120639], "mapped", [954]], [[120640, 120640], "mapped", [955]], [[120641, 120641], "mapped", [956]], [[120642, 120642], "mapped", [957]], [[120643, 120643], "mapped", [958]], [[120644, 120644], "mapped", [959]], [[120645, 120645], "mapped", [960]], [[120646, 120646], "mapped", [961]], [[120647, 120648], "mapped", [963]], [[120649, 120649], "mapped", [964]], [[120650, 120650], "mapped", [965]], [[120651, 120651], "mapped", [966]], [[120652, 120652], "mapped", [967]], [[120653, 120653], "mapped", [968]], [[120654, 120654], "mapped", [969]], [[120655, 120655], "mapped", [8706]], [[120656, 120656], "mapped", [949]], [[120657, 120657], "mapped", [952]], [[120658, 120658], "mapped", [954]], [[120659, 120659], "mapped", [966]], [[120660, 120660], "mapped", [961]], [[120661, 120661], "mapped", [960]], [[120662, 120662], "mapped", [945]], [[120663, 120663], "mapped", [946]], [[120664, 120664], "mapped", [947]], [[120665, 120665], "mapped", [948]], [[120666, 120666], "mapped", [949]], [[120667, 120667], "mapped", [950]], [[120668, 120668], "mapped", [951]], [[120669, 120669], "mapped", [952]], [[120670, 120670], "mapped", [953]], [[120671, 120671], "mapped", [954]], [[120672, 120672], "mapped", [955]], [[120673, 120673], "mapped", [956]], [[120674, 120674], "mapped", [957]], [[120675, 120675], "mapped", [958]], [[120676, 120676], "mapped", [959]], [[120677, 120677], "mapped", [960]], [[120678, 120678], "mapped", [961]], [[120679, 120679], "mapped", [952]], [[120680, 120680], "mapped", [963]], [[120681, 120681], "mapped", [964]], [[120682, 120682], "mapped", [965]], [[120683, 120683], "mapped", [966]], [[120684, 120684], "mapped", [967]], [[120685, 120685], "mapped", [968]], [[120686, 120686], "mapped", [969]], [[120687, 120687], "mapped", [8711]], [[120688, 120688], "mapped", [945]], [[120689, 120689], "mapped", [946]], [[120690, 120690], "mapped", [947]], [[120691, 120691], "mapped", [948]], [[120692, 120692], "mapped", [949]], [[120693, 120693], "mapped", [950]], [[120694, 120694], "mapped", [951]], [[120695, 120695], "mapped", [952]], [[120696, 120696], "mapped", [953]], [[120697, 120697], "mapped", [954]], [[120698, 120698], "mapped", [955]], [[120699, 120699], "mapped", [956]], [[120700, 120700], "mapped", [957]], [[120701, 120701], "mapped", [958]], [[120702, 120702], "mapped", [959]], [[120703, 120703], "mapped", [960]], [[120704, 120704], "mapped", [961]], [[120705, 120706], "mapped", [963]], [[120707, 120707], "mapped", [964]], [[120708, 120708], "mapped", [965]], [[120709, 120709], "mapped", [966]], [[120710, 120710], "mapped", [967]], [[120711, 120711], "mapped", [968]], [[120712, 120712], "mapped", [969]], [[120713, 120713], "mapped", [8706]], [[120714, 120714], "mapped", [949]], [[120715, 120715], "mapped", [952]], [[120716, 120716], "mapped", [954]], [[120717, 120717], "mapped", [966]], [[120718, 120718], "mapped", [961]], [[120719, 120719], "mapped", [960]], [[120720, 120720], "mapped", [945]], [[120721, 120721], "mapped", [946]], [[120722, 120722], "mapped", [947]], [[120723, 120723], "mapped", [948]], [[120724, 120724], "mapped", [949]], [[120725, 120725], "mapped", [950]], [[120726, 120726], "mapped", [951]], [[120727, 120727], "mapped", [952]], [[120728, 120728], "mapped", [953]], [[120729, 120729], "mapped", [954]], [[120730, 120730], "mapped", [955]], [[120731, 120731], "mapped", [956]], [[120732, 120732], "mapped", [957]], [[120733, 120733], "mapped", [958]], [[120734, 120734], "mapped", [959]], [[120735, 120735], "mapped", [960]], [[120736, 120736], "mapped", [961]], [[120737, 120737], "mapped", [952]], [[120738, 120738], "mapped", [963]], [[120739, 120739], "mapped", [964]], [[120740, 120740], "mapped", [965]], [[120741, 120741], "mapped", [966]], [[120742, 120742], "mapped", [967]], [[120743, 120743], "mapped", [968]], [[120744, 120744], "mapped", [969]], [[120745, 120745], "mapped", [8711]], [[120746, 120746], "mapped", [945]], [[120747, 120747], "mapped", [946]], [[120748, 120748], "mapped", [947]], [[120749, 120749], "mapped", [948]], [[120750, 120750], "mapped", [949]], [[120751, 120751], "mapped", [950]], [[120752, 120752], "mapped", [951]], [[120753, 120753], "mapped", [952]], [[120754, 120754], "mapped", [953]], [[120755, 120755], "mapped", [954]], [[120756, 120756], "mapped", [955]], [[120757, 120757], "mapped", [956]], [[120758, 120758], "mapped", [957]], [[120759, 120759], "mapped", [958]], [[120760, 120760], "mapped", [959]], [[120761, 120761], "mapped", [960]], [[120762, 120762], "mapped", [961]], [[120763, 120764], "mapped", [963]], [[120765, 120765], "mapped", [964]], [[120766, 120766], "mapped", [965]], [[120767, 120767], "mapped", [966]], [[120768, 120768], "mapped", [967]], [[120769, 120769], "mapped", [968]], [[120770, 120770], "mapped", [969]], [[120771, 120771], "mapped", [8706]], [[120772, 120772], "mapped", [949]], [[120773, 120773], "mapped", [952]], [[120774, 120774], "mapped", [954]], [[120775, 120775], "mapped", [966]], [[120776, 120776], "mapped", [961]], [[120777, 120777], "mapped", [960]], [[120778, 120779], "mapped", [989]], [[120780, 120781], "disallowed"], [[120782, 120782], "mapped", [48]], [[120783, 120783], "mapped", [49]], [[120784, 120784], "mapped", [50]], [[120785, 120785], "mapped", [51]], [[120786, 120786], "mapped", [52]], [[120787, 120787], "mapped", [53]], [[120788, 120788], "mapped", [54]], [[120789, 120789], "mapped", [55]], [[120790, 120790], "mapped", [56]], [[120791, 120791], "mapped", [57]], [[120792, 120792], "mapped", [48]], [[120793, 120793], "mapped", [49]], [[120794, 120794], "mapped", [50]], [[120795, 120795], "mapped", [51]], [[120796, 120796], "mapped", [52]], [[120797, 120797], "mapped", [53]], [[120798, 120798], "mapped", [54]], [[120799, 120799], "mapped", [55]], [[120800, 120800], "mapped", [56]], [[120801, 120801], "mapped", [57]], [[120802, 120802], "mapped", [48]], [[120803, 120803], "mapped", [49]], [[120804, 120804], "mapped", [50]], [[120805, 120805], "mapped", [51]], [[120806, 120806], "mapped", [52]], [[120807, 120807], "mapped", [53]], [[120808, 120808], "mapped", [54]], [[120809, 120809], "mapped", [55]], [[120810, 120810], "mapped", [56]], [[120811, 120811], "mapped", [57]], [[120812, 120812], "mapped", [48]], [[120813, 120813], "mapped", [49]], [[120814, 120814], "mapped", [50]], [[120815, 120815], "mapped", [51]], [[120816, 120816], "mapped", [52]], [[120817, 120817], "mapped", [53]], [[120818, 120818], "mapped", [54]], [[120819, 120819], "mapped", [55]], [[120820, 120820], "mapped", [56]], [[120821, 120821], "mapped", [57]], [[120822, 120822], "mapped", [48]], [[120823, 120823], "mapped", [49]], [[120824, 120824], "mapped", [50]], [[120825, 120825], "mapped", [51]], [[120826, 120826], "mapped", [52]], [[120827, 120827], "mapped", [53]], [[120828, 120828], "mapped", [54]], [[120829, 120829], "mapped", [55]], [[120830, 120830], "mapped", [56]], [[120831, 120831], "mapped", [57]], [[120832, 121343], "valid", [], "NV8"], [[121344, 121398], "valid"], [[121399, 121402], "valid", [], "NV8"], [[121403, 121452], "valid"], [[121453, 121460], "valid", [], "NV8"], [[121461, 121461], "valid"], [[121462, 121475], "valid", [], "NV8"], [[121476, 121476], "valid"], [[121477, 121483], "valid", [], "NV8"], [[121484, 121498], "disallowed"], [[121499, 121503], "valid"], [[121504, 121504], "disallowed"], [[121505, 121519], "valid"], [[121520, 124927], "disallowed"], [[124928, 125124], "valid"], [[125125, 125126], "disallowed"], [[125127, 125135], "valid", [], "NV8"], [[125136, 125142], "valid"], [[125143, 126463], "disallowed"], [[126464, 126464], "mapped", [1575]], [[126465, 126465], "mapped", [1576]], [[126466, 126466], "mapped", [1580]], [[126467, 126467], "mapped", [1583]], [[126468, 126468], "disallowed"], [[126469, 126469], "mapped", [1608]], [[126470, 126470], "mapped", [1586]], [[126471, 126471], "mapped", [1581]], [[126472, 126472], "mapped", [1591]], [[126473, 126473], "mapped", [1610]], [[126474, 126474], "mapped", [1603]], [[126475, 126475], "mapped", [1604]], [[126476, 126476], "mapped", [1605]], [[126477, 126477], "mapped", [1606]], [[126478, 126478], "mapped", [1587]], [[126479, 126479], "mapped", [1593]], [[126480, 126480], "mapped", [1601]], [[126481, 126481], "mapped", [1589]], [[126482, 126482], "mapped", [1602]], [[126483, 126483], "mapped", [1585]], [[126484, 126484], "mapped", [1588]], [[126485, 126485], "mapped", [1578]], [[126486, 126486], "mapped", [1579]], [[126487, 126487], "mapped", [1582]], [[126488, 126488], "mapped", [1584]], [[126489, 126489], "mapped", [1590]], [[126490, 126490], "mapped", [1592]], [[126491, 126491], "mapped", [1594]], [[126492, 126492], "mapped", [1646]], [[126493, 126493], "mapped", [1722]], [[126494, 126494], "mapped", [1697]], [[126495, 126495], "mapped", [1647]], [[126496, 126496], "disallowed"], [[126497, 126497], "mapped", [1576]], [[126498, 126498], "mapped", [1580]], [[126499, 126499], "disallowed"], [[126500, 126500], "mapped", [1607]], [[126501, 126502], "disallowed"], [[126503, 126503], "mapped", [1581]], [[126504, 126504], "disallowed"], [[126505, 126505], "mapped", [1610]], [[126506, 126506], "mapped", [1603]], [[126507, 126507], "mapped", [1604]], [[126508, 126508], "mapped", [1605]], [[126509, 126509], "mapped", [1606]], [[126510, 126510], "mapped", [1587]], [[126511, 126511], "mapped", [1593]], [[126512, 126512], "mapped", [1601]], [[126513, 126513], "mapped", [1589]], [[126514, 126514], "mapped", [1602]], [[126515, 126515], "disallowed"], [[126516, 126516], "mapped", [1588]], [[126517, 126517], "mapped", [1578]], [[126518, 126518], "mapped", [1579]], [[126519, 126519], "mapped", [1582]], [[126520, 126520], "disallowed"], [[126521, 126521], "mapped", [1590]], [[126522, 126522], "disallowed"], [[126523, 126523], "mapped", [1594]], [[126524, 126529], "disallowed"], [[126530, 126530], "mapped", [1580]], [[126531, 126534], "disallowed"], [[126535, 126535], "mapped", [1581]], [[126536, 126536], "disallowed"], [[126537, 126537], "mapped", [1610]], [[126538, 126538], "disallowed"], [[126539, 126539], "mapped", [1604]], [[126540, 126540], "disallowed"], [[126541, 126541], "mapped", [1606]], [[126542, 126542], "mapped", [1587]], [[126543, 126543], "mapped", [1593]], [[126544, 126544], "disallowed"], [[126545, 126545], "mapped", [1589]], [[126546, 126546], "mapped", [1602]], [[126547, 126547], "disallowed"], [[126548, 126548], "mapped", [1588]], [[126549, 126550], "disallowed"], [[126551, 126551], "mapped", [1582]], [[126552, 126552], "disallowed"], [[126553, 126553], "mapped", [1590]], [[126554, 126554], "disallowed"], [[126555, 126555], "mapped", [1594]], [[126556, 126556], "disallowed"], [[126557, 126557], "mapped", [1722]], [[126558, 126558], "disallowed"], [[126559, 126559], "mapped", [1647]], [[126560, 126560], "disallowed"], [[126561, 126561], "mapped", [1576]], [[126562, 126562], "mapped", [1580]], [[126563, 126563], "disallowed"], [[126564, 126564], "mapped", [1607]], [[126565, 126566], "disallowed"], [[126567, 126567], "mapped", [1581]], [[126568, 126568], "mapped", [1591]], [[126569, 126569], "mapped", [1610]], [[126570, 126570], "mapped", [1603]], [[126571, 126571], "disallowed"], [[126572, 126572], "mapped", [1605]], [[126573, 126573], "mapped", [1606]], [[126574, 126574], "mapped", [1587]], [[126575, 126575], "mapped", [1593]], [[126576, 126576], "mapped", [1601]], [[126577, 126577], "mapped", [1589]], [[126578, 126578], "mapped", [1602]], [[126579, 126579], "disallowed"], [[126580, 126580], "mapped", [1588]], [[126581, 126581], "mapped", [1578]], [[126582, 126582], "mapped", [1579]], [[126583, 126583], "mapped", [1582]], [[126584, 126584], "disallowed"], [[126585, 126585], "mapped", [1590]], [[126586, 126586], "mapped", [1592]], [[126587, 126587], "mapped", [1594]], [[126588, 126588], "mapped", [1646]], [[126589, 126589], "disallowed"], [[126590, 126590], "mapped", [1697]], [[126591, 126591], "disallowed"], [[126592, 126592], "mapped", [1575]], [[126593, 126593], "mapped", [1576]], [[126594, 126594], "mapped", [1580]], [[126595, 126595], "mapped", [1583]], [[126596, 126596], "mapped", [1607]], [[126597, 126597], "mapped", [1608]], [[126598, 126598], "mapped", [1586]], [[126599, 126599], "mapped", [1581]], [[126600, 126600], "mapped", [1591]], [[126601, 126601], "mapped", [1610]], [[126602, 126602], "disallowed"], [[126603, 126603], "mapped", [1604]], [[126604, 126604], "mapped", [1605]], [[126605, 126605], "mapped", [1606]], [[126606, 126606], "mapped", [1587]], [[126607, 126607], "mapped", [1593]], [[126608, 126608], "mapped", [1601]], [[126609, 126609], "mapped", [1589]], [[126610, 126610], "mapped", [1602]], [[126611, 126611], "mapped", [1585]], [[126612, 126612], "mapped", [1588]], [[126613, 126613], "mapped", [1578]], [[126614, 126614], "mapped", [1579]], [[126615, 126615], "mapped", [1582]], [[126616, 126616], "mapped", [1584]], [[126617, 126617], "mapped", [1590]], [[126618, 126618], "mapped", [1592]], [[126619, 126619], "mapped", [1594]], [[126620, 126624], "disallowed"], [[126625, 126625], "mapped", [1576]], [[126626, 126626], "mapped", [1580]], [[126627, 126627], "mapped", [1583]], [[126628, 126628], "disallowed"], [[126629, 126629], "mapped", [1608]], [[126630, 126630], "mapped", [1586]], [[126631, 126631], "mapped", [1581]], [[126632, 126632], "mapped", [1591]], [[126633, 126633], "mapped", [1610]], [[126634, 126634], "disallowed"], [[126635, 126635], "mapped", [1604]], [[126636, 126636], "mapped", [1605]], [[126637, 126637], "mapped", [1606]], [[126638, 126638], "mapped", [1587]], [[126639, 126639], "mapped", [1593]], [[126640, 126640], "mapped", [1601]], [[126641, 126641], "mapped", [1589]], [[126642, 126642], "mapped", [1602]], [[126643, 126643], "mapped", [1585]], [[126644, 126644], "mapped", [1588]], [[126645, 126645], "mapped", [1578]], [[126646, 126646], "mapped", [1579]], [[126647, 126647], "mapped", [1582]], [[126648, 126648], "mapped", [1584]], [[126649, 126649], "mapped", [1590]], [[126650, 126650], "mapped", [1592]], [[126651, 126651], "mapped", [1594]], [[126652, 126703], "disallowed"], [[126704, 126705], "valid", [], "NV8"], [[126706, 126975], "disallowed"], [[126976, 127019], "valid", [], "NV8"], [[127020, 127023], "disallowed"], [[127024, 127123], "valid", [], "NV8"], [[127124, 127135], "disallowed"], [[127136, 127150], "valid", [], "NV8"], [[127151, 127152], "disallowed"], [[127153, 127166], "valid", [], "NV8"], [[127167, 127167], "valid", [], "NV8"], [[127168, 127168], "disallowed"], [[127169, 127183], "valid", [], "NV8"], [[127184, 127184], "disallowed"], [[127185, 127199], "valid", [], "NV8"], [[127200, 127221], "valid", [], "NV8"], [[127222, 127231], "disallowed"], [[127232, 127232], "disallowed"], [[127233, 127233], "disallowed_STD3_mapped", [48, 44]], [[127234, 127234], "disallowed_STD3_mapped", [49, 44]], [[127235, 127235], "disallowed_STD3_mapped", [50, 44]], [[127236, 127236], "disallowed_STD3_mapped", [51, 44]], [[127237, 127237], "disallowed_STD3_mapped", [52, 44]], [[127238, 127238], "disallowed_STD3_mapped", [53, 44]], [[127239, 127239], "disallowed_STD3_mapped", [54, 44]], [[127240, 127240], "disallowed_STD3_mapped", [55, 44]], [[127241, 127241], "disallowed_STD3_mapped", [56, 44]], [[127242, 127242], "disallowed_STD3_mapped", [57, 44]], [[127243, 127244], "valid", [], "NV8"], [[127245, 127247], "disallowed"], [[127248, 127248], "disallowed_STD3_mapped", [40, 97, 41]], [[127249, 127249], "disallowed_STD3_mapped", [40, 98, 41]], [[127250, 127250], "disallowed_STD3_mapped", [40, 99, 41]], [[127251, 127251], "disallowed_STD3_mapped", [40, 100, 41]], [[127252, 127252], "disallowed_STD3_mapped", [40, 101, 41]], [[127253, 127253], "disallowed_STD3_mapped", [40, 102, 41]], [[127254, 127254], "disallowed_STD3_mapped", [40, 103, 41]], [[127255, 127255], "disallowed_STD3_mapped", [40, 104, 41]], [[127256, 127256], "disallowed_STD3_mapped", [40, 105, 41]], [[127257, 127257], "disallowed_STD3_mapped", [40, 106, 41]], [[127258, 127258], "disallowed_STD3_mapped", [40, 107, 41]], [[127259, 127259], "disallowed_STD3_mapped", [40, 108, 41]], [[127260, 127260], "disallowed_STD3_mapped", [40, 109, 41]], [[127261, 127261], "disallowed_STD3_mapped", [40, 110, 41]], [[127262, 127262], "disallowed_STD3_mapped", [40, 111, 41]], [[127263, 127263], "disallowed_STD3_mapped", [40, 112, 41]], [[127264, 127264], "disallowed_STD3_mapped", [40, 113, 41]], [[127265, 127265], "disallowed_STD3_mapped", [40, 114, 41]], [[127266, 127266], "disallowed_STD3_mapped", [40, 115, 41]], [[127267, 127267], "disallowed_STD3_mapped", [40, 116, 41]], [[127268, 127268], "disallowed_STD3_mapped", [40, 117, 41]], [[127269, 127269], "disallowed_STD3_mapped", [40, 118, 41]], [[127270, 127270], "disallowed_STD3_mapped", [40, 119, 41]], [[127271, 127271], "disallowed_STD3_mapped", [40, 120, 41]], [[127272, 127272], "disallowed_STD3_mapped", [40, 121, 41]], [[127273, 127273], "disallowed_STD3_mapped", [40, 122, 41]], [[127274, 127274], "mapped", [12308, 115, 12309]], [[127275, 127275], "mapped", [99]], [[127276, 127276], "mapped", [114]], [[127277, 127277], "mapped", [99, 100]], [[127278, 127278], "mapped", [119, 122]], [[127279, 127279], "disallowed"], [[127280, 127280], "mapped", [97]], [[127281, 127281], "mapped", [98]], [[127282, 127282], "mapped", [99]], [[127283, 127283], "mapped", [100]], [[127284, 127284], "mapped", [101]], [[127285, 127285], "mapped", [102]], [[127286, 127286], "mapped", [103]], [[127287, 127287], "mapped", [104]], [[127288, 127288], "mapped", [105]], [[127289, 127289], "mapped", [106]], [[127290, 127290], "mapped", [107]], [[127291, 127291], "mapped", [108]], [[127292, 127292], "mapped", [109]], [[127293, 127293], "mapped", [110]], [[127294, 127294], "mapped", [111]], [[127295, 127295], "mapped", [112]], [[127296, 127296], "mapped", [113]], [[127297, 127297], "mapped", [114]], [[127298, 127298], "mapped", [115]], [[127299, 127299], "mapped", [116]], [[127300, 127300], "mapped", [117]], [[127301, 127301], "mapped", [118]], [[127302, 127302], "mapped", [119]], [[127303, 127303], "mapped", [120]], [[127304, 127304], "mapped", [121]], [[127305, 127305], "mapped", [122]], [[127306, 127306], "mapped", [104, 118]], [[127307, 127307], "mapped", [109, 118]], [[127308, 127308], "mapped", [115, 100]], [[127309, 127309], "mapped", [115, 115]], [[127310, 127310], "mapped", [112, 112, 118]], [[127311, 127311], "mapped", [119, 99]], [[127312, 127318], "valid", [], "NV8"], [[127319, 127319], "valid", [], "NV8"], [[127320, 127326], "valid", [], "NV8"], [[127327, 127327], "valid", [], "NV8"], [[127328, 127337], "valid", [], "NV8"], [[127338, 127338], "mapped", [109, 99]], [[127339, 127339], "mapped", [109, 100]], [[127340, 127343], "disallowed"], [[127344, 127352], "valid", [], "NV8"], [[127353, 127353], "valid", [], "NV8"], [[127354, 127354], "valid", [], "NV8"], [[127355, 127356], "valid", [], "NV8"], [[127357, 127358], "valid", [], "NV8"], [[127359, 127359], "valid", [], "NV8"], [[127360, 127369], "valid", [], "NV8"], [[127370, 127373], "valid", [], "NV8"], [[127374, 127375], "valid", [], "NV8"], [[127376, 127376], "mapped", [100, 106]], [[127377, 127386], "valid", [], "NV8"], [[127387, 127461], "disallowed"], [[127462, 127487], "valid", [], "NV8"], [[127488, 127488], "mapped", [12411, 12363]], [[127489, 127489], "mapped", [12467, 12467]], [[127490, 127490], "mapped", [12469]], [[127491, 127503], "disallowed"], [[127504, 127504], "mapped", [25163]], [[127505, 127505], "mapped", [23383]], [[127506, 127506], "mapped", [21452]], [[127507, 127507], "mapped", [12487]], [[127508, 127508], "mapped", [20108]], [[127509, 127509], "mapped", [22810]], [[127510, 127510], "mapped", [35299]], [[127511, 127511], "mapped", [22825]], [[127512, 127512], "mapped", [20132]], [[127513, 127513], "mapped", [26144]], [[127514, 127514], "mapped", [28961]], [[127515, 127515], "mapped", [26009]], [[127516, 127516], "mapped", [21069]], [[127517, 127517], "mapped", [24460]], [[127518, 127518], "mapped", [20877]], [[127519, 127519], "mapped", [26032]], [[127520, 127520], "mapped", [21021]], [[127521, 127521], "mapped", [32066]], [[127522, 127522], "mapped", [29983]], [[127523, 127523], "mapped", [36009]], [[127524, 127524], "mapped", [22768]], [[127525, 127525], "mapped", [21561]], [[127526, 127526], "mapped", [28436]], [[127527, 127527], "mapped", [25237]], [[127528, 127528], "mapped", [25429]], [[127529, 127529], "mapped", [19968]], [[127530, 127530], "mapped", [19977]], [[127531, 127531], "mapped", [36938]], [[127532, 127532], "mapped", [24038]], [[127533, 127533], "mapped", [20013]], [[127534, 127534], "mapped", [21491]], [[127535, 127535], "mapped", [25351]], [[127536, 127536], "mapped", [36208]], [[127537, 127537], "mapped", [25171]], [[127538, 127538], "mapped", [31105]], [[127539, 127539], "mapped", [31354]], [[127540, 127540], "mapped", [21512]], [[127541, 127541], "mapped", [28288]], [[127542, 127542], "mapped", [26377]], [[127543, 127543], "mapped", [26376]], [[127544, 127544], "mapped", [30003]], [[127545, 127545], "mapped", [21106]], [[127546, 127546], "mapped", [21942]], [[127547, 127551], "disallowed"], [[127552, 127552], "mapped", [12308, 26412, 12309]], [[127553, 127553], "mapped", [12308, 19977, 12309]], [[127554, 127554], "mapped", [12308, 20108, 12309]], [[127555, 127555], "mapped", [12308, 23433, 12309]], [[127556, 127556], "mapped", [12308, 28857, 12309]], [[127557, 127557], "mapped", [12308, 25171, 12309]], [[127558, 127558], "mapped", [12308, 30423, 12309]], [[127559, 127559], "mapped", [12308, 21213, 12309]], [[127560, 127560], "mapped", [12308, 25943, 12309]], [[127561, 127567], "disallowed"], [[127568, 127568], "mapped", [24471]], [[127569, 127569], "mapped", [21487]], [[127570, 127743], "disallowed"], [[127744, 127776], "valid", [], "NV8"], [[127777, 127788], "valid", [], "NV8"], [[127789, 127791], "valid", [], "NV8"], [[127792, 127797], "valid", [], "NV8"], [[127798, 127798], "valid", [], "NV8"], [[127799, 127868], "valid", [], "NV8"], [[127869, 127869], "valid", [], "NV8"], [[127870, 127871], "valid", [], "NV8"], [[127872, 127891], "valid", [], "NV8"], [[127892, 127903], "valid", [], "NV8"], [[127904, 127940], "valid", [], "NV8"], [[127941, 127941], "valid", [], "NV8"], [[127942, 127946], "valid", [], "NV8"], [[127947, 127950], "valid", [], "NV8"], [[127951, 127955], "valid", [], "NV8"], [[127956, 127967], "valid", [], "NV8"], [[127968, 127984], "valid", [], "NV8"], [[127985, 127991], "valid", [], "NV8"], [[127992, 127999], "valid", [], "NV8"], [[128e3, 128062], "valid", [], "NV8"], [[128063, 128063], "valid", [], "NV8"], [[128064, 128064], "valid", [], "NV8"], [[128065, 128065], "valid", [], "NV8"], [[128066, 128247], "valid", [], "NV8"], [[128248, 128248], "valid", [], "NV8"], [[128249, 128252], "valid", [], "NV8"], [[128253, 128254], "valid", [], "NV8"], [[128255, 128255], "valid", [], "NV8"], [[128256, 128317], "valid", [], "NV8"], [[128318, 128319], "valid", [], "NV8"], [[128320, 128323], "valid", [], "NV8"], [[128324, 128330], "valid", [], "NV8"], [[128331, 128335], "valid", [], "NV8"], [[128336, 128359], "valid", [], "NV8"], [[128360, 128377], "valid", [], "NV8"], [[128378, 128378], "disallowed"], [[128379, 128419], "valid", [], "NV8"], [[128420, 128420], "disallowed"], [[128421, 128506], "valid", [], "NV8"], [[128507, 128511], "valid", [], "NV8"], [[128512, 128512], "valid", [], "NV8"], [[128513, 128528], "valid", [], "NV8"], [[128529, 128529], "valid", [], "NV8"], [[128530, 128532], "valid", [], "NV8"], [[128533, 128533], "valid", [], "NV8"], [[128534, 128534], "valid", [], "NV8"], [[128535, 128535], "valid", [], "NV8"], [[128536, 128536], "valid", [], "NV8"], [[128537, 128537], "valid", [], "NV8"], [[128538, 128538], "valid", [], "NV8"], [[128539, 128539], "valid", [], "NV8"], [[128540, 128542], "valid", [], "NV8"], [[128543, 128543], "valid", [], "NV8"], [[128544, 128549], "valid", [], "NV8"], [[128550, 128551], "valid", [], "NV8"], [[128552, 128555], "valid", [], "NV8"], [[128556, 128556], "valid", [], "NV8"], [[128557, 128557], "valid", [], "NV8"], [[128558, 128559], "valid", [], "NV8"], [[128560, 128563], "valid", [], "NV8"], [[128564, 128564], "valid", [], "NV8"], [[128565, 128576], "valid", [], "NV8"], [[128577, 128578], "valid", [], "NV8"], [[128579, 128580], "valid", [], "NV8"], [[128581, 128591], "valid", [], "NV8"], [[128592, 128639], "valid", [], "NV8"], [[128640, 128709], "valid", [], "NV8"], [[128710, 128719], "valid", [], "NV8"], [[128720, 128720], "valid", [], "NV8"], [[128721, 128735], "disallowed"], [[128736, 128748], "valid", [], "NV8"], [[128749, 128751], "disallowed"], [[128752, 128755], "valid", [], "NV8"], [[128756, 128767], "disallowed"], [[128768, 128883], "valid", [], "NV8"], [[128884, 128895], "disallowed"], [[128896, 128980], "valid", [], "NV8"], [[128981, 129023], "disallowed"], [[129024, 129035], "valid", [], "NV8"], [[129036, 129039], "disallowed"], [[129040, 129095], "valid", [], "NV8"], [[129096, 129103], "disallowed"], [[129104, 129113], "valid", [], "NV8"], [[129114, 129119], "disallowed"], [[129120, 129159], "valid", [], "NV8"], [[129160, 129167], "disallowed"], [[129168, 129197], "valid", [], "NV8"], [[129198, 129295], "disallowed"], [[129296, 129304], "valid", [], "NV8"], [[129305, 129407], "disallowed"], [[129408, 129412], "valid", [], "NV8"], [[129413, 129471], "disallowed"], [[129472, 129472], "valid", [], "NV8"], [[129473, 131069], "disallowed"], [[131070, 131071], "disallowed"], [[131072, 173782], "valid"], [[173783, 173823], "disallowed"], [[173824, 177972], "valid"], [[177973, 177983], "disallowed"], [[177984, 178205], "valid"], [[178206, 178207], "disallowed"], [[178208, 183969], "valid"], [[183970, 194559], "disallowed"], [[194560, 194560], "mapped", [20029]], [[194561, 194561], "mapped", [20024]], [[194562, 194562], "mapped", [20033]], [[194563, 194563], "mapped", [131362]], [[194564, 194564], "mapped", [20320]], [[194565, 194565], "mapped", [20398]], [[194566, 194566], "mapped", [20411]], [[194567, 194567], "mapped", [20482]], [[194568, 194568], "mapped", [20602]], [[194569, 194569], "mapped", [20633]], [[194570, 194570], "mapped", [20711]], [[194571, 194571], "mapped", [20687]], [[194572, 194572], "mapped", [13470]], [[194573, 194573], "mapped", [132666]], [[194574, 194574], "mapped", [20813]], [[194575, 194575], "mapped", [20820]], [[194576, 194576], "mapped", [20836]], [[194577, 194577], "mapped", [20855]], [[194578, 194578], "mapped", [132380]], [[194579, 194579], "mapped", [13497]], [[194580, 194580], "mapped", [20839]], [[194581, 194581], "mapped", [20877]], [[194582, 194582], "mapped", [132427]], [[194583, 194583], "mapped", [20887]], [[194584, 194584], "mapped", [20900]], [[194585, 194585], "mapped", [20172]], [[194586, 194586], "mapped", [20908]], [[194587, 194587], "mapped", [20917]], [[194588, 194588], "mapped", [168415]], [[194589, 194589], "mapped", [20981]], [[194590, 194590], "mapped", [20995]], [[194591, 194591], "mapped", [13535]], [[194592, 194592], "mapped", [21051]], [[194593, 194593], "mapped", [21062]], [[194594, 194594], "mapped", [21106]], [[194595, 194595], "mapped", [21111]], [[194596, 194596], "mapped", [13589]], [[194597, 194597], "mapped", [21191]], [[194598, 194598], "mapped", [21193]], [[194599, 194599], "mapped", [21220]], [[194600, 194600], "mapped", [21242]], [[194601, 194601], "mapped", [21253]], [[194602, 194602], "mapped", [21254]], [[194603, 194603], "mapped", [21271]], [[194604, 194604], "mapped", [21321]], [[194605, 194605], "mapped", [21329]], [[194606, 194606], "mapped", [21338]], [[194607, 194607], "mapped", [21363]], [[194608, 194608], "mapped", [21373]], [[194609, 194611], "mapped", [21375]], [[194612, 194612], "mapped", [133676]], [[194613, 194613], "mapped", [28784]], [[194614, 194614], "mapped", [21450]], [[194615, 194615], "mapped", [21471]], [[194616, 194616], "mapped", [133987]], [[194617, 194617], "mapped", [21483]], [[194618, 194618], "mapped", [21489]], [[194619, 194619], "mapped", [21510]], [[194620, 194620], "mapped", [21662]], [[194621, 194621], "mapped", [21560]], [[194622, 194622], "mapped", [21576]], [[194623, 194623], "mapped", [21608]], [[194624, 194624], "mapped", [21666]], [[194625, 194625], "mapped", [21750]], [[194626, 194626], "mapped", [21776]], [[194627, 194627], "mapped", [21843]], [[194628, 194628], "mapped", [21859]], [[194629, 194630], "mapped", [21892]], [[194631, 194631], "mapped", [21913]], [[194632, 194632], "mapped", [21931]], [[194633, 194633], "mapped", [21939]], [[194634, 194634], "mapped", [21954]], [[194635, 194635], "mapped", [22294]], [[194636, 194636], "mapped", [22022]], [[194637, 194637], "mapped", [22295]], [[194638, 194638], "mapped", [22097]], [[194639, 194639], "mapped", [22132]], [[194640, 194640], "mapped", [20999]], [[194641, 194641], "mapped", [22766]], [[194642, 194642], "mapped", [22478]], [[194643, 194643], "mapped", [22516]], [[194644, 194644], "mapped", [22541]], [[194645, 194645], "mapped", [22411]], [[194646, 194646], "mapped", [22578]], [[194647, 194647], "mapped", [22577]], [[194648, 194648], "mapped", [22700]], [[194649, 194649], "mapped", [136420]], [[194650, 194650], "mapped", [22770]], [[194651, 194651], "mapped", [22775]], [[194652, 194652], "mapped", [22790]], [[194653, 194653], "mapped", [22810]], [[194654, 194654], "mapped", [22818]], [[194655, 194655], "mapped", [22882]], [[194656, 194656], "mapped", [136872]], [[194657, 194657], "mapped", [136938]], [[194658, 194658], "mapped", [23020]], [[194659, 194659], "mapped", [23067]], [[194660, 194660], "mapped", [23079]], [[194661, 194661], "mapped", [23e3]], [[194662, 194662], "mapped", [23142]], [[194663, 194663], "mapped", [14062]], [[194664, 194664], "disallowed"], [[194665, 194665], "mapped", [23304]], [[194666, 194667], "mapped", [23358]], [[194668, 194668], "mapped", [137672]], [[194669, 194669], "mapped", [23491]], [[194670, 194670], "mapped", [23512]], [[194671, 194671], "mapped", [23527]], [[194672, 194672], "mapped", [23539]], [[194673, 194673], "mapped", [138008]], [[194674, 194674], "mapped", [23551]], [[194675, 194675], "mapped", [23558]], [[194676, 194676], "disallowed"], [[194677, 194677], "mapped", [23586]], [[194678, 194678], "mapped", [14209]], [[194679, 194679], "mapped", [23648]], [[194680, 194680], "mapped", [23662]], [[194681, 194681], "mapped", [23744]], [[194682, 194682], "mapped", [23693]], [[194683, 194683], "mapped", [138724]], [[194684, 194684], "mapped", [23875]], [[194685, 194685], "mapped", [138726]], [[194686, 194686], "mapped", [23918]], [[194687, 194687], "mapped", [23915]], [[194688, 194688], "mapped", [23932]], [[194689, 194689], "mapped", [24033]], [[194690, 194690], "mapped", [24034]], [[194691, 194691], "mapped", [14383]], [[194692, 194692], "mapped", [24061]], [[194693, 194693], "mapped", [24104]], [[194694, 194694], "mapped", [24125]], [[194695, 194695], "mapped", [24169]], [[194696, 194696], "mapped", [14434]], [[194697, 194697], "mapped", [139651]], [[194698, 194698], "mapped", [14460]], [[194699, 194699], "mapped", [24240]], [[194700, 194700], "mapped", [24243]], [[194701, 194701], "mapped", [24246]], [[194702, 194702], "mapped", [24266]], [[194703, 194703], "mapped", [172946]], [[194704, 194704], "mapped", [24318]], [[194705, 194706], "mapped", [140081]], [[194707, 194707], "mapped", [33281]], [[194708, 194709], "mapped", [24354]], [[194710, 194710], "mapped", [14535]], [[194711, 194711], "mapped", [144056]], [[194712, 194712], "mapped", [156122]], [[194713, 194713], "mapped", [24418]], [[194714, 194714], "mapped", [24427]], [[194715, 194715], "mapped", [14563]], [[194716, 194716], "mapped", [24474]], [[194717, 194717], "mapped", [24525]], [[194718, 194718], "mapped", [24535]], [[194719, 194719], "mapped", [24569]], [[194720, 194720], "mapped", [24705]], [[194721, 194721], "mapped", [14650]], [[194722, 194722], "mapped", [14620]], [[194723, 194723], "mapped", [24724]], [[194724, 194724], "mapped", [141012]], [[194725, 194725], "mapped", [24775]], [[194726, 194726], "mapped", [24904]], [[194727, 194727], "mapped", [24908]], [[194728, 194728], "mapped", [24910]], [[194729, 194729], "mapped", [24908]], [[194730, 194730], "mapped", [24954]], [[194731, 194731], "mapped", [24974]], [[194732, 194732], "mapped", [25010]], [[194733, 194733], "mapped", [24996]], [[194734, 194734], "mapped", [25007]], [[194735, 194735], "mapped", [25054]], [[194736, 194736], "mapped", [25074]], [[194737, 194737], "mapped", [25078]], [[194738, 194738], "mapped", [25104]], [[194739, 194739], "mapped", [25115]], [[194740, 194740], "mapped", [25181]], [[194741, 194741], "mapped", [25265]], [[194742, 194742], "mapped", [25300]], [[194743, 194743], "mapped", [25424]], [[194744, 194744], "mapped", [142092]], [[194745, 194745], "mapped", [25405]], [[194746, 194746], "mapped", [25340]], [[194747, 194747], "mapped", [25448]], [[194748, 194748], "mapped", [25475]], [[194749, 194749], "mapped", [25572]], [[194750, 194750], "mapped", [142321]], [[194751, 194751], "mapped", [25634]], [[194752, 194752], "mapped", [25541]], [[194753, 194753], "mapped", [25513]], [[194754, 194754], "mapped", [14894]], [[194755, 194755], "mapped", [25705]], [[194756, 194756], "mapped", [25726]], [[194757, 194757], "mapped", [25757]], [[194758, 194758], "mapped", [25719]], [[194759, 194759], "mapped", [14956]], [[194760, 194760], "mapped", [25935]], [[194761, 194761], "mapped", [25964]], [[194762, 194762], "mapped", [143370]], [[194763, 194763], "mapped", [26083]], [[194764, 194764], "mapped", [26360]], [[194765, 194765], "mapped", [26185]], [[194766, 194766], "mapped", [15129]], [[194767, 194767], "mapped", [26257]], [[194768, 194768], "mapped", [15112]], [[194769, 194769], "mapped", [15076]], [[194770, 194770], "mapped", [20882]], [[194771, 194771], "mapped", [20885]], [[194772, 194772], "mapped", [26368]], [[194773, 194773], "mapped", [26268]], [[194774, 194774], "mapped", [32941]], [[194775, 194775], "mapped", [17369]], [[194776, 194776], "mapped", [26391]], [[194777, 194777], "mapped", [26395]], [[194778, 194778], "mapped", [26401]], [[194779, 194779], "mapped", [26462]], [[194780, 194780], "mapped", [26451]], [[194781, 194781], "mapped", [144323]], [[194782, 194782], "mapped", [15177]], [[194783, 194783], "mapped", [26618]], [[194784, 194784], "mapped", [26501]], [[194785, 194785], "mapped", [26706]], [[194786, 194786], "mapped", [26757]], [[194787, 194787], "mapped", [144493]], [[194788, 194788], "mapped", [26766]], [[194789, 194789], "mapped", [26655]], [[194790, 194790], "mapped", [26900]], [[194791, 194791], "mapped", [15261]], [[194792, 194792], "mapped", [26946]], [[194793, 194793], "mapped", [27043]], [[194794, 194794], "mapped", [27114]], [[194795, 194795], "mapped", [27304]], [[194796, 194796], "mapped", [145059]], [[194797, 194797], "mapped", [27355]], [[194798, 194798], "mapped", [15384]], [[194799, 194799], "mapped", [27425]], [[194800, 194800], "mapped", [145575]], [[194801, 194801], "mapped", [27476]], [[194802, 194802], "mapped", [15438]], [[194803, 194803], "mapped", [27506]], [[194804, 194804], "mapped", [27551]], [[194805, 194805], "mapped", [27578]], [[194806, 194806], "mapped", [27579]], [[194807, 194807], "mapped", [146061]], [[194808, 194808], "mapped", [138507]], [[194809, 194809], "mapped", [146170]], [[194810, 194810], "mapped", [27726]], [[194811, 194811], "mapped", [146620]], [[194812, 194812], "mapped", [27839]], [[194813, 194813], "mapped", [27853]], [[194814, 194814], "mapped", [27751]], [[194815, 194815], "mapped", [27926]], [[194816, 194816], "mapped", [27966]], [[194817, 194817], "mapped", [28023]], [[194818, 194818], "mapped", [27969]], [[194819, 194819], "mapped", [28009]], [[194820, 194820], "mapped", [28024]], [[194821, 194821], "mapped", [28037]], [[194822, 194822], "mapped", [146718]], [[194823, 194823], "mapped", [27956]], [[194824, 194824], "mapped", [28207]], [[194825, 194825], "mapped", [28270]], [[194826, 194826], "mapped", [15667]], [[194827, 194827], "mapped", [28363]], [[194828, 194828], "mapped", [28359]], [[194829, 194829], "mapped", [147153]], [[194830, 194830], "mapped", [28153]], [[194831, 194831], "mapped", [28526]], [[194832, 194832], "mapped", [147294]], [[194833, 194833], "mapped", [147342]], [[194834, 194834], "mapped", [28614]], [[194835, 194835], "mapped", [28729]], [[194836, 194836], "mapped", [28702]], [[194837, 194837], "mapped", [28699]], [[194838, 194838], "mapped", [15766]], [[194839, 194839], "mapped", [28746]], [[194840, 194840], "mapped", [28797]], [[194841, 194841], "mapped", [28791]], [[194842, 194842], "mapped", [28845]], [[194843, 194843], "mapped", [132389]], [[194844, 194844], "mapped", [28997]], [[194845, 194845], "mapped", [148067]], [[194846, 194846], "mapped", [29084]], [[194847, 194847], "disallowed"], [[194848, 194848], "mapped", [29224]], [[194849, 194849], "mapped", [29237]], [[194850, 194850], "mapped", [29264]], [[194851, 194851], "mapped", [149e3]], [[194852, 194852], "mapped", [29312]], [[194853, 194853], "mapped", [29333]], [[194854, 194854], "mapped", [149301]], [[194855, 194855], "mapped", [149524]], [[194856, 194856], "mapped", [29562]], [[194857, 194857], "mapped", [29579]], [[194858, 194858], "mapped", [16044]], [[194859, 194859], "mapped", [29605]], [[194860, 194861], "mapped", [16056]], [[194862, 194862], "mapped", [29767]], [[194863, 194863], "mapped", [29788]], [[194864, 194864], "mapped", [29809]], [[194865, 194865], "mapped", [29829]], [[194866, 194866], "mapped", [29898]], [[194867, 194867], "mapped", [16155]], [[194868, 194868], "mapped", [29988]], [[194869, 194869], "mapped", [150582]], [[194870, 194870], "mapped", [30014]], [[194871, 194871], "mapped", [150674]], [[194872, 194872], "mapped", [30064]], [[194873, 194873], "mapped", [139679]], [[194874, 194874], "mapped", [30224]], [[194875, 194875], "mapped", [151457]], [[194876, 194876], "mapped", [151480]], [[194877, 194877], "mapped", [151620]], [[194878, 194878], "mapped", [16380]], [[194879, 194879], "mapped", [16392]], [[194880, 194880], "mapped", [30452]], [[194881, 194881], "mapped", [151795]], [[194882, 194882], "mapped", [151794]], [[194883, 194883], "mapped", [151833]], [[194884, 194884], "mapped", [151859]], [[194885, 194885], "mapped", [30494]], [[194886, 194887], "mapped", [30495]], [[194888, 194888], "mapped", [30538]], [[194889, 194889], "mapped", [16441]], [[194890, 194890], "mapped", [30603]], [[194891, 194891], "mapped", [16454]], [[194892, 194892], "mapped", [16534]], [[194893, 194893], "mapped", [152605]], [[194894, 194894], "mapped", [30798]], [[194895, 194895], "mapped", [30860]], [[194896, 194896], "mapped", [30924]], [[194897, 194897], "mapped", [16611]], [[194898, 194898], "mapped", [153126]], [[194899, 194899], "mapped", [31062]], [[194900, 194900], "mapped", [153242]], [[194901, 194901], "mapped", [153285]], [[194902, 194902], "mapped", [31119]], [[194903, 194903], "mapped", [31211]], [[194904, 194904], "mapped", [16687]], [[194905, 194905], "mapped", [31296]], [[194906, 194906], "mapped", [31306]], [[194907, 194907], "mapped", [31311]], [[194908, 194908], "mapped", [153980]], [[194909, 194910], "mapped", [154279]], [[194911, 194911], "disallowed"], [[194912, 194912], "mapped", [16898]], [[194913, 194913], "mapped", [154539]], [[194914, 194914], "mapped", [31686]], [[194915, 194915], "mapped", [31689]], [[194916, 194916], "mapped", [16935]], [[194917, 194917], "mapped", [154752]], [[194918, 194918], "mapped", [31954]], [[194919, 194919], "mapped", [17056]], [[194920, 194920], "mapped", [31976]], [[194921, 194921], "mapped", [31971]], [[194922, 194922], "mapped", [32e3]], [[194923, 194923], "mapped", [155526]], [[194924, 194924], "mapped", [32099]], [[194925, 194925], "mapped", [17153]], [[194926, 194926], "mapped", [32199]], [[194927, 194927], "mapped", [32258]], [[194928, 194928], "mapped", [32325]], [[194929, 194929], "mapped", [17204]], [[194930, 194930], "mapped", [156200]], [[194931, 194931], "mapped", [156231]], [[194932, 194932], "mapped", [17241]], [[194933, 194933], "mapped", [156377]], [[194934, 194934], "mapped", [32634]], [[194935, 194935], "mapped", [156478]], [[194936, 194936], "mapped", [32661]], [[194937, 194937], "mapped", [32762]], [[194938, 194938], "mapped", [32773]], [[194939, 194939], "mapped", [156890]], [[194940, 194940], "mapped", [156963]], [[194941, 194941], "mapped", [32864]], [[194942, 194942], "mapped", [157096]], [[194943, 194943], "mapped", [32880]], [[194944, 194944], "mapped", [144223]], [[194945, 194945], "mapped", [17365]], [[194946, 194946], "mapped", [32946]], [[194947, 194947], "mapped", [33027]], [[194948, 194948], "mapped", [17419]], [[194949, 194949], "mapped", [33086]], [[194950, 194950], "mapped", [23221]], [[194951, 194951], "mapped", [157607]], [[194952, 194952], "mapped", [157621]], [[194953, 194953], "mapped", [144275]], [[194954, 194954], "mapped", [144284]], [[194955, 194955], "mapped", [33281]], [[194956, 194956], "mapped", [33284]], [[194957, 194957], "mapped", [36766]], [[194958, 194958], "mapped", [17515]], [[194959, 194959], "mapped", [33425]], [[194960, 194960], "mapped", [33419]], [[194961, 194961], "mapped", [33437]], [[194962, 194962], "mapped", [21171]], [[194963, 194963], "mapped", [33457]], [[194964, 194964], "mapped", [33459]], [[194965, 194965], "mapped", [33469]], [[194966, 194966], "mapped", [33510]], [[194967, 194967], "mapped", [158524]], [[194968, 194968], "mapped", [33509]], [[194969, 194969], "mapped", [33565]], [[194970, 194970], "mapped", [33635]], [[194971, 194971], "mapped", [33709]], [[194972, 194972], "mapped", [33571]], [[194973, 194973], "mapped", [33725]], [[194974, 194974], "mapped", [33767]], [[194975, 194975], "mapped", [33879]], [[194976, 194976], "mapped", [33619]], [[194977, 194977], "mapped", [33738]], [[194978, 194978], "mapped", [33740]], [[194979, 194979], "mapped", [33756]], [[194980, 194980], "mapped", [158774]], [[194981, 194981], "mapped", [159083]], [[194982, 194982], "mapped", [158933]], [[194983, 194983], "mapped", [17707]], [[194984, 194984], "mapped", [34033]], [[194985, 194985], "mapped", [34035]], [[194986, 194986], "mapped", [34070]], [[194987, 194987], "mapped", [160714]], [[194988, 194988], "mapped", [34148]], [[194989, 194989], "mapped", [159532]], [[194990, 194990], "mapped", [17757]], [[194991, 194991], "mapped", [17761]], [[194992, 194992], "mapped", [159665]], [[194993, 194993], "mapped", [159954]], [[194994, 194994], "mapped", [17771]], [[194995, 194995], "mapped", [34384]], [[194996, 194996], "mapped", [34396]], [[194997, 194997], "mapped", [34407]], [[194998, 194998], "mapped", [34409]], [[194999, 194999], "mapped", [34473]], [[195e3, 195e3], "mapped", [34440]], [[195001, 195001], "mapped", [34574]], [[195002, 195002], "mapped", [34530]], [[195003, 195003], "mapped", [34681]], [[195004, 195004], "mapped", [34600]], [[195005, 195005], "mapped", [34667]], [[195006, 195006], "mapped", [34694]], [[195007, 195007], "disallowed"], [[195008, 195008], "mapped", [34785]], [[195009, 195009], "mapped", [34817]], [[195010, 195010], "mapped", [17913]], [[195011, 195011], "mapped", [34912]], [[195012, 195012], "mapped", [34915]], [[195013, 195013], "mapped", [161383]], [[195014, 195014], "mapped", [35031]], [[195015, 195015], "mapped", [35038]], [[195016, 195016], "mapped", [17973]], [[195017, 195017], "mapped", [35066]], [[195018, 195018], "mapped", [13499]], [[195019, 195019], "mapped", [161966]], [[195020, 195020], "mapped", [162150]], [[195021, 195021], "mapped", [18110]], [[195022, 195022], "mapped", [18119]], [[195023, 195023], "mapped", [35488]], [[195024, 195024], "mapped", [35565]], [[195025, 195025], "mapped", [35722]], [[195026, 195026], "mapped", [35925]], [[195027, 195027], "mapped", [162984]], [[195028, 195028], "mapped", [36011]], [[195029, 195029], "mapped", [36033]], [[195030, 195030], "mapped", [36123]], [[195031, 195031], "mapped", [36215]], [[195032, 195032], "mapped", [163631]], [[195033, 195033], "mapped", [133124]], [[195034, 195034], "mapped", [36299]], [[195035, 195035], "mapped", [36284]], [[195036, 195036], "mapped", [36336]], [[195037, 195037], "mapped", [133342]], [[195038, 195038], "mapped", [36564]], [[195039, 195039], "mapped", [36664]], [[195040, 195040], "mapped", [165330]], [[195041, 195041], "mapped", [165357]], [[195042, 195042], "mapped", [37012]], [[195043, 195043], "mapped", [37105]], [[195044, 195044], "mapped", [37137]], [[195045, 195045], "mapped", [165678]], [[195046, 195046], "mapped", [37147]], [[195047, 195047], "mapped", [37432]], [[195048, 195048], "mapped", [37591]], [[195049, 195049], "mapped", [37592]], [[195050, 195050], "mapped", [37500]], [[195051, 195051], "mapped", [37881]], [[195052, 195052], "mapped", [37909]], [[195053, 195053], "mapped", [166906]], [[195054, 195054], "mapped", [38283]], [[195055, 195055], "mapped", [18837]], [[195056, 195056], "mapped", [38327]], [[195057, 195057], "mapped", [167287]], [[195058, 195058], "mapped", [18918]], [[195059, 195059], "mapped", [38595]], [[195060, 195060], "mapped", [23986]], [[195061, 195061], "mapped", [38691]], [[195062, 195062], "mapped", [168261]], [[195063, 195063], "mapped", [168474]], [[195064, 195064], "mapped", [19054]], [[195065, 195065], "mapped", [19062]], [[195066, 195066], "mapped", [38880]], [[195067, 195067], "mapped", [168970]], [[195068, 195068], "mapped", [19122]], [[195069, 195069], "mapped", [169110]], [[195070, 195071], "mapped", [38923]], [[195072, 195072], "mapped", [38953]], [[195073, 195073], "mapped", [169398]], [[195074, 195074], "mapped", [39138]], [[195075, 195075], "mapped", [19251]], [[195076, 195076], "mapped", [39209]], [[195077, 195077], "mapped", [39335]], [[195078, 195078], "mapped", [39362]], [[195079, 195079], "mapped", [39422]], [[195080, 195080], "mapped", [19406]], [[195081, 195081], "mapped", [170800]], [[195082, 195082], "mapped", [39698]], [[195083, 195083], "mapped", [4e4]], [[195084, 195084], "mapped", [40189]], [[195085, 195085], "mapped", [19662]], [[195086, 195086], "mapped", [19693]], [[195087, 195087], "mapped", [40295]], [[195088, 195088], "mapped", [172238]], [[195089, 195089], "mapped", [19704]], [[195090, 195090], "mapped", [172293]], [[195091, 195091], "mapped", [172558]], [[195092, 195092], "mapped", [172689]], [[195093, 195093], "mapped", [40635]], [[195094, 195094], "mapped", [19798]], [[195095, 195095], "mapped", [40697]], [[195096, 195096], "mapped", [40702]], [[195097, 195097], "mapped", [40709]], [[195098, 195098], "mapped", [40719]], [[195099, 195099], "mapped", [40726]], [[195100, 195100], "mapped", [40763]], [[195101, 195101], "mapped", [173568]], [[195102, 196605], "disallowed"], [[196606, 196607], "disallowed"], [[196608, 262141], "disallowed"], [[262142, 262143], "disallowed"], [[262144, 327677], "disallowed"], [[327678, 327679], "disallowed"], [[327680, 393213], "disallowed"], [[393214, 393215], "disallowed"], [[393216, 458749], "disallowed"], [[458750, 458751], "disallowed"], [[458752, 524285], "disallowed"], [[524286, 524287], "disallowed"], [[524288, 589821], "disallowed"], [[589822, 589823], "disallowed"], [[589824, 655357], "disallowed"], [[655358, 655359], "disallowed"], [[655360, 720893], "disallowed"], [[720894, 720895], "disallowed"], [[720896, 786429], "disallowed"], [[786430, 786431], "disallowed"], [[786432, 851965], "disallowed"], [[851966, 851967], "disallowed"], [[851968, 917501], "disallowed"], [[917502, 917503], "disallowed"], [[917504, 917504], "disallowed"], [[917505, 917505], "disallowed"], [[917506, 917535], "disallowed"], [[917536, 917631], "disallowed"], [[917632, 917759], "disallowed"], [[917760, 917999], "ignored"], [[918e3, 983037], "disallowed"], [[983038, 983039], "disallowed"], [[983040, 1048573], "disallowed"], [[1048574, 1048575], "disallowed"], [[1048576, 1114109], "disallowed"], [[1114110, 1114111], "disallowed"]];
  }
});

// ../../../../../node_modules/.deno/tr46@0.0.3/node_modules/tr46/index.js
var require_tr46 = __commonJS({
  "../../../../../node_modules/.deno/tr46@0.0.3/node_modules/tr46/index.js"(exports, module) {
    "use strict";
    var punycode = __require("node:punycode");
    var mappingTable = require_mappingTable();
    var PROCESSING_OPTIONS = {
      TRANSITIONAL: 0,
      NONTRANSITIONAL: 1
    };
    function normalize(str) {
      return str.split("\0").map(function(s) {
        return s.normalize("NFC");
      }).join("\0");
    }
    function findStatus(val) {
      var start = 0;
      var end = mappingTable.length - 1;
      while (start <= end) {
        var mid = Math.floor((start + end) / 2);
        var target = mappingTable[mid];
        if (target[0][0] <= val && target[0][1] >= val) {
          return target;
        } else if (target[0][0] > val) {
          end = mid - 1;
        } else {
          start = mid + 1;
        }
      }
      return null;
    }
    var regexAstralSymbols = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
    function countSymbols(string) {
      return string.replace(regexAstralSymbols, "_").length;
    }
    function mapChars(domain_name, useSTD3, processing_option) {
      var hasError = false;
      var processed = "";
      var len = countSymbols(domain_name);
      for (var i2 = 0; i2 < len; ++i2) {
        var codePoint = domain_name.codePointAt(i2);
        var status = findStatus(codePoint);
        switch (status[1]) {
          case "disallowed":
            hasError = true;
            processed += String.fromCodePoint(codePoint);
            break;
          case "ignored":
            break;
          case "mapped":
            processed += String.fromCodePoint.apply(String, status[2]);
            break;
          case "deviation":
            if (processing_option === PROCESSING_OPTIONS.TRANSITIONAL) {
              processed += String.fromCodePoint.apply(String, status[2]);
            } else {
              processed += String.fromCodePoint(codePoint);
            }
            break;
          case "valid":
            processed += String.fromCodePoint(codePoint);
            break;
          case "disallowed_STD3_mapped":
            if (useSTD3) {
              hasError = true;
              processed += String.fromCodePoint(codePoint);
            } else {
              processed += String.fromCodePoint.apply(String, status[2]);
            }
            break;
          case "disallowed_STD3_valid":
            if (useSTD3) {
              hasError = true;
            }
            processed += String.fromCodePoint(codePoint);
            break;
        }
      }
      return {
        string: processed,
        error: hasError
      };
    }
    var combiningMarksRegex = /[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08E4-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B62\u0B63\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0C00-\u0C03\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D01-\u0D03\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D82\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F\u109A-\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u180B-\u180D\u18A9\u1920-\u192B\u1930-\u193B\u19B0-\u19C0\u19C8\u19C9\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F\u1AB0-\u1ABE\u1B00-\u1B04\u1B34-\u1B44\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BE6-\u1BF3\u1C24-\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF2-\u1CF4\u1CF8\u1CF9\u1DC0-\u1DF5\u1DFC-\u1DFF\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA880\uA881\uA8B4-\uA8C4\uA8E0-\uA8F1\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9E5\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2D]|\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD804[\uDC00-\uDC02\uDC38-\uDC46\uDC7F-\uDC82\uDCB0-\uDCBA\uDD00-\uDD02\uDD27-\uDD34\uDD73\uDD80-\uDD82\uDDB3-\uDDC0\uDE2C-\uDE37\uDEDF-\uDEEA\uDF01-\uDF03\uDF3C\uDF3E-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF57\uDF62\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDCB0-\uDCC3\uDDAF-\uDDB5\uDDB8-\uDDC0\uDE30-\uDE40\uDEAB-\uDEB7]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF51-\uDF7E\uDF8F-\uDF92]|\uD82F[\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD83A[\uDCD0-\uDCD6]|\uDB40[\uDD00-\uDDEF]/;
    function validateLabel(label, processing_option) {
      if (label.substr(0, 4) === "xn--") {
        label = punycode.toUnicode(label);
        processing_option = PROCESSING_OPTIONS.NONTRANSITIONAL;
      }
      var error = false;
      if (normalize(label) !== label || label[3] === "-" && label[4] === "-" || label[0] === "-" || label[label.length - 1] === "-" || label.indexOf(".") !== -1 || label.search(combiningMarksRegex) === 0) {
        error = true;
      }
      var len = countSymbols(label);
      for (var i2 = 0; i2 < len; ++i2) {
        var status = findStatus(label.codePointAt(i2));
        if (processing === PROCESSING_OPTIONS.TRANSITIONAL && status[1] !== "valid" || processing === PROCESSING_OPTIONS.NONTRANSITIONAL && status[1] !== "valid" && status[1] !== "deviation") {
          error = true;
          break;
        }
      }
      return {
        label,
        error
      };
    }
    function processing(domain_name, useSTD3, processing_option) {
      var result = mapChars(domain_name, useSTD3, processing_option);
      result.string = normalize(result.string);
      var labels = result.string.split(".");
      for (var i2 = 0; i2 < labels.length; ++i2) {
        try {
          var validation = validateLabel(labels[i2]);
          labels[i2] = validation.label;
          result.error = result.error || validation.error;
        } catch (e) {
          result.error = true;
        }
      }
      return {
        string: labels.join("."),
        error: result.error
      };
    }
    module.exports.toASCII = function(domain_name, useSTD3, processing_option, verifyDnsLength) {
      var result = processing(domain_name, useSTD3, processing_option);
      var labels = result.string.split(".");
      labels = labels.map(function(l) {
        try {
          return punycode.toASCII(l);
        } catch (e) {
          result.error = true;
          return l;
        }
      });
      if (verifyDnsLength) {
        var total = labels.slice(0, labels.length - 1).join(".").length;
        if (total.length > 253 || total.length === 0) {
          result.error = true;
        }
        for (var i2 = 0; i2 < labels.length; ++i2) {
          if (labels.length > 63 || labels.length === 0) {
            result.error = true;
            break;
          }
        }
      }
      if (result.error) return null;
      return labels.join(".");
    };
    module.exports.toUnicode = function(domain_name, useSTD3) {
      var result = processing(domain_name, useSTD3, PROCESSING_OPTIONS.NONTRANSITIONAL);
      return {
        domain: result.string,
        error: result.error
      };
    };
    module.exports.PROCESSING_OPTIONS = PROCESSING_OPTIONS;
  }
});

// ../../../../../node_modules/.deno/whatwg-url@5.0.0/node_modules/whatwg-url/lib/url-state-machine.js
var require_url_state_machine = __commonJS({
  "../../../../../node_modules/.deno/whatwg-url@5.0.0/node_modules/whatwg-url/lib/url-state-machine.js"(exports, module) {
    "use strict";
    var punycode = __require("node:punycode");
    var tr46 = require_tr46();
    var specialSchemes = {
      ftp: 21,
      file: null,
      gopher: 70,
      http: 80,
      https: 443,
      ws: 80,
      wss: 443
    };
    var failure = Symbol("failure");
    function countSymbols(str) {
      return punycode.ucs2.decode(str).length;
    }
    function at(input, idx) {
      const c = input[idx];
      return isNaN(c) ? void 0 : String.fromCodePoint(c);
    }
    function isASCIIDigit(c) {
      return c >= 48 && c <= 57;
    }
    function isASCIIAlpha(c) {
      return c >= 65 && c <= 90 || c >= 97 && c <= 122;
    }
    function isASCIIAlphanumeric(c) {
      return isASCIIAlpha(c) || isASCIIDigit(c);
    }
    function isASCIIHex(c) {
      return isASCIIDigit(c) || c >= 65 && c <= 70 || c >= 97 && c <= 102;
    }
    function isSingleDot(buffer) {
      return buffer === "." || buffer.toLowerCase() === "%2e";
    }
    function isDoubleDot(buffer) {
      buffer = buffer.toLowerCase();
      return buffer === ".." || buffer === "%2e." || buffer === ".%2e" || buffer === "%2e%2e";
    }
    function isWindowsDriveLetterCodePoints(cp1, cp2) {
      return isASCIIAlpha(cp1) && (cp2 === 58 || cp2 === 124);
    }
    function isWindowsDriveLetterString(string) {
      return string.length === 2 && isASCIIAlpha(string.codePointAt(0)) && (string[1] === ":" || string[1] === "|");
    }
    function isNormalizedWindowsDriveLetterString(string) {
      return string.length === 2 && isASCIIAlpha(string.codePointAt(0)) && string[1] === ":";
    }
    function containsForbiddenHostCodePoint(string) {
      return string.search(/\u0000|\u0009|\u000A|\u000D|\u0020|#|%|\/|:|\?|@|\[|\\|\]/) !== -1;
    }
    function containsForbiddenHostCodePointExcludingPercent(string) {
      return string.search(/\u0000|\u0009|\u000A|\u000D|\u0020|#|\/|:|\?|@|\[|\\|\]/) !== -1;
    }
    function isSpecialScheme(scheme) {
      return specialSchemes[scheme] !== void 0;
    }
    function isSpecial(url) {
      return isSpecialScheme(url.scheme);
    }
    function defaultPort(scheme) {
      return specialSchemes[scheme];
    }
    function percentEncode(c) {
      let hex = c.toString(16).toUpperCase();
      if (hex.length === 1) {
        hex = "0" + hex;
      }
      return "%" + hex;
    }
    function utf8PercentEncode(c) {
      const buf = new Buffer(c);
      let str = "";
      for (let i2 = 0; i2 < buf.length; ++i2) {
        str += percentEncode(buf[i2]);
      }
      return str;
    }
    function utf8PercentDecode(str) {
      const input = new Buffer(str);
      const output = [];
      for (let i2 = 0; i2 < input.length; ++i2) {
        if (input[i2] !== 37) {
          output.push(input[i2]);
        } else if (input[i2] === 37 && isASCIIHex(input[i2 + 1]) && isASCIIHex(input[i2 + 2])) {
          output.push(parseInt(input.slice(i2 + 1, i2 + 3).toString(), 16));
          i2 += 2;
        } else {
          output.push(input[i2]);
        }
      }
      return new Buffer(output).toString();
    }
    function isC0ControlPercentEncode(c) {
      return c <= 31 || c > 126;
    }
    var extraPathPercentEncodeSet = /* @__PURE__ */ new Set([
      32,
      34,
      35,
      60,
      62,
      63,
      96,
      123,
      125
    ]);
    function isPathPercentEncode(c) {
      return isC0ControlPercentEncode(c) || extraPathPercentEncodeSet.has(c);
    }
    var extraUserinfoPercentEncodeSet = /* @__PURE__ */ new Set([
      47,
      58,
      59,
      61,
      64,
      91,
      92,
      93,
      94,
      124
    ]);
    function isUserinfoPercentEncode(c) {
      return isPathPercentEncode(c) || extraUserinfoPercentEncodeSet.has(c);
    }
    function percentEncodeChar(c, encodeSetPredicate) {
      const cStr = String.fromCodePoint(c);
      if (encodeSetPredicate(c)) {
        return utf8PercentEncode(cStr);
      }
      return cStr;
    }
    function parseIPv4Number(input) {
      let R = 10;
      if (input.length >= 2 && input.charAt(0) === "0" && input.charAt(1).toLowerCase() === "x") {
        input = input.substring(2);
        R = 16;
      } else if (input.length >= 2 && input.charAt(0) === "0") {
        input = input.substring(1);
        R = 8;
      }
      if (input === "") {
        return 0;
      }
      const regex = R === 10 ? /[^0-9]/ : R === 16 ? /[^0-9A-Fa-f]/ : /[^0-7]/;
      if (regex.test(input)) {
        return failure;
      }
      return parseInt(input, R);
    }
    function parseIPv4(input) {
      const parts = input.split(".");
      if (parts[parts.length - 1] === "") {
        if (parts.length > 1) {
          parts.pop();
        }
      }
      if (parts.length > 4) {
        return input;
      }
      const numbers = [];
      for (const part of parts) {
        if (part === "") {
          return input;
        }
        const n = parseIPv4Number(part);
        if (n === failure) {
          return input;
        }
        numbers.push(n);
      }
      for (let i2 = 0; i2 < numbers.length - 1; ++i2) {
        if (numbers[i2] > 255) {
          return failure;
        }
      }
      if (numbers[numbers.length - 1] >= Math.pow(256, 5 - numbers.length)) {
        return failure;
      }
      let ipv4 = numbers.pop();
      let counter = 0;
      for (const n of numbers) {
        ipv4 += n * Math.pow(256, 3 - counter);
        ++counter;
      }
      return ipv4;
    }
    function serializeIPv4(address) {
      let output = "";
      let n = address;
      for (let i2 = 1; i2 <= 4; ++i2) {
        output = String(n % 256) + output;
        if (i2 !== 4) {
          output = "." + output;
        }
        n = Math.floor(n / 256);
      }
      return output;
    }
    function parseIPv6(input) {
      const address = [
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0
      ];
      let pieceIndex = 0;
      let compress = null;
      let pointer = 0;
      input = punycode.ucs2.decode(input);
      if (input[pointer] === 58) {
        if (input[pointer + 1] !== 58) {
          return failure;
        }
        pointer += 2;
        ++pieceIndex;
        compress = pieceIndex;
      }
      while (pointer < input.length) {
        if (pieceIndex === 8) {
          return failure;
        }
        if (input[pointer] === 58) {
          if (compress !== null) {
            return failure;
          }
          ++pointer;
          ++pieceIndex;
          compress = pieceIndex;
          continue;
        }
        let value = 0;
        let length = 0;
        while (length < 4 && isASCIIHex(input[pointer])) {
          value = value * 16 + parseInt(at(input, pointer), 16);
          ++pointer;
          ++length;
        }
        if (input[pointer] === 46) {
          if (length === 0) {
            return failure;
          }
          pointer -= length;
          if (pieceIndex > 6) {
            return failure;
          }
          let numbersSeen = 0;
          while (input[pointer] !== void 0) {
            let ipv4Piece = null;
            if (numbersSeen > 0) {
              if (input[pointer] === 46 && numbersSeen < 4) {
                ++pointer;
              } else {
                return failure;
              }
            }
            if (!isASCIIDigit(input[pointer])) {
              return failure;
            }
            while (isASCIIDigit(input[pointer])) {
              const number = parseInt(at(input, pointer));
              if (ipv4Piece === null) {
                ipv4Piece = number;
              } else if (ipv4Piece === 0) {
                return failure;
              } else {
                ipv4Piece = ipv4Piece * 10 + number;
              }
              if (ipv4Piece > 255) {
                return failure;
              }
              ++pointer;
            }
            address[pieceIndex] = address[pieceIndex] * 256 + ipv4Piece;
            ++numbersSeen;
            if (numbersSeen === 2 || numbersSeen === 4) {
              ++pieceIndex;
            }
          }
          if (numbersSeen !== 4) {
            return failure;
          }
          break;
        } else if (input[pointer] === 58) {
          ++pointer;
          if (input[pointer] === void 0) {
            return failure;
          }
        } else if (input[pointer] !== void 0) {
          return failure;
        }
        address[pieceIndex] = value;
        ++pieceIndex;
      }
      if (compress !== null) {
        let swaps = pieceIndex - compress;
        pieceIndex = 7;
        while (pieceIndex !== 0 && swaps > 0) {
          const temp = address[compress + swaps - 1];
          address[compress + swaps - 1] = address[pieceIndex];
          address[pieceIndex] = temp;
          --pieceIndex;
          --swaps;
        }
      } else if (compress === null && pieceIndex !== 8) {
        return failure;
      }
      return address;
    }
    function serializeIPv6(address) {
      let output = "";
      const seqResult = findLongestZeroSequence(address);
      const compress = seqResult.idx;
      let ignore0 = false;
      for (let pieceIndex = 0; pieceIndex <= 7; ++pieceIndex) {
        if (ignore0 && address[pieceIndex] === 0) {
          continue;
        } else if (ignore0) {
          ignore0 = false;
        }
        if (compress === pieceIndex) {
          const separator = pieceIndex === 0 ? "::" : ":";
          output += separator;
          ignore0 = true;
          continue;
        }
        output += address[pieceIndex].toString(16);
        if (pieceIndex !== 7) {
          output += ":";
        }
      }
      return output;
    }
    function parseHost(input, isSpecialArg) {
      if (input[0] === "[") {
        if (input[input.length - 1] !== "]") {
          return failure;
        }
        return parseIPv6(input.substring(1, input.length - 1));
      }
      if (!isSpecialArg) {
        return parseOpaqueHost(input);
      }
      const domain = utf8PercentDecode(input);
      const asciiDomain = tr46.toASCII(domain, false, tr46.PROCESSING_OPTIONS.NONTRANSITIONAL, false);
      if (asciiDomain === null) {
        return failure;
      }
      if (containsForbiddenHostCodePoint(asciiDomain)) {
        return failure;
      }
      const ipv4Host = parseIPv4(asciiDomain);
      if (typeof ipv4Host === "number" || ipv4Host === failure) {
        return ipv4Host;
      }
      return asciiDomain;
    }
    function parseOpaqueHost(input) {
      if (containsForbiddenHostCodePointExcludingPercent(input)) {
        return failure;
      }
      let output = "";
      const decoded = punycode.ucs2.decode(input);
      for (let i2 = 0; i2 < decoded.length; ++i2) {
        output += percentEncodeChar(decoded[i2], isC0ControlPercentEncode);
      }
      return output;
    }
    function findLongestZeroSequence(arr) {
      let maxIdx = null;
      let maxLen = 1;
      let currStart = null;
      let currLen = 0;
      for (let i2 = 0; i2 < arr.length; ++i2) {
        if (arr[i2] !== 0) {
          if (currLen > maxLen) {
            maxIdx = currStart;
            maxLen = currLen;
          }
          currStart = null;
          currLen = 0;
        } else {
          if (currStart === null) {
            currStart = i2;
          }
          ++currLen;
        }
      }
      if (currLen > maxLen) {
        maxIdx = currStart;
        maxLen = currLen;
      }
      return {
        idx: maxIdx,
        len: maxLen
      };
    }
    function serializeHost(host) {
      if (typeof host === "number") {
        return serializeIPv4(host);
      }
      if (host instanceof Array) {
        return "[" + serializeIPv6(host) + "]";
      }
      return host;
    }
    function trimControlChars(url) {
      return url.replace(/^[\u0000-\u001F\u0020]+|[\u0000-\u001F\u0020]+$/g, "");
    }
    function trimTabAndNewline(url) {
      return url.replace(/\u0009|\u000A|\u000D/g, "");
    }
    function shortenPath(url) {
      const path2 = url.path;
      if (path2.length === 0) {
        return;
      }
      if (url.scheme === "file" && path2.length === 1 && isNormalizedWindowsDriveLetter(path2[0])) {
        return;
      }
      path2.pop();
    }
    function includesCredentials(url) {
      return url.username !== "" || url.password !== "";
    }
    function cannotHaveAUsernamePasswordPort(url) {
      return url.host === null || url.host === "" || url.cannotBeABaseURL || url.scheme === "file";
    }
    function isNormalizedWindowsDriveLetter(string) {
      return /^[A-Za-z]:$/.test(string);
    }
    function URLStateMachine(input, base, encodingOverride, url, stateOverride) {
      this.pointer = 0;
      this.input = input;
      this.base = base || null;
      this.encodingOverride = encodingOverride || "utf-8";
      this.stateOverride = stateOverride;
      this.url = url;
      this.failure = false;
      this.parseError = false;
      if (!this.url) {
        this.url = {
          scheme: "",
          username: "",
          password: "",
          host: null,
          port: null,
          path: [],
          query: null,
          fragment: null,
          cannotBeABaseURL: false
        };
        const res2 = trimControlChars(this.input);
        if (res2 !== this.input) {
          this.parseError = true;
        }
        this.input = res2;
      }
      const res = trimTabAndNewline(this.input);
      if (res !== this.input) {
        this.parseError = true;
      }
      this.input = res;
      this.state = stateOverride || "scheme start";
      this.buffer = "";
      this.atFlag = false;
      this.arrFlag = false;
      this.passwordTokenSeenFlag = false;
      this.input = punycode.ucs2.decode(this.input);
      for (; this.pointer <= this.input.length; ++this.pointer) {
        const c = this.input[this.pointer];
        const cStr = isNaN(c) ? void 0 : String.fromCodePoint(c);
        const ret = this["parse " + this.state](c, cStr);
        if (!ret) {
          break;
        } else if (ret === failure) {
          this.failure = true;
          break;
        }
      }
    }
    URLStateMachine.prototype["parse scheme start"] = function parseSchemeStart(c, cStr) {
      if (isASCIIAlpha(c)) {
        this.buffer += cStr.toLowerCase();
        this.state = "scheme";
      } else if (!this.stateOverride) {
        this.state = "no scheme";
        --this.pointer;
      } else {
        this.parseError = true;
        return failure;
      }
      return true;
    };
    URLStateMachine.prototype["parse scheme"] = function parseScheme(c, cStr) {
      if (isASCIIAlphanumeric(c) || c === 43 || c === 45 || c === 46) {
        this.buffer += cStr.toLowerCase();
      } else if (c === 58) {
        if (this.stateOverride) {
          if (isSpecial(this.url) && !isSpecialScheme(this.buffer)) {
            return false;
          }
          if (!isSpecial(this.url) && isSpecialScheme(this.buffer)) {
            return false;
          }
          if ((includesCredentials(this.url) || this.url.port !== null) && this.buffer === "file") {
            return false;
          }
          if (this.url.scheme === "file" && (this.url.host === "" || this.url.host === null)) {
            return false;
          }
        }
        this.url.scheme = this.buffer;
        this.buffer = "";
        if (this.stateOverride) {
          return false;
        }
        if (this.url.scheme === "file") {
          if (this.input[this.pointer + 1] !== 47 || this.input[this.pointer + 2] !== 47) {
            this.parseError = true;
          }
          this.state = "file";
        } else if (isSpecial(this.url) && this.base !== null && this.base.scheme === this.url.scheme) {
          this.state = "special relative or authority";
        } else if (isSpecial(this.url)) {
          this.state = "special authority slashes";
        } else if (this.input[this.pointer + 1] === 47) {
          this.state = "path or authority";
          ++this.pointer;
        } else {
          this.url.cannotBeABaseURL = true;
          this.url.path.push("");
          this.state = "cannot-be-a-base-URL path";
        }
      } else if (!this.stateOverride) {
        this.buffer = "";
        this.state = "no scheme";
        this.pointer = -1;
      } else {
        this.parseError = true;
        return failure;
      }
      return true;
    };
    URLStateMachine.prototype["parse no scheme"] = function parseNoScheme(c) {
      if (this.base === null || this.base.cannotBeABaseURL && c !== 35) {
        return failure;
      } else if (this.base.cannotBeABaseURL && c === 35) {
        this.url.scheme = this.base.scheme;
        this.url.path = this.base.path.slice();
        this.url.query = this.base.query;
        this.url.fragment = "";
        this.url.cannotBeABaseURL = true;
        this.state = "fragment";
      } else if (this.base.scheme === "file") {
        this.state = "file";
        --this.pointer;
      } else {
        this.state = "relative";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse special relative or authority"] = function parseSpecialRelativeOrAuthority(c) {
      if (c === 47 && this.input[this.pointer + 1] === 47) {
        this.state = "special authority ignore slashes";
        ++this.pointer;
      } else {
        this.parseError = true;
        this.state = "relative";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse path or authority"] = function parsePathOrAuthority(c) {
      if (c === 47) {
        this.state = "authority";
      } else {
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse relative"] = function parseRelative(c) {
      this.url.scheme = this.base.scheme;
      if (isNaN(c)) {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.url.path = this.base.path.slice();
        this.url.query = this.base.query;
      } else if (c === 47) {
        this.state = "relative slash";
      } else if (c === 63) {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.url.path = this.base.path.slice();
        this.url.query = "";
        this.state = "query";
      } else if (c === 35) {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.url.path = this.base.path.slice();
        this.url.query = this.base.query;
        this.url.fragment = "";
        this.state = "fragment";
      } else if (isSpecial(this.url) && c === 92) {
        this.parseError = true;
        this.state = "relative slash";
      } else {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.url.path = this.base.path.slice(0, this.base.path.length - 1);
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse relative slash"] = function parseRelativeSlash(c) {
      if (isSpecial(this.url) && (c === 47 || c === 92)) {
        if (c === 92) {
          this.parseError = true;
        }
        this.state = "special authority ignore slashes";
      } else if (c === 47) {
        this.state = "authority";
      } else {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse special authority slashes"] = function parseSpecialAuthoritySlashes(c) {
      if (c === 47 && this.input[this.pointer + 1] === 47) {
        this.state = "special authority ignore slashes";
        ++this.pointer;
      } else {
        this.parseError = true;
        this.state = "special authority ignore slashes";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse special authority ignore slashes"] = function parseSpecialAuthorityIgnoreSlashes(c) {
      if (c !== 47 && c !== 92) {
        this.state = "authority";
        --this.pointer;
      } else {
        this.parseError = true;
      }
      return true;
    };
    URLStateMachine.prototype["parse authority"] = function parseAuthority(c, cStr) {
      if (c === 64) {
        this.parseError = true;
        if (this.atFlag) {
          this.buffer = "%40" + this.buffer;
        }
        this.atFlag = true;
        const len = countSymbols(this.buffer);
        for (let pointer = 0; pointer < len; ++pointer) {
          const codePoint = this.buffer.codePointAt(pointer);
          if (codePoint === 58 && !this.passwordTokenSeenFlag) {
            this.passwordTokenSeenFlag = true;
            continue;
          }
          const encodedCodePoints = percentEncodeChar(codePoint, isUserinfoPercentEncode);
          if (this.passwordTokenSeenFlag) {
            this.url.password += encodedCodePoints;
          } else {
            this.url.username += encodedCodePoints;
          }
        }
        this.buffer = "";
      } else if (isNaN(c) || c === 47 || c === 63 || c === 35 || isSpecial(this.url) && c === 92) {
        if (this.atFlag && this.buffer === "") {
          this.parseError = true;
          return failure;
        }
        this.pointer -= countSymbols(this.buffer) + 1;
        this.buffer = "";
        this.state = "host";
      } else {
        this.buffer += cStr;
      }
      return true;
    };
    URLStateMachine.prototype["parse hostname"] = URLStateMachine.prototype["parse host"] = function parseHostName(c, cStr) {
      if (this.stateOverride && this.url.scheme === "file") {
        --this.pointer;
        this.state = "file host";
      } else if (c === 58 && !this.arrFlag) {
        if (this.buffer === "") {
          this.parseError = true;
          return failure;
        }
        const host = parseHost(this.buffer, isSpecial(this.url));
        if (host === failure) {
          return failure;
        }
        this.url.host = host;
        this.buffer = "";
        this.state = "port";
        if (this.stateOverride === "hostname") {
          return false;
        }
      } else if (isNaN(c) || c === 47 || c === 63 || c === 35 || isSpecial(this.url) && c === 92) {
        --this.pointer;
        if (isSpecial(this.url) && this.buffer === "") {
          this.parseError = true;
          return failure;
        } else if (this.stateOverride && this.buffer === "" && (includesCredentials(this.url) || this.url.port !== null)) {
          this.parseError = true;
          return false;
        }
        const host = parseHost(this.buffer, isSpecial(this.url));
        if (host === failure) {
          return failure;
        }
        this.url.host = host;
        this.buffer = "";
        this.state = "path start";
        if (this.stateOverride) {
          return false;
        }
      } else {
        if (c === 91) {
          this.arrFlag = true;
        } else if (c === 93) {
          this.arrFlag = false;
        }
        this.buffer += cStr;
      }
      return true;
    };
    URLStateMachine.prototype["parse port"] = function parsePort(c, cStr) {
      if (isASCIIDigit(c)) {
        this.buffer += cStr;
      } else if (isNaN(c) || c === 47 || c === 63 || c === 35 || isSpecial(this.url) && c === 92 || this.stateOverride) {
        if (this.buffer !== "") {
          const port = parseInt(this.buffer);
          if (port > Math.pow(2, 16) - 1) {
            this.parseError = true;
            return failure;
          }
          this.url.port = port === defaultPort(this.url.scheme) ? null : port;
          this.buffer = "";
        }
        if (this.stateOverride) {
          return false;
        }
        this.state = "path start";
        --this.pointer;
      } else {
        this.parseError = true;
        return failure;
      }
      return true;
    };
    var fileOtherwiseCodePoints = /* @__PURE__ */ new Set([
      47,
      92,
      63,
      35
    ]);
    URLStateMachine.prototype["parse file"] = function parseFile(c) {
      this.url.scheme = "file";
      if (c === 47 || c === 92) {
        if (c === 92) {
          this.parseError = true;
        }
        this.state = "file slash";
      } else if (this.base !== null && this.base.scheme === "file") {
        if (isNaN(c)) {
          this.url.host = this.base.host;
          this.url.path = this.base.path.slice();
          this.url.query = this.base.query;
        } else if (c === 63) {
          this.url.host = this.base.host;
          this.url.path = this.base.path.slice();
          this.url.query = "";
          this.state = "query";
        } else if (c === 35) {
          this.url.host = this.base.host;
          this.url.path = this.base.path.slice();
          this.url.query = this.base.query;
          this.url.fragment = "";
          this.state = "fragment";
        } else {
          if (this.input.length - this.pointer - 1 === 0 || // remaining consists of 0 code points
          !isWindowsDriveLetterCodePoints(c, this.input[this.pointer + 1]) || this.input.length - this.pointer - 1 >= 2 && // remaining has at least 2 code points
          !fileOtherwiseCodePoints.has(this.input[this.pointer + 2])) {
            this.url.host = this.base.host;
            this.url.path = this.base.path.slice();
            shortenPath(this.url);
          } else {
            this.parseError = true;
          }
          this.state = "path";
          --this.pointer;
        }
      } else {
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse file slash"] = function parseFileSlash(c) {
      if (c === 47 || c === 92) {
        if (c === 92) {
          this.parseError = true;
        }
        this.state = "file host";
      } else {
        if (this.base !== null && this.base.scheme === "file") {
          if (isNormalizedWindowsDriveLetterString(this.base.path[0])) {
            this.url.path.push(this.base.path[0]);
          } else {
            this.url.host = this.base.host;
          }
        }
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse file host"] = function parseFileHost(c, cStr) {
      if (isNaN(c) || c === 47 || c === 92 || c === 63 || c === 35) {
        --this.pointer;
        if (!this.stateOverride && isWindowsDriveLetterString(this.buffer)) {
          this.parseError = true;
          this.state = "path";
        } else if (this.buffer === "") {
          this.url.host = "";
          if (this.stateOverride) {
            return false;
          }
          this.state = "path start";
        } else {
          let host = parseHost(this.buffer, isSpecial(this.url));
          if (host === failure) {
            return failure;
          }
          if (host === "localhost") {
            host = "";
          }
          this.url.host = host;
          if (this.stateOverride) {
            return false;
          }
          this.buffer = "";
          this.state = "path start";
        }
      } else {
        this.buffer += cStr;
      }
      return true;
    };
    URLStateMachine.prototype["parse path start"] = function parsePathStart(c) {
      if (isSpecial(this.url)) {
        if (c === 92) {
          this.parseError = true;
        }
        this.state = "path";
        if (c !== 47 && c !== 92) {
          --this.pointer;
        }
      } else if (!this.stateOverride && c === 63) {
        this.url.query = "";
        this.state = "query";
      } else if (!this.stateOverride && c === 35) {
        this.url.fragment = "";
        this.state = "fragment";
      } else if (c !== void 0) {
        this.state = "path";
        if (c !== 47) {
          --this.pointer;
        }
      }
      return true;
    };
    URLStateMachine.prototype["parse path"] = function parsePath(c) {
      if (isNaN(c) || c === 47 || isSpecial(this.url) && c === 92 || !this.stateOverride && (c === 63 || c === 35)) {
        if (isSpecial(this.url) && c === 92) {
          this.parseError = true;
        }
        if (isDoubleDot(this.buffer)) {
          shortenPath(this.url);
          if (c !== 47 && !(isSpecial(this.url) && c === 92)) {
            this.url.path.push("");
          }
        } else if (isSingleDot(this.buffer) && c !== 47 && !(isSpecial(this.url) && c === 92)) {
          this.url.path.push("");
        } else if (!isSingleDot(this.buffer)) {
          if (this.url.scheme === "file" && this.url.path.length === 0 && isWindowsDriveLetterString(this.buffer)) {
            if (this.url.host !== "" && this.url.host !== null) {
              this.parseError = true;
              this.url.host = "";
            }
            this.buffer = this.buffer[0] + ":";
          }
          this.url.path.push(this.buffer);
        }
        this.buffer = "";
        if (this.url.scheme === "file" && (c === void 0 || c === 63 || c === 35)) {
          while (this.url.path.length > 1 && this.url.path[0] === "") {
            this.parseError = true;
            this.url.path.shift();
          }
        }
        if (c === 63) {
          this.url.query = "";
          this.state = "query";
        }
        if (c === 35) {
          this.url.fragment = "";
          this.state = "fragment";
        }
      } else {
        if (c === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
          this.parseError = true;
        }
        this.buffer += percentEncodeChar(c, isPathPercentEncode);
      }
      return true;
    };
    URLStateMachine.prototype["parse cannot-be-a-base-URL path"] = function parseCannotBeABaseURLPath(c) {
      if (c === 63) {
        this.url.query = "";
        this.state = "query";
      } else if (c === 35) {
        this.url.fragment = "";
        this.state = "fragment";
      } else {
        if (!isNaN(c) && c !== 37) {
          this.parseError = true;
        }
        if (c === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
          this.parseError = true;
        }
        if (!isNaN(c)) {
          this.url.path[0] = this.url.path[0] + percentEncodeChar(c, isC0ControlPercentEncode);
        }
      }
      return true;
    };
    URLStateMachine.prototype["parse query"] = function parseQuery(c, cStr) {
      if (isNaN(c) || !this.stateOverride && c === 35) {
        if (!isSpecial(this.url) || this.url.scheme === "ws" || this.url.scheme === "wss") {
          this.encodingOverride = "utf-8";
        }
        const buffer = new Buffer(this.buffer);
        for (let i2 = 0; i2 < buffer.length; ++i2) {
          if (buffer[i2] < 33 || buffer[i2] > 126 || buffer[i2] === 34 || buffer[i2] === 35 || buffer[i2] === 60 || buffer[i2] === 62) {
            this.url.query += percentEncode(buffer[i2]);
          } else {
            this.url.query += String.fromCodePoint(buffer[i2]);
          }
        }
        this.buffer = "";
        if (c === 35) {
          this.url.fragment = "";
          this.state = "fragment";
        }
      } else {
        if (c === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
          this.parseError = true;
        }
        this.buffer += cStr;
      }
      return true;
    };
    URLStateMachine.prototype["parse fragment"] = function parseFragment(c) {
      if (isNaN(c)) {
      } else if (c === 0) {
        this.parseError = true;
      } else {
        if (c === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
          this.parseError = true;
        }
        this.url.fragment += percentEncodeChar(c, isC0ControlPercentEncode);
      }
      return true;
    };
    function serializeURL(url, excludeFragment) {
      let output = url.scheme + ":";
      if (url.host !== null) {
        output += "//";
        if (url.username !== "" || url.password !== "") {
          output += url.username;
          if (url.password !== "") {
            output += ":" + url.password;
          }
          output += "@";
        }
        output += serializeHost(url.host);
        if (url.port !== null) {
          output += ":" + url.port;
        }
      } else if (url.host === null && url.scheme === "file") {
        output += "//";
      }
      if (url.cannotBeABaseURL) {
        output += url.path[0];
      } else {
        for (const string of url.path) {
          output += "/" + string;
        }
      }
      if (url.query !== null) {
        output += "?" + url.query;
      }
      if (!excludeFragment && url.fragment !== null) {
        output += "#" + url.fragment;
      }
      return output;
    }
    function serializeOrigin(tuple) {
      let result = tuple.scheme + "://";
      result += serializeHost(tuple.host);
      if (tuple.port !== null) {
        result += ":" + tuple.port;
      }
      return result;
    }
    module.exports.serializeURL = serializeURL;
    module.exports.serializeURLOrigin = function(url) {
      switch (url.scheme) {
        case "blob":
          try {
            return module.exports.serializeURLOrigin(module.exports.parseURL(url.path[0]));
          } catch (e) {
            return "null";
          }
        case "ftp":
        case "gopher":
        case "http":
        case "https":
        case "ws":
        case "wss":
          return serializeOrigin({
            scheme: url.scheme,
            host: url.host,
            port: url.port
          });
        case "file":
          return "file://";
        default:
          return "null";
      }
    };
    module.exports.basicURLParse = function(input, options) {
      if (options === void 0) {
        options = {};
      }
      const usm = new URLStateMachine(input, options.baseURL, options.encodingOverride, options.url, options.stateOverride);
      if (usm.failure) {
        return "failure";
      }
      return usm.url;
    };
    module.exports.setTheUsername = function(url, username) {
      url.username = "";
      const decoded = punycode.ucs2.decode(username);
      for (let i2 = 0; i2 < decoded.length; ++i2) {
        url.username += percentEncodeChar(decoded[i2], isUserinfoPercentEncode);
      }
    };
    module.exports.setThePassword = function(url, password) {
      url.password = "";
      const decoded = punycode.ucs2.decode(password);
      for (let i2 = 0; i2 < decoded.length; ++i2) {
        url.password += percentEncodeChar(decoded[i2], isUserinfoPercentEncode);
      }
    };
    module.exports.serializeHost = serializeHost;
    module.exports.cannotHaveAUsernamePasswordPort = cannotHaveAUsernamePasswordPort;
    module.exports.serializeInteger = function(integer) {
      return String(integer);
    };
    module.exports.parseURL = function(input, options) {
      if (options === void 0) {
        options = {};
      }
      return module.exports.basicURLParse(input, {
        baseURL: options.baseURL,
        encodingOverride: options.encodingOverride
      });
    };
  }
});

// ../../../../../node_modules/.deno/whatwg-url@5.0.0/node_modules/whatwg-url/lib/URL-impl.js
var require_URL_impl = __commonJS({
  "../../../../../node_modules/.deno/whatwg-url@5.0.0/node_modules/whatwg-url/lib/URL-impl.js"(exports) {
    "use strict";
    var usm = require_url_state_machine();
    exports.implementation = class URLImpl {
      constructor(constructorArgs) {
        const url = constructorArgs[0];
        const base = constructorArgs[1];
        let parsedBase = null;
        if (base !== void 0) {
          parsedBase = usm.basicURLParse(base);
          if (parsedBase === "failure") {
            throw new TypeError("Invalid base URL");
          }
        }
        const parsedURL = usm.basicURLParse(url, {
          baseURL: parsedBase
        });
        if (parsedURL === "failure") {
          throw new TypeError("Invalid URL");
        }
        this._url = parsedURL;
      }
      get href() {
        return usm.serializeURL(this._url);
      }
      set href(v) {
        const parsedURL = usm.basicURLParse(v);
        if (parsedURL === "failure") {
          throw new TypeError("Invalid URL");
        }
        this._url = parsedURL;
      }
      get origin() {
        return usm.serializeURLOrigin(this._url);
      }
      get protocol() {
        return this._url.scheme + ":";
      }
      set protocol(v) {
        usm.basicURLParse(v + ":", {
          url: this._url,
          stateOverride: "scheme start"
        });
      }
      get username() {
        return this._url.username;
      }
      set username(v) {
        if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
          return;
        }
        usm.setTheUsername(this._url, v);
      }
      get password() {
        return this._url.password;
      }
      set password(v) {
        if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
          return;
        }
        usm.setThePassword(this._url, v);
      }
      get host() {
        const url = this._url;
        if (url.host === null) {
          return "";
        }
        if (url.port === null) {
          return usm.serializeHost(url.host);
        }
        return usm.serializeHost(url.host) + ":" + usm.serializeInteger(url.port);
      }
      set host(v) {
        if (this._url.cannotBeABaseURL) {
          return;
        }
        usm.basicURLParse(v, {
          url: this._url,
          stateOverride: "host"
        });
      }
      get hostname() {
        if (this._url.host === null) {
          return "";
        }
        return usm.serializeHost(this._url.host);
      }
      set hostname(v) {
        if (this._url.cannotBeABaseURL) {
          return;
        }
        usm.basicURLParse(v, {
          url: this._url,
          stateOverride: "hostname"
        });
      }
      get port() {
        if (this._url.port === null) {
          return "";
        }
        return usm.serializeInteger(this._url.port);
      }
      set port(v) {
        if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
          return;
        }
        if (v === "") {
          this._url.port = null;
        } else {
          usm.basicURLParse(v, {
            url: this._url,
            stateOverride: "port"
          });
        }
      }
      get pathname() {
        if (this._url.cannotBeABaseURL) {
          return this._url.path[0];
        }
        if (this._url.path.length === 0) {
          return "";
        }
        return "/" + this._url.path.join("/");
      }
      set pathname(v) {
        if (this._url.cannotBeABaseURL) {
          return;
        }
        this._url.path = [];
        usm.basicURLParse(v, {
          url: this._url,
          stateOverride: "path start"
        });
      }
      get search() {
        if (this._url.query === null || this._url.query === "") {
          return "";
        }
        return "?" + this._url.query;
      }
      set search(v) {
        const url = this._url;
        if (v === "") {
          url.query = null;
          return;
        }
        const input = v[0] === "?" ? v.substring(1) : v;
        url.query = "";
        usm.basicURLParse(input, {
          url,
          stateOverride: "query"
        });
      }
      get hash() {
        if (this._url.fragment === null || this._url.fragment === "") {
          return "";
        }
        return "#" + this._url.fragment;
      }
      set hash(v) {
        if (v === "") {
          this._url.fragment = null;
          return;
        }
        const input = v[0] === "#" ? v.substring(1) : v;
        this._url.fragment = "";
        usm.basicURLParse(input, {
          url: this._url,
          stateOverride: "fragment"
        });
      }
      toJSON() {
        return this.href;
      }
    };
  }
});

// ../../../../../node_modules/.deno/whatwg-url@5.0.0/node_modules/whatwg-url/lib/URL.js
var require_URL = __commonJS({
  "../../../../../node_modules/.deno/whatwg-url@5.0.0/node_modules/whatwg-url/lib/URL.js"(exports, module) {
    "use strict";
    var conversions = require_lib();
    var utils = require_utils25();
    var Impl = require_URL_impl();
    var impl = utils.implSymbol;
    function URL2(url) {
      if (!this || this[impl] || !(this instanceof URL2)) {
        throw new TypeError("Failed to construct 'URL': Please use the 'new' operator, this DOM object constructor cannot be called as a function.");
      }
      if (arguments.length < 1) {
        throw new TypeError("Failed to construct 'URL': 1 argument required, but only " + arguments.length + " present.");
      }
      const args = [];
      for (let i2 = 0; i2 < arguments.length && i2 < 2; ++i2) {
        args[i2] = arguments[i2];
      }
      args[0] = conversions["USVString"](args[0]);
      if (args[1] !== void 0) {
        args[1] = conversions["USVString"](args[1]);
      }
      module.exports.setup(this, args);
    }
    URL2.prototype.toJSON = function toJSON() {
      if (!this || !module.exports.is(this)) {
        throw new TypeError("Illegal invocation");
      }
      const args = [];
      for (let i2 = 0; i2 < arguments.length && i2 < 0; ++i2) {
        args[i2] = arguments[i2];
      }
      return this[impl].toJSON.apply(this[impl], args);
    };
    Object.defineProperty(URL2.prototype, "href", {
      get() {
        return this[impl].href;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].href = V;
      },
      enumerable: true,
      configurable: true
    });
    URL2.prototype.toString = function() {
      if (!this || !module.exports.is(this)) {
        throw new TypeError("Illegal invocation");
      }
      return this.href;
    };
    Object.defineProperty(URL2.prototype, "origin", {
      get() {
        return this[impl].origin;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL2.prototype, "protocol", {
      get() {
        return this[impl].protocol;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].protocol = V;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL2.prototype, "username", {
      get() {
        return this[impl].username;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].username = V;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL2.prototype, "password", {
      get() {
        return this[impl].password;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].password = V;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL2.prototype, "host", {
      get() {
        return this[impl].host;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].host = V;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL2.prototype, "hostname", {
      get() {
        return this[impl].hostname;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].hostname = V;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL2.prototype, "port", {
      get() {
        return this[impl].port;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].port = V;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL2.prototype, "pathname", {
      get() {
        return this[impl].pathname;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].pathname = V;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL2.prototype, "search", {
      get() {
        return this[impl].search;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].search = V;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL2.prototype, "hash", {
      get() {
        return this[impl].hash;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].hash = V;
      },
      enumerable: true,
      configurable: true
    });
    module.exports = {
      is(obj2) {
        return !!obj2 && obj2[impl] instanceof Impl.implementation;
      },
      create(constructorArgs, privateData) {
        let obj2 = Object.create(URL2.prototype);
        this.setup(obj2, constructorArgs, privateData);
        return obj2;
      },
      setup(obj2, constructorArgs, privateData) {
        if (!privateData) privateData = {};
        privateData.wrapper = obj2;
        obj2[impl] = new Impl.implementation(constructorArgs, privateData);
        obj2[impl][utils.wrapperSymbol] = obj2;
      },
      interface: URL2,
      expose: {
        Window: {
          URL: URL2
        },
        Worker: {
          URL: URL2
        }
      }
    };
  }
});

// ../../../../../node_modules/.deno/whatwg-url@5.0.0/node_modules/whatwg-url/lib/public-api.js
var require_public_api2 = __commonJS({
  "../../../../../node_modules/.deno/whatwg-url@5.0.0/node_modules/whatwg-url/lib/public-api.js"(exports) {
    "use strict";
    exports.URL = require_URL().interface;
    exports.serializeURL = require_url_state_machine().serializeURL;
    exports.serializeURLOrigin = require_url_state_machine().serializeURLOrigin;
    exports.basicURLParse = require_url_state_machine().basicURLParse;
    exports.setTheUsername = require_url_state_machine().setTheUsername;
    exports.setThePassword = require_url_state_machine().setThePassword;
    exports.serializeHost = require_url_state_machine().serializeHost;
    exports.serializeInteger = require_url_state_machine().serializeInteger;
    exports.parseURL = require_url_state_machine().parseURL;
  }
});

// ../../../../../node_modules/.deno/node-fetch@2.7.0/node_modules/node-fetch/lib/index.mjs
var lib_exports = {};
__export(lib_exports, {
  AbortError: () => AbortError,
  FetchError: () => FetchError,
  Headers: () => Headers,
  Request: () => Request,
  Response: () => Response,
  default: () => lib_default
});
import Stream from "node:stream";
import http from "node:http";
import Url from "node:url";
import https from "node:https";
import zlib from "node:zlib";
function FetchError(message, type, systemError) {
  Error.call(this, message);
  this.message = message;
  this.type = type;
  if (systemError) {
    this.code = this.errno = systemError.code;
  }
  Error.captureStackTrace(this, this.constructor);
}
function Body(body) {
  var _this = this;
  var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref$size = _ref.size;
  let size = _ref$size === void 0 ? 0 : _ref$size;
  var _ref$timeout = _ref.timeout;
  let timeout = _ref$timeout === void 0 ? 0 : _ref$timeout;
  if (body == null) {
    body = null;
  } else if (isURLSearchParams(body)) {
    body = Buffer.from(body.toString());
  } else if (isBlob(body)) ;
  else if (Buffer.isBuffer(body)) ;
  else if (Object.prototype.toString.call(body) === "[object ArrayBuffer]") {
    body = Buffer.from(body);
  } else if (ArrayBuffer.isView(body)) {
    body = Buffer.from(body.buffer, body.byteOffset, body.byteLength);
  } else if (body instanceof Stream) ;
  else {
    body = Buffer.from(String(body));
  }
  this[INTERNALS] = {
    body,
    disturbed: false,
    error: null
  };
  this.size = size;
  this.timeout = timeout;
  if (body instanceof Stream) {
    body.on("error", function(err) {
      const error = err.name === "AbortError" ? err : new FetchError(`Invalid response body while trying to fetch ${_this.url}: ${err.message}`, "system", err);
      _this[INTERNALS].error = error;
    });
  }
}
function consumeBody() {
  var _this4 = this;
  if (this[INTERNALS].disturbed) {
    return Body.Promise.reject(new TypeError(`body used already for: ${this.url}`));
  }
  this[INTERNALS].disturbed = true;
  if (this[INTERNALS].error) {
    return Body.Promise.reject(this[INTERNALS].error);
  }
  let body = this.body;
  if (body === null) {
    return Body.Promise.resolve(Buffer.alloc(0));
  }
  if (isBlob(body)) {
    body = body.stream();
  }
  if (Buffer.isBuffer(body)) {
    return Body.Promise.resolve(body);
  }
  if (!(body instanceof Stream)) {
    return Body.Promise.resolve(Buffer.alloc(0));
  }
  let accum = [];
  let accumBytes = 0;
  let abort = false;
  return new Body.Promise(function(resolve, reject) {
    let resTimeout;
    if (_this4.timeout) {
      resTimeout = setTimeout(function() {
        abort = true;
        reject(new FetchError(`Response timeout while trying to fetch ${_this4.url} (over ${_this4.timeout}ms)`, "body-timeout"));
      }, _this4.timeout);
    }
    body.on("error", function(err) {
      if (err.name === "AbortError") {
        abort = true;
        reject(err);
      } else {
        reject(new FetchError(`Invalid response body while trying to fetch ${_this4.url}: ${err.message}`, "system", err));
      }
    });
    body.on("data", function(chunk) {
      if (abort || chunk === null) {
        return;
      }
      if (_this4.size && accumBytes + chunk.length > _this4.size) {
        abort = true;
        reject(new FetchError(`content size at ${_this4.url} over limit: ${_this4.size}`, "max-size"));
        return;
      }
      accumBytes += chunk.length;
      accum.push(chunk);
    });
    body.on("end", function() {
      if (abort) {
        return;
      }
      clearTimeout(resTimeout);
      try {
        resolve(Buffer.concat(accum, accumBytes));
      } catch (err) {
        reject(new FetchError(`Could not create Buffer from response body for ${_this4.url}: ${err.message}`, "system", err));
      }
    });
  });
}
function convertBody(buffer, headers) {
  if (typeof convert !== "function") {
    throw new Error("The package `encoding` must be installed to use the textConverted() function");
  }
  const ct = headers.get("content-type");
  let charset = "utf-8";
  let res, str;
  if (ct) {
    res = /charset=([^;]*)/i.exec(ct);
  }
  str = buffer.slice(0, 1024).toString();
  if (!res && str) {
    res = /<meta.+?charset=(['"])(.+?)\1/i.exec(str);
  }
  if (!res && str) {
    res = /<meta[\s]+?http-equiv=(['"])content-type\1[\s]+?content=(['"])(.+?)\2/i.exec(str);
    if (!res) {
      res = /<meta[\s]+?content=(['"])(.+?)\1[\s]+?http-equiv=(['"])content-type\3/i.exec(str);
      if (res) {
        res.pop();
      }
    }
    if (res) {
      res = /charset=(.*)/i.exec(res.pop());
    }
  }
  if (!res && str) {
    res = /<\?xml.+?encoding=(['"])(.+?)\1/i.exec(str);
  }
  if (res) {
    charset = res.pop();
    if (charset === "gb2312" || charset === "gbk") {
      charset = "gb18030";
    }
  }
  return convert(buffer, "UTF-8", charset).toString();
}
function isURLSearchParams(obj2) {
  if (typeof obj2 !== "object" || typeof obj2.append !== "function" || typeof obj2.delete !== "function" || typeof obj2.get !== "function" || typeof obj2.getAll !== "function" || typeof obj2.has !== "function" || typeof obj2.set !== "function") {
    return false;
  }
  return obj2.constructor.name === "URLSearchParams" || Object.prototype.toString.call(obj2) === "[object URLSearchParams]" || typeof obj2.sort === "function";
}
function isBlob(obj2) {
  return typeof obj2 === "object" && typeof obj2.arrayBuffer === "function" && typeof obj2.type === "string" && typeof obj2.stream === "function" && typeof obj2.constructor === "function" && typeof obj2.constructor.name === "string" && /^(Blob|File)$/.test(obj2.constructor.name) && /^(Blob|File)$/.test(obj2[Symbol.toStringTag]);
}
function clone(instance) {
  let p1, p2;
  let body = instance.body;
  if (instance.bodyUsed) {
    throw new Error("cannot clone body after it is used");
  }
  if (body instanceof Stream && typeof body.getBoundary !== "function") {
    p1 = new PassThrough();
    p2 = new PassThrough();
    body.pipe(p1);
    body.pipe(p2);
    instance[INTERNALS].body = p1;
    body = p2;
  }
  return body;
}
function extractContentType(body) {
  if (body === null) {
    return null;
  } else if (typeof body === "string") {
    return "text/plain;charset=UTF-8";
  } else if (isURLSearchParams(body)) {
    return "application/x-www-form-urlencoded;charset=UTF-8";
  } else if (isBlob(body)) {
    return body.type || null;
  } else if (Buffer.isBuffer(body)) {
    return null;
  } else if (Object.prototype.toString.call(body) === "[object ArrayBuffer]") {
    return null;
  } else if (ArrayBuffer.isView(body)) {
    return null;
  } else if (typeof body.getBoundary === "function") {
    return `multipart/form-data;boundary=${body.getBoundary()}`;
  } else if (body instanceof Stream) {
    return null;
  } else {
    return "text/plain;charset=UTF-8";
  }
}
function getTotalBytes(instance) {
  const body = instance.body;
  if (body === null) {
    return 0;
  } else if (isBlob(body)) {
    return body.size;
  } else if (Buffer.isBuffer(body)) {
    return body.length;
  } else if (body && typeof body.getLengthSync === "function") {
    if (body._lengthRetrievers && body._lengthRetrievers.length == 0 || // 1.x
    body.hasKnownLength && body.hasKnownLength()) {
      return body.getLengthSync();
    }
    return null;
  } else {
    return null;
  }
}
function writeToStream(dest, instance) {
  const body = instance.body;
  if (body === null) {
    dest.end();
  } else if (isBlob(body)) {
    body.stream().pipe(dest);
  } else if (Buffer.isBuffer(body)) {
    dest.write(body);
    dest.end();
  } else {
    body.pipe(dest);
  }
}
function validateName(name) {
  name = `${name}`;
  if (invalidTokenRegex.test(name) || name === "") {
    throw new TypeError(`${name} is not a legal HTTP header name`);
  }
}
function validateValue(value) {
  value = `${value}`;
  if (invalidHeaderCharRegex.test(value)) {
    throw new TypeError(`${value} is not a legal HTTP header value`);
  }
}
function find(map, name) {
  name = name.toLowerCase();
  for (const key in map) {
    if (key.toLowerCase() === name) {
      return key;
    }
  }
  return void 0;
}
function getHeaders(headers) {
  let kind = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "key+value";
  const keys = Object.keys(headers[MAP]).sort();
  return keys.map(kind === "key" ? function(k) {
    return k.toLowerCase();
  } : kind === "value" ? function(k) {
    return headers[MAP][k].join(", ");
  } : function(k) {
    return [
      k.toLowerCase(),
      headers[MAP][k].join(", ")
    ];
  });
}
function createHeadersIterator(target, kind) {
  const iterator = Object.create(HeadersIteratorPrototype);
  iterator[INTERNAL] = {
    target,
    kind,
    index: 0
  };
  return iterator;
}
function exportNodeCompatibleHeaders(headers) {
  const obj2 = Object.assign({
    __proto__: null
  }, headers[MAP]);
  const hostHeaderKey = find(headers[MAP], "Host");
  if (hostHeaderKey !== void 0) {
    obj2[hostHeaderKey] = obj2[hostHeaderKey][0];
  }
  return obj2;
}
function createHeadersLenient(obj2) {
  const headers = new Headers();
  for (const name of Object.keys(obj2)) {
    if (invalidTokenRegex.test(name)) {
      continue;
    }
    if (Array.isArray(obj2[name])) {
      for (const val of obj2[name]) {
        if (invalidHeaderCharRegex.test(val)) {
          continue;
        }
        if (headers[MAP][name] === void 0) {
          headers[MAP][name] = [
            val
          ];
        } else {
          headers[MAP][name].push(val);
        }
      }
    } else if (!invalidHeaderCharRegex.test(obj2[name])) {
      headers[MAP][name] = [
        obj2[name]
      ];
    }
  }
  return headers;
}
function parseURL(urlStr) {
  if (/^[a-zA-Z][a-zA-Z\d+\-.]*:/.exec(urlStr)) {
    urlStr = new URL(urlStr).toString();
  }
  return parse_url(urlStr);
}
function isRequest(input) {
  return typeof input === "object" && typeof input[INTERNALS$2] === "object";
}
function isAbortSignal(signal) {
  const proto = signal && typeof signal === "object" && Object.getPrototypeOf(signal);
  return !!(proto && proto.constructor.name === "AbortSignal");
}
function getNodeRequestOptions(request) {
  const parsedURL = request[INTERNALS$2].parsedURL;
  const headers = new Headers(request[INTERNALS$2].headers);
  if (!headers.has("Accept")) {
    headers.set("Accept", "*/*");
  }
  if (!parsedURL.protocol || !parsedURL.hostname) {
    throw new TypeError("Only absolute URLs are supported");
  }
  if (!/^https?:$/.test(parsedURL.protocol)) {
    throw new TypeError("Only HTTP(S) protocols are supported");
  }
  if (request.signal && request.body instanceof Stream.Readable && !streamDestructionSupported) {
    throw new Error("Cancellation of streamed requests with AbortSignal is not supported in node < 8");
  }
  let contentLengthValue = null;
  if (request.body == null && /^(POST|PUT)$/i.test(request.method)) {
    contentLengthValue = "0";
  }
  if (request.body != null) {
    const totalBytes = getTotalBytes(request);
    if (typeof totalBytes === "number") {
      contentLengthValue = String(totalBytes);
    }
  }
  if (contentLengthValue) {
    headers.set("Content-Length", contentLengthValue);
  }
  if (!headers.has("User-Agent")) {
    headers.set("User-Agent", "node-fetch/1.0 (+https://github.com/bitinn/node-fetch)");
  }
  if (request.compress && !headers.has("Accept-Encoding")) {
    headers.set("Accept-Encoding", "gzip,deflate");
  }
  let agent = request.agent;
  if (typeof agent === "function") {
    agent = agent(parsedURL);
  }
  return Object.assign({}, parsedURL, {
    method: request.method,
    headers: exportNodeCompatibleHeaders(headers),
    agent
  });
}
function AbortError(message) {
  Error.call(this, message);
  this.type = "aborted";
  this.message = message;
  Error.captureStackTrace(this, this.constructor);
}
function fetch(url, opts) {
  if (!fetch.Promise) {
    throw new Error("native promise missing, set fetch.Promise to your favorite alternative");
  }
  Body.Promise = fetch.Promise;
  return new fetch.Promise(function(resolve, reject) {
    const request = new Request(url, opts);
    const options = getNodeRequestOptions(request);
    const send = (options.protocol === "https:" ? https : http).request;
    const signal = request.signal;
    let response = null;
    const abort = function abort2() {
      let error = new AbortError("The user aborted a request.");
      reject(error);
      if (request.body && request.body instanceof Stream.Readable) {
        destroyStream(request.body, error);
      }
      if (!response || !response.body) return;
      response.body.emit("error", error);
    };
    if (signal && signal.aborted) {
      abort();
      return;
    }
    const abortAndFinalize = function abortAndFinalize2() {
      abort();
      finalize();
    };
    const req = send(options);
    let reqTimeout;
    if (signal) {
      signal.addEventListener("abort", abortAndFinalize);
    }
    function finalize() {
      req.abort();
      if (signal) signal.removeEventListener("abort", abortAndFinalize);
      clearTimeout(reqTimeout);
    }
    if (request.timeout) {
      req.once("socket", function(socket) {
        reqTimeout = setTimeout(function() {
          reject(new FetchError(`network timeout at: ${request.url}`, "request-timeout"));
          finalize();
        }, request.timeout);
      });
    }
    req.on("error", function(err) {
      reject(new FetchError(`request to ${request.url} failed, reason: ${err.message}`, "system", err));
      if (response && response.body) {
        destroyStream(response.body, err);
      }
      finalize();
    });
    fixResponseChunkedTransferBadEnding(req, function(err) {
      if (signal && signal.aborted) {
        return;
      }
      if (response && response.body) {
        destroyStream(response.body, err);
      }
    });
    if (parseInt(process.version.substring(1)) < 14) {
      req.on("socket", function(s) {
        s.addListener("close", function(hadError) {
          const hasDataListener = s.listenerCount("data") > 0;
          if (response && hasDataListener && !hadError && !(signal && signal.aborted)) {
            const err = new Error("Premature close");
            err.code = "ERR_STREAM_PREMATURE_CLOSE";
            response.body.emit("error", err);
          }
        });
      });
    }
    req.on("response", function(res) {
      clearTimeout(reqTimeout);
      const headers = createHeadersLenient(res.headers);
      if (fetch.isRedirect(res.statusCode)) {
        const location2 = headers.get("Location");
        let locationURL = null;
        try {
          locationURL = location2 === null ? null : new URL$1(location2, request.url).toString();
        } catch (err) {
          if (request.redirect !== "manual") {
            reject(new FetchError(`uri requested responds with an invalid redirect URL: ${location2}`, "invalid-redirect"));
            finalize();
            return;
          }
        }
        switch (request.redirect) {
          case "error":
            reject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, "no-redirect"));
            finalize();
            return;
          case "manual":
            if (locationURL !== null) {
              try {
                headers.set("Location", locationURL);
              } catch (err) {
                reject(err);
              }
            }
            break;
          case "follow":
            if (locationURL === null) {
              break;
            }
            if (request.counter >= request.follow) {
              reject(new FetchError(`maximum redirect reached at: ${request.url}`, "max-redirect"));
              finalize();
              return;
            }
            const requestOpts = {
              headers: new Headers(request.headers),
              follow: request.follow,
              counter: request.counter + 1,
              agent: request.agent,
              compress: request.compress,
              method: request.method,
              body: request.body,
              signal: request.signal,
              timeout: request.timeout,
              size: request.size
            };
            if (!isDomainOrSubdomain(request.url, locationURL) || !isSameProtocol(request.url, locationURL)) {
              for (const name of [
                "authorization",
                "www-authenticate",
                "cookie",
                "cookie2"
              ]) {
                requestOpts.headers.delete(name);
              }
            }
            if (res.statusCode !== 303 && request.body && getTotalBytes(request) === null) {
              reject(new FetchError("Cannot follow redirect with body being a readable stream", "unsupported-redirect"));
              finalize();
              return;
            }
            if (res.statusCode === 303 || (res.statusCode === 301 || res.statusCode === 302) && request.method === "POST") {
              requestOpts.method = "GET";
              requestOpts.body = void 0;
              requestOpts.headers.delete("content-length");
            }
            resolve(fetch(new Request(locationURL, requestOpts)));
            finalize();
            return;
        }
      }
      res.once("end", function() {
        if (signal) signal.removeEventListener("abort", abortAndFinalize);
      });
      let body = res.pipe(new PassThrough$1());
      const response_options = {
        url: request.url,
        status: res.statusCode,
        statusText: res.statusMessage,
        headers,
        size: request.size,
        timeout: request.timeout,
        counter: request.counter
      };
      const codings = headers.get("Content-Encoding");
      if (!request.compress || request.method === "HEAD" || codings === null || res.statusCode === 204 || res.statusCode === 304) {
        response = new Response(body, response_options);
        resolve(response);
        return;
      }
      const zlibOptions = {
        flush: zlib.Z_SYNC_FLUSH,
        finishFlush: zlib.Z_SYNC_FLUSH
      };
      if (codings == "gzip" || codings == "x-gzip") {
        body = body.pipe(zlib.createGunzip(zlibOptions));
        response = new Response(body, response_options);
        resolve(response);
        return;
      }
      if (codings == "deflate" || codings == "x-deflate") {
        const raw = res.pipe(new PassThrough$1());
        raw.once("data", function(chunk) {
          if ((chunk[0] & 15) === 8) {
            body = body.pipe(zlib.createInflate());
          } else {
            body = body.pipe(zlib.createInflateRaw());
          }
          response = new Response(body, response_options);
          resolve(response);
        });
        raw.on("end", function() {
          if (!response) {
            response = new Response(body, response_options);
            resolve(response);
          }
        });
        return;
      }
      if (codings == "br" && typeof zlib.createBrotliDecompress === "function") {
        body = body.pipe(zlib.createBrotliDecompress());
        response = new Response(body, response_options);
        resolve(response);
        return;
      }
      response = new Response(body, response_options);
      resolve(response);
    });
    writeToStream(req, request);
  });
}
function fixResponseChunkedTransferBadEnding(request, errorCallback) {
  let socket;
  request.on("socket", function(s) {
    socket = s;
  });
  request.on("response", function(response) {
    const headers = response.headers;
    if (headers["transfer-encoding"] === "chunked" && !headers["content-length"]) {
      response.once("close", function(hadError) {
        const hasDataListener = socket && socket.listenerCount("data") > 0;
        if (hasDataListener && !hadError) {
          const err = new Error("Premature close");
          err.code = "ERR_STREAM_PREMATURE_CLOSE";
          errorCallback(err);
        }
      });
    }
  });
}
function destroyStream(stream, err) {
  if (stream.destroy) {
    stream.destroy(err);
  } else {
    stream.emit("error", err);
    stream.end();
  }
}
var import_whatwg_url, Readable, BUFFER, TYPE, Blob, convert, INTERNALS, PassThrough, invalidTokenRegex, invalidHeaderCharRegex, MAP, Headers, INTERNAL, HeadersIteratorPrototype, INTERNALS$1, STATUS_CODES, Response, INTERNALS$2, URL, parse_url, format_url, streamDestructionSupported, Request, URL$1, PassThrough$1, isDomainOrSubdomain, isSameProtocol, lib_default;
var init_lib = __esm({
  "../../../../../node_modules/.deno/node-fetch@2.7.0/node_modules/node-fetch/lib/index.mjs"() {
    import_whatwg_url = __toESM(require_public_api2(), 1);
    Readable = Stream.Readable;
    BUFFER = Symbol("buffer");
    TYPE = Symbol("type");
    Blob = class _Blob {
      constructor() {
        this[TYPE] = "";
        const blobParts = arguments[0];
        const options = arguments[1];
        const buffers = [];
        let size = 0;
        if (blobParts) {
          const a = blobParts;
          const length = Number(a.length);
          for (let i2 = 0; i2 < length; i2++) {
            const element = a[i2];
            let buffer;
            if (element instanceof Buffer) {
              buffer = element;
            } else if (ArrayBuffer.isView(element)) {
              buffer = Buffer.from(element.buffer, element.byteOffset, element.byteLength);
            } else if (element instanceof ArrayBuffer) {
              buffer = Buffer.from(element);
            } else if (element instanceof _Blob) {
              buffer = element[BUFFER];
            } else {
              buffer = Buffer.from(typeof element === "string" ? element : String(element));
            }
            size += buffer.length;
            buffers.push(buffer);
          }
        }
        this[BUFFER] = Buffer.concat(buffers);
        let type = options && options.type !== void 0 && String(options.type).toLowerCase();
        if (type && !/[^\u0020-\u007E]/.test(type)) {
          this[TYPE] = type;
        }
      }
      get size() {
        return this[BUFFER].length;
      }
      get type() {
        return this[TYPE];
      }
      text() {
        return Promise.resolve(this[BUFFER].toString());
      }
      arrayBuffer() {
        const buf = this[BUFFER];
        const ab = buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
        return Promise.resolve(ab);
      }
      stream() {
        const readable = new Readable();
        readable._read = function() {
        };
        readable.push(this[BUFFER]);
        readable.push(null);
        return readable;
      }
      toString() {
        return "[object Blob]";
      }
      slice() {
        const size = this.size;
        const start = arguments[0];
        const end = arguments[1];
        let relativeStart, relativeEnd;
        if (start === void 0) {
          relativeStart = 0;
        } else if (start < 0) {
          relativeStart = Math.max(size + start, 0);
        } else {
          relativeStart = Math.min(start, size);
        }
        if (end === void 0) {
          relativeEnd = size;
        } else if (end < 0) {
          relativeEnd = Math.max(size + end, 0);
        } else {
          relativeEnd = Math.min(end, size);
        }
        const span = Math.max(relativeEnd - relativeStart, 0);
        const buffer = this[BUFFER];
        const slicedBuffer = buffer.slice(relativeStart, relativeStart + span);
        const blob = new _Blob([], {
          type: arguments[2]
        });
        blob[BUFFER] = slicedBuffer;
        return blob;
      }
    };
    Object.defineProperties(Blob.prototype, {
      size: {
        enumerable: true
      },
      type: {
        enumerable: true
      },
      slice: {
        enumerable: true
      }
    });
    Object.defineProperty(Blob.prototype, Symbol.toStringTag, {
      value: "Blob",
      writable: false,
      enumerable: false,
      configurable: true
    });
    FetchError.prototype = Object.create(Error.prototype);
    FetchError.prototype.constructor = FetchError;
    FetchError.prototype.name = "FetchError";
    try {
      convert = __require("encoding").convert;
    } catch (e) {
    }
    INTERNALS = Symbol("Body internals");
    PassThrough = Stream.PassThrough;
    Body.prototype = {
      get body() {
        return this[INTERNALS].body;
      },
      get bodyUsed() {
        return this[INTERNALS].disturbed;
      },
      /**
      * Decode response as ArrayBuffer
      *
      * @return  Promise
      */
      arrayBuffer() {
        return consumeBody.call(this).then(function(buf) {
          return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
        });
      },
      /**
      * Return raw response as Blob
      *
      * @return Promise
      */
      blob() {
        let ct = this.headers && this.headers.get("content-type") || "";
        return consumeBody.call(this).then(function(buf) {
          return Object.assign(
            // Prevent copying
            new Blob([], {
              type: ct.toLowerCase()
            }),
            {
              [BUFFER]: buf
            }
          );
        });
      },
      /**
      * Decode response as json
      *
      * @return  Promise
      */
      json() {
        var _this2 = this;
        return consumeBody.call(this).then(function(buffer) {
          try {
            return JSON.parse(buffer.toString());
          } catch (err) {
            return Body.Promise.reject(new FetchError(`invalid json response body at ${_this2.url} reason: ${err.message}`, "invalid-json"));
          }
        });
      },
      /**
      * Decode response as text
      *
      * @return  Promise
      */
      text() {
        return consumeBody.call(this).then(function(buffer) {
          return buffer.toString();
        });
      },
      /**
      * Decode response as buffer (non-spec api)
      *
      * @return  Promise
      */
      buffer() {
        return consumeBody.call(this);
      },
      /**
      * Decode response as text, while automatically detecting the encoding and
      * trying to decode to UTF-8 (non-spec api)
      *
      * @return  Promise
      */
      textConverted() {
        var _this3 = this;
        return consumeBody.call(this).then(function(buffer) {
          return convertBody(buffer, _this3.headers);
        });
      }
    };
    Object.defineProperties(Body.prototype, {
      body: {
        enumerable: true
      },
      bodyUsed: {
        enumerable: true
      },
      arrayBuffer: {
        enumerable: true
      },
      blob: {
        enumerable: true
      },
      json: {
        enumerable: true
      },
      text: {
        enumerable: true
      }
    });
    Body.mixIn = function(proto) {
      for (const name of Object.getOwnPropertyNames(Body.prototype)) {
        if (!(name in proto)) {
          const desc = Object.getOwnPropertyDescriptor(Body.prototype, name);
          Object.defineProperty(proto, name, desc);
        }
      }
    };
    Body.Promise = global.Promise;
    invalidTokenRegex = /[^\^_`a-zA-Z\-0-9!#$%&'*+.|~]/;
    invalidHeaderCharRegex = /[^\t\x20-\x7e\x80-\xff]/;
    MAP = Symbol("map");
    Headers = class _Headers {
      /**
      * Headers class
      *
      * @param   Object  headers  Response headers
      * @return  Void
      */
      constructor() {
        let init = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : void 0;
        this[MAP] = /* @__PURE__ */ Object.create(null);
        if (init instanceof _Headers) {
          const rawHeaders = init.raw();
          const headerNames = Object.keys(rawHeaders);
          for (const headerName of headerNames) {
            for (const value of rawHeaders[headerName]) {
              this.append(headerName, value);
            }
          }
          return;
        }
        if (init == null) ;
        else if (typeof init === "object") {
          const method = init[Symbol.iterator];
          if (method != null) {
            if (typeof method !== "function") {
              throw new TypeError("Header pairs must be iterable");
            }
            const pairs = [];
            for (const pair of init) {
              if (typeof pair !== "object" || typeof pair[Symbol.iterator] !== "function") {
                throw new TypeError("Each header pair must be iterable");
              }
              pairs.push(Array.from(pair));
            }
            for (const pair of pairs) {
              if (pair.length !== 2) {
                throw new TypeError("Each header pair must be a name/value tuple");
              }
              this.append(pair[0], pair[1]);
            }
          } else {
            for (const key of Object.keys(init)) {
              const value = init[key];
              this.append(key, value);
            }
          }
        } else {
          throw new TypeError("Provided initializer must be an object");
        }
      }
      /**
      * Return combined header value given name
      *
      * @param   String  name  Header name
      * @return  Mixed
      */
      get(name) {
        name = `${name}`;
        validateName(name);
        const key = find(this[MAP], name);
        if (key === void 0) {
          return null;
        }
        return this[MAP][key].join(", ");
      }
      /**
      * Iterate over all headers
      *
      * @param   Function  callback  Executed for each item with parameters (value, name, thisArg)
      * @param   Boolean   thisArg   `this` context for callback function
      * @return  Void
      */
      forEach(callback) {
        let thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : void 0;
        let pairs = getHeaders(this);
        let i2 = 0;
        while (i2 < pairs.length) {
          var _pairs$i = pairs[i2];
          const name = _pairs$i[0], value = _pairs$i[1];
          callback.call(thisArg, value, name, this);
          pairs = getHeaders(this);
          i2++;
        }
      }
      /**
      * Overwrite header values given name
      *
      * @param   String  name   Header name
      * @param   String  value  Header value
      * @return  Void
      */
      set(name, value) {
        name = `${name}`;
        value = `${value}`;
        validateName(name);
        validateValue(value);
        const key = find(this[MAP], name);
        this[MAP][key !== void 0 ? key : name] = [
          value
        ];
      }
      /**
      * Append a value onto existing header
      *
      * @param   String  name   Header name
      * @param   String  value  Header value
      * @return  Void
      */
      append(name, value) {
        name = `${name}`;
        value = `${value}`;
        validateName(name);
        validateValue(value);
        const key = find(this[MAP], name);
        if (key !== void 0) {
          this[MAP][key].push(value);
        } else {
          this[MAP][name] = [
            value
          ];
        }
      }
      /**
      * Check for header name existence
      *
      * @param   String   name  Header name
      * @return  Boolean
      */
      has(name) {
        name = `${name}`;
        validateName(name);
        return find(this[MAP], name) !== void 0;
      }
      /**
      * Delete all header values given name
      *
      * @param   String  name  Header name
      * @return  Void
      */
      delete(name) {
        name = `${name}`;
        validateName(name);
        const key = find(this[MAP], name);
        if (key !== void 0) {
          delete this[MAP][key];
        }
      }
      /**
      * Return raw headers (non-spec api)
      *
      * @return  Object
      */
      raw() {
        return this[MAP];
      }
      /**
      * Get an iterator on keys.
      *
      * @return  Iterator
      */
      keys() {
        return createHeadersIterator(this, "key");
      }
      /**
      * Get an iterator on values.
      *
      * @return  Iterator
      */
      values() {
        return createHeadersIterator(this, "value");
      }
      /**
      * Get an iterator on entries.
      *
      * This is the default iterator of the Headers object.
      *
      * @return  Iterator
      */
      [Symbol.iterator]() {
        return createHeadersIterator(this, "key+value");
      }
    };
    Headers.prototype.entries = Headers.prototype[Symbol.iterator];
    Object.defineProperty(Headers.prototype, Symbol.toStringTag, {
      value: "Headers",
      writable: false,
      enumerable: false,
      configurable: true
    });
    Object.defineProperties(Headers.prototype, {
      get: {
        enumerable: true
      },
      forEach: {
        enumerable: true
      },
      set: {
        enumerable: true
      },
      append: {
        enumerable: true
      },
      has: {
        enumerable: true
      },
      delete: {
        enumerable: true
      },
      keys: {
        enumerable: true
      },
      values: {
        enumerable: true
      },
      entries: {
        enumerable: true
      }
    });
    INTERNAL = Symbol("internal");
    HeadersIteratorPrototype = Object.setPrototypeOf({
      next() {
        if (!this || Object.getPrototypeOf(this) !== HeadersIteratorPrototype) {
          throw new TypeError("Value of `this` is not a HeadersIterator");
        }
        var _INTERNAL = this[INTERNAL];
        const target = _INTERNAL.target, kind = _INTERNAL.kind, index = _INTERNAL.index;
        const values = getHeaders(target, kind);
        const len = values.length;
        if (index >= len) {
          return {
            value: void 0,
            done: true
          };
        }
        this[INTERNAL].index = index + 1;
        return {
          value: values[index],
          done: false
        };
      }
    }, Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]())));
    Object.defineProperty(HeadersIteratorPrototype, Symbol.toStringTag, {
      value: "HeadersIterator",
      writable: false,
      enumerable: false,
      configurable: true
    });
    INTERNALS$1 = Symbol("Response internals");
    STATUS_CODES = http.STATUS_CODES;
    Response = class _Response {
      constructor() {
        let body = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
        let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        Body.call(this, body, opts);
        const status = opts.status || 200;
        const headers = new Headers(opts.headers);
        if (body != null && !headers.has("Content-Type")) {
          const contentType = extractContentType(body);
          if (contentType) {
            headers.append("Content-Type", contentType);
          }
        }
        this[INTERNALS$1] = {
          url: opts.url,
          status,
          statusText: opts.statusText || STATUS_CODES[status],
          headers,
          counter: opts.counter
        };
      }
      get url() {
        return this[INTERNALS$1].url || "";
      }
      get status() {
        return this[INTERNALS$1].status;
      }
      /**
      * Convenience property representing if the request ended normally
      */
      get ok() {
        return this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300;
      }
      get redirected() {
        return this[INTERNALS$1].counter > 0;
      }
      get statusText() {
        return this[INTERNALS$1].statusText;
      }
      get headers() {
        return this[INTERNALS$1].headers;
      }
      /**
      * Clone this response
      *
      * @return  Response
      */
      clone() {
        return new _Response(clone(this), {
          url: this.url,
          status: this.status,
          statusText: this.statusText,
          headers: this.headers,
          ok: this.ok,
          redirected: this.redirected
        });
      }
    };
    Body.mixIn(Response.prototype);
    Object.defineProperties(Response.prototype, {
      url: {
        enumerable: true
      },
      status: {
        enumerable: true
      },
      ok: {
        enumerable: true
      },
      redirected: {
        enumerable: true
      },
      statusText: {
        enumerable: true
      },
      headers: {
        enumerable: true
      },
      clone: {
        enumerable: true
      }
    });
    Object.defineProperty(Response.prototype, Symbol.toStringTag, {
      value: "Response",
      writable: false,
      enumerable: false,
      configurable: true
    });
    INTERNALS$2 = Symbol("Request internals");
    URL = Url.URL || import_whatwg_url.default.URL;
    parse_url = Url.parse;
    format_url = Url.format;
    streamDestructionSupported = "destroy" in Stream.Readable.prototype;
    Request = class _Request {
      constructor(input) {
        let init = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        let parsedURL;
        if (!isRequest(input)) {
          if (input && input.href) {
            parsedURL = parseURL(input.href);
          } else {
            parsedURL = parseURL(`${input}`);
          }
          input = {};
        } else {
          parsedURL = parseURL(input.url);
        }
        let method = init.method || input.method || "GET";
        method = method.toUpperCase();
        if ((init.body != null || isRequest(input) && input.body !== null) && (method === "GET" || method === "HEAD")) {
          throw new TypeError("Request with GET/HEAD method cannot have body");
        }
        let inputBody = init.body != null ? init.body : isRequest(input) && input.body !== null ? clone(input) : null;
        Body.call(this, inputBody, {
          timeout: init.timeout || input.timeout || 0,
          size: init.size || input.size || 0
        });
        const headers = new Headers(init.headers || input.headers || {});
        if (inputBody != null && !headers.has("Content-Type")) {
          const contentType = extractContentType(inputBody);
          if (contentType) {
            headers.append("Content-Type", contentType);
          }
        }
        let signal = isRequest(input) ? input.signal : null;
        if ("signal" in init) signal = init.signal;
        if (signal != null && !isAbortSignal(signal)) {
          throw new TypeError("Expected signal to be an instanceof AbortSignal");
        }
        this[INTERNALS$2] = {
          method,
          redirect: init.redirect || input.redirect || "follow",
          headers,
          parsedURL,
          signal
        };
        this.follow = init.follow !== void 0 ? init.follow : input.follow !== void 0 ? input.follow : 20;
        this.compress = init.compress !== void 0 ? init.compress : input.compress !== void 0 ? input.compress : true;
        this.counter = init.counter || input.counter || 0;
        this.agent = init.agent || input.agent;
      }
      get method() {
        return this[INTERNALS$2].method;
      }
      get url() {
        return format_url(this[INTERNALS$2].parsedURL);
      }
      get headers() {
        return this[INTERNALS$2].headers;
      }
      get redirect() {
        return this[INTERNALS$2].redirect;
      }
      get signal() {
        return this[INTERNALS$2].signal;
      }
      /**
      * Clone this request
      *
      * @return  Request
      */
      clone() {
        return new _Request(this);
      }
    };
    Body.mixIn(Request.prototype);
    Object.defineProperty(Request.prototype, Symbol.toStringTag, {
      value: "Request",
      writable: false,
      enumerable: false,
      configurable: true
    });
    Object.defineProperties(Request.prototype, {
      method: {
        enumerable: true
      },
      url: {
        enumerable: true
      },
      headers: {
        enumerable: true
      },
      redirect: {
        enumerable: true
      },
      clone: {
        enumerable: true
      },
      signal: {
        enumerable: true
      }
    });
    AbortError.prototype = Object.create(Error.prototype);
    AbortError.prototype.constructor = AbortError;
    AbortError.prototype.name = "AbortError";
    URL$1 = Url.URL || import_whatwg_url.default.URL;
    PassThrough$1 = Stream.PassThrough;
    isDomainOrSubdomain = function isDomainOrSubdomain2(destination, original) {
      const orig = new URL$1(original).hostname;
      const dest = new URL$1(destination).hostname;
      return orig === dest || orig[orig.length - dest.length - 1] === "." && orig.endsWith(dest);
    };
    isSameProtocol = function isSameProtocol2(destination, original) {
      const orig = new URL$1(original).protocol;
      const dest = new URL$1(destination).protocol;
      return orig === dest;
    };
    fetch.isRedirect = function(code) {
      return code === 301 || code === 302 || code === 303 || code === 307 || code === 308;
    };
    fetch.Promise = global.Promise;
    lib_default = fetch;
  }
});

// ../../../../../node_modules/.deno/cross-fetch@4.1.0/node_modules/cross-fetch/dist/node-ponyfill.js
var require_node_ponyfill = __commonJS({
  "../../../../../node_modules/.deno/cross-fetch@4.1.0/node_modules/cross-fetch/dist/node-ponyfill.js"(exports, module) {
    var nodeFetch = (init_lib(), __toCommonJS(lib_exports));
    var realFetch = nodeFetch.default || nodeFetch;
    var fetch2 = function(url, options) {
      if (/^\/\//.test(url)) {
        url = "https:" + url;
      }
      return realFetch.call(this, url, options);
    };
    fetch2.ponyfill = true;
    module.exports = exports = fetch2;
    exports.fetch = fetch2;
    exports.Headers = nodeFetch.Headers;
    exports.Request = nodeFetch.Request;
    exports.Response = nodeFetch.Response;
    exports.default = fetch2;
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/input/io/$fetch.js
var require_fetch = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/input/io/$fetch.js"(exports) {
    "use strict";
    var _a;
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.fetch = void 0;
    var fetch2;
    try {
      exports.fetch = fetch2 = (_a = global.fetch) !== null && _a !== void 0 ? _a : require_node_ponyfill().default;
    } catch (_b) {
      exports.fetch = fetch2 = require_node_ponyfill().default;
    }
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/input/io/NodeIO.js
var require_NodeIO = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/input/io/NodeIO.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
          enumerable: true,
          get: function() {
            return m[k];
          }
        };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
      });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || /* @__PURE__ */ function() {
      var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      };
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i2 = 0; i2 < k.length; i2++) if (k[i2] !== "default") __createBinding(result, mod, k[i2]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : {
        "default": mod
      };
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.readableFromFileOrURL = readableFromFileOrURL;
    exports.readFromFileOrURL = readFromFileOrURL;
    var fs = __importStar(__require("node:fs"));
    var ts_necessities_1 = require_dist3();
    var browser_or_node_1 = require_dist4();
    var is_url_1 = __importDefault(require_is_url());
    var Messages_1 = require_Messages();
    var Support_1 = require_Support();
    var get_stream_1 = require_get_stream();
    var _fetch_1 = require_fetch();
    function parseHeaders(httpHeaders) {
      if (!Array.isArray(httpHeaders)) {
        return {};
      }
      return httpHeaders.reduce((result, httpHeader) => {
        if (httpHeader !== void 0 && httpHeader.length > 0) {
          const split = httpHeader.indexOf(":");
          if (split < 0) {
            return (0, Support_1.panic)(`Could not parse HTTP header "${httpHeader}".`);
          }
          const key = httpHeader.slice(0, split).trim();
          const value = httpHeader.slice(split + 1).trim();
          result[key] = value;
        }
        return result;
      }, {});
    }
    function readableFromFileOrURL(fileOrURL, httpHeaders) {
      return __awaiter(this, void 0, void 0, function* () {
        try {
          if ((0, is_url_1.default)(fileOrURL)) {
            const response = yield (0, _fetch_1.fetch)(fileOrURL, {
              headers: parseHeaders(httpHeaders)
            });
            return (0, ts_necessities_1.defined)(response.body);
          }
          if (browser_or_node_1.isNode) {
            if (fileOrURL === "-") {
              return process.stdin;
            }
            const filePath = fs.lstatSync(fileOrURL).isSymbolicLink() ? fs.readlinkSync(fileOrURL) : fileOrURL;
            if (fs.existsSync(filePath)) {
              return fs.createReadStream(filePath, "utf8");
            }
          }
        } catch (e) {
          return (0, Messages_1.messageError)("MiscReadError", {
            fileOrURL,
            message: (0, ts_necessities_1.exceptionToString)(e)
          });
        }
        return (0, Messages_1.messageError)("DriverInputFileDoesNotExist", {
          filename: fileOrURL
        });
      });
    }
    function readFromFileOrURL(fileOrURL, httpHeaders) {
      return __awaiter(this, void 0, void 0, function* () {
        const readable = yield readableFromFileOrURL(fileOrURL, httpHeaders);
        try {
          return yield (0, get_stream_1.getStream)(readable);
        } catch (e) {
          return (0, Messages_1.messageError)("MiscReadError", {
            fileOrURL,
            message: (0, ts_necessities_1.exceptionToString)(e)
          });
        }
      });
    }
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/input/FetchingJSONSchemaStore.js
var require_FetchingJSONSchemaStore = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/input/FetchingJSONSchemaStore.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.FetchingJSONSchemaStore = void 0;
    var Support_1 = require_Support();
    var NodeIO_1 = require_NodeIO();
    var JSONSchemaStore_1 = require_JSONSchemaStore();
    var FetchingJSONSchemaStore = class extends JSONSchemaStore_1.JSONSchemaStore {
      constructor(_httpHeaders) {
        super();
        this._httpHeaders = _httpHeaders;
      }
      fetch(address) {
        return __awaiter(this, void 0, void 0, function* () {
          return (0, Support_1.parseJSON)(yield (0, NodeIO_1.readFromFileOrURL)(address, this._httpHeaders), "JSON Schema", address);
        });
      }
    };
    exports.FetchingJSONSchemaStore = FetchingJSONSchemaStore;
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/input/PostmanCollection.js
var require_PostmanCollection = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/input/PostmanCollection.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.sourcesFromPostmanCollection = sourcesFromPostmanCollection;
    var Support_1 = require_Support();
    function isValidJSON(s) {
      try {
        JSON.parse(s);
        return true;
      } catch (error) {
        return false;
      }
    }
    function sourcesFromPostmanCollection(collectionJSON, collectionJSONAddress) {
      const sources = [];
      const descriptions = [];
      function processCollection(c) {
        var _a;
        if (typeof c !== "object") {
          return;
        }
        if (Array.isArray(c.item)) {
          for (const item of c.item) {
            processCollection(item);
          }
          if (c.info && typeof c.info === "object" && "description" in c.info && typeof ((_a = c.info) === null || _a === void 0 ? void 0 : _a.description) === "string") {
            descriptions.push(c.info.description);
          }
        }
        if (typeof c.name === "string" && Array.isArray(c.response)) {
          const samples = [];
          for (const r of c.response) {
            if (typeof r === "object" && typeof r.body === "string" && isValidJSON(r.body)) {
              samples.push(r.body);
            }
          }
          if (samples.length > 0) {
            const source = {
              name: c.name,
              samples
            };
            const sourceDescription = [
              c.name
            ];
            if (c.request && typeof c.request === "object") {
              const { method, url } = c.request;
              if (method !== void 0 && typeof url === "object" && "raw" in url && url.raw !== void 0) {
                sourceDescription.push(`${method} ${url.raw}`);
              }
            }
            if (c.request && typeof c.request === "object" && "description" in c.request && typeof c.request.description === "string") {
              sourceDescription.push(c.request.description);
            }
            source.description = sourceDescription.length === 0 ? void 0 : sourceDescription.join("\n\n");
            sources.push(source);
          }
        }
      }
      processCollection((0, Support_1.parseJSON)(collectionJSON, "Postman collection", collectionJSONAddress));
      const joinedDescription = descriptions.join("\n\n").trim();
      let description = void 0;
      if (joinedDescription !== "") {
        description = joinedDescription;
      }
      return {
        sources,
        description
      };
    }
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/index.js
var require_language27 = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/language/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
          enumerable: true,
          get: function() {
            return m[k];
          }
        };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.isLanguageName = exports.languageNamed = exports.defaultTargetLanguages = void 0;
    __exportStar(require_CJSON(), exports);
    __exportStar(require_CPlusPlus(), exports);
    __exportStar(require_Crystal(), exports);
    __exportStar(require_CSharp(), exports);
    __exportStar(require_Dart(), exports);
    __exportStar(require_Elixir(), exports);
    __exportStar(require_Elm(), exports);
    __exportStar(require_Golang(), exports);
    __exportStar(require_Haskell(), exports);
    __exportStar(require_Java(), exports);
    __exportStar(require_JavaScript(), exports);
    __exportStar(require_JavaScriptPropTypes(), exports);
    __exportStar(require_JSONSchema(), exports);
    __exportStar(require_Kotlin(), exports);
    __exportStar(require_Objective_C(), exports);
    __exportStar(require_Php(), exports);
    __exportStar(require_Pike(), exports);
    __exportStar(require_Python(), exports);
    __exportStar(require_Ruby(), exports);
    __exportStar(require_Rust(), exports);
    __exportStar(require_Scala3(), exports);
    __exportStar(require_Smithy4s(), exports);
    __exportStar(require_Swift(), exports);
    __exportStar(require_TypeScriptFlow(), exports);
    __exportStar(require_TypeScriptEffectSchema(), exports);
    __exportStar(require_TypeScriptZod(), exports);
    var All_1 = require_All();
    Object.defineProperty(exports, "defaultTargetLanguages", {
      enumerable: true,
      get: function() {
        return All_1.all;
      }
    });
    Object.defineProperty(exports, "languageNamed", {
      enumerable: true,
      get: function() {
        return All_1.languageNamed;
      }
    });
    Object.defineProperty(exports, "isLanguageName", {
      enumerable: true,
      get: function() {
        return All_1.isLanguageName;
      }
    });
  }
});

// ../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/index.js
var require_dist5 = __commonJS({
  "../../../../../node_modules/.deno/quicktype-core@23.2.6/node_modules/quicktype-core/dist/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
          enumerable: true,
          get: function() {
            return m[k];
          }
        };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.EnumType = exports.ClassProperty = exports.ClassType = exports.ArrayType = exports.PrimitiveType = exports.Type = exports.messageAssert = exports.messageError = exports.QuickTypeError = exports.trainMarkovChain = exports.isLetterOrDigit = exports.legalizeCharacters = exports.allUpperWordStyle = exports.firstUpperWordStyle = exports.combineWords = exports.capitalize = exports.splitIntoWords = exports.inflateBase64 = exports.checkArray = exports.checkStringMap = exports.parseJSON = exports.assertNever = exports.defined = exports.assert = exports.panic = exports.IssueAnnotationData = exports.Namer = exports.funPrefixNamer = exports.Name = exports.parenIfNeeded = exports.singleWord = exports.modifySource = exports.TargetLanguage = exports.getOptionValues = exports.Option = exports.Ref = exports.JSONSchemaInput = exports.jsonInputForTargetLanguage = exports.JSONInput = exports.InputData = exports.CompressedJSON = exports.inferenceFlagsObject = exports.defaultInferenceFlags = exports.inferenceFlagNames = exports.inferenceFlags = exports.combineRenderResults = exports.quicktype = exports.quicktypeMultiFileSync = exports.quicktypeMultiFile = exports.getTargetLanguage = void 0;
    exports.uriTypeAttributeKind = exports.ConvenienceRenderer = exports.nullableFromUnion = exports.matchType = exports.removeNullFromUnion = exports.StringTypes = exports.namesTypeAttributeKind = exports.makeNamesTypeAttributes = exports.TypeNames = exports.emptyTypeAttributes = exports.TypeAttributeKind = exports.derefTypeRef = exports.TypeBuilder = exports.sourcesFromPostmanCollection = exports.JSONSchemaStore = exports.FetchingJSONSchemaStore = exports.readFromFileOrURL = exports.readableFromFileOrURL = exports.getStream = exports.ObjectType = exports.UnionType = exports.MapType = void 0;
    var Run_1 = require_Run();
    Object.defineProperty(exports, "getTargetLanguage", {
      enumerable: true,
      get: function() {
        return Run_1.getTargetLanguage;
      }
    });
    Object.defineProperty(exports, "quicktypeMultiFile", {
      enumerable: true,
      get: function() {
        return Run_1.quicktypeMultiFile;
      }
    });
    Object.defineProperty(exports, "quicktypeMultiFileSync", {
      enumerable: true,
      get: function() {
        return Run_1.quicktypeMultiFileSync;
      }
    });
    Object.defineProperty(exports, "quicktype", {
      enumerable: true,
      get: function() {
        return Run_1.quicktype;
      }
    });
    Object.defineProperty(exports, "combineRenderResults", {
      enumerable: true,
      get: function() {
        return Run_1.combineRenderResults;
      }
    });
    var Inference_1 = require_Inference2();
    Object.defineProperty(exports, "inferenceFlags", {
      enumerable: true,
      get: function() {
        return Inference_1.inferenceFlags;
      }
    });
    Object.defineProperty(exports, "inferenceFlagNames", {
      enumerable: true,
      get: function() {
        return Inference_1.inferenceFlagNames;
      }
    });
    Object.defineProperty(exports, "defaultInferenceFlags", {
      enumerable: true,
      get: function() {
        return Inference_1.defaultInferenceFlags;
      }
    });
    Object.defineProperty(exports, "inferenceFlagsObject", {
      enumerable: true,
      get: function() {
        return Inference_1.inferenceFlagsObject;
      }
    });
    var CompressedJSON_1 = require_CompressedJSON();
    Object.defineProperty(exports, "CompressedJSON", {
      enumerable: true,
      get: function() {
        return CompressedJSON_1.CompressedJSON;
      }
    });
    var Inputs_1 = require_Inputs();
    Object.defineProperty(exports, "InputData", {
      enumerable: true,
      get: function() {
        return Inputs_1.InputData;
      }
    });
    Object.defineProperty(exports, "JSONInput", {
      enumerable: true,
      get: function() {
        return Inputs_1.JSONInput;
      }
    });
    Object.defineProperty(exports, "jsonInputForTargetLanguage", {
      enumerable: true,
      get: function() {
        return Inputs_1.jsonInputForTargetLanguage;
      }
    });
    var JSONSchemaInput_1 = require_JSONSchemaInput();
    Object.defineProperty(exports, "JSONSchemaInput", {
      enumerable: true,
      get: function() {
        return JSONSchemaInput_1.JSONSchemaInput;
      }
    });
    var JSONSchemaInput_2 = require_JSONSchemaInput();
    Object.defineProperty(exports, "Ref", {
      enumerable: true,
      get: function() {
        return JSONSchemaInput_2.Ref;
      }
    });
    var RendererOptions_1 = require_RendererOptions();
    Object.defineProperty(exports, "Option", {
      enumerable: true,
      get: function() {
        return RendererOptions_1.Option;
      }
    });
    Object.defineProperty(exports, "getOptionValues", {
      enumerable: true,
      get: function() {
        return RendererOptions_1.getOptionValues;
      }
    });
    var TargetLanguage_1 = require_TargetLanguage();
    Object.defineProperty(exports, "TargetLanguage", {
      enumerable: true,
      get: function() {
        return TargetLanguage_1.TargetLanguage;
      }
    });
    var Source_1 = require_Source();
    Object.defineProperty(exports, "modifySource", {
      enumerable: true,
      get: function() {
        return Source_1.modifySource;
      }
    });
    Object.defineProperty(exports, "singleWord", {
      enumerable: true,
      get: function() {
        return Source_1.singleWord;
      }
    });
    Object.defineProperty(exports, "parenIfNeeded", {
      enumerable: true,
      get: function() {
        return Source_1.parenIfNeeded;
      }
    });
    var Naming_1 = require_Naming();
    Object.defineProperty(exports, "Name", {
      enumerable: true,
      get: function() {
        return Naming_1.Name;
      }
    });
    Object.defineProperty(exports, "funPrefixNamer", {
      enumerable: true,
      get: function() {
        return Naming_1.funPrefixNamer;
      }
    });
    Object.defineProperty(exports, "Namer", {
      enumerable: true,
      get: function() {
        return Naming_1.Namer;
      }
    });
    var Annotation_1 = require_Annotation();
    Object.defineProperty(exports, "IssueAnnotationData", {
      enumerable: true,
      get: function() {
        return Annotation_1.IssueAnnotationData;
      }
    });
    var Support_1 = require_Support();
    Object.defineProperty(exports, "panic", {
      enumerable: true,
      get: function() {
        return Support_1.panic;
      }
    });
    Object.defineProperty(exports, "assert", {
      enumerable: true,
      get: function() {
        return Support_1.assert;
      }
    });
    Object.defineProperty(exports, "defined", {
      enumerable: true,
      get: function() {
        return Support_1.defined;
      }
    });
    Object.defineProperty(exports, "assertNever", {
      enumerable: true,
      get: function() {
        return Support_1.assertNever;
      }
    });
    Object.defineProperty(exports, "parseJSON", {
      enumerable: true,
      get: function() {
        return Support_1.parseJSON;
      }
    });
    Object.defineProperty(exports, "checkStringMap", {
      enumerable: true,
      get: function() {
        return Support_1.checkStringMap;
      }
    });
    Object.defineProperty(exports, "checkArray", {
      enumerable: true,
      get: function() {
        return Support_1.checkArray;
      }
    });
    Object.defineProperty(exports, "inflateBase64", {
      enumerable: true,
      get: function() {
        return Support_1.inflateBase64;
      }
    });
    var Strings_1 = require_Strings();
    Object.defineProperty(exports, "splitIntoWords", {
      enumerable: true,
      get: function() {
        return Strings_1.splitIntoWords;
      }
    });
    Object.defineProperty(exports, "capitalize", {
      enumerable: true,
      get: function() {
        return Strings_1.capitalize;
      }
    });
    Object.defineProperty(exports, "combineWords", {
      enumerable: true,
      get: function() {
        return Strings_1.combineWords;
      }
    });
    Object.defineProperty(exports, "firstUpperWordStyle", {
      enumerable: true,
      get: function() {
        return Strings_1.firstUpperWordStyle;
      }
    });
    Object.defineProperty(exports, "allUpperWordStyle", {
      enumerable: true,
      get: function() {
        return Strings_1.allUpperWordStyle;
      }
    });
    Object.defineProperty(exports, "legalizeCharacters", {
      enumerable: true,
      get: function() {
        return Strings_1.legalizeCharacters;
      }
    });
    Object.defineProperty(exports, "isLetterOrDigit", {
      enumerable: true,
      get: function() {
        return Strings_1.isLetterOrDigit;
      }
    });
    var MarkovChain_1 = require_MarkovChain();
    Object.defineProperty(exports, "trainMarkovChain", {
      enumerable: true,
      get: function() {
        return MarkovChain_1.train;
      }
    });
    var Messages_1 = require_Messages();
    Object.defineProperty(exports, "QuickTypeError", {
      enumerable: true,
      get: function() {
        return Messages_1.QuickTypeError;
      }
    });
    Object.defineProperty(exports, "messageError", {
      enumerable: true,
      get: function() {
        return Messages_1.messageError;
      }
    });
    Object.defineProperty(exports, "messageAssert", {
      enumerable: true,
      get: function() {
        return Messages_1.messageAssert;
      }
    });
    var Type_1 = require_Type2();
    Object.defineProperty(exports, "Type", {
      enumerable: true,
      get: function() {
        return Type_1.Type;
      }
    });
    Object.defineProperty(exports, "PrimitiveType", {
      enumerable: true,
      get: function() {
        return Type_1.PrimitiveType;
      }
    });
    Object.defineProperty(exports, "ArrayType", {
      enumerable: true,
      get: function() {
        return Type_1.ArrayType;
      }
    });
    Object.defineProperty(exports, "ClassType", {
      enumerable: true,
      get: function() {
        return Type_1.ClassType;
      }
    });
    Object.defineProperty(exports, "ClassProperty", {
      enumerable: true,
      get: function() {
        return Type_1.ClassProperty;
      }
    });
    Object.defineProperty(exports, "EnumType", {
      enumerable: true,
      get: function() {
        return Type_1.EnumType;
      }
    });
    Object.defineProperty(exports, "MapType", {
      enumerable: true,
      get: function() {
        return Type_1.MapType;
      }
    });
    Object.defineProperty(exports, "UnionType", {
      enumerable: true,
      get: function() {
        return Type_1.UnionType;
      }
    });
    Object.defineProperty(exports, "ObjectType", {
      enumerable: true,
      get: function() {
        return Type_1.ObjectType;
      }
    });
    var get_stream_1 = require_get_stream();
    Object.defineProperty(exports, "getStream", {
      enumerable: true,
      get: function() {
        return get_stream_1.getStream;
      }
    });
    var NodeIO_1 = require_NodeIO();
    Object.defineProperty(exports, "readableFromFileOrURL", {
      enumerable: true,
      get: function() {
        return NodeIO_1.readableFromFileOrURL;
      }
    });
    Object.defineProperty(exports, "readFromFileOrURL", {
      enumerable: true,
      get: function() {
        return NodeIO_1.readFromFileOrURL;
      }
    });
    var FetchingJSONSchemaStore_1 = require_FetchingJSONSchemaStore();
    Object.defineProperty(exports, "FetchingJSONSchemaStore", {
      enumerable: true,
      get: function() {
        return FetchingJSONSchemaStore_1.FetchingJSONSchemaStore;
      }
    });
    var JSONSchemaStore_1 = require_JSONSchemaStore();
    Object.defineProperty(exports, "JSONSchemaStore", {
      enumerable: true,
      get: function() {
        return JSONSchemaStore_1.JSONSchemaStore;
      }
    });
    var PostmanCollection_1 = require_PostmanCollection();
    Object.defineProperty(exports, "sourcesFromPostmanCollection", {
      enumerable: true,
      get: function() {
        return PostmanCollection_1.sourcesFromPostmanCollection;
      }
    });
    var TypeBuilder_1 = require_TypeBuilder();
    Object.defineProperty(exports, "TypeBuilder", {
      enumerable: true,
      get: function() {
        return TypeBuilder_1.TypeBuilder;
      }
    });
    var TypeRef_1 = require_TypeRef();
    Object.defineProperty(exports, "derefTypeRef", {
      enumerable: true,
      get: function() {
        return TypeRef_1.derefTypeRef;
      }
    });
    var TypeAttributes_1 = require_TypeAttributes();
    Object.defineProperty(exports, "TypeAttributeKind", {
      enumerable: true,
      get: function() {
        return TypeAttributes_1.TypeAttributeKind;
      }
    });
    Object.defineProperty(exports, "emptyTypeAttributes", {
      enumerable: true,
      get: function() {
        return TypeAttributes_1.emptyTypeAttributes;
      }
    });
    var TypeNames_1 = require_TypeNames();
    Object.defineProperty(exports, "TypeNames", {
      enumerable: true,
      get: function() {
        return TypeNames_1.TypeNames;
      }
    });
    Object.defineProperty(exports, "makeNamesTypeAttributes", {
      enumerable: true,
      get: function() {
        return TypeNames_1.makeNamesTypeAttributes;
      }
    });
    Object.defineProperty(exports, "namesTypeAttributeKind", {
      enumerable: true,
      get: function() {
        return TypeNames_1.namesTypeAttributeKind;
      }
    });
    var StringTypes_1 = require_StringTypes();
    Object.defineProperty(exports, "StringTypes", {
      enumerable: true,
      get: function() {
        return StringTypes_1.StringTypes;
      }
    });
    var TypeUtils_1 = require_TypeUtils();
    Object.defineProperty(exports, "removeNullFromUnion", {
      enumerable: true,
      get: function() {
        return TypeUtils_1.removeNullFromUnion;
      }
    });
    Object.defineProperty(exports, "matchType", {
      enumerable: true,
      get: function() {
        return TypeUtils_1.matchType;
      }
    });
    Object.defineProperty(exports, "nullableFromUnion", {
      enumerable: true,
      get: function() {
        return TypeUtils_1.nullableFromUnion;
      }
    });
    var ConvenienceRenderer_1 = require_ConvenienceRenderer();
    Object.defineProperty(exports, "ConvenienceRenderer", {
      enumerable: true,
      get: function() {
        return ConvenienceRenderer_1.ConvenienceRenderer;
      }
    });
    var URIAttributes_1 = require_URIAttributes();
    Object.defineProperty(exports, "uriTypeAttributeKind", {
      enumerable: true,
      get: function() {
        return URIAttributes_1.uriTypeAttributeKind;
      }
    });
    __exportStar(require_language27(), exports);
  }
});

// mod.ts
var import_npm_quicktype_core = __toESM(require_dist5());
import { relative, join } from "node:path";
async function jsonToTsInterfaces(json, i2) {
  const jsonInput = (0, import_npm_quicktype_core.jsonInputForTargetLanguage)("ts");
  const parentName = getParentFolderName() || "Root";
  let interfaceName = parentName.charAt(0).toUpperCase() + parentName.slice(1);
  interfaceName = `${interfaceName}_${i2}`;
  await jsonInput.addSource({
    name: interfaceName,
    samples: [
      json
    ]
  });
  const inputData = new import_npm_quicktype_core.InputData();
  inputData.addInput(jsonInput);
  const result = await (0, import_npm_quicktype_core.quicktype)({
    inputData,
    lang: "ts",
    rendererOptions: {
      "just-types": "true"
    }
  });
  return result.lines.join("\n");
}
async function getGitRoot() {
  const cmd2 = new Deno.Command("git", {
    args: [
      "rev-parse",
      "--show-toplevel"
    ]
  });
  const { stdout: stdout2 } = await cmd2.output();
  const root = new TextDecoder().decode(stdout2).trim();
  return root;
}
async function getEnvFile() {
  const curr2 = Deno.cwd();
  const root = await getGitRoot();
  const rel = relative(curr2, root);
  return join(rel, "env", "local");
}
async function runTest(file) {
  const curr = Deno.cwd();
  const path = join(curr, file);
  const envFile = await getEnvFile();
  console.log(`Running tests in ${path} with env file ${envFile}`);
  const cmd = new Deno.Command("deno", {
    args: [
      "test",
      "-A",
      `--env-file=${envFile}`,
      path
    ],
    stdout: "piped",
    stderr: "piped"
  });
  const { stdout, stderr } = await cmd.output();
  const stdTxt = new TextDecoder().decode(stdout);
  const errTxt = new TextDecoder().decode(stderr);
  const full = stdTxt + "\n\n" + errTxt;
  const jsObjects = [];
  let braceCount = 0;
  let currentObj = "";
  let inString = false;
  let quoteChar = null;
  for (let i = 0; i < full.length; i++) {
    const char = full[i];
    const prevChar = i > 0 ? full[i - 1] : "";
    if ((char === '"' || char === "'") && prevChar !== "\\") {
      if (!inString) {
        inString = true;
        quoteChar = char;
      } else if (char === quoteChar) {
        inString = false;
        quoteChar = null;
      }
    }
    if (!inString) {
      if (char === "{") {
        if (braceCount === 0) {
          currentObj = "{";
        } else {
          currentObj += char;
        }
        braceCount++;
      } else if (char === "}") {
        braceCount--;
        currentObj += char;
        if (braceCount === 0 && currentObj.length > 2) {
          try {
            eval(`(${currentObj})`);
            jsObjects.push(currentObj);
          } catch (e) {
          }
          currentObj = "";
        }
      } else if (braceCount > 0) {
        currentObj += char;
      }
    } else if (braceCount > 0) {
      currentObj += char;
    }
  }
  console.log(`Found ${jsObjects.length} JS objects`);
  return jsObjects.map((obj2) => [
    obj2
  ]);
}
function parseMatch(match) {
  try {
    const obj = eval(`(${match})`);
    return JSON.stringify(obj, null, 2);
  } catch {
    return null;
  }
}
function findArtifactsFolderUp() {
  const here = Deno.cwd();
  let current = here;
  while (current !== "/" && current !== "") {
    const artifactsPath = join(current, "artifacts");
    try {
      const stat = Deno.statSync(artifactsPath);
      if (stat.isDirectory) {
        return artifactsPath;
      }
    } catch {
    }
    const parent = join(current, "..");
    if (parent === current) break;
    current = parent;
  }
  return null;
}
function getParentFolderName() {
  const here = Deno.cwd();
  const parent = join(here);
  return parent.split("/").pop();
}
if (import.meta.main) {
  const matches = await runTest(Deno.args[0]);
  const artifactsFolder = findArtifactsFolderUp();
  const parsedItems = matches.map((m) => parseMatch(m[0])).filter((m) => m);
  const parsedWithTypes = await Promise.all(parsedItems.map(async (item, i2) => {
    const types = await jsonToTsInterfaces(item, i2);
    return {
      json: item,
      types
    };
  }));
  if (!artifactsFolder) throw new Error("artifacts folder not found");
  const parentFolderName = getParentFolderName();
  const outFolder = join(artifactsFolder, parentFolderName || "default");
  Deno.mkdirSync(outFolder, {
    recursive: true
  });
  Deno.writeTextFileSync(outFolder + "/output.json", `[
${parsedWithTypes.map((i2) => JSON.parse(i2.json)).map((obj2) => JSON.stringify(obj2, null, 2)).join(",\n")}
]`);
  Deno.writeTextFileSync(outFolder + "/types.ts", parsedWithTypes.map((i2) => i2.types).join("\n\n"));
  console.log({
    outFolder
  });
}
/*! Bundled license information:

urijs/src/punycode.js:
  (*! https://mths.be/punycode v1.4.0 by @mathias *)

urijs/src/IPv6.js:
  (*!
   * URI.js - Mutating URLs
   * IPv6 Support
   *
   * Version: 1.19.11
   *
   * Author: Rodney Rehm
   * Web: http://medialize.github.io/URI.js/
   *
   * Licensed under
   *   MIT License http://www.opensource.org/licenses/mit-license
   *
   *)

urijs/src/SecondLevelDomains.js:
  (*!
   * URI.js - Mutating URLs
   * Second Level Domain (SLD) Support
   *
   * Version: 1.19.11
   *
   * Author: Rodney Rehm
   * Web: http://medialize.github.io/URI.js/
   *
   * Licensed under
   *   MIT License http://www.opensource.org/licenses/mit-license
   *
   *)

urijs/src/URI.js:
  (*!
   * URI.js - Mutating URLs
   *
   * Version: 1.19.11
   *
   * Author: Rodney Rehm
   * Web: http://medialize.github.io/URI.js/
   *
   * Licensed under
   *   MIT License http://www.opensource.org/licenses/mit-license
   *
   *)

lodash/lodash.js:
  (**
   * @license
   * Lodash <https://lodash.com/>
   * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   *)
*/
